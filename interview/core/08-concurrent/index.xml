<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>并发编程 on IWiki</title>
    <link>https://jianda1024.github.io/interview/core/08-concurrent/</link>
    <description>Recent content in 并发编程 on IWiki</description>
    <generator>Hugo</generator>
    <language>iwiki</language>
    <atom:link href="https://jianda1024.github.io/interview/core/08-concurrent/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>基础知识</title>
      <link>https://jianda1024.github.io/interview/core/08-concurrent/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://jianda1024.github.io/interview/core/08-concurrent/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>&lt;h3 id=&#34;---线程和进程的区别&#34;&gt;&#xD;&#xA;  &amp;ndash; 线程和进程的区别？&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#---%e7%ba%bf%e7%a8%8b%e5%92%8c%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%8c%ba%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1. 进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2. 不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;3. 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;---并行和并发有什么区别&#34;&gt;&#xD;&#xA;  &amp;ndash; 并行和并发有什么区别？&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#---%e5%b9%b6%e8%a1%8c%e5%92%8c%e5%b9%b6%e5%8f%91%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;多核情况下，&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;多个任务，同一时间，同时运行为并行；&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;多个任务，同一时间，任务之间交替运行为并发；&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;---创建线程的方式有哪些&#34;&gt;&#xD;&#xA;  &amp;ndash; 创建线程的方式有哪些？&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#---%e5%88%9b%e5%bb%ba%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%96%b9%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1. 继承Thread类&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2. 实现runnable接口&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;3. 实现Callable接口&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;4. 线程池创建线程(项目中使用方式)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>并发安全</title>
      <link>https://jianda1024.github.io/interview/core/08-concurrent/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://jianda1024.github.io/interview/core/08-concurrent/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/</guid>
      <description>&lt;h3 id=&#34;---什么是线程安全&#34;&gt;&#xD;&#xA;  &amp;ndash; 什么是线程安全？&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#---%e4%bb%80%e4%b9%88%e6%98%af%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;线程安全是指在多线程环境下，多个线程并发访问共享资源时，&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;程序的行为能够始终保持一致性和正确性，不会出现数据不一致或其他程序异常情况。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;---怎么保证多线程的执行安全&#34;&gt;&#xD;&#xA;  &amp;ndash; 怎么保证多线程的执行安全？&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#---%e6%80%8e%e4%b9%88%e4%bf%9d%e8%af%81%e5%a4%9a%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%89%a7%e8%a1%8c%e5%ae%89%e5%85%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;并发编程有三大核心特性，分别是原子性、可见性和有序性&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;原子性：&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;一个线程在CPU中操作不可暂停，也不可中断，要不执行完成，要不不执行&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;可以使用synchronized、lock来保证&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;可见性：&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;使用volatile、synchronized、lock来保证&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;有序性：&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;程序执行的顺序按照代码的先后顺序执行&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;可以使用volatile来保证&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>线程池</title>
      <link>https://jianda1024.github.io/interview/core/08-concurrent/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://jianda1024.github.io/interview/core/08-concurrent/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid>
      <description>&lt;h3 id=&#34;---线程池的核心参数&#34;&gt;&#xD;&#xA;  &amp;ndash; 线程池的核心参数？&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#---%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e6%a0%b8%e5%bf%83%e5%8f%82%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;img src=&#34;https://jianda1024.github.io/img/2024Q4/img_2024-11-18_172424.png&#34; width=&#34;800&#34;/&gt;&#xD;&#xA;&lt;h3 id=&#34;---线程池的工作原理&#34;&gt;&#xD;&#xA;  &amp;ndash; 线程池的工作原理？&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#---%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1. 创建线程池后，等待提交过来的任务请求&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2. 当调用execute()添加一个新任务时，线程池会做如下判断：&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   a. 如果当前运行的线程数量还小于corePoolSize，则会创建新线程来执行新任务&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   b. 如果当前运行的线程数量不小于corePoolSize，则会将提交的任务放入阻塞队列中&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   c. 如果当前阻塞队列满了，且当前运行的线程数量还小于maximumPoolSize，则创建线程运行这个任务&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   d. 如果当前阻塞队列满了，且当前运行的线程数量不小于maximumPoolSize，则启动拒绝策略&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;3. 当一个线程完成任务时，它会从队列中取下一个任务来执行&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;4. 当一个线程空闲超过一定时间，并且此时当前运行的线程大于corePoolSize时，这个线程会被销毁&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
  </channel>
</rss>
