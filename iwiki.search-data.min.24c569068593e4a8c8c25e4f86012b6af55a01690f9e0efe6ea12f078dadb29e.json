[{"id":0,"href":"/framework/spring/ioc/bean/","title":"Bean","section":"IoC","content":"\rBean\r#\rBean\r#\r是指由Spring IoC容器实例化、组装和管理的对象 可以把 Spring IoC 容器看作是一个大工厂，Bean 就相当于工厂的产品 Bean 作用域\r#\r对于 prototype 作用域的 Bean 来说，Spring IoC 容器只负责创建 作用域 描述 singleton 默认值，在 spring IoC 容器仅存在一个 Bean 实例 prototype 每次通过 Spring 容器获取 Bean 时，容器都会创建一个新的 Bean 实例 request 每次 HTTP 请求，容器都会创建一个 Bean 实例， 仅在当前 HTTP Request 内有效 session 同一个 HTTP Session 共享一个 Bean 实例，仅在当前 HTTP Session 内有效 application 同一个 Web 应用共享一个 Bean 实例，在当前 ServletContext 内有效 Bean 生命周期\r#\r实例化 Spring 启动，加载类路径下配置文件，解析为 BeanDefinition 并装配到对应容器中 查找并加载 Spring 管理的 Bean，进行 Bean 的实例化 对于 prototype 作用域的 Bean 来说，Spring IoC 容器只负责创建，不会再跟踪其生命周期 初始化 Spring 对 bean 进行依赖注入 若 Bean 实现接口 BeanNameAware，则执行 setBeanName()，获取 bean 的名字 若 Bean 实现接口 BeanFactoryAware，则执行 setBeanFactory()，获取 BeanFactory 若 Bean 实现接口 ApplicationContextAware，则执行 setApplicationContext()，获取应用上下文； 若 Bean 实现接口 BeanPostProcessor，则先执行 postProcessBeforeInitialization()； 若 Bean 实现接口 InitializingBean，则执行 afterPropertiesSet()； 在 xml 文件中，若 Bean 配置了 init-method，则执行自定义方法； 若 Bean 实现接口 BeanPostProcessor，则先执行 postProcessAfterInitialization()； 使用 此时 Bean 已经准备就绪，可以被使用了 销毁\n如 Bean 实现接口 DisposableBean，则容器销毁时则执行 destory()； 在 xml 文件中，若 Bean 配置了destory-method，则容器销毁时则执行自定义方法。 "},{"id":1,"href":"/program-lang/java/container/Queue/BlockingQueue/","title":"BlockingQueue","section":"Queue","content":"\rBlockingQueue\r#\r阻塞队列\r#\r队列，Queue，是一种先进先出（first in first out：FIFO）的抽象的数据结构 BlockingQueue，是一个支持两个附加操作的队列 当阻塞队列是空时，从队列中获取元素的操作将会被阻塞 当阻塞队列是满时，往队列中添加元素的操作将会被阻塞 核心方法\r#\r抛出异常 返回特殊值 超时退出 一直阻塞 插入 add(e) offer(e) offer(e,time,unit) put(e) 移除 remove() poll() poll(time,unit) take() 检查 element() peek() / / 说明 抛出异常 当阻塞队列满时，再往队列 add 元素会抛 IllegalStateException:Queuefull当阻塞队列空时，再往队列 Remove 元素时候会抛出 NoSuchElementException 返回特殊值 插入方法，成功返回 true，失败返回 false移除方法，成功返回元素，队列里面没有就返回null 超时退出 当阻塞队列满时，队列会阻塞生产者线程一定时间，超过时限后生产者线程就会退出当阻塞队列空时，队列会阻塞消费者线程一定时间，超过时限后消费者线程就会退出 一直阻塞 当阻塞队列满时，生产者继续往队列里面 put 元素，队列会一直阻塞直到 put 数据 or 响应中断退出当阻塞队列空时，消费者试图从队列 take 元素，队列会一直阻塞消费者线程，直到队列可用 常用队列\r#\r队列 说明 实现 ArrayBlockingQueue 有界阻塞队列 由数组实现 LinkedBlockingQueue 有界阻塞队列 由链表实现 LinkedTransferQueue 无界阻塞队列 由链表实现 LinkedBlockingDeque 双端有界阻塞队列 由链表实现 DelayQueue 延迟无界阻塞队列 SynchronousQueue 单元素的阻塞队列 PriorityBlockingQueue 支持优先级的无界阻塞队列 应用\r#\r线程池、消息中间件、生产者消费者模式 // 生产者消费者模式-传统版 public class ShareData { private int num = 0; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void increment() throws Exception { lock.lock(); try { while (num != 0) { condition.await(); } num++; System.out.println(Thread.currentThread().getName() + \u0026#34;\\t\u0026#34; + num); condition.signalAll(); } finally { lock.unlock(); } } public void deIncrement() throws Exception { lock.lock(); try { while (num == 0) { condition.await(); } num--; System.out.println(Thread.currentThread().getName() + \u0026#34;\\t\u0026#34; + num); condition.signalAll(); } finally { lock.unlock(); } } } public class ProdConsumerTraditionDemo { public static void main(String[] args) { ShareData shareData = new ShareData(); new Thread(() -\u0026gt; { for (int i = 1; i \u0026lt;= 5; i++) { try { shareData.increment(); } catch (Exception e) { e.printStackTrace(); } } }, \u0026#34;AA\u0026#34;).start(); new Thread(() -\u0026gt; { for (int i = 1; i \u0026lt;= 5; i++) { try { shareData.deIncrement(); } catch (Exception e) { e.printStackTrace(); } } }, \u0026#34;BB\u0026#34;).start(); } } // 生产者消费者模式-阻塞队列版 public class MyResource { /** * 默认开启 进行生产消费的交互 */ private volatile boolean flag = true; /** * 默认值是0 */ private AtomicInteger atomicInteger = new AtomicInteger(); private BlockingQueue\u0026lt;String\u0026gt; blockingQueue = null; public MyResource(BlockingQueue\u0026lt;String\u0026gt; blockingQueue) { this.blockingQueue = blockingQueue; System.out.println(blockingQueue.getClass().getName()); } public void produce() throws Exception { String data = null; boolean returnValue; String threadName = Thread.currentThread().getName(); while (flag) { data = atomicInteger.incrementAndGet() + \u0026#34;\u0026#34;; returnValue = blockingQueue.offer(data, 2L, TimeUnit.SECONDS); if (returnValue) { System.out.println(threadName + \u0026#34; 插入队列数据\u0026#34; + data + \u0026#34;成功\u0026#34;); } else { System.out.println(threadName + \u0026#34; 插入队列数据\u0026#34; + data + \u0026#34;失败\u0026#34;); } TimeUnit.SECONDS.sleep(1); } System.out.println(threadName + \u0026#34; 停止 表示 flag=\u0026#34; + flag); } public void consume() throws Exception { String result = null; String threadName = Thread.currentThread().getName(); while (flag) { result = blockingQueue.poll(2L, TimeUnit.SECONDS); if (null == result || \u0026#34;\u0026#34;.equalsIgnoreCase(result)) { flag = false; System.out.println(threadName + \u0026#34; 超过2s没有取到 消费退出\u0026#34;); System.out.println(); System.out.println(); return; } System.out.println(threadName + \u0026#34; 消费队列\u0026#34; + result + \u0026#34;成功\u0026#34;); } } public void stop() throws Exception { flag = false; } } public class ProdConsumerBlockQueueDemo { public static void main(String[] args) throws Exception { MyResource myResource = new MyResource(new ArrayBlockingQueue\u0026lt;\u0026gt;(10)); new Thread(() -\u0026gt; { System.out.println(Thread.currentThread().getName() + \u0026#34;\\t启动\u0026#34;); try { myResource.produce(); } catch (Exception e) { e.printStackTrace(); } }, \u0026#34;producer\u0026#34;).start(); new Thread(() -\u0026gt; { System.out.println(Thread.currentThread().getName() + \u0026#34;\\t启动\u0026#34;); try { myResource.consume(); } catch (Exception e) { e.printStackTrace(); } }, \u0026#34;consumer\u0026#34;).start(); try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(); System.out.println(); System.out.println(\u0026#34;时间到,停止活动\u0026#34;); myResource.stop(); } } "},{"id":2,"href":"/program-lang/java/thread/tool/CountDownLatch/","title":"CountDownLatch","section":"并发工具","content":"\rCountDownLatch\r#\r功能\r#\r倒计时器 一个或多个线程一直等待，直到其他线程完成某件事情之后再执行 原理\r#\r通过一个计数器进行实现。计数器初始值为线程的数量。 每当一个线程执行完毕后，计数器的值就减 1。 当计数器的值为 0 时，表示所有线程都执行完毕，然后在 CountDownLatch 上等待的线程就可以恢复执行了。 方法\r#\r// 构造方法：设定计数器初始值 public CountDownLatch(int count) // 计数器值减1 public void countDown() // 获取当前计数器值 public long getCount() // 非定时等待 public void await() // 定时等待 public boolean await(long timeout, TimeUnit unit) 示例\r#\r// 自习室锁门 public class Test { public static void main(String[] args) throws Exception { CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 1; i \u0026lt;= 6; i++) { new Thread(() -\u0026gt; { System.out.println(Thread.currentThread().getName() + \u0026#34;\\t上完自习\u0026#34;); countDownLatch.countDown(); }, String.valueOf(i)).start(); } countDownLatch.await(); System.out.println(Thread.currentThread().getName() + \u0026#34;\\t班长锁门离开教室\u0026#34;); } } "},{"id":3,"href":"/program-lang/web/css/basic/","title":"CSS 基础","section":"CSS","content":"\rCSS 基础\r#\rCSS\r#\rCascading Style Sheets，层叠样式表 使网页内容与表现相分离，简化网页代码，提高页面浏览速度 层叠样式\r#\rHTML 同一元素，可以定义多个样式 HTML 子元素，会继承其父元素的CSS样式 样式不冲突时，多个样式效果可叠加；样式冲突时，按样式的优先级来显示 语法规则\r#\rCSS规则，由选择器、声明组成 注释：/*注释语句*/ 引入方式\r#\r外部样式表 内部样式表 内联样式 //外部样式表：在网页头部引入 \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;XXX.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; //内部样式表：在网页头部，定义样式表 \u0026lt;head\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; p {color:red;} ... \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; //内联颜色表：在相关标签内，定义style属性 \u0026lt;p style=\u0026#34;color:red;\u0026#34;\u0026gt;这是一个段落。\u0026lt;/p\u0026gt; 基础单位\r#\r尺寸：size\r#\r值 说明 备注 % 百分比 in 英寸 25.4 mm cm 厘米 10 mm mm 毫米 1 mm pt 磅/点，Point 0.35 mm pc 派卡，Pica 4.23 mm px 像素，Pixel em 当前字体尺寸的倍数 1em = 16px（默认） ex x-height 1ex = 0.5em 颜色：color\r#\r值 说明 备注 (颜色名) 颜色名称 red rgb(x,x,x) RGB 值 rgb(255,0,0) rgb(x%, x%, x%) RGB 百分比值 rgb(100%,0%,0%) #rrggbb 十六进制数 #ff0000 盒模型\r#\r垂直方向，相邻元素的外边距会合并，实际高度为较大值 盒模型各属性，默认不继承父元素样式 命名\r#\r规范\n以小写字母开头 英文字母、数字、\u0026quot;_\u0026quot;、\u0026quot;-\u0026quot; 使用有意义的命名 命名形式：单个单词、连字符、驼峰命名 示例\n页头 header 页体 main 页尾 footer 内容 content 容器 container 条 bar 导航 nav 侧栏 sidebar 栏目 column 广告 banner 能区 shop 外围 wrapper "},{"id":4,"href":"/service-manage/deprecated-frame/eureka/","title":"Eureka","section":"日落组件","content":"\rEureka\r#\rEureka\r#\r服务注册中心\n一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。\n工作原理\r#\rEureka 采用了 C-S 的设计架构。 Eureka Server 作为服务注册功能的服务器，是服务注册中心。 而系统中的其他微服务，使用 Eureka Client 连接到 Eureka Server 并维持心跳连接。 这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。 SpringCloud 的其他模块（比如Zuul）就可以通过 Eureka Server 来发现系统中的其他微服务，并执行相关的逻辑。 核心组件\r#\rEureka Server\n提供服务注册服务 各个节点启动后，会在 Eureka Server 中进行注册，这样 Eureka Server 中将会存储所有可用服务的节点信息。 Eureka Client\n是一个 Java 客户端，用于简化与 Eureka Server 的交互。 作为轮询负载均衡器，并提供服务的故障切换支持。 在应用启动后，将会向 Eureka Server 周期性发送心跳。 角色\r#\rEureka Server：提供服务注册和发现 Service Provider：服务提供方，将自身服务注册到 Eureka，从而使服务消费方能够找到 Service Consumer：服务消费方，从 Eureka 获取注册服务列表，从而能够消费服务 自我保护模式\r#\r当 EurekaServer 节点在短时间内丢失过多客户端时，那么这个节点就会进入自我保护模式。 自我保护模式下，EurekaServer 就会保护服务注册表中的信息，即不会注销任何微服务。 当网络故障恢复后，该 EurekaServer 节点会自动退出自我保护模式。 Eureka 保证 AP\r#\rEureka 优先保证高可用性，其各个节点都是平等的。 只要有一台 EurekaServer 在，就能保证注册服务可用，只不过查到的信息可能不是最新的 "},{"id":5,"href":"/framework/spring/ioc/","title":"IoC","section":"Spring","content":"\rIoC\r#\rInversion of Control，即“控制反转”，是一种设计思想，用于解决对象之间的耦合问题。 以前对象的创建及依赖关系是由开发人员自己维护，现在反转交给 spring 来完成创建及注入 控制：指的是对象创建（实例化、管理）的权利 反转：控制权交给外部环境了（spring框架、IoC容器） IoC \u0026amp; DI\r#\rDI，Dependency Injection，即“依赖注入”，由容器动态的将某个依赖关系注入到组件之中。 IOC 是一种软件设计思想，DI 是这种软件设计思想的一个实现。 IoC 和 DI 是同一个概念的不同角度描述。 IoC 容器\r#\r具有依赖注入功能的容器，它可以创建对象，负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖 IoC 容器底层其实就是一个 Bean 工厂，Spring 提供了两种 IoC 容器，即BeanFactory、ApplicationContext BeanFactory：最简单的 IoC 容器，它提供了 IoC 容器最基本的功能 ApplicationContext：BeanFactory 的子接口，并添加了更多的企业特定的功能 "},{"id":6,"href":"/program-lang/java/thread/theory/JMM/","title":"Java 内存模型","section":"并发理论","content":"\rJava 内存模型\r#\rJMM\r#\rJava Memory Model，是一种抽象的概念。 描述的是一组规则或规范，规定了程序中各个变量的访问方式。 内存\r#\r主内存：共享的内存区域，所有线程都可访问。代表：内存条 工作内存：每个线程的私有数据区域。代表：CPU缓存 规则\r#\r线程解锁前，必须把共享变量的值刷新回主内存 线程加锁前，必须读取主内存的最新值到自己的工作内存 加锁解锁是同一把锁 访问过程\r#\r线程对变量的操作(读取赋值等)，必须在工作内存中进行 首先要将变量从主内存拷贝到自己的工作空间，然后对变量进行操作，操作完成再将变量写回主内存 并发三特性\r#\r原子性 不可分割，是一个整体。即一个操作或者多个操作，要么全部执行并且不被打断，要么就都不执行 可见性 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值 有序性 程序执行的顺序按照代码的先后顺序执行 指令重排\r#\r为了优化程序性能，编译器和处理器重新对指令序列进行排序的一种手段 内存屏障\r#\rMemory Barrier 作用： 阻止屏障两侧的指令重排序 强制将缓存数据刷新到主内存 类型： Load指令：读屏障，将内存存储的数据拷贝到处理器的缓存中。 Store指令：写屏障，让当前线程写入高速缓存中的最新数据更新写入到内存，让其他线程也可见。 分为四类：LoadLoad、StoreStore、LoadStore、 StoreLoad 数据依赖性\r#\r如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性 语义：as-if-serial\r#\r不管怎么指令重排，单线程程序的执行结果不会改变 为了遵循此语义，编译器不会对存在数据依赖关系的操作做重排序，因为会改变执行结果。 编译器、runtime和处理器都遵守as-if-serial语义 规则：happens-before\r#\r如果A Happens-Before B，则A操作的结果对B操作可见，且A操作在B操作之前执行 JMM承诺保证happens-before规则 as-if-serial \u0026amp; happens-before\r#\r两者目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度 as-if-serial 保证结果：单线程程序的执行结果不被改变 as-if-serial 创造环境：单线程程序是按程序的顺序来执行的 happens-before 保证结果：正确同步的多线程程序的执行结果不被改变 happens-before 创造环境：正确同步的多线程程序是按happens-before指定的顺序来执行的 "},{"id":7,"href":"/program-lang/java/library/java.io/","title":"java.io","section":"基础类库","content":"\rIO 流\r#\r概述\r#\rI/O 即输入Input/ 输出Output的缩写，就是计算机调度把各个存储中的数据写入写出的过程； Java中用“流（stream）”来抽象表示这么一个写入写出的功能，并封装成一个“类” I/O 体系\r#\rI/O 体系基类：以程序自身为参照基准，判断输入输出\n字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer I/O 体系分类\nInputStream OutputStream Reader Writer 文件流 File\u0026ndash; File\u0026ndash; File\u0026ndash; File\u0026ndash; 管道流 Piped\u0026ndash; Piped\u0026ndash; Piped\u0026ndash; Piped\u0026ndash; 缓冲流 Buffered\u0026ndash; Buffered\u0026ndash; Buffered\u0026ndash; Buffered\u0026ndash; 数据流 Data\u0026ndash; Data\u0026ndash; 字符流 String\u0026ndash; String\u0026ndash; 对象流 Object\u0026ndash; Object\u0026ndash; 转换流 InputStream\u0026ndash; OutputStream\u0026ndash; 字节数组流 ByteArray\u0026ndash; ByteArray\u0026ndash; 字符数组流 CharArray\u0026ndash; CharArray\u0026ndash; 打印流 Print\u0026ndash; Print\u0026ndash; I/O 示例\r#\r文件流\r#\r// FileInputStream、FileOutputStream try (FileInputStream fis = new FileInputStream(\u0026#34;E:\\\\test1.txt\u0026#34;); FileOutputStream fos = new FileOutputStream(\u0026#34;E:\\\\test2.txt\u0026#34;)) { int len; byte[] buff = new byte[1024]; while ((len = fis.read(buff)) \u0026gt; 0) { fos.write(buff, 0, len); } } catch (IOException e) { e.printStackTrace(); } // FileReader、FileWriter try (FileReader fr = new FileReader(\u0026#34;E:\\\\test1.txt\u0026#34;); FileWriter fw = new FileWriter(\u0026#34;E:\\\\test2.txt\u0026#34;)) { int len; char[] buff = new char[1024]; while ((len = fr.read(buff)) \u0026gt; 0) { fw.write(new String(buff, 0, len)); } } catch (IOException e) { e.printStackTrace(); } 缓冲流\r#\r// BufferedInputStream、BufferedOutputStream try (FileInputStream fis = new FileInputStream(\u0026#34;E:\\\\test1.txt\u0026#34;); FileOutputStream fos = new FileOutputStream(\u0026#34;E:\\\\test2.txt\u0026#34;); BufferedInputStream bis = new BufferedInputStream(fis); BufferedOutputStream bos = new BufferedOutputStream(fos)) { int len; byte[] buff = new byte[1024]; while ((len = bis.read(buff)) \u0026gt; 0) { bos.write(buff, 0, len); } } catch (IOException e) { e.printStackTrace(); } 转换流\r#\rInputStreamReader：将字节输入流转换为字符输入流 OutputStreamWriter：将字节输出流转换为字符输出流 // InputStreamReader、OutputStreamWriter try (FileInputStream fis = new FileInputStream(\u0026#34;E:\\\\file_gbk.txt\u0026#34;); FileOutputStream fos = new FileOutputStream(\u0026#34;E:\\\\file_utf8.txt\u0026#34;); InputStreamReader isr = new InputStreamReader(fis, \u0026#34;GBK\u0026#34;); OutputStreamWriter osw = new OutputStreamWriter(fos, \u0026#34;UTF-8\u0026#34;)) { int len; char[] buff = new char[1024]; while ((len = isr.read(buff)) != -1) { osw.write(buff, 0, len); } } catch (IOException e) { e.printStackTrace(); } 对象流\r#\r// ObjectInputStream、ObjectOutputStream public class Test { public static void main(String[] args) { try (FileInputStream fis = new FileInputStream(\u0026#34;E:\\\\test1.txt\u0026#34;); FileOutputStream fos = new FileOutputStream(\u0026#34;E:\\\\test2.txt\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); ObjectOutputStream oos = new ObjectOutputStream(fos)) { // 对象序列化存储 oos.writeObject(new Animal(\u0026#34;dog\u0026#34;)); // 对象反序列化读取 Animal dog = (Animal) ois.readObject(); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } } // 输出对象的类必须实现Serializable接口 public class Animal implements Serializable { private String name; public Animal(String name) { this.name = name; } } "},{"id":8,"href":"/program-lang/java/jvm/tuning/parameter/","title":"JVM 参数","section":"JVM 调优","content":"\rJVM 参数\r#\rJVM 参数\r#\r标配参数、X参数（了解）\r#\r-version 版本信息 -help 帮助 -showversion 版本详情 -Xint 解释模式，强制 JVM 执行所有的字节码 -Xcomp 编译模式，第一次使用就把所有的字节码编译成本地代码 -Xmixed 混合模式，将解释模式和编译模式进行混合使用 XX 参数（重点）\r#\r布尔类型：-XX:+或-某个属性（+ 表示开启，- 表示关闭） 键值类型：-XX:属性键=属性值 示例 说明 -XX:-PrintGCDetails 关闭：打印GC收集细节 -XX:+PrintGCDetails 开启：打印GC收集细节 -XX:-UseSerialGC 关闭：使用串行垃圾回收器 -XX:+UseSerialGC 开启：使用串行垃圾回收器 -XX:MetaspaceSize=128m 设置元空间的内存大小，默认21m -XX:MaxTenuringThreshold=15 设置GC垃圾年龄阈值，默认15 常用 JVM 参数\r#\r-Xms、-Xmx、-Xss、-Xmn\r#\r参数 说明 备注 -Xms 初始分配内存，默认是物理内存的1/64 -Xms 等价于 -XX:InitialHeapSize -Xmx 最大分配内存，默认是物理内存的1/4 -Xmx 等价于 -XX:MaxHeapSize -Xss 设置单个线程栈的内存大小，一般默认512K ~ 1024K -Xss 等价于 -XX:ThreadStackSize -Xmn 设置年轻代的内存大小，一般使用默认值 -XX:MetaspaceSize\r#\r设置元空间的内存大小，默认21m 元空间（Java8）和老年代（Java7）类似，但元空间并不在虚拟机中，而是使用本地内存 -XX:SurvivorRatio\r#\r配置新生代中 eden 和 S0/S1 空间比例\n# eden:S0:S1=8:1:1 (默认) -XX:SurvivorRatio=8 # eden:S0:S1=4:1:1 -XX:SurvivorRatio=4 -XX:NewRatio\r#\r配置新生代与老年代在堆中的比例\n# 新生代:老年代=1:2(默认) -XX:NewRatio=2 # 新生代:老年代=1:4 -XX:NewRatio=4 -XX:MaxTenuringThreshold\r#\r设置新生代中对象最大存活次数 在新生代中对象存活次数（经过Minor GC的次数）后仍然存活，就会晋升到老年代 -XX:+PrintGCDetails\r#\r输出 GC 收集的日志信息 GC 日志分析 查看 JVM 参数\r#\rjps、jinfo\r#\r查询进程号：jps 查看具体参数：jinfo -XX:+PrintFlagsInitial\r#\r查看全部初始默认参数 -XX:+PrintFlagsFinal\r#\r查看全部最终参数 -XX:+PrintCommandLineFlags\r#\r查看特定参数 "},{"id":9,"href":"/program-lang/java/library/java.util.stream/lambda/","title":"Lambda","section":"java.util.stream","content":"\rLambda 表达式\r#\rLambda\r#\r允许把函数作为一个方法的参数，即函数作为参数传递到方法中 也可称为闭包，能使代码更加简洁 基本语法\r#\r参数列表：() 操作符：-\u0026gt; 方法体：{} (参数1,参数2,...) -\u0026gt; { // 方法体 }; 简写规则\r#\r特征 说明 可选类型声明 不需要声明参数类型，编译器可以统一识别参数值。 可选的参数圆括号 一个参数无需定义圆括号，但多个参数需要定义圆括号。 可选的大括号 如果主体包含了一个语句，就不需要使用大括号。 可选的返回关键字 如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。 变量作用域\r#\rLambda 表达式只能引用标记了 final 的外层局部变量，否则会编译错误。 Lambda 表达式的局部变量隐性的具有 final 的语义。 public class Test { public static void main(String[] args) { // 隐性 final int num = 1; Converter s = (param) -\u0026gt; System.out.println(String.valueOf(param + num)); s.convert(2); //编译会出错 num = 5; } public interface Converter { void convert(int i); } } 示例\r#\rpublic static void main(String[] args) { // 匿名内部类 Runnable r1 = new Runnable() { @Override public void run() { System.out.println(\u0026#34;r1：线程执行了...\u0026#34;); } }; new Thread(r1).start(); // Lambda表达式 Runnable r2 = () -\u0026gt; System.out.println(\u0026#34;r2：线程执行了...\u0026#34;); new Thread(r2).start(); } public static void main(String[] args) { // 匿名内部类 Comparator\u0026lt;String\u0026gt; c1 = new Comparator\u0026lt;String\u0026gt;() { @Override public int compare(String o1, String o2) { return o1.length() - o2.length(); } }; // Lambda表达式 Comparator\u0026lt;String\u0026gt; c2 = (o1, o2) -\u0026gt; o1.length() - o2.length(); } public class Test { public static void main(String args[]) { Test tester = new Test(); // 类型声明 MathOperation addition = (int a, int b) -\u0026gt; a + b; // 不用类型声明 MathOperation subtraction = (a, b) -\u0026gt; a - b; // 大括号中的返回语句 MathOperation multiplication = (int a, int b) -\u0026gt; { return a * b; }; // 没有大括号及返回语句 MathOperation division = (int a, int b) -\u0026gt; a / b; System.out.println(\u0026#34;10 + 5 = \u0026#34; + tester.operate(10, 5, addition)); System.out.println(\u0026#34;10 - 5 = \u0026#34; + tester.operate(10, 5, subtraction)); System.out.println(\u0026#34;10 x 5 = \u0026#34; + tester.operate(10, 5, multiplication)); System.out.println(\u0026#34;10 / 5 = \u0026#34; + tester.operate(10, 5, division)); // 不用括号 GreetingService greetService1 = message -\u0026gt; System.out.println(\u0026#34;Hello \u0026#34; + message); // 用括号 GreetingService greetService2 = (message) -\u0026gt; System.out.println(\u0026#34;Hello \u0026#34; + message); greetService1.sayMessage(\u0026#34;Runoob\u0026#34;); greetService2.sayMessage(\u0026#34;Google\u0026#34;); } interface MathOperation { int operation(int a, int b); } interface GreetingService { void sayMessage(String message); } private int operate(int a, int b, MathOperation mathOperation) { return mathOperation.operation(a, b); } } "},{"id":10,"href":"/program-lang/java/container/Map/","title":"Map","section":"集合容器","content":"\r"},{"id":11,"href":"/framework/kafka/mq/","title":"MQ","section":"Kafka","content":"\r消息队列\r#\rMQ\r#\rMessage Queue，消息队列 是基础数据结构中“先进先出”的一种数据结构。 原理\r#\r点对点模式：一对一，消费者主动拉取数据，消息收到后消息清除 发布/订阅模式：一对多，数据生产后，推送给所有订阅者 优点\r#\r解耦：解耦消息处理过程，使得扩展变得容易 异步：允许异步处理消息 削峰：提高峰值处理能力 缓冲：控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况 保证数据安全：消息队列把数据进行持久化直到它们已经被完全处理。这规避了数据丢失风险。 保证消息的有序性：保证数据会按照特定的顺序来处理 缺点\r#\r系统可用性降低 系统复杂性提高 一致性问题 消息中间件\r#\r单机吞吐量 时效性 可用性 消息可靠性 ActiveMQ 万级 ms 级 高，主从架构 有较低的概率丢失数据 RabbitMQ 万级 μs 级 高，主从架构 RocketMQ 10万级 ms 级 非常高，分布式架构 可零丢失 Kafka 10万级 ms 级 非常高，分布式架构 可零丢失 ActiveMQ\r#\r非常成熟，功能强大，在业内大量的公司以及项目中都有应用 偶尔会有较低概率丢失消息 社区活跃度低，官方对其维护也越来越少 而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用 RabbitMQ\r#\rerlang语言开发，性能极其好，延时很低； 吞吐量到万级，MQ功能比较完备 而且开源提供的管理界面非常棒，用起来很好用 社区相对比较活跃，几乎每个月都发布几个版本 RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重 erlang语言本身带来的问题。很难读源码，很难定制和掌控 RocketMQ\r#\r接口简单易用，有阿里品牌保障 日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便 社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景 java系的，可以自己阅读源码，定制自己公司的MQ，可以掌控 Kafka\r#\r仅仅提供较少的核心功能 但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展 kafka最好是支撑较少的topic数量即可，保证其超高吞吐量 kafka唯一的一点劣势是有可能消息重复消费，在大数据领域中以及日志采集中，这点轻微影响可以忽略。 "},{"id":12,"href":"/database/redis/persistence/RDB/","title":"RDB","section":"持久化","content":"\rRDB\r#\rRDB\r#\rRedis DataBase，在指定的时间间隔内将内存中的数据集快照写入磁盘。 持久化文件：dump.rdb 过程\r#\rRedis 调用 fork() ，创建一个子进程。 主进程继续处理client请求，且不进行任何IO操作，以保证性能。 子进程会先将数据写入到一个临时文件中，待持久化过程都结束了， 再用这个临时文件替换上次持久化好的文件。 触发\r#\r自动触发\n根据 save m n 配置规则自动触发； 从节点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点会触发 bgsave； 执行 debug reload 时； 执行 shutdown时，如果没有开启aof，也会触发。 手动触发\nsave：会阻塞当前Redis服务器，直到持久化完成，线上应该禁止使用。 bgsave：该触发方式会fork一个子进程，由子进程负责持久化过程，因此阻塞只会发生在fork子进程的时候。 优点\r#\r只有一个文件 dump.rdb，方便持久化。 容灾性好，一个文件可以保存到安全的磁盘。 性能最大化，保证了 redis的高性能 相对于数据集大时，比 AOF 的启动效率更高。 缺点\r#\r数据安全性低。如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改 每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程。这可能会非常耗时，造成服务器暂时停止处理客户端。 "},{"id":13,"href":"/framework/springmvc/RESTful/","title":"RESTful","section":"Spring MVC","content":"\rRESTful 风格\r#\rRESTful\r#\r是一种互联网软件架构，是一种设计风格 即 REST，是 REST 的形容词形式 RESTful 原则\r#\r网络上的所有事物都被抽象为资源 每个资源都有唯一的标识，对资源的操作不会改变标识 同一个资源具有多种表现形式(xml,json等) 所有的操作都是无状态的 RESTful 规范\r#\r使用 URL 标识资源，URL中原则上不使用“动词”。 使用标准方法（GET、POST、PUT、PATCH、DELETE）操作资源。 使用 Json 格式返回结果，并用HTTP状态码进行标识。 RESTful 示例\r#\r//如果占位符中的名称和形参名一致，在@PathVariable可以不指定名称 @RequestMapping(\u0026#34;/item/{id}\u0026#34;) public @ResponseBody Item item(@PathVariable(\u0026#34;id\u0026#34;) Integer itemId){ //.... } "},{"id":14,"href":"/service-manage/dubbo/rpc/","title":"RPC","section":"Dubbo","content":"\rRPC\r#\rRPC\r#\rRemote Procedure Call，远程过程调用，是一种进程间通信方式 允许程序调用另一个地址空间的过程或函数，而不用程序员显式编码这个远程调用的细节。 优点：调用简单、性能高、低延迟、自带负载均衡 缺点：耦合性强、无法跨语言，平台敏感 REST\r#\rREST，即 RESTful ，是一种架构风格，指的是一组架构约束条件和原则。 优点：耦合性低，兼容性好，通用性好，跨语言支持 缺点：性能不如 RPC 高 RPC \u0026amp; REST\r#\rRPC ：服务提供方与调用方接口依赖方式太强、服务对平台敏感，难以简单复用。 REST ：牺牲了服务调用的性能，但避免了RPC带来的问题。 RPC or REST\r#\rRPC 适用于内网服务调用，对外提供服务请走 REST。 IO 密集的服务调用用 RPC，低频服务用 REST 服务调用过于密集与复杂，RPC 就比较适用 "},{"id":15,"href":"/framework/spring/","title":"Spring","section":"开源框架","content":"\rSpring\r#\rSpring 是一个开源的轻量级 Java 开发框架 Spring 的核心是控制反转（IoC）和面向切面（AOP） Spring 特点\r#\r方便解耦，简化开发 用户可以将所有对象的创建和依赖关系的维护，交给Spring管理 支持AOP编程 Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能 支持声明式事务 只需要通过配置就可以完成对事务的管理，而无需手动编程 方便程序测试 Spring对Junit4支持，可以通过注解方便的测试Spring程序 集成各种优秀框架 Spring内部提供了对各种优秀框架的直接支持 简化JavaEE的使用 Spring对JavaEE开发中非常难用的一些API，都提供了封装，降低了使用难度 Spring 体系结构\r#\r"},{"id":16,"href":"/interview/core/01-ssm/","title":"SSM","section":"重点面试题","content":"\r\u0026ndash; Spring框架中的单例bean是线程安全的吗？\r#\r不是线程安全的。 当多用户同时请求一个服务时，容器会给每个请求分配一个线程，这些线程会并发执行业务逻辑。 通常在项目中使用的Spring bean是不可变状态（如Service类和DAO类），某种程度上可以认为是线程安全的。 如果bean有多种状态，就需要自行保证线程安全，比如用@Scope(\u0026#34;prototype\u0026#34;)修改bean的作用域 \u0026ndash; 什么是AOP？\r#\rAOP： 即面向切面编程，在Spring中用于将那些与业务无关但对多个对象产生影响的公共行为和逻辑抽取出来，实现公共模块复用，降低耦合。 常见应用场景：记录操作日志、缓存处理、Spring中内置的事务处理 \u0026ndash; 你们项目中有没有使用到AOP？\r#\r使用AOP来记录系统操作日志。 主要思路是使用AOP的环绕通知和切点表达式，找到需要记录日志的方法， 然后通过环绕通知的参数获取请求方法的参数，例如类信息、方法信息、注解、请求方式等，并将这些参数保存到数据库。 \u0026ndash; Spring中的事务是如何实现的？\r#\rSpring实现事务的本质是利用AOP完成的。 它对方法前后进行拦截，在执行方法前开启事务，在执行完目标方法后根据执行情况提交或回滚事务。 \u0026ndash; Spring中事务失效的场景有哪些？\r#\r1. 手动处理了异常 原因：事务通知只有捉到了目标抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉 解决：手动处理异常后再将异常抛出 2. 抛出的是检查型异常 原因：Spring 默认只会回滚非检查异常 解决：增加配置@Transactional(rollbackFor=Exception.class) 3. 事务注解的方法不是公开（public）的 原因：Spring 为方法创建代理、添加事务通知、前提条件都是该方法是 public 的 解决：改为 public 方法 \u0026ndash; Spring的bean的生命周期？\r#\r1. 通过BeanDefinition获取bean的定义信息 2. 调用构造函数实例化bean 3. 进行bean的依赖注入 4. 处理实现了Aware接口的bean 5. 执行BeanPostProcessor的前置处理器。 6. 调用初始化方法，如实现了InitializingBean接口或自定义的init-method。 7. 执行BeanPostProcessor的后置处理器，可能在这里产生代理对象。 8. 最后是销毁bean。 \u0026ndash; Spring中的循环引用？\r#\r循环依赖： 两个或两个以上的bean互相依赖，形成闭环。 Spring框架允许循环依赖存在，并通过三级缓存解决大部分循环依赖问题： 1. 一级缓存：单例池，缓存已完成初始化的bean对象。 2. 二级缓存：缓存尚未完成生命周期的早期bean对象。 3. 三级缓存：缓存ObjectFactory，用于创建bean对象。 \u0026ndash; 构造方法出现了循环依赖怎么解决？\r#\r由于构造函数是bean生命周期中最先执行的，Spring框架无法解决构造方法的循环依赖问题。 可以使用@Lazy进行懒加载，什么时候需要对象再进行bean对象的创建 \u0026ndash; SpringMVC的执行流程？\r#\r前后端分离： 1. 用户发送出请求到前端控制器 2. 前端控制器收到请求，调用处理器映射器 3. 处理器映射器找到具体处理器，返回处理器执行链给前端控制器 4. 前端控制器调用处理器适配器 5. 处理器适配器经过适配，调用具体的处理器 6. 通过HttpMessageConverter来返回结果转换为JSON并响应 \u0026ndash; Springboot自动配置原理？\r#\rSpringBoot的自动配置原理基于@SpringBootApplication注解， 它封装了三个注解：@ComponentScan、@SpringBootConfiguration、@EnableAutoConfiguration 1. @EnableAutoConfiguration是核心，它通过@Import导入配置选择器 2. 读取Jar包classpath路径下的META-INF/spring.factories文件中所配置的类的全类名 3. 根据条件注解来决定，是否将配置类中定义的Bean导入到Spring容器中。 \u0026ndash; Spring 常见注解有哪些？\r#\r声明Bean的注解：\t@Component、@Controller、@Service、@Repository 切面编程的注解：\t@Aspect、@Before、@After、@Around、@Pointcut @Autowired\t依赖注入 @Qualifier\t标注依赖注入的方式 @ComponentScan\t标注初始化容器时要扫描的包 @Configuration\t声明当前类是配置类 @Bean\t标注将该方法的返回值存储到Spring容器中 @Scope\t标注Bean的作用范围 @Import\t声明当前类会导入到IOC容器中 \u0026ndash; SpringMVC 常见注解有哪些？\r#\r@RequestMapping\t映射请求路径。 @RequestBody\t接收HTTP请求的JSON数据。 @RequestParam\t指定请求参数名称。 @RequestHeader\t获取请求头数据。 @PathVariable\t从请求路径中获取参数。 @ResponseBody\t将Controller方法返回的对象转化为JSON。 \u0026ndash; Springboot 常见注解有哪些？\r#\r@ComponentScan\t组件扫描，默认扫描当前引导类所在包及其子包。 @SpringBootConfiguration\t声明当前也是一个配置类。 @EnableAutoConfiguration\tSpringBoot实现自动化配置的核心注解。 其他注解如@RestController、@GetMapping、@PostMapping等，用于简化Spring MVC的配置。 \u0026ndash; MyBatis 执行流程？\r#\r1. 读取MyBatis配置文件：mybatis-config.xml加载运行环境和映射文件 2. 构造会话工厂SqlSessionFactory 3. 会话工厂创建SqlSession对象 4. 操作数据库的接口，Executor执行器 5. Executor执行方法中的MappedStatement参数 6. 输入参数映射。 7. 输出结果映射。 \u0026ndash; Mybatis 是否支持延迟加载？\r#\rMyBatis支持延迟加载，即在需要用到数据时才加载。 可以通过配置文件中的lazyLoadingEnabled配置启用或禁用延迟加载。 底层使用CGLIB动态代理实现： 1. 使用CGLIB创建目标对象的代理对象。 2. 调用目标方法时，如果发现是null值，则执行SQL查询。 3. 获取数据后，设置属性值并继续查询目标方法。 \u0026ndash; Mybatis的一级、二级缓存？\r#\rMybatis的一二级缓存，都是基于PerpetualCache的HashMap本地缓存 一级缓存：作用域为Session，默认开启。 二级缓存：作用域为Namespace或mapper，需要手动开启 \u0026ndash; Mybatis的二级缓存什么时候会被清理？\r#\r当作用域内进行了新增、修改、删除操作后，默认该作用域下所有select中的缓存将被清空。 \u0026ndash; Mybatis 中 #{}、${} 的区别？\r#\r#{} 预编译处理，Mybatis会将#{}替换为问号，再调用PreparedStatement的set方法来赋值，能防止SQL注入 ${} 字符串替换，Mybatis会将${}直接替换成变量的值，会发生SQL注入 "},{"id":17,"href":"/program-base/network/tcp-ip/tcp/","title":"TCP","section":"TCP/IP","content":"\rTCP 协议\r#\rTCP 协议\r#\rTransmission Control Protocol，传输控制协议 是面向连接的协议，在收发数据前，必须和对方建立可靠的连接。 一个TCP连接必须有三次握手、四次挥手 报文首部\r#\rseq：报文序号 ask：确认序号 标志位 描述 说明 URG 紧急 当URG=1时，表明报文段有紧急数据，应当尽快传送。 ACK 确认 当ACK=1时，上面的确认号才管用。 PSH 推送 当PSH=1时，接收端应当将缓冲区中的数据尽快交付上层。 RST 重连 当RST=1时，表示TCP连接出现严重差错，必须释放连接，再重新建立连接。 SYN 新建 当SYN=1时，表示请求建立连接。 FIN 终止 当FIN=1时，表示要求释放连接。 建立连接：三次握手\r#\r三次握手（Three-way Handshake），是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包 第一次握手：客户端发出报文（SYN），请求建立连接 第二次握手：服务器收到报文（ SYN ），如果同意连接，则发出确认报文（SYN+ASK） 第三次握手：客户端收到确认报文（SYN+ASK）后，再发出确认报文（ASK） 握手过程简述\n第一次握手 A请求建立连接 A：你听清楚么？ 第二次握手 A发送正常，B接收正常 B：能听清楚，你呢？ 第三次握手 B发送正常，A接收正常 A：也能听清楚。 断开连接：四次挥手\r#\r四次挥手（Four-way handshake），即TCP 的连接的拆除需要发送四个包 第一次挥手：客户端发出报文（FIN），请求释放连接，停止发送数据 第二次挥手：服务器收到报文（FIN），发出确认报文（ASK），停止接收数据 第三次挥手：服务器发出报文（FIN），停止发送数据 第四次挥手：客户端收到报文（FIN），发出确认报文（ASK），停止接收数据 挥手过程简述 第一次挥手 A请求断开连接 A：我要挂电话了？ 第二次挥手 B收到请求，同意断开连接 B：收到，挂吧。 第三次挥手 B确认断开连接 B：我也没有话要说了。 第四次挥手 A收到确认，断开连接 A：挂断电话。 UDP 协议\r#\rUser Data Protocol，用户数据报协议 是一个非连接的协议，传输数据之前源端和终端不建立连接 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上 报文首部\r#\rTCP vs UDP\r#\rTCP UDP 连接性 面向字节流，需要建立连接 面向报文，不需建立连接 可靠性 可靠，不丢包 不可靠，会丢包 传输效率 传输效率低，速度慢 传输效率高，速度快 流量控制 滑动窗口 无 拥塞控制 慢开始、拥塞避免、快重传、快恢复 无 应用场合 对效率要求低，对准确性要求高或要求有连接的场景 对效率要求高，对准确性要求低 连接方式 只支持点到点 支持一对一、一对多、多对多 首部开销 开销20字节 开销8字节 "},{"id":18,"href":"/program-lang/java/thread/container/ThreadLocal/","title":"ThreadLocal","section":"并发容器","content":"\rThreadLocal\r#\r概述\r#\r线程本地变量 变量在每个线程中都有独立拷贝，线程对变量的访问都是基于它自己的变量，就避免了线程不安全问题 数据隔离\r#\rThreadLocal 类操作的是 Thread 的成员变量 threadLocals。 每个线程 Thread 都有自己的 threadLocals，从而互相不影响。 实现\r#\r每个 Thread 对象都有一个 ThreadLocalMap 映射表 ThreadLocalMap 的 key 是 ThreadLocal 实例本身，value 则存储 Object 数据 通过 ThreadLocal 对象的 get()/set() 方法进行取值/设值 方法\r#\r// 构造方法 public ThreadLocal() // 设值 public void set(T value) // 取值 public T get() 示例\r#\rpublic class Test { private static ThreadLocal\u0026lt;String\u0026gt; local = new ThreadLocal\u0026lt;\u0026gt;(); public static void main(String[] args) { String[] values = {\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;}; for (String value : values) { new Thread(() -\u0026gt; { String thread = Thread.currentThread().getName(); Test.local.set(value); System.out.println(thread + \u0026#34; set(\u0026#34; + value + \u0026#34;)\u0026#34;); System.out.println(thread + \u0026#34; get()=\u0026#34; + local.get()); local.remove(); }).start(); } } } "},{"id":19,"href":"/program-lang/java/container/Map/TreeMap/","title":"TreeMap","section":"Map","content":"\rTreeMap\r#\r概述\r#\rTreeMap 是有序集合，通过红黑树实现 特点\r#\r键 不允许为null，不允许重复 值 允许为null，允许重复 顺序 有序 多线程 线程不安全 继承关系\r#\rpublic class TreeMap\u0026lt;K,V\u0026gt; extends AbstractMap\u0026lt;K,V\u0026gt; implements NavigableMap\u0026lt;K,V\u0026gt;, Cloneable, java.io.Serializable AbstractMap接口 提供了Map骨干功能 NavigableMap接口 SortedMap 的扩展接口，提供了一系列的导航方法 Cloneable接口 支持克隆 Serializable接口 支持序列化 成员变量\r#\r// 比较器 private final Comparator\u0026lt;? super K\u0026gt; comparator; // 红黑树的根节点 private transient Entry\u0026lt;K,V\u0026gt; root; // 元素的个数 private transient int size = 0; // 修改的次数 private transient int modCount = 0; // 节点结构 static final class Entry\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { K key; V value; Entry\u0026lt;K,V\u0026gt; left; Entry\u0026lt;K,V\u0026gt; right; Entry\u0026lt;K,V\u0026gt; parent; boolean color = BLACK; Entry(K key, V value, Entry\u0026lt;K,V\u0026gt; parent) { this.key = key; this.value = value; this.parent = parent; } //... } 构造方法\r#\r// 默认 public TreeMap() { comparator = null; } // 指定比较器 public TreeMap(Comparator\u0026lt;? super K\u0026gt; comparator) { this.comparator = comparator; } // 指定集合，转化为TreeMap public TreeMap(Map\u0026lt;? extends K, ? extends V\u0026gt; m) { comparator = null; putAll(m); } // 指定集合，转化为TreeMap public TreeMap(SortedMap\u0026lt;K, ? extends V\u0026gt; m) { //... } "},{"id":20,"href":"/program-lang/java/container/Set/TreeSet/","title":"TreeSet","section":"Set","content":"\rTreeSet\r#\r概述\r#\rTreeSet 基于 TreeMap 实现，是 TreeMap 的缩水版本 特点\r#\r顺序 有序 元素 不允许为null，不允许重复 多线程 线程不安全 继承关系\r#\rpublic class TreeSet\u0026lt;E\u0026gt; extends AbstractSet\u0026lt;E\u0026gt; implements NavigableSet\u0026lt;E\u0026gt;, Cloneable, java.io.Serializable AbstractSet接口 提供了 Set 接口的骨干功能 NavigableSet接口 SortedSet 的扩展接口，提供了一系列的导航方法 Cloneable接口 支持克隆 Serializable接口 支持序列化 成员变量\r#\r// 使用Map的key保存元素 private transient NavigableMap\u0026lt;E,Object\u0026gt; m; // 使用PRESENT作为Map所有key的value private static final Object PRESENT = new Object(); 构造方法\r#\r// 默认 public TreeSet() { this(new TreeMap\u0026lt;E,Object\u0026gt;()); } // 指定比较器 public TreeSet(Comparator\u0026lt;? super E\u0026gt; comparator) { this(new TreeMap\u0026lt;\u0026gt;(comparator)); } // 指定集合，转化为TreeSet public TreeSet(Collection\u0026lt;? extends E\u0026gt; c) { this(); //... } // 指定集合，转化为TreeSet public TreeSet(SortedSet\u0026lt;E\u0026gt; s) { this(s.comparator()); //... } "},{"id":21,"href":"/program-lang/java/container/List/Vector/","title":"Vector","section":"List","content":"\rVector\r#\r概述\r#\r是一个动态数组，其容量能够动态增长 和 ArrayList 很相似，不同的是，Vector 是线程安全的，且包含了许多非集合框架方法 不推荐使用 特点\r#\r顺序 有序 元素 允许为 null，允许重复 效率 比 ArrayList 效率低 多线程 线程安全 继承关系\r#\rpublic class Vector\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable AbstractList、List接口 提供了列表的骨干功能 RandomAccess接口 提供了随机访问功能 Cloneable接口 支持克隆 Serializable接口 支持序列化 成员变量\r#\r// 保存元素的数组 protected Object[] elementData; // 元素的个数 protected int elementCount; // 扩容因子 protected int capacityIncrement; 构造方法\r#\r// 默认 public Vector() { this(10); } // 指定初始容量 public Vector(int initialCapacity) { this(initialCapacity, 0); } // 指定初始容量、扩容因子 public Vector(int initialCapacity, int capacityIncrement) { //... } // 指定集合，转化为Vector public Vector(Collection\u0026lt;? extends E\u0026gt; c) { //... } 扩容机制\r#\r如果扩容因子大于0，就设置新容量为：旧容量 + 增长因子 如果扩容因子不大于0，设置新容量为：旧容量 * 2 private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement \u0026gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); } "},{"id":22,"href":"/program-design/data-algorithm/sort/bubble/","title":"冒泡排序","section":"排序","content":"\r冒泡排序\r#\r算法步骤\r#\r相邻元素两两比较，大的往后放。第一轮完毕后，最后的元素会是最大的数 去除最后的元素，重复以上的步骤。 直到所有元素均排序完毕 动图演示\r#\r代码实现\r#\rpublic class BubbleSort implements IArraySort { @Override public int[] sort(int[] arr) throws Exception { for (int i = 1; i \u0026lt; arr.length; i++) { // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。 boolean flag = true; for (int j = 0; j \u0026lt; arr.length - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; flag = false; } } if (flag) { break; } } return arr; } } "},{"id":23,"href":"/service-manage/distributed/","title":"分布式","section":"服务治理","content":"\r分布式系统\r#\r网络上相互连接的多个组件，通过通信协作而形成的软件系统 CAP 理论\r#\r一个分布式系统，最多只能同时实现 CAP 三要素中的两点，不能三者兼顾。 一致性 Consistency 所有节点上的数据时刻保持同步 可用性 Availability 每个请求都能接收到一个响应，无论响应成功或失败 分区容错 Partition tolerance 系统应该持续提供服务，即使系统内部某个节点有消息丢失 BASE 理论\r#\r基本可用 Basically Available 分布式系统在出现不可预知故障的时候，允许损失部分可用性 响应时间上的损失、系统功能上的损失 软状态 Soft-state 允许系统中的数据存在中间状态，前提是该中间状态的存在不会影响系统的整体可用性 即允许系统在不同节点的数据副本之间数据同步的过程存在延时 最终一致性 Eventually Consistent 系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态 "},{"id":24,"href":"/framework/spring/aop/AspectJ/","title":"切面编程","section":"AOP","content":"\r切面编程\r#\r启用\r#\rJava 配置类 // 在 Java 配置类中，使用 @EnableAspectJAutoProxy 和 @ComponentScan @Configuration @ComponentScan(basePackages = \u0026#34;xxx.xxx.xxx\u0026#34;) //注解扫描 @EnableAspectJAutoProxy //开启 AspectJ 的自动代理 public class AppConfig { } XML 配置文件 \u0026lt;!-- 开启注解扫描 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;xxx.xxx.xxx\u0026#34;/\u0026gt; \u0026lt;!--开启AspectJ 自动代理--\u0026gt; \u0026lt;aop:aspectj-autoproxy/\u0026gt; 示例\r#\r// 定义切面 @Aspect public class TestAnnotationAspect { // 定义切点 @Pointcut(\u0026#34;execution(* com.spring.service.*.*(..))\u0026#34;) private void pointCutMethod() { } // 定义环绕通知 @Around(\u0026#34;pointCutMethod()\u0026#34;) public Object doAround(ProceedingJoinPoint pjp) throws Throwable { System.out.println(\u0026#34;进入方法......\u0026#34;); Object o = pjp.proceed(); System.out.println(\u0026#34;退出方法......\u0026#34;); return o; } // 定义前置通知 @Before(\u0026#34;pointCutMethod()\u0026#34;) public void doBefore() { System.out.println(\u0026#34;......\u0026#34;); } // 定义后置通知 @After(\u0026#34;pointCutMethod()\u0026#34;) public void doAfter() { System.out.println(\u0026#34;......\u0026#34;); } // 定义正常返回通知 @AfterReturning(pointcut = \u0026#34;pointCutMethod()\u0026#34;, returning = \u0026#34;result\u0026#34;) public void doAfterReturning(String result) { System.out.println(\u0026#34;......\u0026#34;); } // 定义异常返回通知 @AfterThrowing(pointcut = \u0026#34;pointCutMethod()\u0026#34;, throwing = \u0026#34;e\u0026#34;) public void doAfterThrowing(Exception e) { System.out.println(\u0026#34;......\u0026#34;); } } "},{"id":25,"href":"/program-design/design-pattern/creational/","title":"创建型","section":"设计模式","content":" 常用 不常用 创造型 单例、工厂、建造者 原型 "},{"id":26,"href":"/program-lang/java/thread/thread/thread-create/","title":"创建线程","section":"线程基础","content":"\r创建线程\r#\r继承Thread类\r#\rpublic class MyThread extends Thread { @Override public void run() { // 执行体... } } public class Test { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.start(); } } 实现 Runnable 接口\r#\rpublic class MyRunnable implements Runnable { @Override public void run() { // 执行体... } } public class Test { public static void main(String[] args) { MyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable); thread.start(); } } 使用 Callable、Future\r#\rpublic class MyCallable implements Callable\u0026lt;String\u0026gt;{ @Override public String call(){ // 执行体... return \u0026#34;\u0026#34;; } } public class Test { public static void main(String[] args) { Callable\u0026lt;String\u0026gt; myCallable = new MyCallable(); FutureTask\u0026lt;String\u0026gt; futureTask = new FutureTask\u0026lt;\u0026gt;(myCallable); Thread thread = new Thread(futureTask); thread.start(); } } 使用 Executor 框架\r#\rpublic class MyRunnable implements Runnable { @Override public void run() { // 执行体... } } public class Test { public static void main(String[] args) { ExecutorService executor = Executors.newSingleThreadExecutor(); MyRunnable myRunnable = new MyRunnable(); for (int i = 0; i \u0026lt; 5; i++) { executor.execute(myRunnable); } System.out.println(\u0026#34;线程任务开始执行\u0026#34;); executor.shutdown(); } } "},{"id":27,"href":"/program-lang/java/jvm/class-load/loader/","title":"加载器","section":"类加载","content":"\r加载器\r#\r类加载\r#\r虚拟机加载class文件到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的Class对象 类加载器\r#\r实现 “通过一个类的全限定名来获取描述此类的二进制字节流” 动作的代码模块，称为类加载器。 相同的字节码被不同的类加载器加载的类不相等。 类加载器类型\r#\r启动类加载器\nBootstrapClassLoader C++ 编写，负责加载 jre/lib 下面的核心类库（java.lang.*等） 扩展类加载器\nExtClassLoader Java 编写，负责加载 jre/lib/ext 目录下的一些扩展类库， 只有一个实例。 应用程序类加载器\nAppClassLoader Java 编写，负责加载应用程序的主函数类 ， 只有一个实例。 用户自定义类加载器\nCustomClassLoader Java 编写，负责加载指定路径的 class 文件 双亲委派机制\r#\r当类加载器需要加载某一个 .class 字节码文件时，它会首先将这个任务委托给其父类加载器。 递归这个操作，直至传递到顶层的启动类加载器。 只有当父类加载器无法完成此加载任务时，子类加载器才会自己去加载。 双亲委派的作用\r#\r防止类的重复加载。通过委派的方式，判断上级是否已经加载过该 .class 文件，如果加载过了，则不需要重新加载 保证核心 .class 不被篡改，即使被篡改也不会被加载，即使被加载也不会是同一个 class 对象。 Java类随着类加载器一起具备了带有优先级的层级关系 "},{"id":28,"href":"/program-design/design-pattern/creational/01-singleton/","title":"单例模式","section":"创建型","content":"\r单例模式\r#\r概述\r#\r英文：Singleton Pattern 简述：保证一个类仅有一个实例，并且提供一个全局访问点 归纳：世上只有一个我 目的：保证独一无二 案例：CEO 示例\r#\r饿汉式\r#\r一般情况下，推荐使用 // 在类初始化时，已经自行实例化 public class Singleton { private static final Singleton instance = new Singleton(); private Singleton(){} public static Singleton getInstance(){ return instance; } } 懒汉式\r#\r一般情况下，不建议使用 // 在第一次调用的时候实例化自己 public class Singleton { private static volatile Singleton instance = null; private Singleton(){} public static Singleton getInstance(){ //双重判定：效率、同步 if(instance == null){ synchronized(Singleton.class){ if(instance == null){ return new Singleton(); } } } return instance; } } 登记式\r#\r内部静态类，只有在要明确实现 lazy loading 效果时，才会使用 public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } } 枚举式\r#\r如果涉及到反序列化创建对象时，可以尝试使用 public enum Singleton { INSTANCE; public void whateverMethod() { } } 应用\r#\r主要解决： 一个全局使用的类频繁的创建与销毁 应用场景： 要求生产唯一序列号。 WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 注意事项： 防止多线程情况下，实例被多次创建 单例类不要实现 Cloneable 接口 "},{"id":29,"href":"/algorithm/leetcode/%E5%93%88%E5%B8%8C/","title":"哈希","section":"leetcode","content":"\r哈希\r#\r哈希\r#\r用空间换时间，提高查询速度 两数之和\r#\r原题\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。 你可以按任意顺序返回答案。 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 题解\n枚举数组中的每一个数 x，寻找数组中是否存在 target - x import java.util.HashMap; public class Main { public int[] twoSum(int[] nums, int target) { HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { int choose = nums[i]; int diff = target - choose; if (map.containsKey(diff)) { return new int[]{map.get(diff), i}; } map.put(choose, i); } return null; } } 字母异位词分组\r#\r原题\n给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的所有字母得到的一个新单词。 输入: strs = [\u0026#34;eat\u0026#34;, \u0026#34;tea\u0026#34;, \u0026#34;tan\u0026#34;, \u0026#34;ate\u0026#34;, \u0026#34;nat\u0026#34;, \u0026#34;bat\u0026#34;] 输出: [[\u0026#34;bat\u0026#34;],[\u0026#34;nat\u0026#34;,\u0026#34;tan\u0026#34;],[\u0026#34;ate\u0026#34;,\u0026#34;eat\u0026#34;,\u0026#34;tea\u0026#34;]] 题解\n互为字母异位词的字符串，排序后的字符串一定是相同的 故可以将排序之后的字符串作为哈希表的键 import java.util.ArrayList; import java.util.Arrays; import java.util.HashMap; import java.util.List; public class Main { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groupAnagrams(String[] strs) { HashMap\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (String key : strs) { char[] chars = key.toCharArray(); Arrays.sort(chars); String sortKey = new String(chars); if (map.containsKey(sortKey)) { map.get(sortKey).add(key); } else { List\u0026lt;String\u0026gt; s = new ArrayList\u0026lt;\u0026gt;(); s.add(key); map.put(sortKey, s); } } return new ArrayList\u0026lt;\u0026gt;(map.values()); } } 最长连续序列\r#\r原题\n给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。 输入：nums = [100,4,200,1,3,2] 输出：4 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 题解\n如果数组中不存在 x-1，则 x 是序列的起始数 如果数组中不存在 x+1，则 x 是序列的终止数 import java.util.HashSet; public class Main { public int longestConsecutive(int[] nums) { HashSet\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int n : nums) { set.add(n); } int count = 0; int ans = 0; for (int n : set) { if (!set.contains(n - 1)) { //说明这部分是开始的数据：头 count = 1; int curr = n; while (set.contains(curr + 1)) { //如果存在说明是：中 count++; curr++; } //结束了不满足条件说明到了：尾 ans = Math.max(ans, count); } } return ans; } } "},{"id":30,"href":"/database/oracle/plsql/basic-syntax/","title":"基本语法","section":"PL/SQL","content":"\r基本语法\r#\rPL/SQL\r#\r是块结构语言，其最基本的单元是语句块。 每一条语句以逗号结尾，不区分大小写。 语句块\r#\r块的结构 关键字 是否必备 声明部分 DECLARE 可选 可执行命令部分 BEGIN、END 必备 异常处理部分 EXCEPTION 可选 -- 基本结构 DECLARE -- declarations section BEGIN -- executable command(s) EXCEPTION -- exception handling END; -- 示例 DECLARE message varchar2(20):= \u0026#39;Hello, World!\u0026#39;; BEGIN dbms_output.put_line(message); END; 标识符\r#\r由字母，数字，美元符号，下划线和数字符号组成 不能使用保留关键字作为标识符 不得超过30个字符 分隔符\r#\r分隔符 ' 字符串分隔符 \u0026quot; 引用标识符分隔符 , 项目分隔符 ( ) 表达式或列表分隔符 \u0026lt;\u0026lt; \u0026gt;\u0026gt; 标签分隔符 运算符 := 赋值运算符 =\u0026gt; 关联运算符 .. 范围运算符 ΙΙ 连接运算符 其他 % 属性绑定 . 组件选择符 : 主机变量指示符 @ 远程访问指示符 ; 声明或语句终止符 -- 单行注释 /* */ 多行注释 运算符\r#\r算术运算符 + - * / 加减乘除 ** 幂运算 关系运算符 \u0026lt; \u0026lt;= 小于、小于等于 \u0026gt; \u0026gt;= 大于、大于等于 = 等于 \u0026lt;\u0026gt; '= ~= ^= 不等于 比较运算符 LIKE 通配符比较 BETWEEN 范围比较 IN 判断值是否在结果集中 IS [NOT] NULL 是否为空 逻辑运算符 NOT 逻辑否 AND 逻辑与 OR 逻辑或 常量变量\r#\r常量\r#\r:= 赋初始值，也可以使用 DEFAULT 代替 -- 语法 constant_name CONSTANT datatype := value; -- 示例 pi CONSTANT NUMBER := 3.141592654; hello CONSTANT VARCHAR2(20) DEFAULT \u0026#39;Hello world\u0026#39;; 变量\r#\rNOT NULL 约束变量值不能为null -- 语法 variable_name datatype [NOT NULL] [:= value]; -- 示例 sales NUMBER(10, 2); name VARCHAR2(25) := \u0026#39;zhangsan\u0026#39;; DECLARE v_counter INTEGER; BEGIN v_counter := 0; v_counter := v_counter+1; DBMS_OUTPUT.put_line(\u0026#39;变量结果=\u0026#39; || v_counter); END; 变量作用域\r#\r局部变量：内部块中声明的变量，外部块不可访问。 全局变量：在最外部块或包中声明的变量。 DECLARE -- Global variables num1 number := 95; num2 number := 85; BEGIN DBMS_OUTPUT.put_line(\u0026#39;Outer Variable num1: \u0026#39; || num1); DBMS_OUTPUT.put_line(\u0026#39;Outer Variable num2: \u0026#39; || num2); DECLARE -- Local variables num1 number := 195; num2 number := 185; BEGIN DBMS_OUTPUT.put_line(\u0026#39;Inner Variable num1: \u0026#39; || num1); DBMS_OUTPUT.put_line(\u0026#39;Inner Variable num2: \u0026#39; || num2); END; END; /* Outer Variable num1: 95 Outer Variable num2: 85 Inner Variable num1: 195 Inner Variable num2: 185 */ 编码风格\r#\r大小写风格：关键字、内置函数、预定义类型使用大写字母。 标识符命名：v_变量名、con_常量名、cur_游标名、type_类型名 缩进风格：2空格缩进 "},{"id":31,"href":"/interview/core/08-concurrent/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"基础知识","section":"并发编程","content":"\r\u0026ndash; 线程和进程的区别？\r#\r1. 进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务 2. 不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间 3. 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低 \u0026ndash; 并行和并发有什么区别？\r#\r多核情况下， 多个任务，同一时间，同时运行为并行； 多个任务，同一时间，任务之间交替运行为并发； \u0026ndash; 创建线程的方式有哪些？\r#\r1. 继承Thread类 2. 实现runnable接口 3. 实现Callable接口 4. 线程池创建线程(项目中使用方式) \u0026ndash; Runnable 和 Callable 有什么区别？\r#\r1. Runnable接口run()方法没有返回值，不允许向上抛出异常 2. Callable接口call()方法有返回值，允许向上抛出异常 3. Callable返回值是个泛型，可以和Future、FutureTask配合使用，来获取异步执行的结果 \u0026ndash; 线程的 run()和 start()有什么区别？\r#\rrun() 封装了要被线程执行的代码，与普通方法一样，可以被手动调用多次。 start() 用来启动线程，线程会自动调用run()方法，去执行具体的逻辑。 线程只能启动一次，即start()方法只能被手动调用一次。 \u0026ndash; 线程包括哪些状态？是如何转换的？\r#\rThread类中的枚举6种状态： 新建（NEW）、可执行（RUNNABLE）、终止（TERMINATED） 阻塞（BLOCKED）、等待（ WAITING ）、计时等待（TIMED_WALTING） 相互转换： 1. 创建线程对象是新建状态 2. 调用了start()方法转变为可执行状态 3. 线程获取到了CPU的执行权，执行结束是终止状态 4. 在可执行状态的过程中，如果没有获取CPU的执行权，可能会切换其他状态 - 如果没有获取锁（synchronized或lock）进入阻塞状态，获得锁再切换为可执行状态 - 如果线程调用了wait()方法进入等待状态，其他线程调用notify()唤醒后可切换为可执行状态 - 如果线程调用了sleep(50)方法，进入计时等待状态，到时间后可切换为可执行状态 \u0026ndash; 新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？\r#\r可以使用线程类的join()方法： 如果线程A执行了t.join()语句，则线程A会被阻塞，直到线程t执行完后，才会继续执行线程A \u0026ndash; notify() 和 notifyAll() 有什么区别？\r#\rnotify：只随机唤醒一个wait线程 notifyAll：唤醒所有wait的线程 \u0026ndash; wait() 和 sleep() 有什么区别？\r#\r共同点： wait()和sleep()都是让当前线程暂时放弃CPU的执行权，进入阻塞状态 不同点： 1. 方法归属不同 sleep(long)是Thread类的静态方法 wait()、wait(long)是Object类的成员方法，每个对象都有 2. 唤醒时机不同 执行sleep(long)和wait(long)的线程都会在等待相应毫秒后自动唤醒 wait()、wait(long)还可以被notify/notifyAll唤醒 wait()如果不唤醒就一直等下去 3. 锁特性不同 wait()的调用必须先获取wait对象的锁，而sleep则无此限制 wait()执行后会释放对象锁，允许其它线程获得该对象锁 sleep()如果在synchronized代码块中执行，并不会释放对象锁 \u0026ndash; 如何停止一个正在运行的线程？\r#\r1. 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止 2. 使用stop()方法强行终止（不推荐，方法已作废） 3. 使用interrupt()方法中断线程 "},{"id":32,"href":"/program-lang/web/css/style/font/","title":"字体样式","section":"CSS 样式","content":"\r字体样式\r#\r属性\r属性说明\r属性值\r属性值说明\rcolor\r字体颜色\rcolor\r颜色值\rfont-style\r字体风格\rnormal\r正常\ritalic\r斜体\roblique\r斜体\rfont-weight\r字体粗细\r100 - 900\r数值：400=normal，700=bold\rlighter\r更细\rnormal\r标准\rbold\r粗体\rbolder\r更粗\rfont-size\r字体尺寸\rsize\r数值\rxx-small\r\u0026nbsp;\u0026nbsp;9px\r\u0026nbsp;x-small\r11px\r\u0026nbsp;\u0026nbsp; small\r13px\r\u0026nbsp; medium\r16px\r\u0026nbsp;\u0026nbsp; large\r19px\r\u0026nbsp;x-large\r23px\rxx-large\r28px\rfont-family\r字体系列\r字体名\rTimes、\"Times New Roman\"、...\r字体集\r\"serif\"、\"sans-serif\"、...\r简写\r#\r顺序：font-style | font-weight | font-size/line-height | font-family 至少需设定 font-size 和 font-family 示例\r#\rdiv{ font-style:italic; font-weight:bold; font-size:12px; line-height:1.5em; font-family:arial,verdana; color:red; } div{ font:italic bold 12px/1.5em arial,verdana; color:red; } "},{"id":33,"href":"/database/mysql/grammar/character-datatype/","title":"字符集、数据类型","section":"基本语法","content":"\r字符集\r#\rMySQL使用变量来存储字符集\n客户端传入数据给服务端：character_set_client\n服务端返回数据给客户端：character_set_results\n客户端服务端之间的连接：character_set_connection\n-- 查询数据库字符集 show variables like \u0026#39;character_set_%\u0026#39;; -- 设置字符集 set character_set_client = utf8; 设置字符集：修改my.ini文件\n[mysqld] character-set-server=utf8 [client] default-character-set=utf8 [mysql] default-character-set=utf8 数据类型\r#\r整数类型\r#\r类型 描述 大小 范围（有符号） 范围（无符号） TINYINT 迷你整形 1 字节 (-128，127) (0，255) SMALLINT 小整形 2 字节 (-32 768，32 767) (0，65 535) MEDIUMINT 中整形 3 字节 INT或INTEGER 标准整形 4 字节 BIGINT 大整形 8 字节 小数类型\r#\r语法：如Float(M,D)，M表示数值总位数，D代表小数部分位数 类型 描述 大小 FLOAT 单精度浮点型 4 字节 DOUBLE 双精度浮点型 8 字节 DECIMAL 数值型 16 字节 日期时间类型\r#\r类型 描述 大小 格式 范围 YEAR 年 1 字节 YYYY 1901 ~ 2155 DATE 日期 3 字节 YYYY-MM-DD 1000-01-01 ~ 9999-12-31 TIME 时间 3 字节 HH:MM:SS \u0026lsquo;-838:59:59\u0026rsquo; ~ \u0026lsquo;838:59:59\u0026rsquo; TIMESTAMP 时间戳 4 字节 YYYYMMDD HHMMSS 1970-01-01 00:00:00 ~ 2038-1-19 11:14:07 DATETIME 日期时间 8 字节 YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 ~9999-12-31 23:59:59 字符串类型\r#\r类型 描述 大小 CHAR 定长字符 0-255字节 VARCHAR 变长字符 0-65535 字节 TINYTEXT 短文本 0-255字节 TEXT 文本 0-65 535字节 MEDIUMTEXT 长文本 0-16 777 215字节 LONGTEXT 极大文本 0-4 294 967 295字节 TINYBLOB 二进制，短文本 0-255字节 BLOB 二进制，文本 0-65 535字节 MEDIUMBLOB 二进制，长文本 0-16 777 215字节 LONGBLOB 二进制，极大文本 0-4 294 967 295字节 "},{"id":34,"href":"/service-manage/springboot/work-principle/","title":"工作原理","section":"Spring Boot","content":"\r工作原理\r#\r核心注解\r#\r@SpringBootApplication，组合以下注解 @SpringBootConfiguration：Spring Boot 项目的配置注解 @EnableAutoConfiguration：启用自动配置 @ComponentScan：默认扫描 @SpringBootApplication 所在类的同级目录以及它的子目录 自动配置原理\r#\r在 spring 程序 main 方法中，添加 @SpringBootApplication 或者 @EnableAutoConfiguration 后， 框架会自动去 maven 中读取每个 starter 中的 spring.factories 文件。 该文件里配置了所有需要被创建的 spring bean。 "},{"id":35,"href":"/service-manage/zookeeper/work-principle/","title":"工作原理","section":"Zookeeper","content":"\r工作原理\r#\r工作机制\r#\r基于观察者模式设计，接受观察者的注册 负责存储和管理大家都关心的数据 当这些数据发现变化时，将会通知到已注册的观察者。 监听原理\r#\r在 main() 主线程中创建 zkClient 客户端。 zkClient 会创建两个线程，一个负责网络连接通信（connet），一个负责监听（listener）。 zkClient 通过 connet 线程，将监听事件注册到 Zookeeper 的监听列表。 当数据或路径发生改变时，Zookeeper 会将消息发送给 listener 线程。 listener 线程调用 process() 方法，执行相应的操作。 "},{"id":36,"href":"/program-lang/java/jvm/gc/reference-type/","title":"引用类型","section":"垃圾回收","content":"\r引用类型\r#\r强引用\r#\r指普通的对象引用 // 对于具有强引用的对象，就算出现OOM，垃圾回收器也不会对该对象进行回收。 Object strongReference = new Object(); // 只有当强引用和对象之间的关联被中断时，对象才会被回收 strongReference = null; 软引用\r#\r对于只有软引用的对象，当内存空间不充足时，它会被回收；当空间充足时，它不会被回收； 应用场景：高速缓存、读取大量本地图片 // 强引用 String str = new String(\u0026#34;abc\u0026#34;); // 软引用 SoftReference\u0026lt;String\u0026gt; softReference = new SoftReference\u0026lt;\u0026gt;(str); System.out.println(softReference.get()); 弱引用\r#\r对于只有弱引用的对象，不管内存空间是否充足，它都会被回收 应用场景：读取大量本地图片 // 强引用 String str = new String(\u0026#34;abc\u0026#34;); // 弱引用 WeakReference\u0026lt;String\u0026gt; weakReference = new WeakReference\u0026lt;\u0026gt;(str); System.out.println(weakReference.get()); // WeakHashMap：键是\u0026#34;弱键\u0026#34;，通过弱引用来管理 entry Map\u0026lt;Integer, String\u0026gt; weakMap = new WeakHashMap\u0026lt;\u0026gt;(); Integer key = new Integer(1); weakMap.put(key, \u0026#34;value\u0026#34;); System.out.println(weakMap); key = null; System.gc(); System.out.println(weakMap); // {1=value} // {} 虚引用\r#\r即形同虚设， 对于只有虚引用的对象，它就和没有引用一样，在任何时候都可能被回收 它必须与 ReferenceQueue 配合使用，垃圾回收之后，它会被放入引用队列中 // 强引用 String str = new String(\u0026#34;abc\u0026#34;); // 虚引用 ReferenceQueue queue = new ReferenceQueue(); PhantomReference pr = new PhantomReference(str, queue); 总结\r#\r引用类型 被垃圾回收时间 用途 生存时间 强引用 从来不会 对象的一般状态 JVM停止运行时终止 软引用 当内存不足时 对象缓存 内存不足时终止 弱引用 正常垃圾回收时 对象缓存 垃圾回收后终止 虚引用 正常垃圾回收时 跟踪对象的垃圾回收 垃圾回收后终止 "},{"id":37,"href":"/algorithm/huawei-od/%E5%BF%85%E4%BC%9A%E9%A2%981/","title":"必会题 - 1","section":"华为OD","content":"\r01. 字符串分割\r#\r描述\n给定一个非空字符串S，其被N个‘-’分隔成N+1的子串，给定正整数K，要求除第一个子串外，其余的子串每K个字符组成新的子串，并用‘-’分隔。 对于新组成的每一个子串， 如果它含有的小写字母比大写字母多，则将这个子串的所有大写字母转换为小写字母； 如果它含有的大写字母比小写字母多，则将这个子串的所有小写字母转换为大写字母； 大小写字母的数量相等时，不做转换。 输入描述：输入为两行，第一行为参数K，第二行为字符串S。 输出描述：输出转换后的字符串 输入： 3 12abc-abcABC-4aB@ 输出： 12abc-abc-ABC-4aB-@ 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int k = Integer.parseInt(sc.nextLine()); String input = sc.nextLine(); String[] strings = input.split(\u0026#34;-\u0026#34;); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(strings[0]); StringBuilder str = new StringBuilder(); for (int i = 1; i \u0026lt; strings.length; i++) { str.append(strings[i]); } for (int i = 0; i \u0026lt; str.length(); i += k) { if (i + k \u0026lt;= str.length()) { list.add(caseConversion(str.substring(i, i + k))); } else { list.add(caseConversion(str.substring(i))); } } System.out.println(String.join(\u0026#34;-\u0026#34;, list)); } private static String caseConversion(String s) { int upperCaseLength = s.length() - s.replaceAll(\u0026#34;[A-Z]\u0026#34;, \u0026#34;\u0026#34;).length(); int lowerCaseLength = s.length() - s.replaceAll(\u0026#34;[a-z]\u0026#34;, \u0026#34;\u0026#34;).length(); if (upperCaseLength \u0026gt; lowerCaseLength) { return s.toUpperCase(Locale.ROOT); } if (lowerCaseLength \u0026gt; upperCaseLength) { return s.toLowerCase(Locale.ROOT); } return s; } 02. 组成最大数\r#\r描述\n小组中每位都有一张卡片，卡片上是6位内的正整数，将卡片连起来可以组成多种数字，计算组成的最大数字。 输入描述：“,”号分割的多个正整数字符串，不需要考虑非数字异常情况，小组最多25个人。 输出描述：最大的数字字符串 输入： 4589,101,41425,9999 输出： 9999458941425101 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String input = sc.nextLine(); String[] strings = input.split(\u0026#34;,\u0026#34;); Arrays.sort(strings); for (int i = strings.length - 1; i \u0026gt;= 0; i--) { System.out.print(strings[i]); } } 03. 统计射击比赛成绩\r#\r描述\n给定一个射击比赛成绩单，包含多个选手若干次射击的成绩分数， 请对每个选手按其最高3个分数之和进行降序排名，输出降序排名后的选手ID序列。 1、一个选手可以有多个射击成绩的分数，且次序不固定。 2、如果一个选手成绩少于3个，则认为选手的所有成绩无效，排名忽略该选手。 3、如果选手的成绩之和相等，则成绩之和相等的选手按照其ID降序排列。 输入描述： 输入第一行，一个整数N，表示该场比赛总共进行了N次射击，产生N个成绩分数（2≤N≤100）。 输入第二行，一个长度为N整数序列，表示参与每次射击的选手ID（0≤ID≤99）。 输入第三行，一个长度为N整数序列，表示参与每次射击的选手对应的成绩（0≤成绩≤100）。 输出描述：符合题设条件的降序排名后的选手ID序列。 输入: 13 3,3,7,4,4,4,4,7,7,3,5,5,5 53,80,68,24,39,76,66,16,100,55,53,80,55 输出： 5,3,7,4 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); String[] idArr = sc.nextLine().split(\u0026#34;,\u0026#34;); String[] scoreArr = sc.nextLine().split(\u0026#34;,\u0026#34;); Integer[] ids = Arrays.stream(idArr).map(Integer::parseInt).toArray(Integer[]::new); Integer[] scores = Arrays.stream(scoreArr).map(Integer::parseInt).toArray(Integer[]::new); Map\u0026lt;Integer, ArrayList\u0026lt;Integer\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; num; i++) { map.putIfAbsent(ids[i], new ArrayList\u0026lt;\u0026gt;()); map.get(ids[i]).add(scores[i]); } ArrayList\u0026lt;int[]\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int id : map.keySet()) { ArrayList\u0026lt;Integer\u0026gt; idScores = map.get(id); if (idScores.size() \u0026lt; 3) { continue; } int total = idScores.stream().sorted((a, b) -\u0026gt; b - a) .limit(3).reduce(Integer::sum).orElse(0); ans.add(new int[]{id, total}); } ans.sort((a, b) -\u0026gt; a[1] != b[1] ? b[1] - a[1] : b[0] - a[0]); String result = ans.stream().map(arr -\u0026gt; String.valueOf(arr[0])) .collect(Collectors.joining(\u0026#34;,\u0026#34;)); System.out.print(result); } 04. 字符串序列判定\r#\r描述\n给定两个字符串 s和 t ，判断 s是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度n ~= 500,000），而 s 是个短字符串（长度 ≤ 100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。 （例如，\u0026#34;ace\u0026#34;是\u0026#34;abcde\u0026#34;的一个子序列，而\u0026#34;aec\u0026#34;不是）。 输入描述：共两行，第一行为字符串s（1≤m≤100）, 第二行为字符串t（1≤n≤500000） 输出描述：输出true或者是false 输入： abc ahbgdc 输出： true 题解\npublic static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); char[] chars1 = br.readLine().toCharArray(); int read; int index = 0; char temp = \u0026#39; \u0026#39;; while ((read = br.read()) != \u0026#39;\\n\u0026#39;) { char ch = (char) read; if (index \u0026lt; chars1.length \u0026amp;\u0026amp; ch == chars1[index] \u0026amp;\u0026amp; ch != temp) { temp = ch; index++; } } String result = index == chars1.length ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;; System.out.print(result); } 05. 数据分类\r#\r描述\n对一个数据a进行分类， 分类方法是，此数据a(4个字节大小)的4个字节相加对一个给定值b取模， 如果得到的结果小于一个给定的值c则数据a为有效类型，其类型为取模的值。 如果得到的结果大于或者等于c则数据a为无效类型。 比如一个数据a = 0x01010103，b = 3 按分类方法计算：(0x01 + 0x01 + 0x01 + 0x03) % 3 = 0 所以如果c = 2则此a就是有效类型，其类型为0 如果c = 0则此a是无效类型 输入描述：输入12个数据， 第一个数据为c，第二个数据为b， 剩余10个数据为需要分类的数据 输出描述： 请找到有效类型中包含数据最多的类型， 并输出该类型含有多少个数据。 输入：3 4 256 257 258 259 260 261 262 263 264 265 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] ints = new int[12]; for (int i = 0; i \u0026lt; ints.length; i++) { ints[i] = sc.nextInt(); } solution(ints); } private static void solution(int[] ints) { int c = ints[0]; int b = ints[1]; Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 2; i \u0026lt; ints.length; i++) { int r = intByteSum(ints[i]) % b; if (r \u0026lt; c) { map.putIfAbsent(r, 0); map.put(r, map.get(r) + 1); } } int max = 0; for (Integer value : map.values()) { if (value \u0026gt; max) { max = value; } } System.out.println(max); } private static int intByteSum(int x) { int sum = 0; for (int i = 0; i \u0026lt; 4; i++) { sum += (byte) (x \u0026gt;\u0026gt; (i * 8)); } return sum; } 06. 五键键盘的输出\r#\r描述\n有一个特殊的 5键键盘，上面有 a,ctrl-c,ctrl-x,ctrl-v,ctrl-a五个键，给定一系列键盘输入，输出最终屏幕上字母的数量。 a键在屏幕上输出一个字母 a; ctrl-c将当前选择的字母复制到剪贴板; ctrl-x将当前选择的 字母复制到剪贴板，并清空选择的字母; ctrl-v将当前剪贴板里的字母输出到屏幕; ctrl-a选择当前屏幕上所有字母。 注意: 1、剪贴板初始为空，新的内容被复制到剪贴板时会覆盖原来的内容 2、当屏幕上没有字母时，ctrl-a无效 3、当没有选择字母时，ctrl-c和 ctrl-x无效 4、当有字母被选择时，a和ctrl-v这两个有输出功能的键会先清空选择的字母，再进行输出 输入描述：输入为一行，为简化解析，用数字 12345代表 a,ctrl-c,ctrl-x,ctrl-v,ctrl-a五个键的输入，数字用空格分隔 输出描述：输出一个数字，为最终屏目上字母的数量。 输入：1 1 5 1 5 2 4 4 输出：2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] strings = sc.nextLine().split(\u0026#34; \u0026#34;); int copy = 0; int sum = 0; boolean isCopy = false; boolean isSelect = false; for (String str : strings) { if (\u0026#34;1\u0026#34;.equals(str) \u0026amp;\u0026amp; isSelect) { sum = 1; isSelect = false; continue; } if (\u0026#34;1\u0026#34;.equals(str) \u0026amp;\u0026amp; !isSelect) { sum++; continue; } if (\u0026#34;2\u0026#34;.equals(str) \u0026amp;\u0026amp; isSelect) { copy = sum; isCopy = true; continue; } if (\u0026#34;3\u0026#34;.equals(str) \u0026amp;\u0026amp; isSelect) { copy = sum; sum = 0; isCopy = true; isSelect = false; continue; } if (\u0026#34;4\u0026#34;.equals(str) \u0026amp;\u0026amp; isCopy \u0026amp;\u0026amp; isSelect) { sum = copy; isSelect = false; continue; } if (\u0026#34;4\u0026#34;.equals(str) \u0026amp;\u0026amp; isCopy \u0026amp;\u0026amp; !isSelect) { sum = sum + copy; continue; } if (\u0026#34;5\u0026#34;.equals(str)) { copy = sum; isSelect=true; } } System.out.println(sum); } 07. 检查是否存在满足条件的数字组合\r#\r描述\n给定一个正整数数组，检查数组中是否存在满足规则的数字组合 规则：A = B + 2C 备注： 数组长度在3~100之间 数组成员为0~65535 数组成员可以重复，但每个成员只能在结果算式中使用一次， 如数组成员为 [0,0,1,5]，0出现两次允许，但结果0=0+2*0不允许 因为算式中使用了3个0 用例保证每组数字里最多只有一组符合要求的解 输入描述： 第一行输出数组的元素个数。 第二行输出所有数组元素，用空格隔开。 输出描述： 如果存在满足要求的数，在同一行里依次输出规则里A/B/C的取值，用空格隔开。 如果不存在，输出0。 输入： 4 2 7 3 0 输出： 7 3 2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); String[] strings = sc.nextLine().split(\u0026#34; \u0026#34;); Integer[] arr = new Integer[strings.length]; for (int i = 0; i \u0026lt; strings.length; i++) { arr[i] = Integer.parseInt(strings[i]); } System.out.println(getResult(n, arr)); } public static String getResult(int n, Integer[] arr) { Arrays.sort(arr, (a, b) -\u0026gt; b - a); for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { for (int k = j + 1; k \u0026lt; n; k++) { if (arr[i] == arr[j] + 2 * arr[k]) { return arr[i] + \u0026#34; \u0026#34; + arr[j] + \u0026#34; \u0026#34; + arr[k]; } if (arr[i] == arr[k] + 2 * arr[j]) { return arr[i] + \u0026#34; \u0026#34; + arr[k] + \u0026#34; \u0026#34; + arr[j]; } } } } return \u0026#34;0\u0026#34;; } 08. 数组拼接\r#\r描述\n现在有多组整数数组，需要将它们合并成一个新的数组。 合并规则，循环从每个数组里按顺序取出固定长度的内容合并到新的数组中，取完的内容会删除掉， 如果该行不足固定长度或者已经为空，则直接取出剩余部分的内容放到新的数组中，继续下一行。 输入描述： 第一行是每次读取的固定长度，0＜长度＜10 第二行是整数数组的数目，0＜数目＜1000 第3-n行是需要合并的数组，不同的数组用回车换行分隔，数组内部用逗号分隔，最大不超过100个元素 输出描述：输出一个新的数组，用逗号分隔。 输入： 3 2 2,5,6,7,9,5,7 1,7,4,3,4 输出： 2,5,6,1,7,4,7,9,5,3,4,7 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int len = Integer.parseInt(sc.nextLine()); int num = Integer.parseInt(sc.nextLine()); List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; num; i++) { list.add(Arrays.asList(sc.nextLine().split(\u0026#34;,\u0026#34;))); } int start = 0; int end; List\u0026lt;String\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); int count = 0; while (count \u0026lt; list.size()) { for (List\u0026lt;String\u0026gt; strings : list) { if (start \u0026gt; strings.size() - 1) { continue; } end = Math.min(start + len, strings.size()); if (end == strings.size()) { count++; } result.addAll(strings.subList(start, end)); } start += len; } System.out.println(String.join(\u0026#34;,\u0026#34;, result)); } 09. 数列描述\r#\r描述\n有一个数列A[n]，从A[0]开始每一项都是一个数字，数列中A[n+1]都是A[n]的描述，其中A[0]=1，规则如下： A[0]:1 A[1]:11 表示A[0]从左到右连续出现了1次1 A[2]:21 表示A[1]从左到右连续出现了2次1 A[3]:1211 表示A[2]从左到右连续出现了一次2又连续出现了一次1 A[4]:111221 表示A[3]从左到右连续出现了一次1又连续出现了一次2又连续出现了2次1 输出第n项的结果 输入描述：数列第n项 0≤n≤59 输出描述：数列内容 输入：4 输出：111221 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); if (num == 0) { System.out.println(\u0026#34;1\u0026#34;); return; } String result = \u0026#34;1\u0026#34;; for (int i = 1; i \u0026lt;= num; i++) { result = getNext(result); } System.out.println(result); } private static String getNext(String str) { char[] chars = str.toCharArray(); int sum = 0; char ch = chars[0]; StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; chars.length; i++) { if (ch == chars[i]) { sum++; continue; } sb.append(sum).append(ch); ch = chars[i]; sum = 1; } sb.append(sum).append(ch); return sb.toString(); } 10. 考勤信息\r#\r描述\n公司用一个字符串来表示员工的出勤信息 缺勤-absent，迟到-late，早退-leaveearly，正常上班-resent 现需根据员工出勤信息，判断本次是否能获得出勤奖，能获得出勤奖的条件如下： 缺勤不超过一次； 没有连续的迟到/早退； 任意连续7次考勤，缺勤/迟到/早退不超过3次。 输入描述： 第一行输入一个整数n，表示有多少个员工 后面n行，每一行输入若干个字符串，表示第i名员工的出勤信息 输出描述： 输出n行，每一行表示这名员工能否获得出勤奖，如果可以，则输出“true\u0026#34;，否则输出”false\u0026#34; 输入： 2 present present absent present present leaveearly present absent 输出： true false 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; num; i++) { list.add(getResult(sc.nextLine())); } list.forEach(System.out::println); } private static String getResult(String string) { // 缺勤不超过一次 String str = string.replaceFirst(\u0026#34;absent\u0026#34;, \u0026#34;\u0026#34;); if (str.contains(\u0026#34;absent\u0026#34;)) { return \u0026#34;false\u0026#34;; } // 没有连续的迟到/早退； if (string.contains(\u0026#34;late leaveearly\u0026#34;) || string.contains(\u0026#34;leaveearly late\u0026#34;)) { return \u0026#34;false\u0026#34;; } // 任意连续7次考勤，缺勤/迟到/早退不超过3次。 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(string.split(\u0026#34; \u0026#34;))); if (list.size() \u0026lt; 7) { // 填充到7天 for (int i = 0; i \u0026lt; 7 - list.size(); i++) { list.add(\u0026#34;\u0026#34;); } } for (int i = 0; i \u0026lt; list.size() - 6; i++) { int time = 0; List\u0026lt;String\u0026gt; subList = list.subList(i, i + 7); for (String subStr : subList) { if (!\u0026#34;resent\u0026#34;.equals(subStr)) { time++; } if (time \u0026gt; 3) { return \u0026#34;false\u0026#34;; } } } return \u0026#34;ture\u0026#34;; } 11. 按单词下标区间翻转文章内容\r#\r描述\n给定一段英文文章片段，由若干单词组成，单词间以空格间隔，单词下标从0开始。 请翻转片段中指定区间的单词顺序并返回翻转后的内容。 例如给定的英文文章片段为\u0026#34;I am a developer\u0026#34;，翻转区间为[0,3]，则输出“developer a am I”。 输入描述：使用换行隔开三个参数 第一个参数为英文文章内容即英文字符串 第二个参数为待翻转内容起始单词下标 第三个参数为待翻转内容最后一个单词下标 输出描述：翻转后的英文文章片段所有单词之间以一个半角空格分隔进行输出。 输入：I am a developer. 0 3 输出：developer. a am I 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String text = sc.nextLine(); int left = Integer.parseInt(sc.nextLine()); int right = Integer.parseInt(sc.nextLine()); List\u0026lt;String\u0026gt; strList = Arrays.stream(text.split(\u0026#34; \u0026#34;)) .filter(str -\u0026gt; str != null \u0026amp;\u0026amp; !str.isBlank()).collect(Collectors.toList()); left = Math.min(left, 0); right = Math.min(right, strList.size() - 1); if (right == left || left \u0026gt; strList.size() - 1 || right \u0026lt; 0) { System.out.println(\u0026#34;EMPTY\u0026#34;); return; } List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; left; i++) { list.add(strList.get(i)); } for (int i = right; i \u0026gt;= left; i--) { list.add(strList.get(i)); } for (int i = right + 1; i \u0026lt; strList.size(); i++) { list.add(strList.get(i)); } System.out.println(String.join(\u0026#34; \u0026#34;, list)); } 12. 最大括号深度\r#\r描述\n现有一字符串 仅由 \u0026#39;(\u0026#39;, \u0026#39;)\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;}\u0026#39;, \u0026#39;[\u0026#39;, \u0026#39;]\u0026#39;一共六种括号组成。若字符串满足以下条件之一，则为无效字符串。 1、任意类型的左右括号数量不相等 2、存在未按正确顺序(先左后右)闭合的括号，输出括号的最大嵌套深度，若字符串无效则输出 0。 输入描述：一个只包括 \u0026#39;(\u0026#39;, \u0026#39;)\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;}\u0026#39;, \u0026#39;[\u0026#39;, \u0026#39;]\u0026#39; 以一共6种字符的字符串。 输出描述：一个整数，表示最大的括号深度。若字符串无效，则输出 0 输入：([]{()}) 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chars = sc.nextLine().toCharArray(); int depth = 0; Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (char ch : chars) { if (ch == \u0026#39;(\u0026#39; || ch == \u0026#39;{\u0026#39; || ch == \u0026#39;[\u0026#39;) { stack.push(ch); depth = Math.max(depth, stack.size()); continue; } if (stack.isEmpty()) { System.out.println(\u0026#34;0\u0026#34;); return; } char left = stack.pop(); if ((ch == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; left != \u0026#39;(\u0026#39;) || (ch == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; left != \u0026#39;{\u0026#39;) || (ch == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; left != \u0026#39;[\u0026#39;)) { System.out.println(\u0026#34;0\u0026#34;); return; } } System.out.println(depth); } 13. 字符串加密\r#\r描述\n给你一串未加密的字符串str，过对字符串的每一个字母进行改变来实现加密， 加密方式是在每一个字母str[i]偏移特定数组元素a[i]的量， 数组a前三位已经赋值：a[0]=1,a[1]=2,a[2]=4。 当i\u0026gt;=3时，数组元素a[i]=a[i-1]+a[i-2]+a[i-3]， 例如：原文 abcde 加密后 bdgkr，其中偏移量分别是1,2,4,7,13。 输入描述： 第一行为一个整数n（1 ≤ n ≤ 1000）， 表示有n组测试数据，每组数据包含一行， 原文str（只含有小写字母， 长度小于等于50）。 输出描述：每组测试数据输出一行，表示字符串的密文 输入：1 xy 输出：a 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); for (int i = 0; i \u0026lt; num; i++) { getResult(sc.nextLine()); } } private static void getResult(String string) { char[] chars = string.toCharArray(); StringBuilder sb = new StringBuilder(); int temp1 = 1; int temp2 = 2; int temp3 = 4; int offset = 0; for (int i = 0; i \u0026lt; chars.length; i++) { if (i == 0) { sb.append(getNextChar(chars[i], temp1)); continue; } if (i == 1) { sb.append(getNextChar(chars[i], temp2)); continue; } if (i == 2) { sb.append(getNextChar(chars[i], temp3)); continue; } offset = temp1 + temp2 + temp3; sb.append(getNextChar(chars[i], offset)); temp1 = temp2; temp2 = temp3; temp3 = offset; } System.out.println(sb.toString()); } private static char getNextChar(char c, int offset) { offset = ((c - \u0026#39;a\u0026#39;) + offset) % 26; return (char) (\u0026#39;a\u0026#39; + offset); } 14. 整数对最小和\r#\r描述\n给定两个整数数组 array1、array2，数组元素按升序排列 假设从array1、array2中分别取出一个元素可构成一对元素 现在需要取出K个元素，对取出的所有元素求和，计算和的最小值 注意： 两对元素如果对应于array1、array2中的两个下标均相同，则视为同一个元素 输入描述： 输入两行数组：array1、array2, 每行首个数字为数组大小：size(0＜size≤100), 0＜array1[i]≤1000, 0＜array2[i]≤1000 接下来一行为正整数k：0＜k≤ array1.size()*array2.size() 输出描述： 满足要求的最小和 输入：3 1 1 2 3 1 2 3 2 输出：4 说明： 用例中，需要取2对元素 取第一个数组第0个元素与第二个数组第0个元素组成1对元素[1，1]； 取第一个数组第1个元素与第二个数组第0个元素组成1对元素[1，1]； 求和为1+1+1+1=4，为满足要求的最小和 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] arr1 = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int[] arr2 = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int k = Integer.parseInt(sc.nextLine()); Arrays.sort(arr1); Arrays.sort(arr2); int l = 2; int r = 2; Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;1-1\u0026#34;, arr1[1] + arr2[1]); while (map.size() \u0026lt; k) { if (arr1[l] \u0026lt;= arr2[r]) { for (int i = 1; i \u0026lt; r; i++) { String key = l + \u0026#34;-\u0026#34; + i; if (!map.containsKey(key)) { map.put(key, arr1[l] + arr2[i]); } } l++; continue; } if (arr1[l] \u0026gt; arr2[r]) { for (int i = 1; i \u0026lt; l; i++) { String key = i + \u0026#34;-\u0026#34; + r; if (!map.containsKey(key)) { map.put(key, arr1[i] + arr2[r]); } } r++; } } System.out.println(map.values().stream().reduce(Integer::sum).orElse(0)); } 15. 求字符串中所有整数的最小和\r#\r描述\n输入字符串s，输出s中包含所有整数的最小和。 说明： 字符串s，只包含 a-z A-Z ± ； 合法的整数包括 正整数：一个或者多个0-9组成，如0，2，3，002，102 负整数：负号 – 开头，数字部分由一个或者多个0-9组成，如-0，-012，-23，-00023 输入描述：包含数字的字符串。 输出描述：所有整数的最小和。 输入：b12-34aa 输出：-31 说明：1+2+(-34)=-31 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chars = sc.nextLine().toCharArray(); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); String temp = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; chars.length; i++) { if (\u0026#39;-\u0026#39; == chars[i]) { temp = \u0026#34;-\u0026#34;; continue; } if (chars[i] \u0026lt; \u0026#39;0\u0026#39; || chars[i] \u0026gt; \u0026#39;9\u0026#39;) { if (temp.length() \u0026gt; 1) { list.add(temp); temp = \u0026#34;\u0026#34;; } continue; } if (!temp.isEmpty()) { temp += chars[i]; continue; } list.add(String.valueOf(chars[i])); } if (temp.length() \u0026gt; 1) { list.add(temp); } System.out.println(list.stream().mapToInt(Integer::parseInt).reduce(Integer::sum).orElse(0)); } 16. 乱序整数序列两数之和绝对值最小\r#\r描述\n给定一个随机的整数数组(可能存在正整数和负整数)nums, 请你在该数组中找出两个数，其和的绝对值(|nums[x]+nums[y]|)为最小值，并返回这两个数(按从小到大返回)以及绝对值。 每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 输入描述：一个通过空格空格分割的有序整数序列字符串，最多1000个整数，且整数数值范围是[-65535,65535] 输出描述：两个数、两数之和绝对值 输入：-1 -3 7 5 11 15 输出：-3 5 2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); List\u0026lt;Integer\u0026gt; list = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).distinct() .map(Integer::parseInt).collect(Collectors.toCollection(ArrayList::new)); int a = 0; int b = 0; int sum = Integer.MAX_VALUE; for (int i = 0; i \u0026lt; list.size(); i++) { for (int j = 0; j \u0026lt; list.size(); j++) { if (i == j) { continue; } int temp = Math.abs(list.get(i) + list.get(j)); if (temp \u0026lt; sum) { a = list.get(i); b = list.get(j); sum = temp; } } } System.out.print(Math.min(a, b) + \u0026#34; \u0026#34; + Math.max(a, b) + \u0026#34; \u0026#34; + sum); } 17. 非严格递增连续数字序列\r#\r描述\n输入一个字符串仅包含大小写字母和数字，求字符串中包含的最长的非严格递增连续数字序列长度 比如： 12234属于非严格递增数字序列 输入描述：输入一个字符串仅包含大小写字母和数字 输出描述：出字符串中包含的最长的非严格递增连续数字序列长度 输入：abc2234019A334bc 输出：4 说明：2234为最长的非严格递增连续数字序列 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chars = sc.nextLine().toCharArray(); int curLen = 0; int maxLen = 0; char last = \u0026#39;0\u0026#39;; for (int i = 0; i \u0026lt; chars.length; i++) { char ch = chars[i]; if (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { curLen = 0; continue; } if (ch \u0026lt; last) { last = \u0026#39;0\u0026#39;; curLen = 1; continue; } curLen++; last = ch; maxLen = Math.max(maxLen, curLen); } System.out.println(maxLen); } 18. 分积木\r#\r描述\nsolo和koko是两兄弟，分一堆积木，每块积木有自己的重量，现在他们将积木分成两堆。 弟弟koko还小只会将数字转化为二进制进行计算，而且总是忘记进位。 弟弟koko按照他计算的方式要求两堆积木重量相等，要不然就会哭 哥哥solo进行分积木希望尽量给弟弟少分，并且不让弟弟哭 输入描述： 第一行是一个整数N (2 ≤ N ≤ 100)，表示有多少块积木 第二行为空格分开的N个整数Ci (1 ≤ Ci ≤ 10^6)，表示第i块积木的重量 输出描述：让koko不哭，输入solo所能获得积木的最大总重量否则输出 \u0026#34;No\u0026#34; 输入：3 3 5 6 输出：11 按koko计算，其得到的积木的重量都是11(二进制) 按真实计算，solo得到的积木的重量是5+6=11(十进制) 101 十进制--5 + 110 十进制--6 —————— 011 十进制--3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); int[] arr = new int[num]; String[] strings = sc.nextLine().split(\u0026#34; \u0026#34;); for (int i = 0; i \u0026lt; strings.length; i++) { arr[i] = Integer.parseInt(strings[i]); } String result = solution(arr); System.out.print(result); } private static String solution(int[] arr) { if (arr.length \u0026lt; 2 || (arr.length == 2 \u0026amp;\u0026amp; arr[0] != arr[1])) { return \u0026#34;NO\u0026#34;; } int min = arr[0]; int sum = min; int temp = min; for (int i = 1; i \u0026lt; arr.length; i++) { sum += arr[i]; min = Math.min(min, arr[i]); temp ^= arr[i]; } if (temp != 0) { return \u0026#34;NO\u0026#34;; } else { return String.valueOf(sum - min); } } 19. 连续字母长度\r#\r描述\n给定一个字符串，只包含大写字母，求在包含同一字母的子串中，长度第 k 长的子串的长度，相同字母只取最长的那个子串。 输入描述： 第一行有一个子串(1＜长度≤100)，只包含大写字母。 第二行为 k的值 输出描述：输出连续出现次数第k多的字母的次数。 输入：AABAAA 2 输出：1 说明：同一字母连续出现的最多的是A，3次；第二多的还是A，两次，但是A已经出现过了，故为B，一次； 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chars = sc.nextLine().toCharArray(); int k = Integer.parseInt(sc.nextLine()); System.out.println(getResult(chars, k)); } public static int getResult(char[] chars, int k) { if (k \u0026lt;= 0) { return -1; } Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int tempLen = 1; char tempCh = \u0026#39;-\u0026#39;; for (char curCh : chars) { if (curCh == tempCh) { tempLen++; map.put(curCh, Math.max(tempLen, map.get(curCh))); } else { map.putIfAbsent(curCh, 1); tempCh = curCh; tempLen = 1; } } Integer[] arr = map.values().stream().sorted((a, b) -\u0026gt; b - a).toArray(Integer[]::new); if (k \u0026lt;= arr.length) { return arr[k - 1]; } return -1; } 20. 滑动窗口最大和\r#\r描述\n给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 输入：1,3,-1,-3,5,3,6,7 3 输出：3,3,5,5,6,7 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] ints = Arrays.stream(sc.nextLine().split(\u0026#34;,\u0026#34;)).mapToInt(Integer::parseInt).toArray(); int k = Integer.parseInt(sc.nextLine()); int max; List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; ints.length - k + 1; i++) { max = ints[i]; for (int j = 1; j \u0026lt; k; j++) { max = Math.max(max, ints[i + j]); } list.add(String.valueOf(max)); } System.out.println(String.join(\u0026#34;,\u0026#34;, list)); } 21. 素数之积\r#\r描述\nRSA加密算法在网络安全世界中无处不在，它利用了极大整数因数分解的困难度，数据越大，安全系数越高。 给定一个32位正整数，请对其进行因数分解，找出是哪两个素数的乘积。 输入描述：一个正整数num，0＜num≤2147483647 输出描述：如果成功找到，以单个空格分割，从小到大输出两个素数，分解失败，请输出-1 -1 输入： 15 输出： 3 5 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); int r1 = -1; int r2 = -1; for (int i = 2; i \u0026lt; Math.sqrt(num) + 1; i++) { if (num % i != 0) { continue; } if (isPrime(i) \u0026amp;\u0026amp; isPrime(num / i)) { r1 = i; r2 = num / i; break; } } System.out.println(r1 + \u0026#34; \u0026#34; + r2); } // 判断 n 是否为素数 private static boolean isPrime(int n) { if (n \u0026lt; 2) { return false; } for (int i = 2; i \u0026lt;= Math.sqrt(n); i++) { if (n % i == 0) { return false; } } return true; } 22. 仿LISP运算\r#\r描述\nLISP语言唯一的语法就是括号要配对。 形如 (OP P1 P2 …)，括号内元素由单个空格分割。其中第一个元素OP为操作符，后续元素均为其参数，参数个数取决于操作符类型 注意：参数 P1, P2 也有可能是另外一个嵌套的 (OP P1 P2 …) 当前OP类型为add/sub/mul/div(全小写)，分别代表整数的加减乘除法。简单起见，所以OP参数个数为2 输入描述：合法C字符串，字符串长度不超过512，用例保证了无语法错误 输出描述：合法C字符串，字符包括’0’-‘9’及负号’-‘或者’error’ 输入：(mul 3 -7)输出：-21 输入：(add 1 2) 输出：3 输入：(sub (mul 2 4) (div 9 3)) 输出 ：5 输入：(div 1 0) 输出：error 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); solution(str); } public static void solution(String str) { Stack\u0026lt;Integer\u0026gt; numStack = new Stack\u0026lt;\u0026gt;(); Stack\u0026lt;String\u0026gt; opStack = new Stack\u0026lt;\u0026gt;(); int mark = 0; int paramOne = 0; int paramTwo = 0; for (int i = 0; i \u0026lt; str.length(); i++) { char chas = str.charAt(i); if (chas == \u0026#39;(\u0026#39;) { //截取符号位 opStack.push(str.substring(i + 1, i + 4)); //这里为空格的索引位置 i = i + 4; //符号位后第一个数字的索引坐标 mark = i + 1; } else if (chas == \u0026#39;)\u0026#39;) { if (mark \u0026lt; i) { //所有数字的截取 numStack.push(Integer.valueOf(str.substring(mark, i))); i++; mark = i + 1; } //得到一次（）的对应，就进行一次计算 paramTwo = numStack.pop(); paramOne = numStack.pop(); calc(numStack, opStack, paramOne, paramTwo); } else { //空格位将数字进行区分 if (chas == \u0026#39; \u0026#39;) { if (mark \u0026lt; i) { numStack.push(Integer.valueOf(str.substring(mark, i))); //下一个数字的索引为空格后面一位，故mark = i+1; mark = i + 1; } } } } //如果还有没计算完的，就进行再次计算 while (!opStack.isEmpty()) { paramTwo = numStack.pop(); paramOne = numStack.pop(); calc(numStack, opStack, paramOne, paramTwo); } System.out.println(numStack.pop()); } private static void calc(Stack\u0026lt;Integer\u0026gt; numStack, Stack\u0026lt;String\u0026gt; operStack, int paramOne, int paramTwo) { switch (operStack.pop()) { case \u0026#34;add\u0026#34;: numStack.push(paramOne + paramTwo); break; case \u0026#34;sub\u0026#34;: numStack.push(paramOne - paramTwo); break; case \u0026#34;mul\u0026#34;: numStack.push(paramOne * paramTwo); break; case \u0026#34;div\u0026#34;: if (paramTwo == 0) System.out.println(\u0026#34;error\u0026#34;); else numStack.push(paramOne / paramTwo); break; } } 23. 贪吃蛇\r#\r描述\n贪吃蛇是一个经典游戏，蛇的身体由若干方格连接而成，身体随蛇头移动。蛇头触碰到食物时，蛇的长度会增加一格。 蛇头和身体的任一方格或者游戏版图边界碰撞时，游戏结束。 贪吃蛇游戏的模拟： 给定一个NM的数组ar，代表NM个方格组成的版图，贪吃蛇每次移动一个方格。 若ar[i][j]==\u0026#39;H\u0026#39;，表示该方可为贪吃蛇的起始位置; 若ar[i][j]==\u0026#39;F\u0026#39;，表示该方格为食物， 若ar[i][j]==\u0026#39;E\u0026#39;，表示该方格为空格。 贪吃蛇初始长度为1，初始移动方向为向左。 输入为给定一系列贪吃蛇的移动操作，返回操作后蛇的长度，如果在操作执行完之前已经游戏结束，返回游戏结束时贪吃蛇的长度。 输入描述: 第1行：为空格分隔的字母，代表贪吃蛇的移动操作。字母取值为 U、D、L、R、G， 其中UDLR分别表示贪吃蛇往上下左右转向，转向时贪吃蛇不移动，G表示贪吃蛇按 当前的方向移动一格。用例保证输入的操作正确。 第2行：为空格分隔的两个数，指定为 N和 M，为数组的行和列数。 余下 N行每行是空格分 隔的 M个字母。字母取值为 H、F和 E，H表示贪吃蛇的起始位置，F表示食物，E表示该 方格为空。 用例保证有且只有一个 H，而 F和 E会有多个。 输出描述: 输出一个数字为蛇的长度。 输入：D G G 3 3 F F F F F H E F E 输出：1 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] roadArr = sc.nextLine().split(\u0026#34; \u0026#34;); String[] numArr = sc.nextLine().split(\u0026#34; \u0026#34;); int n = Integer.parseInt(numArr[0]); int m = Integer.parseInt(numArr[1]); String[][] arr = new String[n][m]; for (int i = 0; i \u0026lt; n; i++) { String[] tempArr = sc.nextLine().split(\u0026#34; \u0026#34;); for (int j = 0; j \u0026lt; m; j++) { arr[i][j] = tempArr[j]; } } int ans = solution(roadArr, arr, n, m); System.out.println(ans); } public static int solution(String[] roadArr, String[][] arr, int n, int m) { int[] start = {0, 0}; ArrayDeque\u0026lt;String\u0026gt; body = new ArrayDeque\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { if (\u0026#34;H\u0026#34;.equals(arr[i][j])) { body.add(i + \u0026#34;-\u0026#34; + j); start[0] = i; start[1] = j; } } } String curDir = \u0026#34;L\u0026#34;; for (int i = 0; i \u0026lt; roadArr.length; i++) { String str = roadArr[i]; if (\u0026#34;U\u0026#34;.equals(str) || \u0026#34;D\u0026#34;.equals(str) || \u0026#34;L\u0026#34;.equals(str) || \u0026#34;R\u0026#34;.equals(str)) { curDir = str; } if (\u0026#34;G\u0026#34;.equals(str)) { if (\u0026#34;U\u0026#34;.equals(curDir)) start = new int[]{start[0] - 1, start[1]}; if (\u0026#34;D\u0026#34;.equals(curDir)) start = new int[]{start[0] + 1, start[1]}; if (\u0026#34;L\u0026#34;.equals(curDir)) start = new int[]{start[0], start[1] - 1}; if (\u0026#34;R\u0026#34;.equals(curDir)) start = new int[]{start[0], start[1] + 1}; if (start[0] \u0026lt; 0 || start[1] \u0026lt; 0 || start[0] \u0026gt; n - 1 || start[1] \u0026gt; m - 1 || body.contains(start[0] + \u0026#34;-\u0026#34; + start[1])) { return body.size(); } if (\u0026#34;E\u0026#34;.equals(arr[start[0]][start[1]])) { body.addFirst(start[0] + \u0026#34;-\u0026#34; + start[1]); body.removeLast(); } if (\u0026#34;F\u0026#34;.equals(arr[start[0]][start[1]])) { body.addFirst(start[0] + \u0026#34;-\u0026#34; + start[1]); } } } return body.size(); } 24. 解密犯罪时间\r#\r描述\n警察在侦破一个案件时，得到了线人给出的可能犯罪时间，形如 “HH:MM” 表示的时刻。根据约定，为了隐蔽，该时间是修改过的， 解密规则为：利用当前出现过的数字，构造下一个距离当前时间最近的时刻，则该时间为可能的犯罪时间。 每个出现的数字都可以被无限次使用。 输入描述：形如 HH:SS 的字符串，表示原始输入 输出描述：形如 HH:SS 的字符串，表示推理出来的犯罪时间 注意事项：1、可以保证线人给定的字符串一定是合法的。2、最近的时刻有可能在第二天。 输入：18:52 输出：18:55 说明：利用数字 1, 8, 5, 2 构造出来的最近时刻是 18:55，是 3 分钟之后。 输入：23:59 输出：22:22 说明：利用数字 2, 3, 5, 9 构造出来的最近时刻是 22:22 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String input = sc.nextLine(); String[] split = input.split(\u0026#34;:\u0026#34;); // 记录已经出现的数字 boolean[] exists = new boolean[10]; for (char c : input.toCharArray()) { if (Character.isDigit(c)) { exists[c - \u0026#39;0\u0026#39;] = true; } } // 原始时间 int times = Integer.parseInt(split[0]) * 60 + Integer.parseInt(split[1]); // 枚举所有时间，找到下一个距离当前事件最近的时刻 // -- 如果时间点中有字符未出现，则不考虑该时间点，因为该时间点已经不可能是答案了 // -- 如果时间点中有字符出现: // -- -- 如果时间相同，则不考虑该时间点，因为该时间点已经不可能是答案了 // -- -- 如果时间不同，则考虑该时间点，因为该时间点可能是答案了，但是要判断当天还是下一天 int hour = 0; int minute = 0; int d = Integer.MAX_VALUE; for (int h = 0; h \u0026lt; 24; h++) { if (!exists[h % 10] || !exists[h / 10]) continue; for (int m = 0; m \u0026lt; 60; m++) { int curTimes = h * 60 + m; // 字符未出现或时间相同 if (!exists[m % 10] || !exists[m / 10] || curTimes == times) continue; // 计算时间间隔，找到更近的时刻 int curD = (curTimes \u0026gt; times) ? curTimes - times : 24 * 60 - (times - curTimes); if (curD \u0026lt; d) { hour = h; minute = m; d = curD; } } } // %02d 表示将整数值按照至少占据两个字符的方式输出，不足两位时会在前面补零 // %n 表示一个换行符 System.out.printf(\u0026#34;%02d:%02d%n\u0026#34;, hour, minute); } 25. 求满足条件的最长子串的长度\r#\r描述\n给定一个字符串，只包含字母和数字，按要求找出字符串中的最长（连续）子串的长度，字符串本身是其最长的子串， 如果找不到满足要求的子串，如全是字母或全是数字，则返回-1。 子串要求： 1、只包含1个字母(a~z, A~Z)，其余必须是数字； 2、字母可以在子串中的任意位置； 输入描述：字符串(只包含字母和数字) 输出描述：子串的长度 输入：abC124ACb 输出：4 说明：满足条件的最长子串是C124或者124A，长度都是4 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chars = sc.nextLine().toCharArray(); // 是否字母 boolean isCap = false; int maxLen = -1; for (int i = 0; i \u0026lt; chars.length; i++) { if (Character.isLetter(chars[i])) { isCap = true; } for (int j = i + 1; j \u0026lt; chars.length; j++) { if (Character.isLetter(chars[j])) { if (isCap) { if (j - i \u0026gt; 1) { maxLen = Math.max(maxLen, j - i); } isCap = false; break; } else { isCap = true; } } else { if (isCap) { maxLen = Math.max(maxLen, j - i + 1); } } } } System.out.println(maxLen); } "},{"id":38,"href":"/program-base/network/http/message/","title":"报文","section":"HTTP","content":"\rHTTP 报文\r#\r报文格式\r#\r请求方式\r#\rGET 返回请求路径所对应的资源。 POST 向请求路径提交数据，创建新的资源。 PUT 更新请求路径所对应的资源。 DELETE 删除请求路径所对应的资源。 HEAD 不需要返回资源，仅返回响应行和响应头即可。 PATCH 更新请求路径所对应的部分资源。 OPTIONS 获取请求路径对应资源的信息（是否可可跨域获取，可以支持哪些请求方式等）。 TRACE 直接返回请求，主要用于测试。 媒体类型\r#\rContent-Type，用于定义请求和响应中的媒体类型信息 类型 描述 类型 描述 text/html HTML格式 application/xhtml+xml XHTML格式 text/plain 纯文本格式 application/xml XML数据格式 text/xml XML格式 application/json JSON数据格式 image/gif gif图片格式 application/pdf pdf格式 image/jpeg jpg图片格式 application/msword Word文档格式 image/png png图片格式 application/octet-stream 二进制流数据 multipart/form-data 表单文件上传 application/x-www-form-urlencoded 表单key/value格式 "},{"id":39,"href":"/database/redis/persistence/","title":"持久化","section":"Redis","content":"\r持久化\r#\r持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。 RDB方式\r#\r能够在指定的时间间隔能对你的数据进行快照存储 AOF方式\r#\r记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据， AOF命令以redis协议追加保存每次写的操作到文件末尾。 Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大 "},{"id":40,"href":"/database/intro/","title":"数据库","section":"数据存储","content":"\r数据库\r#\r数据库\r#\rDatabase，是按照数据结构来组织、存储和管理数据的仓库 非关系型数据库\r#\r主要指非关系型的、分布式的，且一般不保证ACID的数据存储系统 优点：善于处理海量数据、支持分布式集群，负载均衡，性能高 缺点：事务处理能力弱、数据间没有关系、对于复杂业务场景支持较差 代表：Redis、MongoDB、CouchDB 关系型数据库\r#\r采用了关系模型来组织数据的数据库。 优点：容易理解、使用方便、易于维护 缺点：海量数据的读写效率低、难以横向扩展 代表：MySQL、Oracle、PostgreSQL、DB2、SQL Server、Microsoft Access 三大范式\r#\r第一范式（1NF）：字段是最小单元，不可再进行拆分\n第一范式要求字段中的值已经是无法再分割的值。 例如：员工表，姓名字段仅包含员工的正式名称，就符合第一范式， 反之包含中文名、英文名、别名等，则意味着姓名字段是再拆分的 第二范式（2NF）：表要具有唯一性的主键列\n第二范式是在第一范式的基础上的增强，要求数据库表中的行必须可以被唯一的区分。 例如：员工表，定义工号作为主键 第三范式（3NF）：表中的字段不能包含在其他表中已经出现的非主键字段\n第二范式是在前两个范式的基础上的增强，主要用来降低数据的冗余。 例如：员工表包含了部门编码，它引用到部门表中的部门编号这个主键，此时符合第三范式 如果在员工表中又包含一个部门名称，则造成了数据的冗余，不符合第三范式 SQL\r#\rStructured Query Language，结构化查询语言 是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。 语句分类 说明 DDL 数据定义语句，Data Definition Language DML 数据操纵语句，Data Manipulation Language DQL 数据查询语句，Data Query Language DCL 数据控制语句，Data Control Language "},{"id":41,"href":"/database/mysql/advanced-feature/database-engine/","title":"数据库引擎","section":"高级特性","content":"\r数据库引擎\r#\rInnoDB\r#\r是一个事务型的存储引擎，支持行级锁、外键约束、自动增长列。 它的设计目标是处理大容量数据库系统，运行时，InnoDB会在内存中建立缓冲池，用于缓冲数据和索引。 索引结构\r#\rInnoDB是B+Tree索引结构，其将主键组织到一棵B+Tree中，而行数据储存在叶节点上（即聚集索引） 检索算法\r#\r若对主键列进行条件搜索，则按B+Tree的检索算法即可查找到对应的叶节点，获得行数据。\n若对非主键列进行条件搜索，则先在辅助索引B+Tree中检索对应列，到达其叶节点获取对应的主键，\n再进行“对主键列进行条件搜索”\n适用场景\r#\r更新密集的表 事务 自动灾难恢复 外键约束 支持自动增加列属性 MyISAM\r#\r极度强调快速读取操作，不支持数据库事务、行级锁、外键约束 存储格式\r#\r存储格式 特点 优点 缺点 静态表 表中字段均固定长度 存储快，容易缓存 空间占用多 动态表 表中字段均长度可变 空间占用少 容易产生磁盘碎片 压缩表 单独压缩每个记录 访问开支小 需解压 索引结构\r#\rMyISAM 是B+Tree索引结构，其B+Tree的数据域存储的内容为实际数据的地址（即非聚集索引）。 检索算法\r#\r先按B+Tree的检索算法搜索索引，取出其数据域的值， 再以这个值为地址，去读取相应的数据记录。 适用场景\r#\r查询密集型表。MyISAM 存储引擎在筛选大量数据时非常快； 插入密集型表。MyISAM 的并发插入特性允许同时选择、插入数据。 InnoDB \u0026amp; MyISAM\r#\r对比\r#\r区别 InnoDB MyISAM 锁级别 行级锁 表级锁 事务、外键、自增列 支持 不支持 全文索引 不支持 支持 主键 必须有 可以没有 存储空间 占用较多 占用较少 表的具体行数 不保存 保存 使用建议\r#\rInnoDB：可靠性高或者要求事务处理的、表更新和查询都相当频繁的 MyISAM：做很多count的计算的、插入修改不频繁而查询非常频繁的 "},{"id":42,"href":"/database/mysql/mysql-command/database/","title":"数据库管理","section":"基础命令","content":"\r数据库管理\r#\r# 创建 create database 库名 [charset = 字符集] [collate = 校对集]; # 选择 use 库名; # 显示库结构 show create database 库名; # 显示库名 show databases [like \u0026#39;...\u0026#39;]; # 显示当前库名 select database(); # 修改 alter database 库名 [charset = 字符集]/[collate = 校对集]; # 删除 drop database 库名; "},{"id":43,"href":"/program-design/data-structure/","title":"数据结构","section":"程序设计","content":"\r数据\r#\r所有能输入到计算机中并能被程序识别和处理的符号集合 数据结构\r#\r是计算机存储、组织数据的方式 逻辑结构：集合结构、线性结构、树形结构、图形结构 物理结构：顺序存储结构、链式存储结构 "},{"id":44,"href":"/program-design/data-structure/array/","title":"数组","section":"数据结构","content":"\r数组\r#\r数组\r#\rArray 是一种线性结构，在物理内存中占据着一块连续空间。 数组为每个存储的元素都分配了一个下标（索引） ，下标从0开始且自增连续 查询速度快，新增/删除速度慢 特点\r#\r查询速度快 新增、删除速度慢 查询元素\r#\r根据索引直接定位 新增元素\r#\r根据索引找到位置 把后面的所有元素往后移动 插入元素 删除元素\r#\r根据索引找到位置 删除元素 再把后面的所有元素往前移动 "},{"id":45,"href":"/program-base/linux/cmd/flie-manage/","title":"文件管理","section":"常用命令","content":"\r文件管理\r#\rls - 列出目录内容\ncd - 改变目录\ncp - 复制文件或目录\nmv - 移动或重命名文件或目录\nrm - 删除文件或目录\ncat - 连接文件并打印到标准输出\nmore / less - 分页显示文件内容\nhead / tail - 显示文件开头或结尾的内容\n"},{"id":46,"href":"/program-lang/web/html/document/","title":"文档标签","section":"HTML","content":"\r文档标签\r#\r标签 说明 \u0026lt;!DOCTYPE\u0026gt; 定义文档类型 \u0026lt;html\u0026gt; 定义 HTML 文档 \u0026lt;head\u0026gt; 定义网页的头部 \u0026lt;body\u0026gt; 定义网页的主体 头部标签\r#\r标签 说明 \u0026lt;title\u0026gt; 定义网页的标题 \u0026lt;meta\u0026gt; 定义网页的元数据 \u0026lt;base\u0026gt; 定义页面链接标签的默认链接地址 \u0026lt;link\u0026gt; 定义外部资源 \u0026lt;script\u0026gt; 定义脚本文件 \u0026lt;style\u0026gt; 定义样式文件 "},{"id":47,"href":"/framework/quartz/core-class/","title":"核心类","section":"Quartz","content":"\r核心类\r#\rJob\r#\r任务接口\n承载着要被执行的具体业务逻辑\n该接口中定义了 execute 方法，我们需要在里面编写任务执行的业务逻辑。\nJobDetail\r#\r任务实例 负责定义任务数据，为 Job 实例提供了许多属性，存储着 Job 实例的状态信息 调度器每次执行 Job 时，都会根据 JobDetail 创建一个新的 Job 实例，以规避并发访问的问题。 // 重要属性 JobDataMap jobDataMap = jobDetail.getJobDataMap(); String name = jobDetail.getKey().getName(); String group = jobDetail.getKey().getGroup(); String jobName = jobDetail.getJobClass().getName(); Trigger\r#\r触发器 描述触发任务执行的时间规则 // 按简单时间规则执行调度 SimpleTrigger // 按Cron表达式定义的时间规则执行调度 CronTrigger： Scheduler\r#\r调度器 相当于一个容器，装载着任务和触发器。基于 Trigger 触发器，来执行 Job 任务 Trigger 和 JobDetail 可以注册到 Scheduler 中，两者在 Scheduler 中拥有各自的组及名称。 Listener\r#\r监听器 // 监听任务执行前事件、任务执行后事件； JobListener： // 监听触发前事件，出发后事件； TriggerListener： JobDataMap\r#\r可以存储不限量的数据对象，在job实例执行的时候，可以使用其中的数据 // 将job加入到scheduler之前，在构建JobDetail时，可以将数据放入JobDataMap JobDetail job = newJob(DumbJob.class) .withIdentity(\u0026#34;myJob\u0026#34;, \u0026#34;group1\u0026#34;) // name \u0026#34;myJob\u0026#34;, group \u0026#34;group1\u0026#34; .usingJobData(\u0026#34;jobSays\u0026#34;, \u0026#34;Hello World!\u0026#34;) .usingJobData(\u0026#34;myFloatValue\u0026#34;, 3.141f) .build(); // 在job的执行过程中，可以从JobDataMap中取出数据 public class DumbJob implements Job { public DumbJob() { } public void execute(JobExecutionContext context)throws JobExecutionException{ JobKey key = context.getJobDetail().getKey(); JobDataMap dataMap = context.getJobDetail().getJobDataMap(); String jobSays = dataMap.getString(\u0026#34;jobSays\u0026#34;); float myFloatValue = dataMap.getFloat(\u0026#34;myFloatValue\u0026#34;); // ..... } } 两个注解\r#\r// 禁止并发地执行同一个JobDetail实例 @DisallowConcurrentExecution // 当正常执行完Job后，JobDataMap中的数据会保留下来，继续给下一次调用使用 @PersistJobDataAfterExecution "},{"id":48,"href":"/program-design/expression/regular/","title":"正则表达式","section":"表达式","content":"\r正则表达式\r#\r简介\r#\rRegular Expression 是一种字符串匹配的描述模式，用来检索、替换那些符合某个规则的字符串 语法\r#\r转义字符\r#\r特殊字符：( ) [ ] { } 、? * + 、^ $、 . \\ | 构造 匹配 x 字符 x \\ 反斜线字符 \\t 水平制表符 \\v 垂直制表符 \\r 回车符 \\n 换行符 \\f 换页符 普通字符类\r#\r构造 匹配 [abc] 包含：a、b 或 c [^abc] 排除：任何字符，除了 a、b 或 c [a-z] 区间：a 到 z [a-zA-Z] 并集：a 到 z 或 A 到 Z [a-z\u0026amp;\u0026amp;[^bc]] 交集：a 到 z，除了 b 和 c 预定义字符类\r#\r构造 匹配 构造 匹配 . 任何字符 \\d 数字：[0-9] \\D 非数字： [^\\d] \\s 空白字符：[ \\t\\n\\x0B\\f\\r] \\S 非空白字符：[^\\s] \\w 单词字符：[a-zA-Z_0-9] \\W 非单词字符：[^\\w] 边界定位符\r#\r构造 匹配 ^ 行的开头 $ 行的结尾 \\b 单词边界 \\B 非单词边界 数量符\r#\r构造 匹配 X? X，零次或一次 X* X，零次或多次 X+ X，一次或多次 X{n} X，恰好 n 次 X{n,} X，至少 n 次 X{n,m} X，至少 n 次，但是不超过 m 次 运算符\r#\r构造 匹配 XY X 后跟 Y X|Y X 或 Y (X) X，作为捕获组 \\n 引用第n个捕获组 贪婪\r#\r限定符 * + 是贪婪的，它们会尽可能多的匹配文字\n限定符 ? 是非贪婪的，它可以实现最小匹配。\n匹配字符串：\u0026lt;h1\u0026gt;RUNOOB-菜鸟教程\u0026lt;/h1\u0026gt; 正则表达式：/\u0026lt;.*\u0026gt;/\t匹配结果： \u0026lt;h1\u0026gt;RUNOOB-菜鸟教程\u0026lt;/h1\u0026gt; 正则表达式：/\u0026lt;.*?\u0026gt;/\t匹配结果： \u0026lt;h1\u0026gt; 捕获组\r#\r捕获组就是把正则表达式中子表达式匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用 使用( )表示捕获分组 普通捕获组\r#\r格式：(Expression)\n从左到右计算表达式的(，从 1 开始进行编号，0 代表整个表达式\n正则表达式：(\\d{4})-(\\d{2}-(\\d\\d)) 编号 命名 捕获组 匹配内容 0 (\\d{4})-(\\d{2}-(\\d\\d)) 2008-12-31 1 (\\d{4}) 2008 2 (\\d{2}-(\\d\\d)) 12-31 3 (\\d\\d) 31 命名捕获组\r#\r格式：(?\u0026lt;name\u0026gt;Expression) 正则表达式：(?\u0026lt;year\u0026gt;\\d{4})-(?\u0026lt;date\u0026gt;\\d{2}-(?\u0026lt;day\u0026gt;\\d\\d)) 编号 命名 捕获组 匹配内容 0 0 (?\\d{4})-(?\\d{2}-(?\\d\\d)) 2008-12-31 1 year (?\\d{4}) 2008 2 date (?\\d{2}-(?\\d\\d)) 12-31 3 day (?\\d\\d) 31 选择\r#\r?=、?\u0026lt;=、?!、?\u0026lt;! 构造 匹配 \\n 引用捕获组 n X(?=Y) 查找 Y 前面的 X (?\u0026lt;=Y)X 查找 Y 后面的 X X(?!Y) 查找后面不是 Y 的 X (?\u0026lt;!Y)X 查找前面不是 Y 的 X JDK正则\r#\rjava.util.regex String input = \u0026#34;ABC\u0026#34;; String regex = \u0026#34;[a-z]{4}\u0026#34;; // String类 input.matches(regex); // Pattern类 Pattern.matches(regex, input) // Matcher类 Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(input); matcher.matches();\t// 整个字符串是否匹配 matcher.find();\t// 是否有下一个匹配的子串 matcher.group(1);\t// 获取1号捕获组匹配到的子串 ... 常用正则\r#\r\u0026hellip;\n"},{"id":49,"href":"/program-lang/java/thread/problem/deadlock/","title":"死锁","section":"并发问题","content":"\r死锁\r#\r概述\r#\r两个或两个以上的线程，在执行过程中，因争夺资源而造成的一种相互等待的现象 产生条件\r#\r互斥使用 即当资源被一个线程使用(占有)时，别的线程不能使用 不可抢占 资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放 请求和保持 即当资源请求者在请求其他的资源的同时保持对原有资源的占有 循环等待 即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路 图示\r#\r示例\r#\rpublic class HoldThread implements Runnable { private String lockA; private String lockB; public HoldThread(String lockA, String lockB) { this.lockA = lockA; this.lockB = lockB; } @Override public void run() { String threadName = Thread.currentThread().getName(); synchronized (lockA) { System.out.println(threadName + \u0026#34;\\t 持有锁\u0026#34; + lockA + \u0026#34;尝试获得\u0026#34; + lockB); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (lockB) { System.out.println(threadName + \u0026#34;\\t 持有锁\u0026#34; + lockB + \u0026#34;尝试获得\u0026#34; + lockA); } } } } public class DeadLockDemo { public static void main(String[] args) { String lockA = \u0026#34;lockA\u0026#34;; String lockB = \u0026#34;lockB\u0026#34;; new Thread(new HoldThread(lockA, lockB), \u0026#34;AAA\u0026#34;).start(); new Thread(new HoldThread(lockB, lockA), \u0026#34;BBB\u0026#34;).start(); } } 解决办法\r#\rjps：定位进程编号 jstack：找到死锁查看 "},{"id":50,"href":"/dev-tool/git/version-control/","title":"版本控制","section":"Git","content":"\r版本控制\r#\r概述\r#\r版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统\n功能：\n协同修改：多人并行不悖的修改服务器端的同一个文件。 数据备份：不仅保存目录和文件的当前状态， 还能够保存每一个提交过的历史状态。 版本管理：在保存每一个版本的文件信息的时候要做到不保存重复数据， 以节约存储空间， 提高运行效率。 权限控制：对参与开发的人员进行权限控制及代码审核 历史记录：查看修改人、 修改时间、 修改内容、 日志信息。将本地文件恢复到某一个历史状态。 分支管理：允许开发团队在工作过程中多条生产线同时推进任务， 进一步提高效率 分类\r#\r本地式\r#\r用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别 好处就是简单，但是特别容易犯错 集中式\r#\r使用一个单一的集中管理的服务器，保存所有文件的修订版本 而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新 增量维护，特点： 数据不安全：存在单点故障、黑客攻击的问题，需做好数据备份 服务器压力大：所有操作都需要与服务器交互，受限于宽带 强调集中管理：适合人数不多的项目 分布式\r#\r客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 全量维护，特点： 数据安全完整：所有节点都是服务器，无带宽和性能瓶颈；提交全部使用SHA1哈希 效率高：提交为本地操作，全离线操作；编码不会被冲突打断 强调个体：适合分布式开发 SVN\r#\r是基于差异的版本控制，存储的是一组基本文件和每个文件随时间逐步累积的差异 优缺点：节省磁盘空间，耗时、效率低。 不适合的领域：跨地域的协同开发、追求高质量代码和代码门禁 Git\r#\r是基于快照的版本控制，存储的是文件的一系列快照 优缺点：版本切换时非常快，占用磁盘空间较大 不适合的领域：目录级别的读授权、word等二进制文档的版本控制 "},{"id":51,"href":"/program-base/linux/dir/","title":"目录结构","section":"Linux","content":"\rLinux 目录结构\r#\r"},{"id":52,"href":"/program-lang/java/oop/class/","title":"类和对象","section":"面向对象","content":"\r类和对象\r#\r概述\r#\r类：是一个模板，它描述一类对象的状态和行为。 对象：是类的一个实例，有状态和行为。 构造方法\r#\r每个类都有构造方法。 如果没有显式定义，Java编译器将会为该类提供一个默认构造方法。 在创建一个对象的时候，至少要调用一个构造方法。 构造方法的名称必须与类同名。 一个类可以有多个构造方法。 public class Puppy{ public Puppy(){ } public Puppy(String name){ // 这个构造器仅有一个参数：name } } 创建对象\r#\r// 创建类 class 类名{ // 成员变量定义... // 方法定义... } // 创建对象，调用类构造方法 className myObject = new className(); 对象操作\r#\rpublic class Puppy { private String name; public Puppy(String name) { this.name = name; } public String getName() { return this.name; } public static void main(String[] args) { Puppy myPuppy = new Puppy(\u0026#34;tommy\u0026#34;); //创建对象 System.out.println(myPuppy.name); //访问对象属性 System.out.println(myPuppy.getName()); //访问对象方法 } } 内部类\r#\r将一个类定义在另一个类的里面，称里面那个类为内部类 内部类的作用就是为了访问外部类中的成员变量（包括私有） 必须先有外部类对象才能生成内部类对象 //外部类 class Out { private int age = 12; //内部类 class In { public void print() { System.out.println(age); } } } public class Demo { public static void main(String[] args) { // 访问方式一 Out.In in = new Out().new In(); in.print(); // 访问方式二 // Out out = new Out(); // Out.In in = out.new In(); // in.print(); } } 枚举类\r#\r是一种特殊形式的Java类 每一个枚举值，代表一个实例对象 构造函数必须为私有 //格式 enum 枚举类名{ 枚举对象实例1, 枚举对象实例2, ...; } //示例 public enum Color{ RED(\u0026#34;red\u0026#34;,\u0026#34;红色\u0026#34;),GREEN(\u0026#34;green\u0026#34;,\u0026#34;绿色\u0026#34;),BLUE(\u0026#34;blue\u0026#34;,\u0026#34;蓝色\u0026#34;); private final String key; private final String value; //... } 初始化顺序\r#\r静态属性 \u0026ndash;\u0026gt; 静态代码块 \u0026ndash;\u0026gt; 成员属性 \u0026ndash;\u0026gt; 构造代码块 \u0026ndash;\u0026gt; 构造函数 先静态后非静态、先父类后子类 public class Test{ // 静态属性：只初始化一次 private static float PI = 3.14f; // 静态代码块：只初始化一次 static { //... } // 成员属性 private int id = 1; // 构造代码块：提取构造方法中的相同部分，减少重复代码 { // 每次对象实例化，都执行一次 } // 构造函数 public Test() { //... } } "},{"id":53,"href":"/database/oracle/system-function/","title":"系统函数","section":"Oracle","content":"\r系统函数\r#\r转换函数\r#\r函数 说明 示例 TO_CHAR 日期 ==\u0026gt; 字符串数值 ==\u0026gt; 字符串 TO_CHAR(SYSDATE, \u0026lsquo;YYYY-MM-DD HH24:MI:SS\u0026rsquo;)TO_CHAR(123.45678, \u0026lsquo;$9999,999\u0026rsquo;) TO_DATE 字符串 ==\u0026gt; 日期 TO_DATE(\u0026lsquo;2000/01/01\u0026rsquo;, \u0026lsquo;YYYY/MM/DD\u0026rsquo;) TO_NUMBER 字符串 ==\u0026gt; 数值 TO_NUMBER(\u0026rsquo;-$12,345.67\u0026rsquo;, \u0026lsquo;$99,999.99\u0026rsquo;) 字符函数\r#\r函数 说明 LOWER(x) 全部转换为小写 UPPER(x) 全部转换为大写 INITCAP(x) 首字母转换为大写 CONCAT(x, y) 连接字符串 x 和 y ，可以用 || 代替 LENGTH(x) 返回字符串的长度 SUBSTR(x, start[, len]) 截取子字符串，从 start 处开始，截取 len 个字符，缺省 len 截到结尾 INSTR(x, str [, start] [, n) 在 x 中查找 str ，可指定从 start 开始、从第 n 次开始 LPAD(x, n, str) 使用 str 进行左填充，直到长度到达 n RPAD(x, n, str) 使用 str 进行右填充，直到长度到达 n TRIM([str FROM] x) 去除 x 两边的 str ，缺省去除空格 LTRIM(x [, str]) 去除 x 左边的 str ，缺省去除空格 RTRIM(x [, str]) 去除 x 右边的 str ，缺省去除空格 REPLACE(x, old, new) 在 x 中查找 old ，并替换为 new 数值函数\r#\r函数 说明 示例 CEIL(x) 向上取整 CEIL(5.4)=6 FLOOR(x) 向下取整 FLOOR(5.8)=5 ROUND(x [, n]) 四舍五入到小数点后的第 n 位 ROUND(3.456, 2)=3.46 TRUNC(x [, n]) 截取到小数点后的第 n 位 TRUNC(3.456, 2)=3.45 ABS(x) x 绝对值 ABS(-3)=3 MOD(x, y) x 除以 y 的余数 MOD(8, 3)=2 POWER(x, y) x 的 y 次幂 POWER(2, 3)=8 SQRT(x) x 的平方根 SQRT(4)=2 日期函数\r#\r函数 说明 SYSDATE 返回系统当前日期 ADD_MONTHS(date, n) 在 date 上加 n 个月 MONTHS_BETWEEN(date1, date2) date1、date2间相差的月份 LAST_DAY(date) date所在月的最后一天 NEXT_DAY(date, \u0026lsquo;星期六\u0026rsquo;) date后的下个星期六 EXTRACT(year from date) 单独取日期里面的年 分组函数\r#\r函数 说明 sum() 求总和 max() 求最大值 min() 求最小值 avg() 求平均数 count() 求总个数 通用函数\r#\r函数 说明 NVL (expr1, expr2) 如果 expr1 不是 null，返回 expr1，否则返回 expr2 NVL2(expr1, expr2, expr3) 如果 expr1 不是 null，返回 expr2，否则返回 expr3 NULLIF(expr1, expr2) 比较 expr1、expr2，如果相等，返回null，否则返回 expr1 COALESCE(expr1, expr2, \u0026hellip;, exprn) 返回第一个不为空的参数 DECODE(col | expression, search1, result1 [, search2, result2, …, ][, default]) 多条件判断 附录：日期转换格式\r#\r格式元素 描述 格式元素 描述 YYYY 年（4位） W 周数（1-5） MM 月份（01-12） Q 季度 DD 一个月里的天数（01-31） TZ 时区 HH、HH12、HH24 一天的小时数 （01-12、01-12、00-23） MI 分钟 （00-59） SS 秒 （00-59） MS 毫秒 (000-999) 附录：数值转换格式\r#\r格式元素 描述 示例 结果 9 每个9代表一个有效位 999999 1234 0 前导0或后继0 099999 001234 . 小数点 99999.99 1234.00 , 分组（千）分隔符 999,999 1,234 EEEE 科学记数 99.999EEEE 1.234E+03 V 10的n次方 9999V99 123400 $ 货币符号 $99999 $1234 L 本地货币符号 L99999 ￥1234 "},{"id":54,"href":"/program-lang/java/thread/thread/","title":"线程基础","section":"多线程","content":"\r程序 \u0026amp; 进程 \u0026amp; 线程\r#\r程序 是为完成特定任务，用某种语言编写的一组指令的集合是静态的实体 进程 是程序执行时的一个实例，即运行中的程序是操作系统资源分配的基本单位是动态的过程 线程 是在进程中独立运行的子任务，代表一个单一顺序的执行流是任务调度和执行的基本单位 临界区\r#\r临界资源：是一次仅允许一个进程使用的共享资源 临界区：各个进程中，操作临界资源的代码片段 相关临界区：多个进程涉及到同一个临界资源的临界区 线程互斥：多个线程之间竞争使用临界资源的现象 "},{"id":55,"href":"/program-lang/java/thread/threadpool/threadpool-theory/","title":"线程池 - 原理","section":"线程池","content":"\r线程池原理\r#\r核心参数\r#\r创建线程池主要是 ThreadPoolExecutor 类来完成 corePoolSize\r#\r核心线程数 如果线程池中的线程数小于 corePoolSize，则会创建新线程来执行新提交的任务 如果线程池中的线程数到达 corePoolSize，则不会创建新线程，而是把新任务放入到缓存队列当中 类比：银行网点中，当值业务窗口数 maximumPoolSize\r#\r最大线程数量 如果阻塞队列已满，且线程池中线程数量未超过 maximumPoolSize，就会创建新线程来执行新提交的任务 类比：银行网点中，最大业务窗口数 keepAliveTime、unit\r#\r空闲线程的存活时间 如果线程数量超过 corePoolSize，且多余空闲线程的存活时间超过 keepAliveTime 时，会销毁空闲的线程 类比：银行网点中，加开的业务窗口，如果其空闲时间超过一定时限，则撤除 workQueue\r#\r阻塞队列 用于保存被提交但尚未被执行的任务 类比：银行网点中，等候区 threadFactory\r#\r创建线程的工厂类 可定制线程，一般使用默认即可 handler\r#\r饱和策略 如果阻塞队列满了，并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。 策略 说明 AbortPolicy 默认策略， 直接拒绝所提交的任务，并抛出RejectedExecutionException异常 CallerRunPolicy 用调用者所在的线程来执行任务 DiscardOldestPolicy 丢弃掉阻塞队列中存放时间最久的任务，执行当前任务 DiscardPolicy 不处理直接丢弃掉任务 工作过程\r#\r创建线程池后，等待提交过来的任务请求 当调用 execute() 添加一个新任务时，线程池会做如下判断： 如果当前运行的线程数量还小于 corePoolSize，则会创建新线程来执行新任务 如果当前运行的线程数量不小于 corePoolSize，则会将提交的任务放入阻塞队列中 如果当前阻塞队列满了，且当前运行的线程数量还小于 maximumPoolSize，则创建线程运行这个任务 如果当前阻塞队列满了，且当前运行的线程数量不小于 maximumPoolSize，则启动拒绝策略 当一个线程完成任务时，它会从队列中取下一个任务来执行 当一个线程空闲超过一定时间，并且此时当前运行的线程大于 corePoolSize 时，这个线程会被销毁 "},{"id":56,"href":"/program-base/network/network-model/","title":"网络模型","section":"网络","content":"\r网络模型\r#\r网络协议\r#\r是指双方实体完成通信或服务所必须遵循的规则和约定 网络协议分层\r#\r"},{"id":57,"href":"/database/mysql/mysql-tuning/table-tuning/","title":"表结构优化","section":"性能调优","content":"\r表结构优化\r#\r合理设计表结构\r#\r尽量将表字段定义为 NOT NULL 约束 单表不要有太多字段，建议在20以内 VARCHAR 类型只分配真正需要的空间 选取最适用的字段属性，优先最简单的数据类型\r#\r尽量使用数字型字段 尽量使用 VARCHAR 代替 CHAR 尽量使用 TIMESTAMP 代替 DATETIME 尽量使用 TINYINT、SMALLINT、MEDIUMINT 代替 INT 对于特定类型字段，可用enum、set 等符合的数据类型 将字段多的表分解成多个表，增加中间表。\r#\r混用范式与反范式，适当冗余\r#\r第一范式：数据表中每个字段都必须是不可拆分的最小单元 第二范式：满足一范式后，要求每条记录由主键唯一区分，记录中所有属性都依赖于主键。 第三范式：满足二范式后，要求所有属性必须直接依赖主键，不允许间接依赖。 分库分表，读写分离\r#\r垂直分表（按列） 水平分表（按行）：按时间分表、按区间分表、按hash分表 "},{"id":58,"href":"/program-lang/java/grammar/syntax-element/","title":"语法元素","section":"基本语法","content":"\r语法元素\r#\rHello World\r#\rpublic class HelloWorld { public static void main(String []args) { System.out.println(\u0026#34;Hello World\u0026#34;); } } 将以上代码，保存为文件HelloWorld.java 进入cmd 命令窗口，进入目标文件所在的位置 编译代码： javac HelloWorld.java 运行：java HelloWorld 标识符\r#\r大小写敏感 命名规则 由字母、数字、美元符$、下划线_组成 不可以数字开头 不可以使用关键字 包名 xxxyyyzzz 类名、接口名、枚举名 XxxYyyZzz 方法名、变量名 xxxYyyZzz 常量名 XXX_YYY_ZZZ 关键字\r#\rJava语言里事先定义的、有特别意义的标识符，即保留字，均为小写\n访问控制修饰符\n修饰符 当前类 同包 子类 其他包 public OK OK OK OK protected OK OK OK default OK OK private OK 其他修饰符 修饰符 含义 修饰 备注 static 静态的 类方法、类变量 final 最终的 类、方法、变量 abstract 抽象的 类、方法 用来创建抽象类和抽象方法 synchronized 同步的 方法、代码块 其修饰的方法，同一时间只能被一个线程访问 volatile 易变的 成员变量 1、线程每次访问该变量，都强制从共享内存中重新读取值2、当变量发生改变时，都强制线程将变化值回写到共享内存 操作符\r#\r算术运算符 +、-、*、/ 加、减、乘、除 ％ 取余：左操作数除以右操作数的余数 ++ 自增：操作数的值增加1 -- 自减：操作数的值减少1 关系运算符 \u0026lt;、\u0026gt; 小于、大于 \u0026lt;=、\u0026gt;= 小于等于、大于等于 ==、!= 相等、不相等 按位运算符 \u0026amp;、` 、〜` ^ 按位异或，二进制比较，相同为0，不同为1. \u0026lt;\u0026lt; 、\u0026gt;\u0026gt;、\u0026gt;\u0026gt;\u0026gt; 按位左移、按位右移、按位右移补零 逻辑运算符 \u0026amp;\u0026amp; 短路与 ` ! 非 赋值运算符 = 赋值 +=、-=、*=、/= 加赋值、减赋值、乘赋值、除赋值 三元运算符 // 格式 variable x = (expression) ? value if true : value if false // 示例 int a , b; a = 10; b = (a == 1) ? 20 : 30; // 如果 a 等于 1 成立，则设置 b 为 20，否则为 30 instanceof // 格式：检查该对象是否是一个特定类型 ( Object reference variable ) instanceof (class/interface type) // 示例 String name = \u0026#34;James\u0026#34;; boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真 注释\r#\r// 单行注释\t/*\t多行注释 多行注释 */ /** * 文档注释 * 能被javadoc解析 */ 常量\r#\r常量在程序运行时是不能被修改的。 // 常量用 final 来修饰 final double PI = 3.1415927; 变量\r#\r定义：代表内存中的一个存储区域 注意：须先声明并初始化，才能使用 作用域：从定义位置开始，到变量所在{}结束 //变量类型 public class Variable { // 静态变量（类变量） static int allClicks = 0; // 实例变量 String str = \u0026#34;hello world\u0026#34;; public void method() { // 局部变量 int i = 0; } } "},{"id":59,"href":"/program-lang/web/css/position/border/","title":"边","section":"CSS 位置","content":"\r边框\r#\r属性\r属性说明\r属性值\r属性值说明\rborder\r简写属性\rborder: \\[宽度]\\[样式][颜色]\rborder-width | style | color\r简写属性\r\u0026nbsp;\rborder-left | right | top | bottom\r简写属性\r\u0026nbsp;\rborder-[ left | right | top | bottom ]-width\r边框宽度\rthin\r细边框\rmedium\r中边框，默认\rthick\r粗边框\rsize\r数值\rborder-[ left | right | top | bottom ]-style\r边框样式\rnone\r无边框\rhidden\r无边框，用于解决边框冲突\rdotted\r点状边框\rdashed\r虚线边框\rsolid\r实线边框\rdouble\r双线边框\rgroove\r3D 凹槽边框\rridge\r3D 垄状边框\rinset\r3D inset 边框\routset\r3D outset 边框\rborder-[ left | right | top | bottom ]-color\r边框颜色\rtransparent\r透明色，默认\rcolor\r颜色值\r边距\r#\rpadding\rpadding-left | right | top | bottom\r内边距\rmargin\rmargin-left | right | top | bottom\r外边距\r值\rauto\r浏览器自动计算\rsize\r数值\r简写\u0026nbsp;\n助记：顺时针\rmargin:值1\r上下左右 = 值1\rmargin:值1 值2\r上下=值1，左右=值2\rmargin:值1 值2 值3\r上=值1，左右=值2，下=值3\rmargin:值1 值2 值3 值4\r上=值1，右=值2，下=值3，左=值4\r"},{"id":60,"href":"/dev-tool/gradle/config/","title":"配置","section":"Gradle","content":"\r工作原理\r#\rAndroid 配置\r#\rAndroid Studio打开一个工程时，首先会读取gradle-wrapper.properties 文件，获知gradle版本\n然后去 GRADLE_USER_HOME 文件夹，查看是否存在对应版本的gradle\n如果不存在，则会去 distributionUrl 去下载gradle\n配置文件：gradle-wrapper.properties\n# 下载的Gradle压缩包解压后存储的主目录 distributionBase=GRADLE_USER_HOME # 相对于distributionBase的解压缩后的Gradle压缩包的路径 distributionPath=wrapper/dists # 同distributionBase，只不过是存放zip压缩包的 zipStoreBase=GRADLE_USER_HOME # 同distributionPath，只不过是存放zip压缩包的 zipStorePath=wrapper/dists # Gradle发行版压缩包的下载地址 distributionUrl=https\\://services.gradle.org/distributions/gradle-6.5-bin.zip "},{"id":61,"href":"/program-lang/java/thread/lock/concurrency-lock/","title":"锁","section":"锁体系","content":"\r锁\r#\r并发锁\r#\r锁是用来控制多个线程访问共享资源的方式 一个锁能够防止多个线程同时访问共享资源 实现方案\r#\rsynchronized\r#\r存在层次 是一个Java关键字，基于JVM层面实现 锁的获取 假设A线程持有锁，B线程等待。如果A线程阻塞，B线程会一直等待 锁的释放 自动释放：当持有锁的线程执行完同步代码，释放锁；当线程执行发生异常，jvm会让线程释放锁 锁的状态 无法判断 锁的类型 可重入、不可中断、非公平 锁的机制 悲观锁机制 Lock\r#\r存在层次 是一个Java接口，基于JDK层面实现 锁的获取 有多种方式获取锁，线程可以不用一直等待 锁的释放 手动释放：需要在finally中释放锁，不然容易造成线程死锁 锁的状态 可以判断 锁的类型 可重入、可中断、可公平/可非公平 锁的机制 乐观锁机制 性能\r#\r推荐优先使用synchronized，而不是Lock synchronized：少量同步 Lock：大量同步 调度\r#\rsynchronized：使用Object对象本身的wait 、notify、notifyAll调度机制 Lock：可以使用Condition进行线程之间的调度 锁的类型\r#\r偏向锁 / 轻量级锁 / 重量级锁\r#\r详情 乐观锁 \u0026amp; 悲观锁\r#\r乐观锁\n总是假设最好的情况。每次去拿数据的时候都认为别人不会修改，所以不会上锁。但是在更新的时候会判断一下在此期间别人有没有去更新这个数据 实现：版本号机制、CAS 算法 缺点：ABA问题、循环时间长开销大、只能保证单个共享变量的原子操作 例如：原子变量类 悲观锁\n总是假设最坏的情况。每次去拿数据的时候都认为别人会修改，所以会上锁。别人想拿这个数据就会阻塞直到它拿到锁 例如：synchronized、ReentrantLock、关系型数据库中的行锁、表锁等。 公平锁 \u0026amp; 非公平锁\r#\r公平锁\n是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。 优点：避免了线程的“饥饿” 缺点：性能相对于非公平锁会差很多 例如：ReentrantLock(指定) 非公平锁\n是指多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待 优点：效率高 缺点：容易导致线程”饥饿” 例如：synchronized、ReentrantLock(默认) 独占锁 \u0026amp; 共享锁\r#\r独享锁 （互斥锁）\n定义：每次只能有一个线程能持有锁 示例：ReentrantLock、Synchronized都是独占锁 共享锁\n定义：允许多个线程同时获取锁，并发访问共享资源 示例：ReentrantReadWriteLock，其读锁是共享锁，其写锁是独占锁 可重入锁\r#\r即递归锁，线程可以进入任何一个它已经拥有的锁所同步着的代码块 同一线程，在外层方法获取锁的时候，进入内层方法会自动获取锁 避免死锁 自旋锁\r#\r是一种锁机制，是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁 优点：减少线程上下文切换的消耗 缺点：循环会消耗CPU资源 分段锁\r#\r是一种锁的设计，即分段加锁。其目的是细化锁的粒度。 ConcurrentHashMap 运用的就是分段锁 "},{"id":62,"href":"/database/redis/persistence/AOF/","title":"AOF","section":"持久化","content":"\rAOF\r#\rAOF\r#\rAppend Only File，以日志的形式来记录每个写操作，并追加到文件中。 当Redis重启时，会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。 持久化文件：appendonly.aof 过程\r#\rRedis 调用 fork() ，创建一个子进程。 主进程处理client请求，把写命令写入到aof文件中，并把写命令缓存起来。 子进程往临时文件中写入重建数据库状态的命令，之后通知主进程。 主进程把缓存的写命令也写入到临时文件，然后用临时文件替换老aof文件。 触发\r#\r自动触发：根据配置规则自动触发； 手动触发：bgrewriteaof 优点\r#\r数据安全 解决了数据一致性问题 AOF 机制的 rewrite 模式 缺点\r#\rAOF 文件比 RDB 文件大，且恢复速度慢。 数据集大的时候，比 rdb 启动效率低。 "},{"id":63,"href":"/framework/spring/aop/","title":"AOP","section":"Spring","content":"\rAOP\r#\rAspect Oriented Programming，面向切面编程，是一种编程思想 是通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术 在面向对象编程(OOP)中，基本单元是类(class)，而 AOP 中的基本单元是切面(aspect) OOP是解决了纵向的代码复用问题，AOP是解决了横向的代码复用问题 术语\r#\r术语 名称 描述 Jointpoint 连接点 程序类中，允许插入通知（Advice）的位置点 Pointcut 切入点 程序类中，已经插入通知（Advice）的位置点 Advice 通知、增强 在切入点（Pointcut）上要执行的代码 Aspect 切面 是切入点（Pointcut）和通知（Advice）的结合 Target 目标 被织入通知（Advice）的目标对象，这个对象永远是一个被代理对象 Weaving 织入 将通知（Advice）添加到目标类具体连接点上的过程 通知类型\r#\r通知 说明 备注 around 环绕通知 在建议方法调用之前和之后，执行通知。 before 前置通知 在一个方法执行之前，执行通知。 after 后置通知 在一个方法执行之后，不考虑其结果，执行通知。 after-returning 正常返回通知 在一个方法执行之后，只有在方法成功完成时，才能执行通知。 after-throwing 异常返回通知 在一个方法执行之后，只有在方法退出抛出异常时，才能执行通知。 "},{"id":64,"href":"/program-lang/java/thread/lock/aqs/","title":"AQS","section":"锁体系","content":"\rAQS 原理\r#\rAQS\r#\r抽象的队列同步器，AbstarctQueuedSynchronizer，简称AQS AQS 定义了一套多线程访问共享资源的同步器基础框架，许多同步类实现都依赖于它，如ReentrantLock、Semaphore\u0026hellip; CLH 队列\r#\r是一个FIFO双向队列。 （FIFO：First in First out，先入先出） AQS 原理\r#\rAQS 维护了一个共享变量 state 和一个 CLH 队列。 线程通过 CAS 去改变 state 状态，成功则获取锁成功，失败则进入等待队列，等待被唤醒。 AQS 实现\r#\rAQS的设计是基于模板模式。 AQS已实现了对等待队列的维护，自定义同步器只需要实现共享资源state的获取与释放方式即可。 AQS 定义了两种资源共享方式： Exclusive：独占方式，只有一个线程能执行，如ReentrantLock Share：共享方式，多个线程可以同时执行，如Semaphore、CountDownLatch 同步状态\r#\rstate用来表示当前的同步状态，根据当前state的值，来判断当前处于锁定状态还是其他状态 // 同步状态 private volatile int state; // 获取当前同步状态 int getState() // 设置当前同步状态 void setState(int newState) // 使用CAS设置当前同步状态，该方法能够保证设置同步状态时的原子性； // 参数expect为state的预期旧值，而update是需要修改的新值，若设置成功，方法返回true，否则false boolean compareAndSetState(int expect, int update) 需重写的方法\r#\r// 独占方式。尝试获取共享资源，成功则返回true，失败则返回false protected boolean tryAcquire(int arg) // 独占方式。尝试释放共享资源，成功则返回true，失败则返回false protected boolean tryRelease(int arg) // 共享方式。尝试获取共享资源，成功则返回正数，失败则返回负数，0表示无可用资源 protected int tryAcquireShared(int arg) // 共享方式。尝试释放共享资源，成功则返回true，失败则返回false protected boolean tryReleaseShared(int arg) // 当前同步器是否在独占模式下被线程占用。只有用到condition才需要去实现它 protected boolean isHeldExclusively() 提供的模板方法\r#\r// 独占方式，获取同步状态 public final void acquire(int arg) // 与acquire()相同，该方法响应中断 public final void acquireInterruptibly(int arg) // 在acquireInteruptibly()上增加了超时限制 public final boolean tryAcquireNanos(int arg, long nanosTimeout) // 独占方式，释放同步状态 public final boolean release(int arg) // 共享方式，获取同步状态 public final void acquireShared(int arg) // 与acquireShared()相同，该方法响应中断 public final void acquireSharedInterruptibly(int arg) // 在acquireSharedInterruptibly()基础上增加了超时限制。 public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout) // 共享方式，释放同步状态 public final boolean releaseShared(int arg) // 获取等待在同步队列上的线程集合 public final Collection\u0026lt;Thread\u0026gt; getQueuedThreads() "},{"id":65,"href":"/program-lang/java/container/List/ArrayList/","title":"ArrayList","section":"List","content":"\rArrayList\r#\r概述\r#\r是一个动态数组，其容量能够动态增长 特点\r#\r顺序 有序 元素 允许为 null，允许重复 效率 修改和查询元素效率高，插入和移除元素效率不高 多线程 线程不安全 继承关系\r#\rpublic class ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable AbstractList、List接口 提供了列表的骨干功能 RandomAccess接口 提供了随机访问功能 Cloneable接口 支持克隆 Serializable接口 支持序列化 成员变量\r#\r// 默认的初始化容量 private static final int DEFAULT_CAPACITY = 10; // 指定容量为0时，返回该空数组 private static final Object[] EMPTY_ELEMENTDATA = {}; // 当调用无参构造方法，返回的是该空数组 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; // 保存元素的数组 transient Object[] elementData; // 元素的个数 private int size; // 最大数组容量 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 构造方法\r#\r// 默认 public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } // 指定初始容量 public ArrayList(int initialCapacity) { //... } // 指定集合，转化为ArrayList public ArrayList(Collection\u0026lt;? extends E\u0026gt; c) { //... } 扩容机制\r#\r每次新增元素都会检查是否需要扩容 默认初始容量10，扩容的新容量为：旧容量的1.5 倍 private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } "},{"id":66,"href":"/framework/spring/ioc/bean-definition/","title":"Bean 定义","section":"IoC","content":"\rBean 定义\r#\r开启组件扫描\r#\rapplication.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!-- 开启组件扫描，指定了 base-package 扫描的包 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;xxx.xxx.xxx\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 组件类注解\r#\r这四个注解实现的功能基本一样，只是为了明确的标识类的层次及意图 注解 说明 @Component 将一般的类标识为 Bean 组件，并委托给 Spring 容器进行管理 @Controller 将控制层的类标识为 Bean 组件，是 @Component 的特化 @Service 将业务层的类标识为 Bean 组件，是 @Component 的特化 @Repository 将数据访问层的类标识为 Bean 组件，是 @Component 的特化 配置类注解\r#\r注解 说明 @Configuration 定义配置类，配置类本身也会被注册为 Bean @Bean 标注在配置类的方法上，将方法返回的实例注册为 Bean "},{"id":67,"href":"/program-lang/java/thread/container/BlockingQueue/","title":"BlockingQueue","section":"并发容器","content":"\rBlockingQueue\r#\rBlockingQueue\n"},{"id":68,"href":"/program-design/expression/cron/","title":"Cron表达式","section":"表达式","content":"\rCron表达式\r#\r简介\r#\r是一个具有时间含义的字符串 格式\r#\r{秒数} {分钟} {小时} {日期} {月份} {星期} {年份(可为空)} 分为 6~7 个域 ，以空格隔开。每个域可以是确定的取值，也可以是具有逻辑意义的特殊字符。 域取值\r#\r下表为各个域的取值范围及支持的特殊字符 域 允许的取值范围 允许的特殊符号 是否必填 秒 0-59 , - * / 是 分钟 0-59 , - * / 是 小时 0-23 , - * / 是 日期 1-31 , - * / ? L W 是 月份 1-12 或 JAN-DEC , - * / 是 星期 1-7 或 SUN-SAT , - * / ? L # 是 年 1970-2099 , - * / 否 特殊字符\r#\r字符不区分大小写，MON、mon相同 字符 含义 示例 * 所有可能的值 在月份域中，*表示每个月 ? 任意可能的值 在月份域中，?表示任意某个月 , 列出枚举值 在分钟域中，5,20表示分别在5分钟和20分钟触发一次 - 范围 在分钟域中，5-20表示从5分钟到20分钟之间每一分钟触发一次 / 数值的增量 在分钟域中，0/15表示从第0分钟开始，每15分钟触发一次 # 每个月的第几个星期几 在星期域中，4#2表示某月的第二个星期四。 L Last，最后一天 在日期域中，L表示某个月的最后一天 W 离指定某日最近的工作日 在日期域中，5W表示如果5号是星期六，则在4号触发；如果5号是星期天，则在6日触发；如果5号是工作日，则就在5号触发。 取值示例\r#\r示例 说明 0 15 10 ? * * 每天 10:15 执行任务 0 15 10 * * ? 每天 10:15 执行任务 0 0 12 * * ? 每天 12:00 执行任务 0 0 10,14,16 * * ? 每天 10:00 点、14:00、16:00 执行任务 0 0/30 9-17 * * ? 每天 09:00 到 17:00 时间段内，每隔半小时执行任务 0 * 14 * * ? 每天 14:00 到 14:59 时间段内，每隔1分钟执行任务 0 0-5 14 * * ? 每天 14:00 到 14:05 时间段内，每隔1分钟执行任务 0 0/5 14 * * ? 每天 14:00 到 14:55 时间段内，每隔5分钟执行任务 0 0/5 14,18 * * ? 每天 14:00 到 14:55、18:00 到 18:55时间段内，每隔5分钟执行任务 0 0 12 ? * WED 每个星期三 12:00 执行任务 0 15 10 15 * ? 每月 15 日 10:15 执行任务 0 15 10 L * ? 每月最后一日 10:15 执行任务 0 15 10 ? * 6L 每月最后一个星期六 10:15 执行任务 0 15 10 ? * 6#3 每月第三个星期六 10:15 执行任务 0 10,44 14 ? 3 WED 每年 3 月的每个星期三 14:10 和 14:44 执行任务 0 15 10 ? * * 2022 2022 年每天 10:15 执行任务 0 15 10 ? * * * 每年每天 10:15 执行任务 0 0/5 14,18 * * ? 2022 2022 年每天 14:00 到 14:55、18:00 到 18:55 时间段内，每隔5分钟执行任务 0 15 10 ? * 6#3 2022,2023 2022 年至 2023 年每月第三个星期六 10:15 执行任务 0 0/30 9-17 * * ? 2022-2025 2022 年至 2025 年每天 09:00 到 17:30 时间段内，每隔半小时执行任务 0 10,44 14 ? 3 WED 2022/2 从 2022 年开始，每隔两年 3 月的每个星期三 14:10 和 14:44 执行任务 "},{"id":69,"href":"/program-lang/java/thread/tool/CyclicBarrier/","title":"CyclicBarrier","section":"并发工具","content":"\rCyclicBarrier\r#\r功能\r#\r循环栅栏 多个线程互相等待，直到全部都到达同一个同步点，再继续一起执行 原理\r#\r在CyclicBarrier类的内部有一个计数器 每个线程在到达屏障点的时候都会调用 await() 将自己阻塞，此时计数器会减 1 当计数器减为 0 的时候，所有因调用 await() 而被阻塞的线程将被唤醒 方法\r#\r// 构造方法：设置要拦截的线程数，及安全栅跳闸时无预定义的动作 public CyclicBarrier(int parties) // 构造方法：设置要拦截的线程数，及安全栅跳闸时执行的预定义动作 public CyclicBarrier(int parties, Runnable barrierAction) // 非定时等待 public int await() // 定时等待 public int await(long timeout, TimeUnit unit) // 定时等待 public void reset() 示例\r#\r// 集齐七龙珠 public static void main(String[] args) { CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -\u0026gt; { System.out.println(\u0026#34;召唤神龙\u0026#34;); }); for (int i = 1; i \u0026lt;= 7; i++) { final int temp = i; new Thread(() -\u0026gt; { System.out.println(\u0026#34;收集到第\u0026#34; + temp + \u0026#34;颗龙珠\u0026#34;); try { cyclicBarrier.await(); } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } }, String.valueOf(i)).start(); } } CyclicBarrier \u0026amp; CountDownLatch\r#\r他们内部都有一个计数器，当计数器的值不断的减为 0 的时候，所有阻塞的线程将会被唤醒 CyclicBarrier的计数器由自己控制，而CountDownLatch的计数器则由使用者来控制 CyclicBarrier可以实现循环拦截，而CountDownLatch只能拦截一轮 "},{"id":70,"href":"/program-lang/java/container/Map/HashMap/","title":"HashMap","section":"Map","content":"\rHashMap\r#\r概述\r#\r是一个哈希表，存储的是键值对 (key-value) 映射。 特点\r#\r键 允许为null（放在第一位），不允许重复 值 允许为null，允许重复 顺序 无序 效率 插入、获取的时间复杂度基本是 O(1)。遍历整个 Map 需要的时间与数组的长度成正比 多线程 线程不安全 继承关系\r#\rpublic class HashMap\u0026lt;K,V\u0026gt; extends AbstractMap\u0026lt;K,V\u0026gt; implements Map\u0026lt;K,V\u0026gt;, Cloneable, Serializable { AbstractMap、Map接口 提供了Map接口的骨干功能 Cloneable接口 支持克隆 Serializable接口 支持序列化 成员变量\r#\r// 默认初始容量为16 static final int DEFAULT_INITIAL_CAPACITY = 1 \u0026lt;\u0026lt; 4; // 默认负载因子为0.75 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 临界值 = 容量 * 负载因子 int threshold; // 负载因子 final float loadFactor; // 最大容量为int的最大值除2 static final int MAXIMUM_CAPACITY = 1 \u0026lt;\u0026lt; 30; // 如果主干数组上的链表的长度大于8，链表转化为红黑树 static final int TREEIFY_THRESHOLD = 8; // 如果发现某一个红黑树的长度小于6，则会重新退化为链表 static final int UNTREEIFY_THRESHOLD = 6; // 当hashmap容量大于64时，链表才能转成红黑树 static final int MIN_TREEIFY_CAPACITY = 64; // 存储元素的数组 transient Node\u0026lt;k,v\u0026gt;[] table; transient Set\u0026lt;map.entry\u0026lt;k,v\u0026gt;\u0026gt; entrySet; // 元素的个数 transient int size; // HashMap改变的次数 transient int modCount; 构造方法\r#\r// 默认 public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; } // 指定初始容量 public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } // 指定初始容量、负载因子 public HashMap(int initialCapacity, float loadFactor) { //... } // 指定集合，转化为HashMap public HashMap(Map\u0026lt;? extends K, ? extends V\u0026gt; m) { this.loadFactor = DEFAULT_LOAD_FACTOR; //... } 底层结构\r#\rJDK1.7：数组 + 链表\nJDK1.8：数组 + 链表 + 红黑树\n​\n内部类\n// 用来实现数组及链表 static class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { final int hash; final K key; V value; Node\u0026lt;K,V\u0026gt; next; Node(int hash, K key, V value, Node\u0026lt;K,V\u0026gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } //... } // 用来实现红黑树 static final class TreeNode\u0026lt;K,V\u0026gt; extends LinkedHashMap.Entry\u0026lt;K,V\u0026gt; { TreeNode\u0026lt;K,V\u0026gt; parent; // red-black tree links TreeNode\u0026lt;K,V\u0026gt; left; TreeNode\u0026lt;K,V\u0026gt; right; TreeNode\u0026lt;K,V\u0026gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node\u0026lt;K,V\u0026gt; next) { super(hash, key, val, next); } //... } 重要函数\r#\r新增：put()\r#\r调用 hash()，计算 key 的 hash 值 再通过哈希算法，将 hash 值转换成数组的下标 如果下标位置为空，则新增一个节点 如果下标位置上为红黑树，则就调用树方法插入节点 如果下标位置上有链表或单个节点（即发生哈希碰撞），则将 key 和链表每个节点上的 key 依次进行 equals() 对比 如果有节点返回 true，则覆盖该节点 如果所有节点都返回 false，则将新节点添加到链表的末尾。并判断是否需要转换为红黑树。 如果数组长度大于阀值，则 resize() 进行扩容 public V put(K key, V value) { // 调用hash(key)计算key的hashcode值 return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, i; // 如果table为空，初始化哈希表 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 计算出索引位置 if ((p = tab[i = (n - 1) \u0026amp; hash]) == null) // 节点若不存在，则新增一个节点 tab[i] = newNode(hash, key, value, null); else { // 节点若已经存在，执行赋值操作 Node\u0026lt;K,V\u0026gt; e; K k; // 如果节点的key、hash值与传入的相等 if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) e = p; // 如果是红黑树 else if (p instanceof TreeNode) e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); // 如果是链表 else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { // 如果找不到目标节点，则在链表尾部新增一个节点， p.next = newNode(hash, key, value, null); //链表长度8，将链表转化为红黑树存储 if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } // 如果目标节点存在 if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) break; p = e; } } // 如果目标节点存在，则覆盖该节点的value if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } // 记录修改次数 ++modCount; //判断是否需要扩容 if (++size \u0026gt; threshold) resize(); afterNodeInsertion(evict); return null; } 查找：get()\r#\r调用 hash()，计算 key 的 hash 值 再通过哈希算法，将 hash 值转换成数组的下标 判断索引处第一个key与传入key是否相等，如果相等直接返回 如果不相等，判断链表是否是红黑二叉树，如果是，直接从树中取值 如果不是树，就遍历链表查找 public V get(Object key) { Node\u0026lt;K,V\u0026gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node\u0026lt;K,V\u0026gt; getNode(int hash, Object key) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; first, e; int n; K k; if ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (first = tab[(n - 1) \u0026amp; hash]) != null) { if (first.hash == hash \u0026amp;\u0026amp; // always check first node ((k = first.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode\u0026lt;K,V\u0026gt;)first).getTreeNode(hash, key); do { if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } 扩容：resize()\r#\r当元素的个数大于临界值时，会进行扩容。扩容很耗时 扩容的新容量为：旧容量 * 2 扩容机制： 新表是旧表的两倍容量，以(e.hash \u0026amp; oldCap) == 0把单链表拆分为两队， 如果等于0，则将元素迁移到新数组 “原位置”的位置上 如果不等于0，则将元素迁移到新数组 “原位置+oldCap”的位置上 final Node\u0026lt;K,V\u0026gt;[] resize() { Node\u0026lt;K,V\u0026gt;[] oldTab = table; // 原容量 int oldCap = (oldTab == null) ? 0 : oldTab.length; // 原临界值 int oldThr = threshold; // 新容量，新临界值 int newCap, newThr = 0; // 初始化newCap, newThr if (oldCap \u0026gt; 0) { if (oldCap \u0026gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 设新临界值为旧临界值的2倍 else if ((newCap = oldCap \u0026lt;\u0026lt; 1) \u0026lt; MAXIMUM_CAPACITY \u0026amp;\u0026amp; oldCap \u0026gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr \u0026lt;\u0026lt; 1; // double threshold } else if (oldThr \u0026gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap \u0026lt; MAXIMUM_CAPACITY \u0026amp;\u0026amp; ft \u0026lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; // 下面开始构造新表，初始化表中的数据 @SuppressWarnings({\u0026#34;rawtypes\u0026#34;,\u0026#34;unchecked\u0026#34;}) Node\u0026lt;K,V\u0026gt;[] newTab = (Node\u0026lt;K,V\u0026gt;[])new Node[newCap]; table = newTab; // 遍历所有节点，将节点赋值到新表 if (oldTab != null) { for (int j = 0; j \u0026lt; oldCap; ++j) { Node\u0026lt;K,V\u0026gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash \u0026amp; (newCap - 1)] = e; // 如果是红黑树节点，则进行红黑树的重新hash分布 else if (e instanceof TreeNode) ((TreeNode\u0026lt;K,V\u0026gt;)e).split(this, newTab, j, oldCap); // 如果是普通的链表节点，则进行普通的重新hash分布 else { // preserve order // 存储索引位置为：“原索引位置”，即低位链 Node\u0026lt;K,V\u0026gt; loHead = null, loTail = null; // 存储索引位置为：“原索引位置+oldCap”，即高位链 Node\u0026lt;K,V\u0026gt; hiHead = null, hiTail = null; Node\u0026lt;K,V\u0026gt; next; do { next = e.next; if ((e.hash \u0026amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); // 尾插法（低位链） if (loTail != null) { loTail.next = null; newTab[j] = loHead; } // 尾插法（高位链） if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } 哈希算法\r#\rHash，一般称“散列”，也译为“哈希” 哈希函数：将任意长度的数据，通过散列算法，变换成固定长度的数据摘要（哈希值） 哈希碰撞：两个不同的输入值，根据同一散列函数计算出的哈希值相同的现象 基本特性：根据同一散列函数计算出的散列值， 如果不同，那么输入值肯定也不同。 如果相同，输入值不一定相同。 应用：密码学\r#\r在密码学中，哈希算法主要用于对整个消息的完整性进行校验，对于抗碰撞和抗篡改能力要求极高 抗碰撞能力： 对于任意两个不同的数据块，其hash值相同的可能性极小； 对于一个给定的数据块，找到和它hash值相同的数据块极为困难。 抗篡改能力： 对于一个数据块，哪怕只改动其一个比特位，其hash值的改动也会非常大。 应用：数据结构\r#\r比如HashMap中，哈希算法是为了加速键值对的查找，并将元素均匀地放在各个桶里 这时候，对于抗碰撞的要求就没有那么高，哈希值的产生速度更为重要。 // java.lang.String public int hashCode() { int h = hash; if (h == 0 \u0026amp;\u0026amp; value.length \u0026gt; 0) { char val[] = value; for (int i = 0; i \u0026lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; } 单链表创建\r#\r头插法\r#\r尾插法\r#\r因为每次都是将新节点插入到链表尾部，所以需要增加一个始终指向表尾节点的指针R "},{"id":71,"href":"/program-lang/java/container/Set/HashSet/","title":"HashSet","section":"Set","content":"\rHashSet\r#\r概述\r#\rHashSet 基于 HashMap 实现，是 HashMap 的缩水版本 特点\r#\r顺序 无序 元素 允许为 null，不允许重复 多线程 线程不安全 继承关系\r#\rpublic class HashSet\u0026lt;E\u0026gt; extends AbstractSet\u0026lt;E\u0026gt; implements Set\u0026lt;E\u0026gt;, Cloneable, java.io.Serializable AbstractSet、Set接口 提供了 Set 接口的骨干功能 Cloneable接口 支持克隆 Serializable接口 支持序列化 成员变量\r#\r// 使用Map的key保存元素 private transient HashMap\u0026lt;E,Object\u0026gt; map; // 使用PRESENT作为Map所有key的value private static final Object PRESENT = new Object(); 构造方法\r#\r// 默认 public HashSet() { map = new HashMap\u0026lt;\u0026gt;(); } // 指定初始容量 public HashSet(int initialCapacity) { map = new HashMap\u0026lt;\u0026gt;(initialCapacity); } // 指定初始容量、负载因子 public HashSet(int initialCapacity, float loadFactor) { map = new HashMap\u0026lt;\u0026gt;(initialCapacity, loadFactor); } // 指定集合，转化为HashSet public HashSet(Collection\u0026lt;? extends E\u0026gt; c) { map = new HashMap\u0026lt;\u0026gt;(Math.max((int) (c.size()/.75f) + 1, 16)); //... } "},{"id":72,"href":"/program-lang/web/html/","title":"HTML","section":"Web","content":"\rHTML\r#\r超文本标记语言，Hyper Text Markup Language 是一种描述网页的语言，由标签组成 不需编译，直接由浏览器执行 HTML 不区分大小写 HTML 结构\r#\r声明：\u0026lt;!DOCTYPE html\u0026gt;，必须放在HTML文档第一行 标签：由尖括号包围关键词构成，如\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;、\u0026lt;br/\u0026gt; 元素：从 开始标签 到 结束标签 的所有代码 属性：在 开始标签 中规定，以键/值对的形式出现，例如：\u0026lt;p name=\u0026ldquo;value\u0026rdquo;\u0026gt;xxx\u0026lt;/p\u0026gt; 注释：\u0026lt;!\u0026ndash; 注释内容 \u0026ndash;\u0026gt; HTML 文档\r#\r即网页，包含 HTML 标签和纯文本 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Hello world!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; HTML 转义\r#\r转义字符 字符 转义字符 字符 \u0026amp;nbsp; Space \u0026amp;quot; \u0026quot; \u0026amp;lt; \u0026lt; \u0026amp;trade; ™ 商标 \u0026amp;gt; \u0026gt; \u0026amp;reg; ® 注册 \u0026amp;amp; \u0026amp; \u0026amp;copy; © 版权 "},{"id":73,"href":"/program-base/network/tcp-ip/ip/","title":"IP","section":"TCP/IP","content":"\rIP 协议\r#\rIP 协议\r#\rInternet Protocol，网际互连协议 IP 地址\r#\r是指互联网协议地址，规定网络上所有的设备都必须有独一无二的标识 IPV4：使用 32 个比特或者 4 组 0 到 255 之间的数字来为计算机编址，如192.168.1.60，分为ABCDE五类 起始地址 终止地址 A类 0.0.0.0 127.255.255.255 B类 128.0.0.0 191.255.255.255 C类 192.0.0.0 223.255.255.255 D类 224.0.0.0 239.255.255.255 E类 240.0.0.0 255.255.255.255 子网掩码\r#\rIP 地址由网络号和主机号两部分组成 子网掩码是一个32位地址，结合IP地址进行计算，可以得到IP地址的网络号、主机号 A:\t202.194.128.9 B:\t202.194.128.14 子网掩码: 255.255.255.0 转二进制： A:\t1100 1010.1100 0010.1000 0000.0000 1001 B:\t1100 1010.1100 0010.1000 0000.0000 1101 子网掩码: 1111 1111.1111 1111.1111 1111.0000 0000 掩码取反: 0000 0000.0000 0000.0000 0000.1111 1111 获取网络号：对IP和掩码，作与运算 A:\t1100 1010.1100 0010.1000 0000.0000 0000 B:\t1100 1010.1100 0010.1000 0000.0000 0000 即： A:\t202.194.128.0 B:\t202.194.128.0 获取主机号：对IP和反掩码，作与运算\tA:\t0000 0000.0000 0000.0000 0000.0000 1001 B:\t0000 0000.0000 0000.0000 0000.0000 1101 即： A:\t9 B:\t14 "},{"id":74,"href":"/program-lang/java/","title":"Java","section":"程序语言","content":"\rJava\r#\r是一种高级的面向对象的程序设计语言 特点：跨平台、面向对象、简单易学、安全健壮、支持多线程 Java 版本\r#\rJavaSE Java Platform Standard Edition 标准版 是其他版本的基础，主要用于开发桌面应用程序 JavaEE Java Platform Enterprise Edition 企业版 主要用于开发企业级分布式网络程序 JavaME Java Platform Micro Edition 小型版 主要用于嵌入式系统开发 Java 概念\r#\rJVM Java Virtual Machine Java 虚拟机 JRE Java Runtime Environment Java 运行环境 JDK Java Development Kit Java 开发工具包 "},{"id":75,"href":"/program-lang/java/library/java.sql/","title":"java.sql","section":"基础类库","content":"\rJDBC\r#\r概述\r#\rJava Data Base Connectivity，java 数据库连接 是一种用于执行 sql 语句的 java API，可以为多种关系数据库提供统一访问。 相关API\r#\rjava.sql.Driver 数据库驱动，由数据库厂商提供具体实现 java.sql.DriverManager 数据库驱动管理器 java.sql.Connection 数据库连接 java.sql.Statement SQL语句对象 java.sql.ResultSet 数据库结果集 连接步骤\r#\r加载驱动\nClass.forName(\u0026#34;com.mysql.jdbc.Driver\u0026#34;); 建立连接\nString user = \u0026#34;xxx\u0026#34;; String password = \u0026#34;xxx\u0026#34;; String url = \u0026#34;jdbc:mysql://127.0.0.1:3306/xxx?useUnicode=true\u0026#34;; Connection conn = DriverManager.getConnection(url, user, password); 创建 Statement\nString sql =\u0026#34;SELECT * FROM catalog_info WHERE catalog_name=?\u0026#34;; PreparedStatement prs = conn.prepareStatement(sql); prs.setString(1, \u0026#34;JavaSE\u0026#34;); 执行sql语句，获取结果集\nResultSet res = prs.executeQuery(); while (res.next()) { System.out.println(res.getLong(\u0026#34;catalog_id\u0026#34;) + \u0026#34; - \u0026#34; + res.getString(\u0026#34;catalog_name\u0026#34;)); } 关闭资源\nres.close(); prs.close(); conn.close(); "},{"id":76,"href":"/program-base/linux/","title":"Linux","section":"编程基础","content":"\rLinux\r#\r是一套免费使用和自由传播的类Unix操作系统 Linux 思想\r#\r一切都是文件 每个文件都有确定的用途 Linux 特点\r#\r开源、开放性 多用户、多任务 良好的界面 设备独立性 丰富的网络功能 可靠的安全系统 良好的可移植性 "},{"id":77,"href":"/program-lang/java/container/List/","title":"List","section":"集合容器","content":"\r"},{"id":78,"href":"/database/mysql/","title":"MySQL","section":"数据存储","content":"\rMySQL\r#\r是一个关系型数据库管理系统。\n属于 Oracle 旗下产品，开源免费。\n# 开/关服务 net start mysql net stop mysql # 登录/退出 mysql -h主机地址 -P端口 -u用户名 -p密码 exit \\q quit "},{"id":79,"href":"/program-lang/java/jvm/tuning/oom/","title":"OOM 问题","section":"JVM 调优","content":"\rOOM 问题\r#\r内存溢出\r#\rOut Of Memory，内存溢出 java.lang.OutOfMemoryError OOM 异常信息 栈内存溢出 java.lang.StackOverflowError 堆内存溢出 java.lang.OutOfMemoryError：Java heap space 元空间内存溢出 java.lang.OutOfMemoryError：MetaSpace 直接内存溢出 java.lang.OutOfMemoryError：Direct buffer memory GC 回收时间过长\r#\rjava.lang.OutOfMemoryError：GC overhead limit exceeded 超过 98% 的时间都在用来做 GC，且回收了不到 2% 的堆内存 不能再创建新的线程\r#\rjava.lang.OutOfMemoryError：unable to create new native thread 原因：创建了太多的线程，超过系统承载极限 解决：想办法减少应用程序创建的线程的数量 "},{"id":80,"href":"/interview/core/02-redis/","title":"Redis","section":"重点面试题","content":"\r\u0026ndash; 什么是缓存穿透？怎么解决？\r#\r缓存穿透 查询一个一定不存在的数据， 由于数据库查不到数据，因此也不写入缓存， 就会导致每次请求都查数据库，失去了使用缓存的意义。 解决方案 方案：将空结果也缓存起来，设置较短的过期时间，如此第二次就不会继续访问数据库了 优点：简单 缺点：消耗内存，可能会发生不一致的问题 方案：布隆过滤器 优点：内存占用较少，没有多余的key 缺点：实现复杂，存在误判 布隆过滤器 布隆过滤器主要是用于检索一个元素是否在一个集合中，可以使用Redisson来实现 将所有可能存在的数据哈希到一个足够大的bitmap（位图）中，那些一定不存在的数据会被这个bitmap过滤掉。 底层原理： 使用一个比较大的数组，将元素元素全部初始化为二进制数0， 当一个key来了之后，经过3次哈希计算，与组长度取模，找到数据的下标位置，设元素值为二进制数1。 这样，三个数组的位置就能标明一个key的存在。查找的过程类似。 误判率： 布隆过滤器有可能会产生一定的误判，我们一般可以设置这个误判率，大概不会超过5%。 其实这个误判是必然存在的，要不就得增加数组的长度。5%以内的误判率一般的项目也能接受，不至于高并发下压倒数据库。 \u0026ndash; 什么是缓存击穿？怎么解决？\r#\r缓存击穿 对于设置了过期时间的key，当key过期的时候，恰好在这个时间点 对这个key有大量的并发请求过来，这些并发的请求可能会瞬间把DB压垮，击穿缓存。 解决方案 方案：互斥锁 当缓存失效时，不立即去加载数据库数据，而是先使用如 Redis 的 SETNX 去设置一个互斥锁。 当操作成功返回时，再进行加载数据库数据的操作并回设缓存，否则重试get缓存的方法。 方案：设置key逻辑过期 在设置key的时候，设置一个过期时间字段一块存入缓存中，不给当前key设置过期时间； 当查询的时候，从redis取出数据后判断时间是否过期； 如果过期，则开通另外一个线程进行数据同步，当前线程正常返回数据，这个数据可能不是最新的。 两种方案各有利弊： 如果选择数据的强一致性，建议使用分布式锁的方案，但性能上可能没那么高，且有可能产生死锁的问题。 如果选择key的逻辑删除，则优先考虑高可用性，性能比较高，但数据同步这块做不到强一致。 \u0026ndash; 什么是缓存雪崩？怎么解决？\r#\r缓存雪崩 同一时间大面积的缓存数据过期，此时又有大批量的请求这些数据。 缓存中取不到数据，就会将请求全部转发到数据库，造成数据库瞬时压力过重宕机。 从而形成一系列连锁反应，造成整个系统崩溃 解决方案 1. 给不同的Key的过期时间添加随机值 2. 利用Redis集群提高服务的可用性，如哨兵模式、集群模式 3. 给缓存业务添加降级限流策略，如nginx、springcloud gateway 4. 给业务添加多级缓存 \u0026ndash; mysql 数据如何与 redis 缓存进行同步呢？\r#\r双写一致性 当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致 方案：允许延时一致的业务，采用异步通知 结合项目业务： PPM项目的当前用户的部门权限信息，虽然是热点数据，但是实时性要求并没有那么高。 所以，我们采用的是异步通知的方式，使用MQ中间件，更新数据之后，通知缓存删除。 通过保证MQ的可靠性，保证数据的最终一致性 方案：强一致性的业务，采用Redisson提供的读写锁 结合项目业务： xxx项目xxxx功能，需要让数据库与redis高度保持一致，因为要求时效性比较高。我们当时采用的读写锁保证的强一致性。 我们使用的是Redisson实现的读写锁。 在读的时候添加共享锁，可以保证读读不互斥、读写互斥。 当我们更新数据的时候，添加排他锁。它是读写、读读都互斥， 这样就能保证在写数据的同时，是不会让其他线程读数据的，避免了脏数据。 这里面需要注意的是，读方法和写方法上需要使用同一把锁才行。 \u0026ndash; 知道延时双删吗？为什么不用它呢？\r#\r延迟双删： 写数据操作，先把缓存中的数据删除，然后更新数据库，最后再延时删除缓存中的数据 为什么不用： 这个延时时间不太好确定，在延时的过程中，可能会出现脏数据，并不能保证强一致性，所以没有采用它。 \u0026ndash; Redis 的持久化方式？\r#\rRDB Redis Database Backup file 在指定的时间间隔内，定时的将Redis存储的数据生成快照并存储到磁盘上 当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。 AOF Append Only File 以日志的形式来记录每个写指令，并追加到文件中。 当Redis重启时，通过重新执行这些写命令，就能实现数恢复。 RDB vs AOF RDB AOF 持久化方式 定时对整个内存做快照 记录每一次执行的命令 数据完整性 不完整，两次备份之间会丢失 相对完整，取决于刷盘策略 文件大小 会有压缩，文件体积小 记录命令，文件体积很大 宕机恢复速度 很快 慢 数据恢复优先级 低，因为数据完整性不如AOF 高，因为数据完整性更高 系统资源占用 高，大量CPU和内存消耗 低，主要是磁盘IO资源\n但AOF重写时会占用大量CPU和内存资源 使用场景 可以容忍数分钟的数据丢失，追求更快的启动速度 对数据安全性要求较高常见 \u0026ndash; Redis 的数据过期策略?\r#\rRedis采用：定期删除+惰性删除 过期策略 说明 优点 缺点 定时删除 为每个定时键创建一个定时器，一旦过期就立即删除 对内存友好 对CPU不友好 定期删除 每隔一段时间随机抽查一些键，删除其中已过期的键 兼顾内存与CPU 难以衡量删除操作的执行频率 惰性删除 只有在访问键时，才会检查键是否过期，过期则删除 对CPU友好 对内存不友好会造成内存泄漏 \u0026ndash; Redis 的内存淘汰策略?\r#\r内存淘汰策略：当Redis的内存超过了配置的最大内存值时，以一定的策略释放内存 noeviction\t默认策略，不进行内存淘汰，当内存不足时，新写入命令会报错 volatile-ttl\t对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰 volatile/allkeys-random/lru/lfu\t其他策略 volatile\t针对设置了过期时间的key allkeys\t针对所有key random\t随机淘汰键值对 lru\t最近最少使用，用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。 lfu\t最少频率使用，统计每个key的访问频率，值越小淘汰优先级越高。 \u0026ndash; Redis 分布式锁如何实现？\r#\r在redis中提供了一个命令SETNX(SET if not exists)。 由于redis是单线程的，用了这个命令之后，只能有一个客户端对某一个key设置值。 在没有过期或删除key的时候，其他客户端是不能设置这个key的。 分布式锁使用的场景： 集群情况下的定时任务、抢单、幂等性场景 \u0026ndash; 如何控制 Redis 分布式锁的有效时长？\r#\r通过使用redis的一个框架Redisson来实现： 在redisson的分布式锁中，提供了一个WatchDog(看门狗）， 一个线程获取锁成功以后，WatchDog会给持有锁的线程进行续期（默认是每隔10秒续期一次） \u0026ndash; Redisson 分布式锁是可重入的吗？\r#\r是可以重入的。这样做是为了避免死锁的产生。 多个锁重入需要判断是否是当前线程，在redis中进行存储的时候使用的hash结构，来存储线程信息和重入的次数 \u0026ndash; Redisson锁能解决主从数据一致的问题吗？\r#\r不能解决，但是可以使用redisson提供的红锁来解决，但是这样的话，性能就太低了， 如果业务中非要保证数据的强一致性，建议采用zookeeper实现的分布式锁 \u0026ndash; Redis 集群有哪些方案?\r#\r1. 主从复制 2. 哨兵模式 3. 分片集群 \u0026ndash; Redis的主从同步？\r#\r单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。 一般都是一主多从，主节点负责写数据，从节点负责读数据 \u0026ndash; Redis 主从同步数据的流程？\r#\r全量同步 1. 从节点请求主节点同步数据（replication id、 offset ） 2. 主节点判断是否是第一次请求，是第一次就与从节点同步版本信息（replication id和offset） 3. 主节点执行bgsave，生成RDB文件后，发送给从节点去执行 4. 在RDB生成执行期间，主节点会以命令的方式记录到缓冲区（一个日志文件） 5. 把生成之后的命令日志文件发送给从节点进行同步 增量同步 1. 从节点请求主节点同步数据，主节点判断不是第一次请求，不是第一次就获取从节点的offset值 2. 主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步 \u0026ndash; 如何保证Redis的高并发高可用？\r#\r主从集群 + 哨兵模式 哨兵的作用： 1. 监控：Sentinel会不断检查您的master和slave是否按预期工作 2. 自动故障恢复：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主 3. 通知：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端 服务状态监控： Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令 主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线。 客观下线：若超过指定数量的sentinel都认为该实例主观下线，则该实例客观下线。 哨兵选主规则： 1. 首先判断主与从节点断开时间长短，如超过指定值就排该从节点 2. 然后判断从节点的slave-priority值，越小优先级越高 3. 如果slave-prority一样，则判断slave节点的offset值，越大优先级越高 4. 最后是判断slave节点的运行id大小，越小优先级越高。 \u0026ndash; Redis 集群脑裂，该怎么解决呢？\r#\r集群脑裂 由于主节点和从节点和sentinel处于不同的网络分区，使得sentinel不能心跳感知到主节点， 所以通过选举的方式提升了一个从节点为主，这样就存在了两个master，就像大脑分裂了一样。 这导致客户端还在老的主节点那里写入数据，新节点无法同步数据， 当网络恢复后，sentinel会将老的主节点降为从节点，这时再从新master同步数据，就会导致数据丢失 解决方案 1. 设置最少的slave节点个数，比如设置至少要有一个从节点才能同步数据 2. 第二个可以设置主从数据复制和同步的延迟时间，达不到要求就拒绝请求，就可以避免大量的数据丢失。 \u0026ndash; 你们使用Redis是单点还是集群，哪种集群？\r#\r主从（1主1从）+ 哨兵就可以了。 单节点不超过10G内存，如果Redis内存不足则可以给不同服务分配独立的Redis主从节点 \u0026ndash; Redis 分片集群有什么作用？\r#\r分片集群主要解决的是海量数据存储的问题， 1. 集群中有多个master，每个master保存不同数据 2. 每个master都可以有多个slave节点 3. master之间通过ping监测彼此健康状态 4. 客户端请求可以访问集群任意节点，最终都会被转发到正确节点 \u0026ndash; Redis 分片集群中数据是怎么存储和读取的？\r#\rRedis 集群引入了哈希槽的概念，有 16384 个哈希槽，集群中每个主节点绑定了一定范围的哈希槽范围， 根据key计算哈希值，再对16384取余，余数做为插槽，通过槽找到对应的节点进行存储。 读取的逻辑是一样的。 \u0026ndash; Redis是单线程的，但是为什么还那么快？\r#\r1. Redis是纯内存操作，执行速度非常快 2. 采用单线程，避免不必要的上下文切换可竞争条件，多线程还要考虑线程安全问题 3. 使用I/O多路复用模型，非阻塞IO \u0026ndash; I/O多路复用模型？\r#\r是指利用单个线程来同时监听多个Socket， 并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源，实现了高效的网络请求。 \u0026ndash; Redis 数据类型\r#\r1. 字符串：String 最基本的数据类型，可以存储字符串或数字 应用场景：缓存会话、配置参数、计数器 2. 哈希：Hash 键值对的集合 应用场景：用户属性、配置文件 3. 列表：List 有序列表，支持两端插入和删除 应用场景：消息队列、栈或队列、最新帖子列表 4. 集合：Set 无序集合，元素唯一 应用场景：共同好友、标签、去重 5. 有序集合：Zset 有序集合，元素唯一，每个元素关联一个分数，元素按分数排序 应用场景：排行榜、延迟队列 "},{"id":81,"href":"/service-manage/deprecated-frame/ribbon/","title":"Ribbon","section":"日落组件","content":"\rRibbon\r#\rRibbon\r#\r负载均衡 是一个基于 HTTP 和 TCP 的客户端负载均衡工具 工作原理\r#\r先访问注册中心，获取可用的服务列表 再根据用户指定的策略，再从服务列表中选择一个地址。 Ribbon 自带 LB 策略\r#\rLoad Balance，即负载均衡 "},{"id":82,"href":"/framework/springmvc/","title":"Spring MVC","section":"开源框架","content":"\rSpring MVC\r#\r一种基于 Java 的、实现了 MVC 设计模式的、请求驱动类型的轻量级 Web 框架。 MVC\r#\rModel、View、Controller 是一种软件设计典范，通过分离业务逻辑、数据、界面显示的方式来组织代码。 使程序分层、分工合作，既相互独立，又协同合作。 Model 模型 负责数据封装及业务逻辑处理 View 视图 负责渲染模型数据，进行可视化展示 Controller 控制器 负责居中调度。将接收的用户请求，指派给模型进行处理，并将结果传递给视图进行展示 "},{"id":83,"href":"/program-lang/java/thread/theory/synchronized/","title":"synchronized","section":"并发理论","content":"\rsynchronized\r#\r特性\r#\r并发三特性：原子性、可见性、有序性 可重入性：是可重入锁 基本用法\r#\rsynchronized 内置锁，是一种“对象锁”，锁的是对象而非引用变量，作用粒度是对象 同步原理\r#\r对象头\r#\r实例数据：存放类的属性数据信息，包括父类的属性信息 对齐填充：非必须，仅仅是为了字节对齐 对象头：Mark Word、Class Metadata Address、Array Length Mark Word 存储对象自身的运行时数据，如 hashCode、锁信息或分代年龄或GC标志等 Class Metadata Address 存储指向对象类型数据的指针 Array Length 存储数组长度（如果当前对象是数组） 锁记录\r#\rLock Record，是线程私有的数据结构。 当线程进入同步代码块时，如果此同步对象没有被锁定，JVM会在当前线程的栈中创建Lock Record空间，用于存储锁对象的Mark Word的拷贝。 每一个被锁住的对象Mark Word都会和一个Lock Record关联，同时Lock Record中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。 监视器\r#\rMonitor，可以理解为一种同步机制、一个对象。任何一个对象都有一个Monitor与之关联。 Monitor只能被一个线程持有，此时当前对象就处于锁定状态，其它线程只能阻塞等待。 在JVM中，Synchronized是基于进入和退出Monitor对象，来实现方法同步和代码块同步。 MonitorEnter指令 插入在同步代码块的开始位置。当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁； MonitorExit指令 插入在方法结束处和异常处。JVM保证每个MonitorEnter必须有对应的MonitorExit； 同步优化\r#\r为优化synchronized性能，在JDK1.6后增加了自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁等策略 锁的信息存储在对象头的MarkWord里，不同的锁状态对应的存储内容如下图 锁膨胀：无锁——\u0026gt;偏向锁——\u0026gt;轻量级锁——\u0026gt;重量级锁，并且膨胀方向不可逆 偏向锁\r#\r减少同一线程获取锁的代价 当持有锁的线程再次请求该锁时，无需再做任何同步操作，即获取锁 轻量级锁\r#\r轻量级锁是由偏向锁升级而来 当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁 重量级锁\r#\r重量级锁是由轻量级锁升级而来 当同一时间有多个线程竞争锁时，锁就会被升级成重量级锁，此时其申请锁带来的开销也就变大 其他策略\r#\r锁消除 当检测到不可能存在共享数据的竞争时，JVM会对这些同步锁进行消除 锁粗化 将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁 自旋锁 是一种锁机制，尝试获取锁的线程不会立即阻塞，而是采用循环的方式去多次尝试 自适应自旋锁 自旋的次数不是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定 "},{"id":84,"href":"/program-base/network/tcp-ip/","title":"TCP/IP","section":"网络","content":"\rTCP/IP 协议\r#\rTransmission Control Protocol / Internet Protocol，传输控制协议/网际协议 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准，是一系列互联网通信协议的统称 "},{"id":85,"href":"/program-lang/java/thread/thread/thread-stop/","title":"停止线程","section":"线程基础","content":"\r停止线程\r#\r正常结束\r#\r程序运行结束，线程自动结束 使用退出标志\r#\r使用一个停止标记，在线程中进行判断该标记的状态然后进行处理 public class MyThread extends Thread { private volatile boolean isShutDown = false; public void run() { while (!isShutDown) { // 执行体... } } public void shutDown() { this.isShutDown = true; } } public class Test { public static void main(String[] args) throws Exception { MyThread thread = new MyThread(); thread.start(); Thread.sleep(5000); thread.shutDown(); } } 使用 interrupt()\r#\r线程处于阻塞状态时，调用 interrupt() 会抛出 InterruptException 异常 线程未处于阻塞状态时，使用 isInterrupted() 判断线程的中断标志来退出循环 public class MyThread extends Thread { public void run() { // 非阻塞状态：通过判断中断标志来退出 while (!isInterrupted()) { try { // 执行体... Thread.sleep(5 * 1000); } catch (InterruptedException e) { // 阻塞状态：通过捕获中断异常来退出 break; } } } } public class Test { public static void main(String[] args) throws Exception { Thread thread = new MyThread(); thread.start(); thread.interrupt(); thread.join(); } } 使用 stop()\r#\r可以直接使用 thread.stop() 来强行终止线程，但不推荐 但是stop()是很危险的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果 "},{"id":86,"href":"/program-lang/java/jvm/memory-structure/","title":"内存结构","section":"虚拟机","content":"\r内存结构\r#\r运行时数据区\r#\rJVM 在执行 Java 程序的过程中，会把它所管理的内存区域划分为若干个不同的数据区域 方法区\r#\r即永久代 用于存储类信息、常量、静态常量、即时编译后的代码 运行时常量池，也是方法区的一部分，用于存放编译期生成的各种字面量和符号引用 堆内存\r#\r用于存储对象实例、数组 是垃圾收集器管理的主要区域 堆内存采用分代收集算法，又细分为：新生代（Eden区、SurvivorFrom区、SurvivorTo区）、老年代 虚拟机栈\r#\r栈内存，是Java方法执行的内存模型 每个方法被执行时，都会创建一个栈帧来存储局部变量表、操作数栈、动态链接、方法出口等信息 方法从被调用到执行完成的过程，就对应着栈帧在虚拟机栈中从入栈到出栈的过程 本地方法栈\r#\r与虚拟机栈相同，区别是虚拟机栈为执行 Java 方法服务，而本地方法栈则为 Native 方法服务 程序计算器\r#\r在 Java 虚拟机中，唯一没有 OOM 的区域 是一小块内存空间，用于存储当前线程正在执行字节码指令的地址值 正在执行 Java 方法时，记录的是当前指令的地址 正在执行 Native 方法时，则为 Undefined 内存区域分代\r#\r新生代\r#\r由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收 分区 说明 Eden 区 Java 新对象的出生地（大对象直接分配到老年代）当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收 ServivorFrom 区ServivorTo 区 存放 MinorGC 过程中的幸存者使用复制算法，From、To区交互配合使用 老年代\r#\r主要存放应用程序中生命周期长的内存对象，老年代的对象比较稳定，所以 MajorGC 不会频繁执行 永久代\r#\r指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息 GC 不会在主程序运行期对永久区域进行清理 在JDK1.8中，永久代被元空间取代，元空间并不在虚拟机中，而是使用本地内存 "},{"id":87,"href":"/program-lang/java/jvm/gc/judge/","title":"判定算法","section":"垃圾回收","content":"\r判定算法\r#\r引用计数法\r#\r原理：通过计算引用的数量，来判断一个对象是否可以回收 缺陷：不能解决对象间循环引用的问题 实现： 给对象添加一个引用计数器，记录引用该对象的次数 当有地方引用该对象时，计数器加 1。当引用失效时，计数器减 1。 当计数器值为 0 时，代表为垃圾对象，就会被 GC 进行回收。 可达性分析法\r#\r原理：通过判断对象是否可到达，来决定对象是否可以被回收\n实现：\n通过一系列的名为GC Roots的对象作为起始点。 从这些节点开始向下搜索，搜索所走过的路径称为引用链。 当从 GC Roots 到一个对象不可达时，则证明此对象是不可用的。 可以作为 GC Roots 的对象\nJava 虚拟机栈中正在引用的对象 本地方法栈中正在引用的对象 方法区常量引用的对象 静态属性引用的对象 "},{"id":88,"href":"/program-lang/java/jvm/class-load/load-process/","title":"加载过程","section":"类加载","content":"\r加载过程\r#\r1、加载\r#\r通过一个类的全限定名，获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构，转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区该类各种数据的访问入口。 2、验证\r#\r目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全 阶段 说明 文件格式验证 验证字节流是否符合 Class 文件格式的规范，确保能被当前虚拟机处理。 元数据验证 对字节码进行语义验证，确保其描述信息符合 Java 语言规范的要求 字节码验证 通过数据流和控制流分析，确保程序语义是合法的、符合逻辑的 符号引用验证 验证符号引用是否为可用的直接引用，确保解析动作能正确执行。 3、准备\r#\r为类变量（静态变量）分配内存，并将其初始化为系统默认值（零值） 如果是 final 修饰的类变量，则会直接初始化设定的值。 4、解析\r#\r将常量池内的符号引用替换为直接引用 解析：类或接口、字段、类方法、接口方法 5、初始化\r#\r初始化阶段是执行类构造器 \u0026lt;clinit\u0026gt;() 方法的过程\n\u0026lt;clinit\u0026gt;() 方法：\n是由编译器自动收集类中的所有类变量的赋值动作和静态语句块 (static{}块) 中的语句合并产生的。 虚拟机保证一个类的 \u0026lt;clinit\u0026gt;() 方法在多线程环境中被正确的加锁、同步 触发初始化：\n当虚拟机启动时，虚拟机会初始化定义了main()方法的主类 当使用 java.lang.reflect 包的方法对类进行反射调用时，会触发类的初始化 当初始化一个类的时候，如果其父类还未初始化，会先触发其父类的初始化 当遇到 new、getstatic、putstatic 或 invokestatic 节码指令时，会触发类的初始化如使用 new 关键字实例化对象、访问类的静态变量、访问类的静态方法 不触发初始化：\n访问类的常量 通过数组定义来引用类 子类访问父类的静态变量，子类不会被初始化 "},{"id":89,"href":"/algorithm/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/","title":"双指针","section":"leetcode","content":"\r双指针\r#\r双指针\r#\r前提：数据具有规则性 由于数据的有序性（大小或正负），可以证明当前节点优于过往节点 从而可以通过数据的维度数量的指针，逐步的迭代收敛，最终找到最优解 移动零\r#\r原题\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0] 题解\n1、左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。 2、右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。 注意到以下性质： 左指针左边均为非零数； 右指针左边直到左指针处均为零。 public class Main { public void moveZeroes(int[] nums) { int n = nums.length, left = 0, right = 0; while (right \u0026lt; n) { if (nums[right] != 0) { swap(nums, left, right); left++; } right++; } } public void swap(int[] nums, int left, int right) { int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; } } 盛最多水的容器\r#\r原题\n给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 输入：[1,8,6,2,5,4,8,3,7] 输出：49 题解\n1、用左右指针位置表示容器的边界 2、由于容量由短边决定，移动短边的指针 public class Main { public int maxArea(int[] height) { int l = 0; int r = height.length - 1; int ans = 0; while (l \u0026lt; r) { int area = Math.min(height[l], height[r]) * (r - l); ans = Math.max(ans, area); if (height[l] \u0026lt;= height[r]) { ++l; } else { --r; } } return ans; } } 三数之和\r#\r原题\n给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 题解\n1、先排序，使用双指针 2、根据条件，移动左右指针 public class Main { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { Arrays.sort(nums); int n = nums.length; List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { // 处理重复 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } int right = n - 1; int target = -nums[i]; for (int left = i + 1; left \u0026lt; right; left++) { // 处理重复 if (left != i + 1 \u0026amp;\u0026amp; nums[left] == nums[left - 1]) { continue; } while (nums[left] + nums[right] \u0026gt; target \u0026amp;\u0026amp; right \u0026gt; left) { right--; } if (left == right) { break; } if (nums[left] + nums[right] == target) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(nums[i]); list.add(nums[left]); list.add(nums[right]); ans.add(list); } } } return ans; } } "},{"id":90,"href":"/program-lang/web/css/position/width-height/","title":"宽高","section":"CSS 位置","content":"\r宽高\r#\r属性 属性说明 width 宽度 min-width 最小宽度 max-width 最大宽度 height 高度 min-height 最小高度 max-height 最大高度 属性值 属性值说明 auto 默认 size 数值 inherit 继承 "},{"id":91,"href":"/program-lang/java/oop/encapsulation/","title":"封装","section":"面向对象","content":"\r封装\r#\r概念\r#\r封装：将属性和行为绑定起来，并隐藏部分实现的细节，对外只提供访问接口。 优点：降低耦合、隐藏细节、类内部可自由修改 示例\r#\r设为私有 对外提供公共访问方法 public class Person{ private String name; public String getName(){ return name; } public void setName(String name){ this.name = name; } } "},{"id":92,"href":"/dev-tool/git/principle/","title":"工作原理","section":"Git","content":"\r工作原理\r#\r原理\r#\rGit 把数据看作是微型文件系统的一系列快照， 每次提交更新时，Git 都会对当前的全部文件制作一个快照并保存这个快照的索引（哈希算法）， 为了高效， 如果文件没有修改，Git 不再重新存储该文件， 而是只保留一个链接指向之前存储的文件。 特性\r#\r直接记录快照，而非差异比较 近乎所有操作都是本地执行，不需要联网 时刻保持数据完整性 一般只是添加数据 工程区域\r#\r工作区：日常工作的工程目录 暂存区：又称索引，工程根目录.git/index 文件夹 版本区：又称本地仓库，工程根目录.git文件夹 工作流程\r#\r文件必须一步一步的依次提交 文件可以依次检出，也可以直接从远程仓库检出到工作目录 "},{"id":93,"href":"/framework/kafka/work-principle/","title":"工作原理","section":"Kafka","content":"\r工作原理\r#\r术语\r#\rproducer：生产者，生产 message 发送到 topic consumer：消费者，订阅 topic 消费 message consumer group：消费者组，同组的不同消费者不能同时消费同一个分区的数据 broker：指 Kafka 节点，一个 Kafka 集群由多个 Kafka 节点组成。 topic：指消息类别，每条发布到 kafka 集群的消息都属于某个类别。 partition：指 topic 的分区，每个 topic 多个 partition。 segment：指 partition 的分段，每个 partition 包含多个 segment 段，每个 Segment 存着 message 信息。 offset：指 Message 在 partition 中的偏移量，可理解为消息在 partition 中的索引 存储设计\r#\rpartition 在物理上对应一个 log 文件夹，包含多个 segment 段，每个 segment 大小相等，顺序读写。 segment 在物理上对应一个.log 数据文件和一个 .index 索引文件，文件以该段中最小的 offset 进行命名。 Kafka 并没有为每条 Message 建立索引，而是采用了稀疏存储的方式，每隔一定字节的数据建立一条索引。 这样在查找指定 offset 的 Message 时，用二分查找就可以快速定位到该 Message "},{"id":94,"href":"/service-manage/dubbo/work-principle/","title":"工作原理","section":"Dubbo","content":"\r工作原理\r#\r核心功能\r#\r面向接口的远程方法调用 智能容错和负载均衡 服务自动注册和发现 Dubbo 角色\r#\r服务提供者：Provider 服务消费者：Consumer 注册中心：Registry 监控中心：Monitor Dubbo 工作原理\r#\r服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 "},{"id":95,"href":"/framework/springmvc/workflow/","title":"工作流程","section":"Spring MVC","content":"\r工作流程\r#\r核心组件\r#\r前端控制器：DispatcherServlet 处理器映射器：HandlerMapping 处理器适配器：HandlerAdapter 处理器：Handler 视图解析器：ViewResolver 视图：View 工作流程\r#\r发起请求到前端控制器。 前端控制器请求 HandlerMapping 查找 Handler。 HandlerMapping 向前端控制器返回 Handler。 前端控制器调用 HandlerAdapter 去执行 Handler。 HandlerAdapter 执行 Handler。 Handler 执行完成后，向 HandlerAdapter 返回 ModelAndView。 HandlerAdapter 将 ModelAndView返回给前端控制器。 前端控制器将 ModelAndView 传给 ViewReslover。 ViewReslover 解析后，向前端控制器返回具体 View。 前端控制器根据 View 进行渲染视图。 前端控制器响应用户。 "},{"id":96,"href":"/program-design/design-pattern/creational/02-factory/","title":"工厂模式","section":"创建型","content":"\r工厂模式\r#\r概述\r#\r英文：Factory Pattern 简述：不同条件下创建不同实例 归纳：产品标准化，生产更高效 目的：封装创建细节 案例：实体工厂 示例\r#\r简单工厂\r#\r// 产品 public interface Phone { void function(); } // 类似产品：XiaoMi，Iphone public class HuanWei implements Phone{ @Override public void function() { System.out.println(\u0026#34;华为手机\u0026#34;); } } // 统一工厂 public class PhoneFactory { public static Phone createPhone(String type){ if (\u0026#34;XiaoMi\u0026#34;.equals(type)){ return new XiaoMi(); } if (\u0026#34;HuanWei\u0026#34;.equals(type)){ return new HuanWei(); } if (\u0026#34;Iphone\u0026#34;.equals(type)){ return new Iphone(); } return null; } } 工厂方法\r#\r主要解决： 接口选择的问题 应用场景： 日志记录器（记录到硬盘/系统事件/远程服务器） 数据库访问（多种类型数据库） 连接服务器（多种通讯协议） // 产品 public interface Phone { void function(); } // 类似产品：XiaoMi，Iphone public class HuanWei implements Phone{ @Override public void function() { System.out.println(\u0026#34;华为手机\u0026#34;); } } // 工厂 public interface PhoneFactory { Phone createPhone(); } // 类似工厂：XiaoMiFactory，IphoneFactory public class HuanWeiFactory implements PhoneFactory { @Override public Phone createPhone() { return new HuanWei(); } } 抽象工厂\r#\r主要解决： 接口选择的问题 应用场景： 生成不同操作系统的程序 注意事项： 产品族难扩展，产品等级易扩展 // 类似产品族：Camera、Screen public interface CPU { void name(); } // 类似产品等级：XiaoM、Iphone public class HuanWeiCPU implements CPU { void name(); } public class HuanWeiCamera implements Camera { void name(); } public class HuanWeiScreen implements Screen { void name(); } // 类似工厂：XiaoMiFactory、IphoneFactory public interface PhoneFactory { CPU createCpu(); Camera createCamera(); Screen createScreen(); } public class HuanWeiFactory implements PhoneFactory { @Override public CPU createCpu() { return new HuanWeiCPU(); } @Override public Camera createCamera() { return new HuanWeiCamera(); } @Override public Screen createScreen() { return new HuanWeiScreen(); } } "},{"id":97,"href":"/program-lang/java/thread/problem/ConcurrentModificationException/","title":"并发修改异常","section":"并发问题","content":"\r并发修改异常\r#\r故障现象\r#\rpublic class Test { public static void main(String[] args) { ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;Integer\u0026gt;(); list.add(2); Iterator\u0026lt;Integer\u0026gt; iterator = list.iterator(); while(iterator.hasNext()){ Integer integer = iterator.next(); if(integer==2) list.remove(integer); } } } Exception in thread \u0026#34;main\u0026#34; java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:911) at java.util.ArrayList$Itr.next(ArrayList.java:861) at org.local.Test.main(Test.java:15) 导致原因\r#\r并发争抢修改导致。一个正在写，另一个抢夺，导致数据不一致，并发修改异常 解决方案\r#\rnew Vector\u0026lt;\u0026gt;(); Collections.synchronizedList(new ArrayList\u0026lt;\u0026gt;()); new CopyOnWriteArrayList\u0026lt;\u0026gt;(); "},{"id":98,"href":"/interview/core/08-concurrent/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/","title":"并发安全","section":"并发编程","content":"\r\u0026ndash; 什么是线程安全？\r#\r线程安全是指在多线程环境下，多个线程并发访问共享资源时， 程序的行为能够始终保持一致性和正确性，不会出现数据不一致或其他程序异常情况。 \u0026ndash; 怎么保证多线程的执行安全？\r#\r并发编程有三大核心特性，分别是原子性、可见性和有序性 原子性： 一个线程在CPU中操作不可暂停，也不可中断，要不执行完成，要不不执行 可以使用synchronized、lock来保证 可见性： 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值 使用volatile、synchronized、lock来保证 有序性： 程序执行的顺序按照代码的先后顺序执行 可以使用volatile来保证 \u0026ndash; synchronized 关键字的底层原理？\r#\r1. synchronized synchronized底层依赖于JVM级别的Monitor对象来实现，线程通过关联【锁对象】的Monitor来获得锁。 如果某一个线程获得了锁，在没有释放锁之前，其它线程再想获取这个锁时就会被阻塞。 2. Monitor 每个对象都存在着一个与之对应的Monitor对象。 在对象的对象头中，有个MarkWord区域，存储着对象的锁状态。 当锁状态为重量级锁时，Markword中会记录着指向该Monitor对象的指针，而Monitor中关联着竞争锁的线程。 Monitor内部维护了三个属性： - WaitSet：关联处于Waiting状态的线程 - EntryList：关联处于Blocked状态的线程 - Owner：关联获得锁的线程，并且只能关联一个线程 3. 锁升级 synchronized有偏向锁、轻量级锁、重量级锁三种形式 偏向锁：\t当只有一个线程持有锁时，是偏向锁 在第一次获得锁时，会有一个CAS命令，之后该线程再获取锁， 只需要判断MarkWord中是否是自己的线程id即可，而不是开销相对较大的CAS命令 轻量级锁：\t当不同线程交替持有锁时，即线程加锁的时间是错开的没有竞争，是轻量级锁 通过CAS命令，修改MarkWord中LockRecord来关联获取锁的线程。 重量级锁：\t当多个线程竞争锁时，是重量级锁。 底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。 \u0026ndash; 请谈谈 Java 内存模型 JMM ？\r#\rJava Memory Model，Java内存模型， 定义了共享内存中多线程程序读写操作的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性 JMM把内存分为两块，一块是私有线程的工作区域（工作内存），一块是所有线程的共享区域（主内存） 线程跟线程之间是相互隔离，线程跟线程交互需要通过主内存 \u0026ndash; CAS 是什么？\r#\rCompare And Swap，比较再交换，它体现的一种乐观锁的思想，在无锁状态下保证线程操作数据的原子性。 1. 涉及三个操作数：当前内存值V、旧的预期值A、即将更新的值B， 2. 当且仅当A和V相同时，将内存值修改为B，并返回true，否则直接返回false。 3. 如果CAS操作失败，通过自旋的方式等待并再次尝试，直到成功 CAS使用到的地方很多：AQS框架、AtomicXXX类 CAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现 \u0026ndash; 乐观锁和悲观锁的区别？\r#\r乐观锁： CAS是基于乐观锁的思想。 最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。 悲观锁： synchronized是基于悲观锁的思想 最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。 \u0026ndash; 谈谈你对 volatile 的理解？\r#\rvolatile 是一个关键字， 可以修饰类的成员变量、类的静态成员变量，主要有两个功能： 1. 保证线程间共享变量的可见性 volatile能够防止编译器对代码进行优化 当一个线程修改了共享变量的值，volatile会强制将新值立即写入主内存，使得新值对其他线程来说是立即可见的。 2. 禁止进行指令重排序 禁止进行指令重排序，可以保证代码执行有序性。 底层实现原理是，添加了一个内存屏障，通过插入内存屏障，禁止在内存屏障前后的指令执行重排序优化 \u0026ndash; 什么是AQS？\r#\rAbstractQueuedSynchronizer，即抽象队列同步器 是jdk提供的一种锁机制，是阻塞式锁和相关的同步器工具的基础框架。 AQS内部维护了一个先进先出的双向队列，用于存储等待资源的线程。 AQS内部还有一个属性state，来标志资源的状态，state默认是0，表示没有获取锁，state等于1时，表示获取到了锁。 AQS通过CAS机制来设置state状态，保证多个线程修改的情况下的原子性。 \u0026ndash; ReentrantLock 的实现原理？\r#\r1. ReentrantLock是属于juc包下的类，属于api层面的锁， 跟synchronized一样，都是悲观锁。通过lock()来获取锁，unlock()来释放锁。 2. ReentrantLock底层主要利用CAS+AQS队列来实现， 支持公平锁和非公平锁，在提供的无参构造器中默认是非公平锁，也可以传参设置为公平锁 3. ReentrantLock是一个可重入锁，调用lock()方法获取了锁之后，再次调用lock()，是不会再阻塞线程 \u0026ndash; synchronized 和 Lock 有什么区别 ?\r#\r语法层面 synchronized是关键字，源码在jvm中，用c++语言实现，退出同步代码块锁会自动释放 Lock是接口，源码由jdk提供，用java语言实现，需要手动调用 unlock()释放锁 功能层面 二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能 Lock 提供了许多 synchronized 不具备的功能，例如公平锁、可打断、可超时、多条件变量 Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock(读写锁) 性能层面 在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不错 在竞争激烈时，Lock 的实现通常会提供更好的性能 \u0026ndash; 死锁产生的条件是什么？\r#\r产生条件： 1. 互斥使用：一个资源每次只能被一个线程使用 2. 不可抢占：资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放 3. 请求保持：当资源请求者在请求其他的资源的同时保持对原有资源的占有 4. 循环等待：若干线程之间形成一种头尾相接的循环等待资源关系 如何进行死锁诊断？ 1. 使用jps和jstack工具 先用jps输出JVM运行的线程，找到DeadLock状态的线程id 再用jstack打印该线程的信息，找到DeadLock日志，根据日志分析死锁位置 2. 可视化工具jconsole、VisualVM也可以检查死锁问题 \u0026ndash; 说一下 ConcurrentHashMap？\r#\r1. 底层数据结构 JDK1.7底层采用：分段的数组 + 链表实现 JDK1.8底层采用：数组 + 链表 + 红黑树 2. 加锁的方式 JDK1.7采用Segment分段锁，底层使用的是ReentrantLock JDK1.8采用CAS添加新节点，采用synchronized锁定链表或红黑树的首节点，相对Segment分段锁粒度更细，性能更好 \u0026ndash; 说一下 ThreadLocal？\r#\rThreadLocal\tThreadLocal会为每个访问线程都创建一个独立的本地副本 各个线程实际上是操作独属于本线程的变量，从而实现了资源对象的线程隔离，避免了线程安全问题 也起到了线程内资源共享的作用 底层原理\tThread类中，有个ThreadLocal.ThreadLocalMap的成员变量，用来存储资源对象。 ThreadLocalMap的key是ThreadLocal实例本身，value则存储资源对象 每个线程都是操作自己的成员变量，从而互相不影响 内存泄漏问题\tThreadLocalMap中的key是弱引用，value为强引用； key会被GC释放内存，关联value的内存并不会释放，导致出现内存泄漏。 避免内存泄漏\t将ThreadLocal设置成静态变量（即强引用） 主动调用remove()方法key和value \u0026ndash; 线程工具类？\r#\rCountDownLatch 倒计时器： 一个或多个线程一直等待，直到其他线程完成某件事情之后再执行 实现原理： 1. 通过一个计数器进行实现。计数器初始值为线程的数量。 2. 每当一个线程执行完毕后，计数器的值就减1。 3. 当计数器的值为0时，表示所有线程都执行完毕，然后在CountDownLatch上等待的线程就可以恢复执行了 CyclicBarrier 循环栅栏： 多个线程互相等待，直到全部都到达同一个同步点，再继续一起执行 实现原理： 1. 在CyclicBarrier类的内部有一个计数器 2. 每个线程在到达屏障点的时候都会调用await()将自己阻塞，此时计数器会减1 3. 当计数器减为0的时候，所有因调用await()而被阻塞的线程将被唤醒 Semaphore 信号灯： 作为一种流量控制手段，用于控制同时访问特定资源的线程数量，保证合理的使用共享资源 实现原理： 1. Semaphore管理一系列许可（仅维护许可的计数）。 2. 线程通过acquire()获取许可。当没有可用的许可的时候，线程阻塞，直到有可用的许可为止。 3. 线程通过release()释放许可。 Exchanger 交换器： 是一个用于线程间协作的工具类，用于两个线程间交换数据。 实现原理： 1. Exchanger提供了一个交换的同步点，在这个同步点两个线程能够交换数据。 2. 如果一个线程先执行exchange()，那它会阻塞等待另一个线程也执行exchange()。 3. 当两个线程就都达到了同步点，它们就可以交换数据。 "},{"id":99,"href":"/program-lang/java/thread/theory/","title":"并发理论","section":"多线程","content":"\r串行、并行、并发\r#\r串行：顺序执行多个任务；一个任务执行完毕后，再执行下一个任务。 并行：同时执行多个任务；同一时刻，同时有多个任务在执行。 并发：交替执行多个任务；同一时刻，只有一个任务在执行。 阻塞、非阻塞\r#\r指自身状态，是否能去做其他事 阻塞 ：调用在发出去后，在消息返回之前，当前进/线程会被阻塞 非阻塞：调用在发出去后，不会阻塞当前进/线程，而是立即返回 同步、异步\r#\r指处理方式，是否等待结果 同步：执行某个任务，等待结果返回，再执行后续任务 异步：执行某个任务，不等待结果返回，就执行后续任务 "},{"id":100,"href":"/program-lang/java/feature/exception/","title":"异常处理","section":"语言特性","content":"\r异常处理\r#\r异常\r#\r就是程序出现了不正常的情况 异常体系\r#\r编译时异常\nRuntimeException之外的异常，又称受检异常 在编译期间出现的异常，必须处理，否则无法通过编译 比如：FileNotFoundException 运行时异常\nRuntimeException及其子类，又称非受检异常 在运行期间出现的异常，可延后处理 比如：NullPointerException 抛出异常\r#\r默认方式\nJVM会把异常信息输出在了控制台，并停止程序 throw 方式\n用在方法内，后面跟异常对象 thorws 方式\n用在方法声明上，后面跟异常类名 可以跟多个，用逗号隔开 // 在方法内 throw new Exception(); // 在方法声明上 public void method() throws Exception { } 捕获异常\r#\rtry - catch - finally try { // 可能出现异常的语句 } catch (异常类 变量){ // 处理异常的代码，可以有多个 // 出现异常，才会执行 } finally { // 不是必须的 // 无论是否产生异常，一定会执行的语句 } 自定义异常\r#\r自定义类，使之继承 Exception 等异常类 // 用法与内置异常类一样 public class MyException extends Exception { MyException(String message) { super(message); } } finally \u0026amp; return\r#\r执行逻辑 finally块前的return语句，记为out-return finally块内的return语句，记为in-return finally块中无return： 执行out-return，保存结果到缓存槽，执行finally块，返回缓存槽的数据 finally块中有return： 执行out-return，保存结果到缓存槽，执行finally块，执行in-return提前退出 场景示例 // finally块中无return，且未操作变量 public static void test() { try { System.out.println(\u0026#34;执行try\u0026#34;); } finally { System.out.println(\u0026#34;执行finally\u0026#34;); } } /** * 打印： * 执行try * 执行finally */ // finally块中无return，且操作了变量（基本类型/String） public static String test() { String result; try { result = \u0026#34;try\u0026#34;; return result; } finally { result = \u0026#34;finally\u0026#34;; } } /** * 返回：try */ // finally块中无return，且操作了变量（引用类型） public static String[] test() { String[] arr = new String[2]; try { arr[0] = \u0026#34;try\u0026#34;; return arr; } finally { arr[1] = \u0026#34;finally\u0026#34;; } } /** * 返回：[try, finally] */ // finally块中有return public static String test() { try { return \u0026#34;try\u0026#34;; } finally { return \u0026#34;finally\u0026#34;; } } /** * 返回：finally */ "},{"id":101,"href":"/algorithm/huawei-od/%E5%BF%85%E4%BC%9A%E9%A2%982/","title":"必会题 - 2","section":"华为OD","content":"\r01. 机器人走迷宫\r#\r描述\n1、房间有X*Y的方格组成，例如下图为6*4的大小。每一个放个以坐标(x,y)描述。 2、机器人固定从方格(0,0)出发，只能向东或者向北前进，出口固定为房间的最东北角，用例保证机器人可以从入口走到出口。 3、房间有些方格是墙壁，如(4,1),机器人不能经过那儿。 4、有些地方是一旦到达就无法走到出口的，如标记为B的方格，称之为陷阱方格。 5、有些地方是机器人无法达到的，如标记为A的方格，称之为不可达方格，不可达方格不包括墙壁所在的位置 6、如下实例图中，陷阱方格有2个，不可达方格有3个。 请为该机器人实现路径规划功能：给定房间大小，墙壁位置，请计算出陷阱方格与不可达方格分别有多少个 输入描述： 1、第一行为房间的x和y(0 ＜ x,y ≤ 1000) 2、第二行为房间中墙壁的个数N (0 ≤ N ＜ X*Y) 3、接着下面会有N行墙壁的坐标 同一行中如果有多个数据以一个空格隔开，用例保证所有的输入数据均合法，(结尾不带回车换行) 输出描述： 陷阱方格与不可达方格数量，两个信息在一行中输出，以一个空格隔开。(结尾不带回车换行) 输入：6 4 5 0 2 1 2 2 2 4 1 5 1 输出：2 3 题解\npublic static void main(String[] args) { // 0 是未踩过的。 1是墙。 2是踩过的。 Scanner sc = new Scanner(System.in); String[] xyArr = sc.nextLine().split(\u0026#34; \u0026#34;); int x = Integer.parseInt(xyArr[0]); int y = Integer.parseInt(xyArr[1]); int wallNum = Integer.parseInt(sc.nextLine()); int[][] room = new int[x][y]; for (int i = 0; i \u0026lt; wallNum; i++) { String[] tempArr = sc.nextLine().split(\u0026#34; \u0026#34;); int wallX = Integer.parseInt(tempArr[0]); int wallY = Integer.parseInt(tempArr[1]); room[wallX][wallY] = 1; } path(room, 0, 0, x - 1, y - 1); int badPath = 0; //陷阱 int noWay = 0; // 不可达 for (int i = 0; i \u0026lt; x; i++) { for (int j = 0; j \u0026lt; y; j++) { if (room[i][j] == 9) { badPath += 1; } else if (room[i][j] == 0) { noWay += 1; } } } System.out.println(badPath + \u0026#34; \u0026#34; + noWay); } // 不可达方格 : 机器人无法通过增加X Y值到的方格。走完还是0的方格 // 陷阱方格 : 走到该位置不能正确走到终点的方格。 向前/向上不可达、同为陷阱方格则也标记为 9 // 标记：0未踩过、 1墙、2已踩过、9陷阱 private static void path(int[][] room, int nextX, int nextY, int wallX, int wallY) { // 跳过：墙、已踩过 if (room[nextX][nextY] == 1 || room[nextX][nextY] == 2) { return; } // 已到出口 if (nextX == wallX \u0026amp;\u0026amp; nextY == wallY) { room[nextX][nextY] = 2; return; } // 递归走完所有能走的方格 if (nextX \u0026lt; wallX) { path(room, nextX + 1, nextY, wallX, wallY); } if (nextY \u0026lt; wallY) { path(room, nextX, nextY + 1, wallX, wallY); } // 标记：0未踩过、 1墙、2已踩过、9陷阱 if (nextX == wallX || nextY == wallY) { // 已走到x边，且向y一格不可达 if (nextX == wallX \u0026amp;\u0026amp; nextY \u0026lt; wallY \u0026amp;\u0026amp; room[nextX][nextY + 1] != 2) { room[nextX][nextY] = 9; return; } // 已走到y边，且向x一格不可达 if (nextY == wallY \u0026amp;\u0026amp; nextX \u0026lt; wallX \u0026amp;\u0026amp; room[nextX + 1][nextY] != 2) { room[nextX][nextY] = 9; return; } // 当前方格已踩过 room[nextX][nextY] = 2; return; } // 未到达xy边界，且向x向y一格都不可达 if (room[nextX + 1][nextY] != 2 \u0026amp;\u0026amp; room[nextX][nextY + 1] != 2) { room[nextX][nextY] = 9; } else { room[nextX][nextY] = 2; } } 02. 高效的任务规划\r#\r描述\n你有 n 台机器编号为 1~n，每台都需要完成完成一项工作，机器经过配置后都能完成独立完成一项工作。 假设第 i 台机器你需要花 B 分钟进行设置，然后开始运行，J 分钟后完成任务。 现在，你需要选择布置工作的顺序，使得用最短的时间完成所有工作。 注意，不能同时对两台进行配置，但配置完成的机器们可以同时执行他们各自的工作。 输入描述： 第一行输入代表总共有 M 组任务数据（1＜M≤10）。 每组数第一行为一个整数指定机器的数量 N（0＜N≤1000）。 随后的 N 行每行两个整数，第一个表示 B（0≤B≤10000），第二个表示 J（0≤J≤10000）。 每组数据连续输入，不会用空行分隔。各组任务单独计时。 输出描述： 对于每组任务，输出最短完成时间，且每组的结果独占一行。例如，两组任务就应该有两行输出。 输入：2 2 1 1 2 2 3 1 1 2 2 3 3 输出：4 7 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); for (int i = 0; i \u0026lt; m; i++) { int n = sc.nextInt(); int[][] jobs = new int[n][2]; for (int j = 0; j \u0026lt; n; j++) { jobs[j][0] = sc.nextInt(); jobs[j][1] = sc.nextInt(); } solution(jobs); } } // 因为是顺序配置，所以配置的总时长是固定的 // 因此只要让耗时长的先执行，即可保证最高效 private static void solution(int[][] jobs) { Arrays.sort(jobs, (job1, job2) -\u0026gt; job2[1] - job1[1]); int time = 0; int remaining = 0; for (int[] job : jobs) { // 添加配置时间 time += job[0]; remaining -= job[0]; if (remaining \u0026lt;= 0) { remaining = job[1]; } else { remaining = remaining - job[0] + job[1]; } } time += remaining; System.out.println(time); } 03. 二叉树遍历\r#\r描述\n根据给定的二叉树结构描述字符串，输出该二叉树按照中序遍历结果字符串。中序遍历顺序为:左子树，根结点，右子树。 输入描述：由大小写字母、左右大括号、逗号组成的字符串: 1、字母代表一个节点值，左右括号内包含该节点的子节点。 2、左右子节点使用逗号分隔，逗号前为空则表示左子节点为空,没有逗号则表示右子节点为空。 3、二叉树节点数最大不超过100。 注：输入字符串格式是正确的，无需考虑格式错误的情况。 输出描述 输出一个字符串，为二叉树中序遍历各节点值的拼接结果。 示例： 输入：a{b{d,e{g,h{,I}}},c{f}} 输出：dbgehIafc 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chars = sc.nextLine().toCharArray(); System.out.println(getResult(chars)); } public static String getResult(char[] chars) { Map\u0026lt;String, TreeNode\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (char ch : chars) { stack.push(ch); if (ch == \u0026#39;}\u0026#39;) { stack.pop(); StringBuilder sb = new StringBuilder(); while (stack.peek() != \u0026#39;{\u0026#39;) { sb.append(stack.pop()); } stack.pop(); String key = stack.peek() + \u0026#34;\u0026#34;; TreeNode node = new TreeNode(key); map.put(key, node); String[] split = sb.reverse().toString().split(\u0026#34;,\u0026#34;); if (!split[0].isBlank()) { node.left = map.getOrDefault(split[0], new TreeNode(split[0])); } if (split.length == 2 \u0026amp;\u0026amp; !split[1].isBlank()) { node.right = map.getOrDefault(split[1], new TreeNode(split[1])); } } } TreeNode root = map.get(chars[0] + \u0026#34;\u0026#34;); StringBuilder sb = new StringBuilder(); show(sb, root); return sb.toString(); } private static void show(StringBuilder sb, TreeNode node) { if (node == null) { return; } show(sb, node.left); sb.append(node.value); show(sb, node.right); } static class TreeNode { public TreeNode(String value) { this.value = value; } public String value; public TreeNode left; public TreeNode right; } 04. 书籍叠放\r#\r描述\n书籍的长宽都是整数对(l,w) 如果书A的长度宽度都比B长宽大，则允许将B排列放在A上面。 现在有一组规格的书籍，书籍叠放时要求书籍不能做旋转，请计算最多能有多少个规格书籍能叠放在一起。 输入描述：书本长宽对的数组 输出描述：最多可堆叠摆放的规则数量 输入：[[20,16],[15,11],[10,10],[9,10]] 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String input = sc.nextLine(); String[] strings = input.replaceAll(\u0026#34;\\\\[\u0026#34;, \u0026#34;\u0026#34;) .replaceAll(\u0026#34;]\u0026#34;, \u0026#34;\u0026#34;).split(\u0026#34;,\u0026#34;); int num = strings.length / 2; int[][] books = new int[num][2]; int j = 0; for (int i = 0; i \u0026lt; num; i++) { books[i][0] = Integer.parseInt(strings[j]); j++; books[i][1] = Integer.parseInt(strings[j]); j++; } // 降序排序 Arrays.sort(books, ((o1, o2) -\u0026gt; { if (o1[0] != o2[0]) { return o2[0] - o1[0]; } return o2[1] - o1[1]; })); // 获取当前长宽最大的书籍作为基 int[] preArr = books[0]; int count = 1; for (int i = 1; i \u0026lt; books.length; i++) { int[] curArr = books[i]; if (preArr[0] \u0026gt; curArr[0] \u0026amp;\u0026amp; preArr[1] \u0026gt; curArr[1]) { count++; preArr = curArr; } } System.out.println(count); } 05. 区间交集\r#\r描述\n给定一组闭区间，其中部分区间存在交集。 任意两个给定区间的交集，称为公共区间(如:[1,2],[2,3]的公共区间为[2,2]，[3,5],[3,6]的公共区间为[3,5])。 公共区间之间若存在交集，则需要合并(如:[1,3],[3,5]区间存在交集[3,3]，需合并为[1,5])。 输入描述：一组区间列表，区间数为 N: 0≤N≤1000；区间元素为 X: -10000≤X≤10000。 输出描述：按升序输出合并后的区间列表。 备注说明：1、区间元素均为数字，不考虑字母、符号等异常输入。2、单个区间认定为无公共区间。 输入：0 3 1 3 3 5 3 6 输出：1 5 说明： [0,3]和[1,3]的公共区间为[1,3]，[0,3]和[3,5]的公共区间为[3,3]，[0,3]和[3,6]的公共区间为[3,3]， [1,3]和[3,5]的公共区间为[3,3]，[1,3]和[3,6]的公共区间为[3,3]， [3,5]和[3,6]的公共区间为[3,5]， 公共区间列表为[[1,3],[3,3],[3,5]]，存在交集，须合并为[1,5] 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); List\u0026lt;int[]\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); while (sc.hasNextLine()) { String input = sc.nextLine(); if (input.isBlank()) { break; } String[] strings = input.split(\u0026#34; \u0026#34;); int[] arr = new int[2]; arr[0] = Integer.parseInt(strings[0]); arr[1] = Integer.parseInt(strings[1]); list.add(arr); } List\u0026lt;int[]\u0026gt; regions = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; list.size(); i++) { for (int j = i + 1; j \u0026lt; list.size(); j++) { int[] arr = intersection(list.get(i), list.get(j)); if (arr != null) { regions.add(arr); } } } regions.sort(Comparator.comparingInt(r -\u0026gt; r[0])); int left = regions.get(0)[0]; int right = regions.get(0)[1]; List\u0026lt;int[]\u0026gt; resList = new ArrayList\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt; regions.size(); i++) { int[] tempArr = regions.get(i); if (right \u0026lt; tempArr[0]) { resList.add(new int[]{left, right}); left = tempArr[0]; right = tempArr[1]; } else if (right \u0026lt;= tempArr[1]) { right = tempArr[1]; } } resList.add(new int[]{left, right}); for (int[] ints : resList) { System.out.println(ints[0] + \u0026#34; \u0026#34; + ints[1]); } } private static int[] intersection(int[] r1, int[] r2) { if (r1[1] \u0026lt; r2[0] || r2[1] \u0026lt; r1[0]) { return null; } int[] arr = new int[2]; arr[0] = Math.max(r1[0], r2[0]); arr[1] = Math.min(r1[1], r2[1]); return arr; } 06. 分月饼\r#\r描述\n中秋节，公司要给员工分月饼。公司有m个员工，买了n个月饼，且m≤n。每个员工至少分到 1 个月饼，但可以分多个。 要求： 单人分到最多的月饼个数为Max1，单人分到第二多的月饼个数为Max2，需要满足Max1−Max2≤3。 单人分到倒数第二多的月饼个数为Max(n−1)，单人分到最少的月饼个数为Max(n)，需要满足Max(n−1)−Max(n)≤3。 问有多少种分月饼的方法？ 输入描述：第一行输入两个整数m和n，表示m个员工和n个月饼，m≤n。 输出描述：输出有多少种分月饼的方法。 输入：3 12 输出：6 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] input = sc.nextLine().split(\u0026#34; \u0026#34;); int m = Integer.parseInt(input[0]); int n = Integer.parseInt(input[1]); System.out.println(countWays(m, n)); } // 动态规划 // 定义状态 dp[i][j][k] 表示前 i 个人分配了 j 个月饼，且第 i 个人分配了 k 个月饼的方案数。 // 状态方程为 dp[i][j]=∑k=1\u0026gt;\u0026gt;3 dp[i−1][j−k] public static int countWays(int m, int n) { int[][][] dp = new int[m + 1][n + 1][n + 1]; // 初始化 for (int k = 1; k \u0026lt;= n; k++) { // 只有1个员工时，只有一种分法 dp[1][k][k] = 1; } // 动态规划 for (int i = 1; i \u0026lt;= m; i++) { // 确保月饼数量不少于员工数 for (int j = i; j \u0026lt;= n; j++) { // 每个员工至少分得1个月饼 for (int k = 1; k \u0026lt;= j; k++) { //确保当前分配不超过上一个员工的分配 for (int l = Math.max(1, k - 3); l \u0026lt;= k; l++) { dp[i][j][k] += dp[i - 1][j - k][l]; } } } } // 汇总结果 int count = 0; for (int k = 0; k \u0026lt;= n; k++) { System.out.println(\u0026#34;m=\u0026#34; + m + \u0026#34;, n=\u0026#34; + n + \u0026#34;, k=\u0026#34; + k + \u0026#34;, dp[m][n][k]=\u0026#34; + dp[m][n][k]); count += dp[m][n][k]; } return count; } 07. 找最小数\r#\r描述\n给一个正整数NUM1，计算出新正整数NUM2，NUM2为NUM1中移除N位数字后的结果，需要使得NUM2的值最小。 输入描述： 1.输入的第一行为一个字符串，字符串由0-9字符组成，记录正整数NUM1，NUM1长度小于32。 2.输入的第二行为需要移除的数字的个数，小于NUM1长度。 输出描述： 输出一个数字字符串，记录最小值NUM2。 输入：2615371 4 输出：131 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chars = sc.nextLine().toCharArray(); int n = sc.nextInt(); Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (char ch : chars) { while (!stack.empty() \u0026amp;\u0026amp; stack.peek() \u0026gt; ch \u0026amp;\u0026amp; n \u0026gt; 0) { stack.pop(); n--; } if (stack.empty() \u0026amp;\u0026amp; ch == \u0026#39;0\u0026#39;) { //跳过前置0 continue; } stack.push(ch); } StringBuilder sb = new StringBuilder(); while (!stack.empty()) { if (n \u0026gt; 0) { //当还要再移除数字的时候：从此时单调递增栈的top部删去数字 n--; } else if (n == 0) { //当不用再移除数字的时候：把字符串取出来到result sb.append(stack.peek()); } stack.pop(); } sb.reverse(); String res = sb.isEmpty() ? \u0026#34;0\u0026#34; : sb.toString(); System.out.println(res); } 08. 简易内存池\r#\r描述\n请实现一个简易内存池Q，根据请求命令完成内存分配和释放。 内存池支持两种操作命令，REQUEST和RELEASE， REQUEST=请求的内存大小 表示请求分配指定大小内存，如果分配成功，返回分配到的内存首地址；如果内存不足，或指定的大小为0,则输出error. RELEASE=释放的内存首地址， 表示释放掉之前分配的内存，释放成功无需输出，如果释放不存在的首地址则输出error。 注意： 1.内存池总大小为100字节。 2.内存池地址分配必须是连续内存，并优先从低地址分配。 3.内存释放后可被再次分配，已释放的内存在空闲时不能被二次释放 4.不会释放已申请的内存块的中间地址， 5.释放操作只是针对首地址所对应的单个内存块进行操作，不会影响其它内存块。 输入描述： 首行为整数N，表示操作命令的个数，取值范围：N≤100. 接下来的N行，每行将给出一个操作命令，操作命令和参数之间用等号分割。 输出描述： 根据操作命令返回输出 输入：5 REQUEST=10 REQUEST=20 RELEASE=0 REQUEST=15 RELEASE=10 输出：0 10 10 题解\n// 0 表示未分配 1表示已经分配 public static final int[] RAM_ARR = new int[100]; // 存放分配过的内存的首地址及长度 static final HashMap\u0026lt;Integer, Integer\u0026gt; MAP = new HashMap\u0026lt;\u0026gt;(); public static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = sc.nextInt(); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; num; i++) { String[] strings = sc.nextLine().split(\u0026#34;=\u0026#34;); int answer = answer(strings[0], Integer.parseInt(strings[1])); if (answer != -2) { list.add(answer == -1 ? \u0026#34;error\u0026#34; : answer + \u0026#34;\u0026#34;); } } list.forEach(System.out::println); } public static int answer(String str, int num) { if (str.equals(\u0026#34;REQUEST\u0026#34;)) { if (num == 0) { return -1; } int len = 0; for (int i = 0; i \u0026lt; RAM_ARR.length; i++) { if (RAM_ARR[i] != 0) { continue; } for (int j = i; j \u0026lt; RAM_ARR.length; j++) { if (RAM_ARR[j] == 0) { len++; } else { i = len - 1; len = 0; break; } if (len == num) { for (int k = i; k \u0026lt; i + num; k++) { RAM_ARR[k] = 1; } MAP.put(i, num); return i; } } } return -1; } if (str.equals(\u0026#34;RELEASE\u0026#34;)) { if (MAP.containsKey(num)) { Integer len = MAP.get(num); MAP.remove(num); for (int i = num; i \u0026lt; len + num; i++) { RAM_ARR[i] = 0; } return -2; } else { return -1; } } return -1; } 09. 服务失效判断\r#\r描述\n某系统中有众多服务，每个服务用字符串（只包含字母和数字，长度≤10）唯一标识， 服务间可能有依赖关系，如A依赖B，则当B故障时导致A也故障。 依赖具有传递性，如A依赖B，B依赖C，当C故障时导致B故障，也导致A故障。 给出所有依赖关系，以及当前已知故障服务，要求输出所有正常服务。 依赖关系：服务1-服务2 表示“服务1”依赖“服务2” 不必考虑输入异常，用例保证：依赖关系列表、故障列表非空，且依赖关系数，故障服务数都不会超过3000，服务标识格式正常。 输入描述： 第1行是依赖关系列表，用逗号分隔 第2行是故障服务列表，用逗号分隔 输出描述： 依赖关系列表中提到的所有服务中可以正常工作的服务列表，用逗号分隔， 按依赖关系列表中出现的顺序排序，如果没有正常节点，则输出一个逗号 输入： a1-a2,a5-a6,a2-a3 a5,a2 输出：a6,a3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); // 服务器的状态 Map\u0026lt;String, Boolean\u0026gt; resMap = new LinkedHashMap\u0026lt;\u0026gt;(); // 依赖关系 Map\u0026lt;String, String\u0026gt; tempMap = new HashMap\u0026lt;\u0026gt;(); String[] strings = sc.nextLine().split(\u0026#34;,\u0026#34;); for (int i = 0; i \u0026lt; strings.length; i++) { String[] arr = strings[i].split(\u0026#34;-\u0026#34;); resMap.put(arr[0], true); resMap.put(arr[1], true); tempMap.put(arr[0], arr[1]); } String[] arr = sc.nextLine().split(\u0026#34;,\u0026#34;); for (String str : arr) { resMap.put(str, false); } boolean flag = true; while (flag) { int sum = 0; for (String s1 : tempMap.keySet()) { String s2 = tempMap.get(s1); if (!resMap.get(s2) \u0026amp;\u0026amp; resMap.get(s1)) { resMap.put(s1, false); break; } sum++; if (sum == tempMap.size()) { flag = false; } } } String res = resMap.entrySet().stream().filter(Map.Entry::getValue) .map(Map.Entry::getKey).collect(Collectors.joining(\u0026#34;,\u0026#34;)); res = res.isBlank() ? \u0026#34;,\u0026#34; : res; System.out.println(res); } 10. 图像物体的边界\r#\r描述\n给定一个二维数组M行N列，二维数组里的数字代表图片的像素， 为了简化问题，仅包含像素1和5两种像素，每种像素代表一个物体，2个物体相邻的格子为边界，求像素1代表的物体的边界个数。 像素1代表的物体的边界指与像素5相邻的像素1的格子，边界相邻的属于同一个边界， 相邻需要考虑8个方向(上，下，左，右，左上，左下，右上，右下)。 输入描述： 第一行包含两个正整数 M 和 N，表示二维数组的行数和列数。 接下来的 M 行，每行包含 N 个数字，表示二维数组的像素。 输出描述： 输出像素1代表的物体的边界数目。如果没有边界，输出0（例如只存在像素1，或者只存在像素5）。 输入： 6 6 1 1 1 1 1 1 1 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5 1 1 1 1 1 1 1 输出：1 题解\nprivate static int m; private static int n; private static int[] dx = {0, 0, -1, 1, -1, 1, -1, 1}; private static int[] dy = {-1, 1, 0, 0, -1, 1, 1, -1}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); m = sc.nextInt(); n = sc.nextInt(); int[][] grid = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { grid[i][j] = sc.nextInt(); } } sc.close(); // 标记边界 int[][] border = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == 5) { for (int k = 0; k \u0026lt; 8; k++) { int newI = i + dx[k]; int newJ = j + dy[k]; if (0 \u0026lt;= newI \u0026amp;\u0026amp; newI \u0026lt; m \u0026amp;\u0026amp; 0 \u0026lt;= newJ \u0026amp;\u0026amp; newJ \u0026lt; n \u0026amp;\u0026amp; grid[newI][newJ] == 1) { border[newI][newJ] = 1; } } } } } // 计算边界数量 int count = 0; boolean[][] visited = new boolean[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (border[i][j] == 1 \u0026amp;\u0026amp; !visited[i][j]) { count++; dfs(i, j, border, visited); } } } System.out.println(count); } public static void dfs(int x, int y, int[][] border, boolean[][] visited) { if (x \u0026lt; 0 || x \u0026gt;= n || y \u0026lt; 0 || y \u0026gt;= m || border[x][y] == 0 || visited[x][y]) { return; } visited[x][y] = true; for (int i = 0; i \u0026lt; 8; i++) { dfs(x + dx[i], y + dy[i], border, visited); } } 11. 跳格子游戏\r#\r描述\n小明和朋友们一起玩跳格子游戏，每个格子上有特定的分数 score = [1, -1, -6, 7, -17, 7]， 从起点score[0]开始，每次最大的步长为k，请你返回小明跳到终点 score[n-1] 时，能得到的最大得分。 输入描述： 第一行输入总的格子数量 n 第二行输入每个格子的分数 score[i] 第三行输入最大跳的步长 k 输出描述： 输出最大得分 输入：6 1 -1 -6 7 -17 7 2 输出：14 说明：输出最大得分数，小明从起点score[0]开始跳，第一次跳score[1],第二次跳到score[3],第三次跳到score[5]， 因此得到的最大的得分是score[0] + score[1] + score[3] + score[5] = 14 题解\n// 动态规划： // 创建一个数组 dp，其中 dp[i] 表示跳到 score[i] 时能得到的最大得分。 // 状态转移方程：dp[i] = max(dp[i-1],dp[i-2],...,dp[i-k]) + score[i]; // // 单调队列优化： // 使用双向队列从尾部添加dp[i]的下标i，添加之前判断队列尾部的下标last对应的元素dp[last]是否比dp[i]小 // dp[last]比dp[i]小，则将dp[last]取出丢弃。因为在dp[i]前面的比dp[i]还小的值不会被后面使用到，后面要的是最大值。 // 这样队列里保存的下标对应的dp元素是单调递减的。较小的元素直接淘汰，无需多次排序。 public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); int[] arr = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int k = Integer.parseInt(sc.nextLine()); sc.close(); int[] dp = new int[arr.length]; // 使用一个双端队列来维护单调递减的索引 Deque\u0026lt;Integer\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; arr.length; i++) { // 移除队列中超出步长限制的索引 if (!deque.isEmpty() \u0026amp;\u0026amp; i - deque.peekFirst() \u0026gt; k) { deque.pollFirst(); } // 更新当前位置的最大得分 dp[i] = (deque.isEmpty() ? 0 : dp[deque.peekFirst()]) + arr[i]; // 保持单调递减性质，比当前dp[i]还小的dp[i-x]已经没有用了，要取也是取当前dp[i]或前面更大的值 while (!deque.isEmpty() \u0026amp;\u0026amp; dp[i] \u0026gt;= dp[deque.peekLast()]) { // 队列中无用的索引移除 deque.pollLast(); } // 将当前索引加入队列 deque.offerLast(i); // 对于dp数组 8 5 4 3 7 0 0，假如步长k=4，arr[4]=-1 // i=4时队列里存的dp的索引index为 0 1 2 3，其对应的dp元素是递减的 // 计算dp[4] = 8 + arr[4] = 7 // 此时，dp数组中dp[1] dp[2] dp[3]都比dp[4] 小，将队列中的对应index移除 // 最后添加当前索引i=4到队列末尾，此时队列中的index对应的dp元素还是递减的 } System.out.println(dp[dp.length-1]); } 12. 最小叶子节点\r#\r描述\n二叉树也可以用数组来存储，给定一个数组，树的根节点的值储存在下标1， 对于储存在下标n的节点，他的左子节点和右子节点分别储存在下标 2*n 和 2*n+1，并且我们用-1代表一个节点为空。 给定一个数组存储的二叉树，试求从根节点到最小的叶子节点的路径，路径由节点的值组成。 输入描述： 输入一行为数组的内容，数组的每个元素都是正整数，元素间用空格分割。 注意第一个元素即为根节点的值，即数组的第n元素对应下标 n。下标0在树的表示中没有使用，所以我们省略了。 输入的树最多为7层。 输出描述： 输出从根节点到最小叶子节点的路径上各个节点的值由空格分割 用例保证最小叶子节点只有一个 输入：3 5 7 -1 -1 2 4 输出：3 7 2 输入：5 9 8 -1 -1 7 -1 -1 -1 -1 -1 6 输出：5 8 7 6 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); String[] arr = (\u0026#34;0 \u0026#34; + str).split(\u0026#34; \u0026#34;); // 获取最小叶子节点的位置 int minPos = 0; int min = Integer.MAX_VALUE; for (int i = 2; i \u0026lt; arr.length; i++) { int tmp = Integer.parseInt(arr[i]); if (tmp != 0 \u0026amp;\u0026amp; tmp != -1 \u0026amp;\u0026amp; tmp \u0026lt; min \u0026amp;\u0026amp; i * 2 \u0026gt; arr.length) { min = tmp; minPos = i; } } // 向上回溯 List\u0026lt;String\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); back(arr, minPos, path); Collections.reverse(path); System.out.println(String.join(\u0026#34; \u0026#34;, path)); } private static void back(String[] split, int minPos, List\u0026lt;String\u0026gt; path) { path.add(split[minPos]); if (minPos == 1) { return; } if (minPos % 2 == 0) { back(split, minPos / 2, path); } else { back(split, (minPos - 1) / 2, path); } } 13. 考古学家\r#\r描述\n有一个考古学家发现一个石碑，但是很可惜发现时其已经断成多段。 有N个断口整齐的石碑碎片，为了破解石碑内容，考古学家希望有程序能帮忙计算复原后的石碑文字组合数 输入描述： 第一行输入N，N表示石碑碎片的个数 第二行依次输入石碑碎片上的文字内容S共有N组 输出描述： 输出石碑文字的组合(按照升序排列)，行尾无多余空格 输入：3 a b ab 输出：aabb abab abba baab baba 题解\nprivate static int num; private static int len; private static String[] arr; public static void main(String[] args) { Scanner sc = new Scanner(System.in); num = Integer.parseInt(sc.nextLine()); String line = sc.nextLine(); len = line.replaceAll(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;).length(); arr = line.split(\u0026#34; \u0026#34;); Arrays.sort(arr); boolean[] used = new boolean[num]; TreeSet\u0026lt;String\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); dfs(used, \u0026#34;\u0026#34;, set); set.forEach(System.out::println); } public static void dfs(boolean[] used, String path, TreeSet\u0026lt;String\u0026gt; set) { if (path.length() == len) { set.add(path); return; } // 记录上一次访问的索引 int lastIndex = -1; for (int i = 0; i \u0026lt; num; i++) { if (used[i] || i == lastIndex) { continue; } used[i] = true; dfs(used, path + arr[i], set); used[i] = false; // 更新上一次访问的索引 lastIndex = i; } } 14. 解压报文\r#\r描述\n为了提升数据传输的效率，会对传输的报文进行压缩处理。输入一个压缩后的报文，请返回它解压后的原始报文。 压缩规则：n[str]，表示方括号内部的 str 正好重复 n 次。 注意 n 为正整数（0 ＜ n ≤ 100），str只包含小写英文字母，不考虑异常情况。 输入压缩后的报文： 1）不考虑无效的输入，报文没有额外的空格，方括号总是符合格式要求的； 2）原始报文不包含数字，所有的数字只表示重复的次数 n,例如不会出现像 5b 或 3[8] 的输入； 输出描述: 解压后的原始报文 输入：3[k]2[mn] 输出：kkkmnmn 输入：3[m2[c]] 输出：mccmccmcc 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chars = sc.nextLine().toCharArray(); Stack\u0026lt;Object\u0026gt; stack1 = new Stack\u0026lt;\u0026gt;(); Stack\u0026lt;Object\u0026gt; stack2 = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; chars.length; i++) { //如果是数字，需要判断接下来的字符是不是数字，如果是，要进行拼接 if (chars[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; chars[i] \u0026lt;= \u0026#39;9\u0026#39;) { StringBuilder temp = new StringBuilder(\u0026#34;\u0026#34; + chars[i]); for (int j = i + 1; j \u0026lt; chars.length; j++) { if (chars[j] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; chars[j] \u0026lt;= \u0026#39;9\u0026#39;) { temp.append(chars[j]); } else { i = j - 1; stack1.add(Integer.parseInt(temp.toString())); break; } } } else if (chars[i] != \u0026#39;]\u0026#39;) { stack1.add(chars[i]); } else { //遇到]，形成闭环，将 [ ] 之间的字符拼串，然后按 [ 前方的数字拼接 while (!stack1.peek().equals(\u0026#39;[\u0026#39;)) { stack2.add(stack1.pop()); } stack1.pop(); int nums = Integer.parseInt(\u0026#34;\u0026#34; + stack1.pop()); StringBuilder temp = new StringBuilder(); while (!stack2.isEmpty()) { temp.append(stack2.pop()); } String paste = temp.toString(); while (nums-- \u0026gt; 1) { temp.append(paste); } stack1.push(temp); } } //拼串 StringBuilder result = new StringBuilder(); while (!stack1.isEmpty()) { stack2.push(stack1.pop()); } while (!stack2.isEmpty()) { result.append(stack2.pop()); } System.out.println(result); } 15. 最长的指定瑕疵度的元音子串\r#\r描述\n如果一个字符串的开头和结尾都是元音字母（a、e、i、o、u、A、E、I、O、U），那么它就被称为元音字符串。 元音字符串中非元音字母的数量定义为该字符串的瑕疵度 现在，给定一个字符串和一个目标瑕疵度，请你找出具有指定瑕疵度的最长元音子串，并输出其长度。如果不存在则输出0 注意：字符串中任意连续的字符组成的子序列称为该字符串的子串。 a 和 aa 都是元音字符串，它们的瑕疵度为 0。 aiur 不是元音字符串，因为它的结尾不是元音字母。 abira 是一个元音字符串，它的瑕疵度为2 输入描述： 第一行包含一个整数flaw，表示目标瑕疵度，满足0≤flaw≤65535。 第二行包含一个字符串str，仅由小写字母和大写字母组成，满足1≤str≤65535。 输出描述： 输出一个整数，表示满足条件的最长元音子串的长度。如果不存在满足条件的元音子串，则输出0 输入：1 aabeebuu 输出：5 题解\nprivate static final char[] YAUN = {\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;U\u0026#39;}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); char[] chars = sc.nextLine().toCharArray(); boolean[] arr = new boolean[chars.length]; for (int i = 0; i \u0026lt; chars.length; i++) { arr[i] = isYuan(chars[i]); } int maxLen = 0; for (int i = 0; i \u0026lt; arr.length; i++) { if (!arr[i]) { continue; } int sum = 0; for (int j = i + 1; j \u0026lt; arr.length; j++) { if (arr[j]) { if (sum == num) { maxLen = Math.max(maxLen, j - i + 1); } } else { sum++; } } } System.out.println(maxLen); } private static boolean isYuan(char ch) { for (char c : YAUN) { if (ch == c) { return true; } } return false; } 16. 目录删除\r#\r描述\n某文件系统中有N个目录，每个目录都一个独一无二的ID。 每个目录只有一个父目录，但每个父目录下可以有零个或者多个子目录，目录结构呈树状结构。 假设，根目录的ID为0，且根目录没有父目录，其他所有目录的ID用唯一的正整数表示，并统一编号。 现给定目录ID和其父目录ID的对应父子关系表[子目录ID，父目录ID]，以及一个待删除的目录ID， 请计算并返回一个ID序列，表示因为删除指定目录后剩下的所有目录，返回的ID序列以递增序输出。 注意: 1、被删除的目录或文件编号一定在输入的ID序列中 2、当一个目录删除时，它所有的子目录都会被删除 输入描述： 输入的第一行为父子关系表的长度m; 接下来的行为m个父子关系对; 最后一行为待删除的ID。序列中的元素以空格分割，参见样例。 输出描述： 输出一个序列，表示因为删除指定目录后，剩余的目录ID. 输入：5 8 6 10 8 6 0 20 8 2 6 8 输出：2 6 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); int[][] arr = new int[num][2]; for (int i = 0; i \u0026lt; num; i++) { String[] strings = sc.nextLine().split(\u0026#34; \u0026#34;); arr[i][0] = Integer.parseInt(strings[0]); arr[i][1] = Integer.parseInt(strings[1]); } List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); String[] strings = sc.nextLine().split(\u0026#34; \u0026#34;); for (String str : strings) { list.add(Integer.parseInt(str)); } Map\u0026lt;Integer, Boolean\u0026gt; ansMap = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Integer, Integer\u0026gt; tmpMap = new HashMap\u0026lt;\u0026gt;(); for (int[] subArr : arr) { ansMap.put(subArr[0], true); ansMap.put(subArr[1], true); tmpMap.put(subArr[0], subArr[1]); } for (Integer i : list) { ansMap.put(i, false); } boolean flag = true; while (flag) { int sum = 0; for (Map.Entry\u0026lt;Integer, Integer\u0026gt; entry : tmpMap.entrySet()) { Integer parent = entry.getValue(); Integer sub = entry.getKey(); if (!ansMap.get(parent) \u0026amp;\u0026amp; ansMap.get(sub)) { ansMap.put(sub, false); break; } sum++; if (sum == tmpMap.size()) { flag = false; } } } String ans = ansMap.entrySet().stream() .filter(Map.Entry::getValue).map(Map.Entry::getKey).filter(key -\u0026gt; key != 0) .sorted().map(String::valueOf).collect(Collectors.joining(\u0026#34; \u0026#34;)); System.out.println(ans); } 17. 吃火锅\r#\r描述\n火锅里会在不同时间下很多菜，不同食材要煮不同时间，才能变得刚好合适，你希望吃到最多的刚好合适的菜， 但是你的手速不够快用m代替手速，每次下手捞菜后至少要过m秒，才能再捞（每次只能捞一个） 那么用最合理的策略，最多能吃到多少，刚好合适的菜 输入描述： 第一行两个整数n、m，其中n代表往锅里下菜的个数，m代表手速 接下来有n行，每行有两个数x、y，代表第x秒下的菜过y秒才能变得刚好合适（1 ＜ mn ＜ 1000），（1 ＜ xy ＜ 1000） 输出描述： 输出一个整数代表用最合理的策略，最多能吃到刚好合适的菜的数量 输入：3 2 1 2 2 1 3 2 输出：2 往锅里下的菜的个数3，手速2； 第1秒的时候下入菜品1，2秒后熟了； 第2秒的时候下入菜品2，1秒后熟了； 第3秒的时候下入菜品3，2秒后熟了； 第一种菜品和第二种菜品只能吃到一种，第三种菜品可以吃到； 题解\n// 遍历每一种菜，若当前与上一次捞菜的时间差\u0026gt;=m，则当前可以进行捞菜 public static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int n = Integer.parseInt(split[0]); int m = Integer.parseInt(split[1]); int[] arr = new int[n]; for (int i = 0; i \u0026lt; n; i++) { String[] tmp = sc.nextLine().split(\u0026#34; \u0026#34;); // 每种菜刚好合适的时间点 arr[i] = Integer.parseInt(tmp[0]) + Integer.parseInt(tmp[1]); } Arrays.sort(arr); // 第1个合适的菜 int count = 1; int pre = 0; for (int i = 1; i \u0026lt; arr.length; i++) { if (arr[i] \u0026gt;= arr[pre] + m) { // 当前与上次捞菜的时间差大于等于m，则可以进行捞菜 count++; // 更新本次捞菜时间点 pre = i; } } System.out.println(count); } 18. 服务器广播\r#\r描述\n服务器连接方式包括直接相连，间接连接。 A 和 B 直接连接， B 和 C 直接连接，则 A 和 C 间接连接。直接连接和间接连接都可以发送广播。 给出一个 N * N 数组，代表 N 个服务器， matrix[i][j] == 1 ，则代表 i 和 j 直接连接； 不等于 1 时，代表 i 和 j 不直接连接。 matrix[i][i]== 1 ，即自己和自己直接连接。matrix[i][j]==matrix[j][i] 。 计算初始需要给几台服务器广播，才可以使每个服务器都收到广播。 输入描述：输入为N行，每行有N个数字，为0或1，由空格分隔，构成N*N的数组，N的范围为 1 ≤ N ≤ 40 输出描述：输出一个数字，为需要广播的服务器的数量 输入：1 0 0 0 1 0 0 0 1 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] str = sc.nextLine().split(\u0026#34; \u0026#34;); int n = str.length; int[][] arr = new int[n][n]; for (int i = 0; i \u0026lt; n; i++) { arr[0][i] = Integer.parseInt(str[i]); } for (int i = 1; i \u0026lt; n; i++) { String[] s = sc.nextLine().split(\u0026#34; \u0026#34;); for (int j = 0; j \u0026lt; n; j++) { arr[i][j] = Integer.parseInt(s[j]); } } int count = 0; List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { if (!list.contains(i)) { dfs(arr, list, i); count++; } } System.out.println(count); } public static void dfs(int[][] arr, List\u0026lt;Integer\u0026gt; list, int index) { list.add(index); for (int i = index + 1; i \u0026lt; arr.length; i++) { if (arr[index][i] == 1 \u0026amp;\u0026amp; !list.contains(i)) { dfs(arr, list, i); } } } 19. 二叉树的广度优先遍历\r#\r描述\n有一棵二叉树，每个节点由一个大写字母标识(最多26个节点）。 现有两组字母，分别表示前序遍历（父节点-\u0026gt;左孩子-\u0026gt;右孩子）和中序遍历（左孩子-\u0026gt;父节点-\u0026gt;右孩子）的结果， 请你输出后序遍历（左孩子-\u0026gt;右孩子-\u0026gt;父节点）的结果。 输入描述： 每个输入文件包含两串字母，各占一行。（每串只包含大写字母） 第一行字母表示前序遍历结果，第二行字母表示中序遍历结果。 输出描述： 输出仅一行，表示后序遍历的结果，结尾换行。 输入：DBACEGF ABCDEFG 输出：ACBFGED 思路：先从先序遍历中找到根节点，然后从中序遍历中找到左子树和右子树，递归，构建二叉树，最后再进行后序遍历。 例如：已知前序遍历是DBACEGF，中序遍历是ABCDEFG，那么由前序遍历先根，可知道D是树的根，再看在中序遍历中D左边是ABC，所以可知道ABC一定在D的左子树上，而EFG在D的右子树上。那么前序遍历为BAC,中序遍历为ABC 题解\npublic static class TreeNode { char val; TreeNode left; TreeNode right; TreeNode(char val) { this.val = val; } } public static void lastOrder(StringBuilder sb, TreeNode node) { if (node == null) { return; } lastOrder(sb, node.left); lastOrder(sb, node.right); sb.append(node.val); } private static TreeNode build(String preOrder, String inOrder) { if (preOrder.isEmpty()) { return null; } char midVal = preOrder.charAt(0); TreeNode root = new TreeNode(midVal); if (preOrder.length() == 1) { return root; } int midIndex = inOrder.indexOf(midVal); String preLeft = preOrder.substring(1, midIndex + 1); String preRight = preOrder.substring(midIndex + 1); String inLeft = inOrder.substring(0, midIndex); String inRight = inOrder.substring(midIndex + 1); root.left = build(preLeft, inLeft); root.right = build(preRight, inRight); return root; } public static void main(String[] args) { Scanner sc = new Scanner(System.in); String preOrder = sc.nextLine(); String inOrder = sc.nextLine(); TreeNode root = build(preOrder, inOrder); StringBuilder sb = new StringBuilder(); lastOrder(sb, root); System.out.println(sb); } 20. 单词搜索\r#\r描述\n给一个字符串和一个二维字符数组，如果该字符串存在于该数组中，则按字符串的字符顺序输出字符串每个字符所在单元格的位置下标字符串，如果找不到返回字符串N。 1.需要按照字符串的字符组成顺序搜索，且搜索到的位置必须是相邻单元格，其中“相邻单元格”是指那些水平相邻或垂直相邻的单元格。 2.同一个单元格内的字母不允许被重复使用。 3.假定在数组中最多只存在一个可能的匹配。 输入描述： 第1行为一个数字N指示二维数组在后续输入所占的行数。 第2行到第N+1行输入为一个二维大写字符数组，每行字符用半角,分割。二维数组的大小为N*N，小于等于 100。 第N+2行为待查找的字符串，由大写字符组成。单词长度K，小于 1000。 输出描述： 输出一个位置下标字符串，拼接格式为：第1个字符行下标+\u0026#34;,\u0026#34;+第1个字符列下标+\u0026#34;,\u0026#34;+第2个字符行下标+\u0026#34;,\u0026#34;+第2个字符列下标...+\u0026#34;,\u0026#34;+第N个字符行下标+\u0026#34;,\u0026#34;+第N个字符列下标示例1 输入：4 A,C,C,F C,D,E,D B,E,S,S F,E,C,A ACCESS 输出：0,0,0,1,0,2,1,2,2,2,2,3 说明：ACCESS分别对应二维数组的[0,0] [0,1] [0,2] [1,2] [2,2] [2,3]下标位置 题解\nprivate static final List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); public static void main(String[] args) { Scanner sc = new Scanner(System.in); int N = Integer.parseInt(sc.nextLine()); char[][] arr = new char[N][N]; for (int i = 0; i \u0026lt; N; i++) { arr[i] = sc.nextLine().replaceAll(\u0026#34;,\u0026#34;, \u0026#34;\u0026#34;).toCharArray(); } String word = sc.nextLine(); sc.close(); if (exist(arr, word)) { for (int i = list.size() - 1; i \u0026gt;= 0; i--) { System.out.print(list.get(i)); if (i != 0) { System.out.print(\u0026#34;,\u0026#34;); } } } else { System.out.println(\u0026#34;N\u0026#34;); } } private static boolean exist(char[][] board, String word) { char[] words = word.toCharArray(); for (int i = 0; i \u0026lt; board.length; i++) { for (int j = 0; j \u0026lt; board[0].length; j++) { if (dfs(board, words, i, j, 0)) { list.add(i + \u0026#34;,\u0026#34; + j); return true; } } } return false; } private static boolean dfs(char[][] arr, char[] word, int i, int j, int k) { if (i \u0026gt;= arr.length || i \u0026lt; 0 || j \u0026gt;= arr[0].length || j \u0026lt; 0 || arr[i][j] != word[k]) { return false; } if (k == word.length - 1) { return true; } int newI = i; int newJ = j; boolean flag = false; if (dfs(arr, word, i + 1, j, k + 1)) { flag = true; newI = i + 1; } if (dfs(arr, word, i - 1, j, k + 1)) { flag = true; newI = i - 1; } if (dfs(arr, word, i, j + 1, k + 1)) { flag = true; newJ = j + 1; } if (dfs(arr, word, i, j - 1, k + 1)) { flag = true; newJ = j - 1; } if (flag) { list.add(newI + \u0026#34;,\u0026#34; + newJ); } return flag; } 21. 最少面试官数\r#\r描述\n某公司组织一场公开招聘活动，假设由于人数和场地的限制，每人每次面试的时长不等，并已经安排给定， 用(S1,E1)、(S2,E2)、(Sj,Ej)...(Si 小于 Ei，均为非负整数)表示每场面试的开始和结束时间。 面试采用一对一的方式，即一名面试官同时只能面试一名应试者， 一名面试官完成一次面试后可以立即进行下一场面试，且每个面试官的面试人次不超过m。 为了支撑招聘活动高效顺利进行，请你计算至少需要多少名面试官。 输入描述： 输入的第一行为面试官的最多面试人次m，第二行为当天总的面试场次n， 接下来的n行为每场面试的起始时间和结束时间，起始时间和结束时间用空格分隔。其中，1 ≤ n, m ≤ 500 输出描述： 输出一个整数，表示至少需要的面试官数量。 输入：2 5 1 2 2 3 3 4 4 5 5 6 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); int n = sc.nextInt(); int[][] arr = new int[n][2]; for (int i = 0; i \u0026lt; n; i++) { arr[i][0] = sc.nextInt(); arr[i][1] = sc.nextInt(); } solution(m, n, arr); } private static void solution(int m, int n, int[][] arr) { Arrays.sort(arr, Comparator.comparing(c1 -\u0026gt; c1[0])); List\u0026lt;int[]\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(new int[]{arr[0][1], 1}); for (int i = 1; i \u0026lt; n; i++) { boolean flag = false; for (int[] p : list) { if (p[0] \u0026lt;= arr[i][0] \u0026amp;\u0026amp; p[1] \u0026lt; m) { p[1]++; p[0] = arr[i][1]; flag = true; break; } } if (!flag) { list.add(new int[]{arr[i][1], 1}); } } System.out.print(list.size()); } 22. 斗地主之顺子\r#\r描述\n在斗地主扑克牌游戏中， 扑克牌由小到大的顺序为：3,4,5,6,7,8,9,10,J,Q,K,A,2，玩家可以出的扑克牌阵型有：单张、对子、顺子、飞机、炸弹等。 其中顺子的出牌规则为：由至少5张由小到大连续递增的扑克牌组成，且不能包含2。 例如：{3,4,5,6,7}{3,4,5,6,7,8,9,10,J,Q,K,A}都是有效的顺子；而{J,Q,K,A,2}{3,4,5,6}{3,4,5,6,8}等都不是顺子。 给定一个包含13张牌的数组，如果有满足出牌规则的顺子，请输出顺子。 如果存在多个顺子，请每行输出一个顺子，且需要按顺子的第一张牌的大小（必须从小到大）依次输出。 如果没有满足出牌规则的顺子，请输出No。 输入描述：13张任意顺序的扑克牌，每张扑克牌数字用空格隔开，每张扑克牌的数字都是合法的，并且不包括大小王： 输出描述：组成的顺子，每张扑克牌数字用空格隔开： 输入：2 9 J 10 3 4 K A 7 Q A 5 6 输出：3 4 5 6 7 9 10 J Q K A 输入：3 3 4 4 5 5 6 6 7 7 8 8 9 输出：3 4 5 6 7 8 3 4 5 6 7 8 9 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] strings = sc.nextLine().split(\u0026#34; \u0026#34;); int[] arr = new int[15]; int index; for (String str : strings) { index = getIndex(str); arr[index]++; } solution(arr); } private static void solution(int[] arr) { List\u0026lt;String\u0026gt; ansList = new ArrayList\u0026lt;\u0026gt;(); for (int left = 3; left \u0026lt;= 10; left++) { if (arr[left] \u0026lt;= 0) { continue; } int right = left + 1; for (; right \u0026lt;= 14; right++) { if (arr[right] \u0026lt;= 0) { break; } } right--; if (right - left \u0026gt;= 4) { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int k = left; k \u0026lt;= right; k++) { arr[k]--; list.add(getString(k)); } ansList.add(String.join(\u0026#34; \u0026#34;, list)); left--; } } ansList.stream().sorted().forEach(System.out::println); } private static int getIndex(String str) { return switch (str) { case \u0026#34;J\u0026#34; -\u0026gt; 11; case \u0026#34;Q\u0026#34; -\u0026gt; 12; case \u0026#34;K\u0026#34; -\u0026gt; 13; case \u0026#34;A\u0026#34; -\u0026gt; 14; default -\u0026gt; Integer.parseInt(str); }; } private static String getString(int index) { return switch (index) { case 11 -\u0026gt; \u0026#34;J\u0026#34;; case 12 -\u0026gt; \u0026#34;Q\u0026#34;; case 13 -\u0026gt; \u0026#34;K\u0026#34;; case 14 -\u0026gt; \u0026#34;A\u0026#34;; default -\u0026gt; String.valueOf(index); }; } "},{"id":102,"href":"/program-design/data-algorithm/","title":"数据算法","section":"程序设计","content":"\r时间复杂度\r#\r是一个关于输入数据量 n 的函数，定量描述了该算法所需的最大运行时间\n记作 T(n)=O(f(n))，表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同\nn：问题规模\nf(n)：是 n 的某个函数\nT(n)：时间频度，算法中语句总的执行次数，是 n 的某个函数\n推导时间复杂度： 1. 复杂度与具体的常系数无关 2. 多项式级的复杂度相加的时候，只保留最高阶项 示例：T(n) = 2n²+7n+6 =\u0026gt; T(n) = 2n²+7n+1 =\u0026gt; T(n) = 2n² =\u0026gt; T(n) = n² =\u0026gt; 记为 O(n²) 常见时间复杂度\r#\rO(1) \u0026lt; O(logn) \u0026lt; O(n) \u0026lt; O(nlogn)\u0026lt; O(n²) \u0026lt; O(n³ ) \u0026lt; O(2ⁿ ) \u0026lt; O(n!) \u0026lt; O(nⁿ ) 常数阶：O(1) int i=1; int j=2; ++i; j++; int m=i+j; 对数阶：O(logn) int i=1; while(i\u0026lt;n){ i=i*2; } 线性阶：O(n) for(int i=1;i\u0026lt;=n;i++){ j=i; j++; } 线性对数阶：O(nlogn) for(int m=1;m\u0026lt;=n;m++){ int i=1; while(i\u0026lt;n){ i=i*2; } } 平方阶：O(n²) for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=n;j++){ total+=j; } } "},{"id":103,"href":"/database/oracle/plsql/data-types/","title":"数据类型","section":"PL/SQL","content":"\r数据类型\r#\r标量类型\r#\r数字型\r#\r精度：prec，所有数字位的个数 刻度：scale，小数点右边的数字位的个数，可以是负数 类型 描述 NUMBER(prec, scale) 整型或浮点型，最大精度 38 位。 PLS_INTEGER 带符号整型，以 32 位表示。 BINARY_INTEGER 带符号整型，以 32 位表示。 BINARY_FLOAT 单精度浮点型 BINARY_DOUBLE 双精度浮点型 1. NUMBER 等价子类型，用于兼容ANSI和IBM： 整型：DEC(prec, scale)、DECIMAL(prec, scale)、INT、INTEGER、SMALLINT 浮点型：NUMERIC(pre, secale)、DOUBLE PRECISION、FLOAT、REAL 2. NUMBER：以十进制进行存储，需转换为二进制后才能进行算术运算 PLS_INTEGER、BINARY_INTEGER：以二进制进行存储，可直接进行算术运算，比NUMBER更有效率 3. PLS_INTEGER：数值溢出时，抛出异常 BINARY_INTEGER：数值溢出时，会指派为 NUMBER 类型 字符型\r#\r类型 描述 CHAR 固定长度字符串，最大大小为32,767字节 VARCHAR2 可变长度字符串，最大大小为32,767字节 1. CHAR、VARCHAR2语法：CHAR[(maxSize [CHAR|BYTE])] CHAR|BYTE：以字符/字节为单位 maxSize:字符长度 2. STRING、VARCHAR：VARCHAR2的等价子类型，用于兼容ANSI和IBM 3. LONG、LONG RAW：仅为了保持向后兼容，可用BLOB代替 4. NCHAR、NVARCHAR2：CHAR、VARCHAR2的Unicode版本，用于多语言环境 5. ROWID：物理行标识符，用来标识普通数据表中的一行信息 UROWID：通用行标识符，可以存储物理、逻辑或外部行标识符 日期型\r#\r类型 描述 DATE 表示日期和时间，精度为秒级别，没有时区信息 TIMESTAMP 表示日期和时间，精度为纳秒级别， 可以选择包含时区信息 INTERVAL 表示时间段，可以选择以年，月，日，秒来表示时间区别 布尔型\r#\rBOOLEAN：TRUE、FALSE、NULL 注意：Oracle 数据库中并不包含布尔类型，故不能用布尔值与数据库交互 LOB类型\r#\r即大对象类型，存储大数据项，如文本，图形图像，视频剪辑和声音波形。 LOB数据类型允许对数据进行高效，随机，分段访问。 类型 描述 大小 BFILE 用于在数据库外的操作系统文件中存储大型二进制对象 取决于系统，但不得超过 4GB。 BLOB 用于在数据库中存储大型二进制对象 8TB 至 128TB CLOB 用于在数据库中存储大字符数据 8TB 至 128TB NCLOB 用于在数据库中存储大块 NCHAR 数据 8TB 至 128TB 引用类型\r#\r类型 描述 %TYPE 定义一个变量类型，其类型与数据表中某个列或某个变量的数据类型相同 %ROWTYPE 定义一个记录类型，其结构与数据表的数据结构相一致 --%TYPE 引用表单个字段类型 DECLARE v_name emp.ename%TYPE; -- 引用表的单个字段类型（单值变量） v_sal emp.sal%TYPE; BEGIN SELECT ename, sal INTO v_name, v_sal FROM emp WHERE empno=7369; DBMS_OUTPUT.put_line(\u0026#39;姓名:\u0026#39; || v_name ||\u0026#39; 工资: \u0026#39; ||v_sal); END; -- %ROWTYPE 引用表的所有字段类型 DECLARE v_emp emp%ROWTYPE; -- 引用整个表的字段类型（表变量） BEGIN SELECT * INTO v_emp -- 插入整行数据（所有字段数据） FROM emp WHERE empno=7369; -- 不能直接打印整个表,只能是单个值的拼接 DBMS_OUTPUT.put_line(\u0026#39;姓名:\u0026#39; || v_emp.ename ||\u0026#39; 工资: \u0026#39; ||v_emp.sal); END; 复合类型\r#\r记录：RECORD\r#\rDECLARE TYPE test_record IS RECORD( userName VARCHAR2(30) NOT NULL := \u0026#39;oracle\u0026#39;, userInfo VARCHAR2(100)); record_book test_record; BEGIN record_book.userName :=\u0026#39;oracle\u0026#39;; record_book.userInfo :=\u0026#39;oracle PL/SQL\u0026#39;; DBMS_OUTPUT.PUT_LINE(record_book.userName||\u0026#39; \u0026#39; ||record_book.userInfo); END; 数组：VARRAY\r#\rDECLARE --定义一个最多容纳5个VARCHAR(20)数据类型成员的VARRAY数据类型 TYPE test_varray_type IS VARRAY(5) OF VARCHAR(20); test_varray test_varray_type; BEGIN --用构造函数语法赋予初值 test_varray := test_varray_type(\u0026#39;北京\u0026#39;, \u0026#39;上海\u0026#39;, \u0026#39;重庆\u0026#39;, \u0026#39;成都\u0026#39;, \u0026#39;杭州\u0026#39;); DBMS_OUTPUT.PUT_LINE(\u0026#39;城市名称：\u0026#39;||test_varray (1)||\u0026#39;、\u0026#39; ||test_varray (2)||\u0026#39;、\u0026#39; ||test_varray (3)||\u0026#39;、\u0026#39; ||test_varray (4)); DBMS_OUTPUT.PUT_LINE(\u0026#39;赋予初值NULL的第5个成员的值：\u0026#39;||test_varray (5)); --用构造函数语法赋予初值后就可以这样对成员赋值 test_varray (5) := \u0026#39;深圳\u0026#39;; DBMS_OUTPUT.PUT_LINE(\u0026#39;第5个成员的值：\u0026#39;||test_varray (5)); END; 表：TABLE\r#\rDECLARE --定义记录表数据类型 TYPE emp_table_type IS TABLE OF employees%ROWTYPE INDEX BY BINARY_INTEGER; v_emp_table EMP_TABLE_TYPE; BEGIN SELECT first_name, hire_date, job_id INTO v_emp_table(1).first_name, v_emp_table(1).hire_date, v_emp_table(1).job_id FROM employees WHERE employee_id = 177; SELECT first_name, hire_date, job_id INTO v_emp_table(2).first_name, v_emp_table(2).hire_date, v_emp_table(2).job_id FROM employees WHERE employee_id = 178; DBMS_OUTPUT.PUT_LINE(\u0026#39;177雇员名称：\u0026#39;||v_emp_table(1).first_name ||\u0026#39; 雇佣日期：\u0026#39;||v_emp_table(1).hire_date ||\u0026#39; 岗位：\u0026#39;||v_emp_table(1).job_id); DBMS_OUTPUT.PUT_LINE(\u0026#39;178雇员名称：\u0026#39;||v_emp_table(2).first_name ||\u0026#39; 雇佣日期：\u0026#39;||v_emp_table(2).hire_date ||\u0026#39; 岗位：\u0026#39;||v_emp_table(2).job_id); END; 自定义子类型\r#\r是在标准类型的基础上进一步约束而创建的新类型 与其基类型有着相同的操作条款，属于基类型指定值的子集 DECLARE SUBTYPE type_userName IS char(20); SUBTYPE type_sex IS char(6); uName type_userName; userSex type_sex; BEGIN uName := \u0026#39;ewang\u0026#39;; userSex := \u0026#39;male\u0026#39;; DBMS_OUTPUT.PUT_LINE(\u0026#39;user name:\u0026#39; || uName || \u0026#39; Sex: \u0026#39; || userSex); END; "},{"id":104,"href":"/database/redis/data-type/","title":"数据类型","section":"Redis","content":"\r数据类型\r#\r字符串：String\r#\r是Redis最基本的数据类型，最大能存储512MB。 是二进制安全的，可以包含任何数据。 应用：计数功能 哈希：Hash\r#\r是一个键值对集合。 是一个string类型的field和value的映射表 应用：存储用户信息。 列表：List\r#\r是简单的字符串列表，按照插入顺序排序。 你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 应用：做简单的消息队列的功能 集合：Set\r#\r是string类型的无序集合，通过HashTable实现 应用：全局去重功能 有序集合：Zset\r#\r是string类型元素的集合，且不允许重复的成员。 其每个元素都会关联一个double类型的分数，Redis通过此分数来排序 应用：排行榜 "},{"id":105,"href":"/program-lang/java/grammar/data-type/","title":"数据类型","section":"基本语法","content":"\r数据类型\r#\r计算机容量单位\r#\r1Byte = 8 bit， 1KB = 1024Byte bit：位，比特，是计算机运算的基础，代表二进制数位，取值范围：0或1 Byte：字节，计算机文件大小的基本计算单位，用于表示计算机中的一个字符 基本数据类型\r#\r数据类型 描述 字节 默认值 取值范围 举例说明 byte 位 1 0 -128 ~ 127 byte b = 10; short 短整数 2 0 -32768 ~ 32767 short s = 10; int 整数 4 0 -2^31 - 2^31-1 int i = 10; long 长整数 8 0l -2^63 - 2^63-1 long l = 10l; float 单精度 4 0.0f -2^31 - 2^31-1 float f = 10.0f; double 双精度 8 0.0d -2^63 - 2^63-1 double d = 10.0d; char 字符 2 空 0 - 2^16-1 char c = \u0026lsquo;c\u0026rsquo;; boolean 布尔值 1 false true、false boolean b = true; 引用数据类型\r#\rJava语言中，除了基本类型其他都为引用类型，如对象、接口、数组 类型转换\r#\r基本规则 不能对boolean类型进行类型转换 不能把对象类型转换成不相关类的对象 在把容量大的类型转换为容量小的类型时，必须使用强制类型转换 转换过程中可能导致溢出或损失精度 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入 自动类型转换 整型、浮点型、字符型可以混合运算。 运算中，不同类型的数据先转化为同一类型，然后进行运算 转换从低级到高级 byte,short,char—\u0026gt; int —\u0026gt; long—\u0026gt; float —\u0026gt; double 强制类型转换 条件：转换的数据类型必须是兼容的 格式：(type)value 隐藏强制类型转换 整数的默认类型是 int 浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上 F 或者 f。 "},{"id":106,"href":"/database/mysql/mysql-command/table/","title":"数据表管理","section":"基础命令","content":"\r数据表管理\r#\r创建\r#\r# 创建表 create table 表名(列名 列类型 [长度],...) [engine = 存储引擎] [charset = 字符集] [collate = 校对集]; # 复制表结构 create table 新表名 like [数据库名.]表名; -- 示例 CREATE TABLE IF NOT EXISTS `runoob_tbl`( `runoob_id` INT UNSIGNED AUTO_INCREMENT, `runoob_title` VARCHAR(100) NOT NULL, `runoob_author` VARCHAR(40) NOT NULL, `submission_date` DATE, PRIMARY KEY ( `runoob_id` ) )ENGINE=InnoDB DEFAULT CHARSET=utf8; 查询\r#\rshow create table 表名; show columns from 表名; describe 表名; desc 表名; show tables [like \u0026#39;...\u0026#39;]; 修改\r#\r# 改表名 rename table 旧表名 to 新表名; # 改属性 alter table 表名 [engine=存储引擎]/[charset=字符集]/[collate=校对集]; # 删除列 alter table 表名 drop 列名; # 修改列 alter table 表名 add 列名 列类型 [列属性] [first]/[after 字段名]; # 添加列 alter table 表名 modify 列名 列类型 [列属性] [first]/[after 字段名]; # 改列类型 alter table 表名 change 旧列名 新列名 列类型 [列属性] [first]/[after 字段名]; # 改列名 删除\r#\rdrop table 表名; truncate 表名; delete from 表名; 区别 drop truncate delete 速度 快 中 慢 空间 释放全部空间 恢复到初始大小 不释放空间 表结构 删除 不删 不删 类型 DDL DDL DML 事务 不支持 不支持 支持 trigger 不触发 不触发 触发 生效时机 执行立即生效 执行立即生效 事务提交后生效 "},{"id":107,"href":"/program-base/linux/cmd/flie-view/","title":"文件查看","section":"常用命令","content":"\r文件查看\r#\rgrep - 文本搜索工具\nsed - 流编辑器，用于过滤和转换文本\nawk - 强大的文本分析工具\nvi / vim - 文本编辑器\n"},{"id":108,"href":"/program-lang/web/html/text/","title":"文本标签","section":"HTML","content":"\r文本标签\r#\r标签 说明 \u0026lt;b\u0026gt; 定义粗体文本（无语义） \u0026lt;i\u0026gt; 定义斜体文本（无语义） \u0026lt;u\u0026gt; 定义下划线文本（无语义） \u0026lt;s\u0026gt; 定义删除线文本（无语义） \u0026lt;del\u0026gt; 定义被删除文本（有语义） \u0026lt;ins\u0026gt; 定义被插入文本（有语义） \u0026lt;em\u0026gt; 定义强调文本（有语义） \u0026lt;strong\u0026gt; 定义强调文本（有语义，语气更为强烈） \u0026lt;sup\u0026gt; 定义上标文本 \u0026lt;sub\u0026gt; 定义下标文本 \u0026lt;big\u0026gt; 定义大号字 \u0026lt;small\u0026gt; 定义小号字 \u0026lt;code\u0026gt; 定义计算机代码 \u0026lt;pre\u0026gt; 定义预格式文本 排版标签\r#\r标签 说明 \u0026lt;h1\u0026gt;\u0026hellip;\u0026hellip;\u0026lt;h6\u0026gt; 定义 HTML 标题 \u0026lt;p\u0026gt; 定义一个段落 \u0026lt;br\u0026gt; 定义换行 \u0026lt;hr\u0026gt; 定义水平线 \u0026lt;div\u0026gt; 定义文档中的块 \u0026lt;span\u0026gt; 定义文档中的块 "},{"id":109,"href":"/program-lang/web/css/style/text/","title":"文本样式","section":"CSS 样式","content":"\r文本样式\r#\r属性\r属性说明\r属性值\r属性值说明\rtext-align\r水平对齐\u0026nbsp;\n仅对块级元素有效\rleft\r左对齐\rcenter\r居中\rright\r右对齐\rjustify\r两端对齐\rvertical-align\r垂直对齐\rbaseline\r默认\rsub\r下标\rsuper\r上标\rtop\r最顶端对齐\rtext-top\r顶端对齐\rmiddle\r中部对齐\rbottom\r最底端对齐\rtext-bottom\r底端对齐\rsize\r数值\rline-height\r文本行高\rsize\r数值\rword-spacing\r单词间距\rsize\r数值\rletter-spacing\r字符间距\rsize\r数值\rtext-indent\r首行缩进\rsize\r数值\rtext-transform\r文本大小写\rnone\r默认\rcapitalize\r单词大写字母开头\ruppercase\r字母都大写\rlowercase\r字母都小写\rtext-decoration\r修饰文本\rnone\r默认\runderline\r划线，文本底部\roverline\r划线，文本顶部\rline-through\r划线，穿过文本\r文字基线\r#\r"},{"id":110,"href":"/program-lang/java/library/java.util.stream/method-reference/","title":"方法引用","section":"java.util.stream","content":"\r方法引用\r#\r方法引用\r#\r通过方法的名字来指向一个方法 使用一对冒号 :: 进行引用 引用方式\r#\rpublic class Test { public static void main(String[] args) { // 构造器引用 // Class::new或Class\u0026lt; T \u0026gt;::new final Car car = Car.create(Car::new); final List\u0026lt;Car\u0026gt; cars = Collections.singletonList(car); // 静态方法引用 // Class::static_method cars.forEach(Car::collide); // 特定类的任意对象的方法引用 // Class::method cars.forEach(Car::repair); // 特定对象的方法引用 // instance::method final Car police = Car.create(Car::new); cars.forEach(police::follow); } } @FunctionalInterface public interface Supplier\u0026lt;T\u0026gt; { T get(); } public class Car { public static Car create(final Supplier\u0026lt;Car\u0026gt; supplier) { return supplier.get(); } public static void collide(final Car car) { System.out.println(\u0026#34;Collided \u0026#34; + car.toString()); } public void follow(final Car another) { System.out.println(\u0026#34;Following the \u0026#34; + another.toString()); } public void repair() { System.out.println(\u0026#34;Repaired \u0026#34; + this.toString()); } } "},{"id":111,"href":"/program-base/network/http/status/","title":"状态码","section":"HTTP","content":"\rHTTP 状态码\r#\r状态码\r#\rHTTP Status Code 由三位数字代码组成，用于表示HTTP请求的处理结果和状态 状态码分类\r#\r状态码 含义 描述 1xx 消息响应 服务器收到请求，需要请求者继续执行操作 2xx 成功响应 操作被成功接收并处理 3xx 重定向 需要进一步的操作以完成请求 4xx 客户端错误 请求包含语法错误或无法完成请求 5xx 服务器错误 服务器在处理请求的过程中发生了错误 常见状态码\r#\r消息响应\n100 Continue 继续 101 Switching Protocol 切换协议 成功响应\n200 OK 成功 201 Created 已创建 202 Accepted 已创建 203 Non-Authoritative Information 未授权信息 204 No Content 无内容 205 Reset Content 重置内容 206 Partial Content 部分内容 重定向\n300 Multiple Choice 多种选择 301 Moved Permanently 永久移动 302 Found 临时移动 303 See Other 查看其他位置 304 Not Modified 未修改 305 Use Proxy 使用代理 306 unused 未使用 307 Temporary Redirect 临时重定向 308 Permanent Redirect 永久重定向 客户端错误\n400 Bad Request 错误请求 401 Unauthorized 未授权 402 Payment Required 需要付款 403 Forbidden 禁止访问 404 Not Found 未找到 405 Method Not Allowed 不允许使用该方法 406 Not Acceptable 无法接受 407 Proxy Authentication Required 要求代理身份验证 408 Request Timeout 请求超时 409 Conflict 冲突 410 Gone 已失效 411 Length Required 需要内容长度头 412 Precondition Failed 预处理失败 413 Request Entity Too Large 请求实体过长 414 Request-URI Too Long 请求网址过长 415 Unsupported Media Type 媒体类型不支持 416 Requested Range Not Satisfiable 请求范围不合要求 417 Expectation Failed 预期结果失败 服务器端错误\n500 Internal Server Error 内部服务器错误 501 Implemented 未实现 502 Bad Gateway 网关错误 503 Service Unavailable 服务不可用 504 Gateway Timeout 网关超时 505 HTTP Version Not Supported HTTP 版本不受支持 "},{"id":112,"href":"/database/mysql/advanced-feature/user-auth/","title":"用户权限","section":"高级特性","content":"\r用户权限\r#\r用户管理\r#\r-- 查询用户信息 select * from mysql.user; -- 创建用户 -- @后为主机域，可使用占位符 create user \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;password\u0026#39;; -- 删除用户 drop user \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 修改root用户密码 mysqladmin -u root -h localhost -p password \u0026#34;password\u0026#34; -- root用户修改普通用户密码 set password for \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;=password(\u0026#39;password\u0026#39;); 权限管理\r#\r数据权限：增删改查（select\\update\\delete\\insert） 结构权限：结构操作（create\\drop） 管理权限：权限管理（create user\\grant\\revoke） # 新增 grant 权限列表 on 数据库.表名 to 用户; # 删除 revoke 权限列表 on 数据库.表 from 用户; -- 授予username用户，所有数据库所有表的，增删改查权限 grant select,insert,update,delete on *.* to \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 授予username用户，所有数据库所有表的，所有权限 grant all on *.* to \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 取消username用户，所有库所有表的，插入权限 revoke insert on *.* from \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 刷新权限 flush privileges; "},{"id":113,"href":"/framework/quartz/demo/","title":"示例","section":"Quartz","content":"\r示例\r#\rJob\r#\r@Slf4j @PersistJobDataAfterExecution public class TestJob implements Job { @Override public void execute(JobExecutionContext jobExecutionContext){ System.out.println(\u0026#34;TestJob 执行啦\u0026#34;); } } Scheduler\r#\r@Slf4j public class TestScheduler { public static void main(String[] args) throws Exception { // 获取任务调度的实例 Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); // 定义任务调度实例, 并与TestJob绑定 JobDetail jobDetail = JobBuilder.newJob(TestJob.class) .usingJobData(\u0026#34;executeCount\u0026#34;, 0) .withIdentity(\u0026#34;testJob\u0026#34;, \u0026#34;testJobGroup\u0026#34;) .build(); // 定义触发器, 会马上执行一次, 接着5秒执行一次 Date endTime = new Date(); endTime.setTime(endTime.getTime()+5000); Trigger trigger = TriggerBuilder.newTrigger() .usingJobData(\u0026#34;testInfo\u0026#34;, \u0026#34;trigger数据存放\u0026#34;) .withIdentity(\u0026#34;testTrigger\u0026#34;, \u0026#34;testTriggerGroup\u0026#34;) .startNow() .endAt(endTime) //设置了停止时间 .withSchedule(SimpleScheduleBuilder.repeatSecondlyForever(5)) .build(); // 创建SchedulerListener scheduler.getListenerManager().addSchedulerListener(new MySchedulerListener()); // 使用触发器调度任务的执行 scheduler.scheduleJob(jobDetail, trigger); // 开启任务 scheduler.start(); } } /** OUTPUT: testJobGroup.testJob 添加工作任务 testJob 完成部署 调度器 正在开启时调用 调度器 开启时调用 TestJob 执行啦 触发器被移除 testJob testJobGroup.testJob 删除工作任务 **/ SchedulerListener\r#\rpublic class MySchedulerListener implements SchedulerListener { @Override public void jobScheduled(Trigger trigger) { String jobName = trigger.getJobKey().getName(); System.out.println(jobName + \u0026#34; 完成部署\u0026#34;); } @Override public void jobUnscheduled(TriggerKey triggerKey) { System.out.println(triggerKey + \u0026#34; 完成卸载\u0026#34;); } @Override public void triggerFinalized(Trigger trigger) { System.out.println(\u0026#34;触发器被移除 \u0026#34; + trigger.getJobKey().getName()); } @Override public void triggerPaused(TriggerKey triggerKey) { System.out.println(triggerKey + \u0026#34; 正在被暂停\u0026#34;); } @Override public void triggersPaused(String triggerGroup) { System.out.println(\u0026#34;触发器组 \u0026#34; + triggerGroup + \u0026#34; 正在被暂停\u0026#34;); } @Override public void triggerResumed(TriggerKey triggerKey) { System.out.println(triggerKey + \u0026#34; 正在从暂停中恢复\u0026#34;); } @Override public void triggersResumed(String triggerGroup) { System.out.println(\u0026#34;触发器组 \u0026#34; + triggerGroup + \u0026#34; 正在从暂停中恢复\u0026#34;); } @Override public void jobAdded(JobDetail jobDetail) { System.out.println(jobDetail.getKey() + \u0026#34; 添加工作任务\u0026#34;); } @Override public void jobDeleted(JobKey jobKey) { System.out.println(jobKey + \u0026#34; 删除工作任务\u0026#34;); } @Override public void jobPaused(JobKey jobKey) { System.out.println(jobKey + \u0026#34; 工作任务正在被暂停\u0026#34;); } @Override public void jobsPaused(String jobGroup) { System.out.println(\u0026#34;工作任务组 \u0026#34; + jobGroup + \u0026#34; 正在被暂停\u0026#34;); } @Override public void jobResumed(JobKey jobKey) { System.out.println(jobKey + \u0026#34; 正在从暂停中恢复\u0026#34;); } @Override public void jobsResumed(String jobGroup) { System.out.println(\u0026#34;工作任务组 \u0026#34; + jobGroup + \u0026#34; 正在从暂停中恢复\u0026#34;); } @Override public void schedulerError(String msg, SchedulerException cause) { System.out.println(\u0026#34;产生严重错误时调用： \u0026#34; + msg + \u0026#34; \u0026#34; + cause.getUnderlyingException()); } @Override public void schedulerInStandbyMode() { System.out.println(\u0026#34;调度器在挂起模式下调用\u0026#34;); } @Override public void schedulerStarted() { System.out.println(\u0026#34;调度器 开启时调用\u0026#34;); } @Override public void schedulerStarting() { System.out.println(\u0026#34;调度器 正在开启时调用\u0026#34;); } @Override public void schedulerShutdown() { System.out.println(\u0026#34;调度器 已经被关闭 时调用\u0026#34;); } @Override public void schedulerShuttingdown() { System.out.println(\u0026#34;调度器 正在被关闭 时调用\u0026#34;); } @Override public void schedulingDataCleared() { System.out.println(\u0026#34;调度器的数据被清除时调用\u0026#34;); } } "},{"id":114,"href":"/database/oracle/system-table/","title":"系统表","section":"Oracle","content":"\r系统表\r#\r系统表前缀\r#\r前缀 说明 USER_ 记录用户对象的信息 ALL_ 记录用户对象的信息及被授权访问的对象信息 DBA_ 记录数据库实例的所有对象的信息 V$ 当前实例的动态视图 常用查询\r#\r-- 常用表\r#\rdba_ all_ user_ 对象 dba_objects all_objects user_objects 视图 dba_views all_views user_views 表 dba_tables all_tables user_tables 列 dba_tab_columns all_tab_columns user_tab_columns 序列 dba_sequences all_sequences user_sequences 同义词 dba_synonyms all_synonyms user_synonyms 索引 dba_indexs all_indexs user_indexs 列索引 dba_ind_columns all_ind_columns user_ind_columns 约束 dba_constraints all_constraints user_constrainst 列约束 dba_cons_columns all_cons_columns user_cons_columns dual -- 伪表 dba_users -- 用户 dba_roles -- 角色 dba_tablespaces -- 表空间 dba_data_files -- 数据文件 dba_trigers -- 触发器 user_source -- 对象资源 user_procedures -- 存储过程 附录：dba_\r#\rdba_users 数据库用户信息 dba_segments 表段信息 dba_extents 数据区信息 dba_objects 数据库对象信息 dba_tablespaces 数据库表空间信息 dba_data_files 数据文件设置信息 dba_temp_files 临时数据文件信息 dba_rollback_segs 回滚段信息 dba_ts_quotas 用户表空间配额信息 dba_free_space 数据库空闲空间信息 dba_profiles 数据库用户资源限制信息 dba_sys_privs 用户的系统权限信息 dba_tab_privs 用户具有的对象权限信息 dba_col_privs 用户具有的列对象权限信息 dba_role_privs 用户具有的角色信息 dba_audit_trail 审计跟踪记录信息 dba_stmt_audit_opts 审计设置信息 dba_audit_object 对象审计结果信息 dba_audit_session 会话审计结果信息 dba_indexes 用户模式的索引信息 附录：all_\r#\rall_users 数据库所有用户的信息 all_objects 数据库所有的对象的信息 all_def_audit_opts 所有默认的审计设置信息 all_tables 所有的表对象信息 all_indexes 所有的数据库对象索引的信息 附录：user_\r#\ruser_objects 用户对象信息 user_source 用户的所有资源对象信息 user_segments 用户的表段信息 user_tables 用户的表对象信息 user_tab_columns 用户的表列信息 user_constraints 用户的对象约束信息 user_sys_privs 当前用户的系统权限信息 user_tab_privs 当前用户的对象权限信息 user_col_privs 当前用户的表列权限信息 user_role_privs 当前用户的角色权限信息 user_indexes 用户的索引信息 user_ind_columns 用户的索引对应的表列信息 user_cons_columns 用户的约束对应的表列信息 user_clusters 用户的所有簇信息 user_clu_columns 用户的簇所包含的内容信息 user_cluster_hash_expressions 散列簇的信息 user_jobs 用户定时任务信息表 附录：v$\r#\rv$database 数据库信息 v$datafile 数据文件信息 v$controlfile 控制文件信息 v$logfile 重做日志信息 v$instance 数据库实例信息 v$log 日志组信息 v$loghist 日志历史信息 v$sga 数据库SGA信息 v$parameter 初始化参数信息 v$process 数据库服务器进程信息 v$bgprocess 数据库后台进程信息 v$controlfile_record_section 控制文件记载的各部分信息 v$thread 线程信息 v$datafile_header 数据文件头所记载的信息 v$archived_log 归档日志信息 v$archive_dest 归档日志的设置信息 v$logmnr_contents 归档日志分析的DML DDL结果信息 v$logmnr_dictionary 日志分析的字典文件信息 v$logmnr_logs 日志分析的日志列表信息 v$tablespace 表空间信息 v$tempfile 临时文件信息 v$filestat 数据文件的I/O统计信息 v$undostat Undo 数据信息 v$rollname 在线回滚段信息 v$session 会话信息 v$transaction 事务信息 v$rollstat 回滚段统计信息 v$pwfile_users 特权用户信息 v$sqlarea 当前查询过的sql语句访问过的资源及相关的信息 v$sql 与v$sqlarea基本相同的相关信息 v$sysstat 数据库系统状态信息 附录：其他\r#\rsession_roles 会话的角色信息 session_privs 会话的权限信息 index_stats 索引的设置和存储信息 "},{"id":115,"href":"/database/mysql/mysql-tuning/index-tuning/","title":"索引优化","section":"性能调优","content":"\r索引优化\r#\r建立合适的索引\r#\r索引应建立在区分度高、数据量小的字段上 对数字的索引效率要优于字符串 下列情况，应建立索引 外键 经常作为查询条件的字段 经常与其他表进行连接的字段 经常需要排序、分组和联合操作的字段 执行频率高（几千次/每天）的语句 数据量大（超过300万）的表 控制索引的数量\r#\r删除不再使用或者很少使用的索引 频繁进行数据更新操作的表，不要建立太多的索引 充分利用索引查询，避免全表扫描\r#\r全表扫描：读取表所有数据，检查每一行是否满足给定条件的过程。 导致索引失效的情况 使用 null 、not、\u0026lt;\u0026gt;、!=、参数、内置函数 or 拼接非索引字段 like 前模糊匹配，形如‘%abc’ 对索引字段进行操作运算 不符合复合索引的最左前缀匹配原则 查询的数量是大表的大部分（30％以上） 列与列进行比较 数据类型转换，包括显式与隐式 尽量使用前缀来索引 "},{"id":116,"href":"/program-lang/java/thread/threadpool/threadpool-type/","title":"线程池 - 种类","section":"线程池","content":"\r常见线程池\r#\r四种线程池\r#\rnewSingleThreadExecutor\r#\r创建一个单线程化的线程池 它只会用唯一的工作线程来执行任务，保证所有任务都按照指定顺序执行 public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;())); } newFixedThreadPool\r#\r创建一个指定工作线程数量的线程池 可控制线程的最大并发数，超出的线程会在队列中等待。 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;()); } newCachedThreadPool\r#\r创建一个可缓存线程池 如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则创建新线程 public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue\u0026lt;Runnable\u0026gt;()); } newScheduledThreadPool\r#\r创建一个可定期或者延时执行任务的定长线程池，支持定时及周期性任务执行 public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize); } public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue()); } 注意事项\r#\r阿里规约中，禁止使用 Executors 创建线程池。因为有可能导致OOM 方法 弊端 newFixedThreadPoolnewSingleThreadExecutor 主要问题是堆积的请求处理队列可能会耗费非常大的内存甚至OOM newCachedThreadPoolnewScheduledThreadPool 主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建非常多的线程甚至OOM "},{"id":117,"href":"/program-design/design-pattern/structural/","title":"结构型","section":"设计模式","content":" 常用 不常用 结构型 代理、桥接、装饰、适配器 门面、组合、享元 "},{"id":118,"href":"/database/mysql/grammar/operator-attribute/","title":"运算符、列属性","section":"基本语法","content":"\r运算符\r#\r算术运算符\r#\r运算符 描述 + 加法 - 减法 * 乘法 /、DIV 除法 %、MOD 取余 逻辑运算符\r#\r运算符 描述 NOT、! 逻辑非 AND 逻辑与 OR 逻辑或 XOR 逻辑异或 位运算符\r#\r运算符 描述 \u0026amp; 按位与 | 按位或 ^ 按位异或 ! 取反 \u0026lt;\u0026lt;、\u0026gt;\u0026gt; 左移、右移 比较运算符\r#\r运算符 描述 运算符 描述 = 等于 [NOT] BETWEEN 【不】在两值之间 \u0026lt;\u0026gt;、!= 不等于 [NOT] IN 【不】在集合中 \u0026lt;、\u0026gt; 小于、大于 IS [NOT] NULL 【不】为空 \u0026lt;=、\u0026gt;= 小于等于、大于等于 LIKE 模糊匹配，%代表多个字符、_代表单个字符 \u0026lt;=\u0026gt; 含NULL值的比较 RLIK、EREGEXP 正则式匹配 语句结束符\r#\rMysql一旦见到语句结束符，就会开始执行。所以定义函数时，需要修改语句结束符，控制执行时机 语句结束符 描述 ; 默认结束符，列名显示在上边，值显示在下边 \\g 效果与分号一样 \\G 列名显示在左边，值显示在右边 列属性\r#\rnull、notnull\r#\r数据列是否允许NULL值。 在设计表的时候，尽量不要让数据为空。 default\r#\r默认值。 如果没有数据插入，以默认值进行填充，通常是null。 comment\r#\r列的注释说明。 unsigned\r#\r数值型数据，无符号 zerofill\r#\r当存储的数值型数据未达到显示长度时，在左侧补0，适用于正数数值 auto_increment\r#\r自动递增，适用于整数类型\n-- 查询自动递增变量 show variables like \u0026#39;auto_increment%\u0026#39;; -- 修改步长 alter table tableName auto_increment= 2; primary key\r#\r主键，在一张表中，有且只有一个主键。\n不能为空，且具有唯一性。\n-- 修改 alter table tableName add primary key(fieldName); -- 删除 alter table tableName drop primary key; foreign key\r#\r外键，表示两表间的关系。 一般不设外键，影响数据库效率，外键关系一般由业务来实现。 unique\r#\r唯一键，在不为空的情况下，不允许重复。\n-- 修改 alter table tableName add unique key(fieldName); -- 删除 alter table tableName drop index keyName; "},{"id":119,"href":"/service-manage/zookeeper/elect-leader/","title":"选举机制","section":"Zookeeper","content":"\r选举机制\r#\r选举\r#\r在 Zookeeper工作时，有一个节点为 Leader，其他则为 Follower，而 Leader 是通过内部的选举机制临时产生的 节点状态：领导者（LEADING）、竞选者（LOOKING）、跟随者（FOLLOWING）、观察者（OBSERVER） 触发选举时机：集群首次启动、集群在工作时Leader宕机 投票信息：myid（服务器id）、ZXID （事务id）、逻辑时钟、节点状态 选举原则\r#\rZookeeper 集群中只有超过半数以上的服务器启动，集群才能正常工作；\n在集群正常工作之前，myid 小的服务器给 myid 大的服务器投票，直到集群正常工作，选出 Leader；\n选出Leader之后，之前的服务器状态由 Looking 改变为 Following，以后的服务器都是 Follower。\n选举过程\r#\r假设：有五台服务器，从 id1-5 依序启动 服务器1启动，发起一次选举： 服务器1投自己一票。 此时服务器1为1票，不够半数以上（3票），选举无法完成； 服务器1状态保持为LOOKING； 服务器2启动，再发起一次选举： 服务器1和2分别投自己一票，此时服务器1发现服务器2的id比自己大，更改选票投给服务器2； 此时服务器1为0票，服务器2为2票，不够半数以上（3票），选举无法完成； 服务器1、2状态保持LOOKING； 服务器3启动，发起一次选举： 与上面过程一样，服务器1和2先投自己一票，然后因为服务器3id最大，两者更改选票投给为服务器3； 此时服务器1为0票，服务器2为0票，服务器3为3票。服务器3的票数已经超过半数当选Leader。 服务器1，2更改状态为FOLLOWING，服务器3更改状态为LEADING； 服务器4启动，发起一次选举： 此时服务器1、2、3已经不是LOOKING状态，不会更改选票信息。投票结果：服务器3为3票，服务器4为1票。 此时服务器4服从多数，更改选票信息为服务器3； 服务器4并更改状态为FOLLOWING； 服务器5启动，发起一次选举： 同4一样投票给3，此时服务器3一共5票，服务器5为0票； 服务器5并更改状态为FOLLOWING； 最终Leader是服务器3，状态为LEADING；其余服务器是Follower，状态为FOLLOWING。 "},{"id":120,"href":"/program-design/data-algorithm/sort/selection/","title":"选择排序","section":"排序","content":"\r选择排序\r#\r算法步骤\r#\r首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 动图演示\r#\r代码实现\r#\rpublic class SelectionSort implements IArraySort { @Override public int[] sort(int[] arr) throws Exception { // 总共要经过 N-1 轮比较 for (int i = 0; i \u0026lt; arr.length - 1; i++) { int min = i; // 每轮需要比较的次数 N-i for (int j = i + 1; j \u0026lt; arr.length; j++) { if (arr[j] \u0026lt; arr[min]) { // 记录目前能找到的最小值元素的下标 min = j; } } // 将找到的最小值和i位置所在的值进行交换 if (i != min) { int tmp = arr[i]; arr[i] = arr[min]; arr[min] = tmp; } } return arr; } } "},{"id":121,"href":"/program-design/data-structure/linked-list/","title":"链表","section":"数据结构","content":"\r链表\r#\r链表\r#\rLinked List 是一种物理存储单元上非连续、非顺序的存储结构 数据元素的逻辑顺序，是通过链表中的指针链接次序实现的 每个数据元素包含两个部分：存储元素的数据域、指向下一个结点地址的指针域 特点\r#\r查询速度慢 新增、删除速度快 查询元素\r#\r因为数据都是分散存储的，所以只能从第一个数据开始，顺着指针的指向逐一往下查找 新增元素\r#\r顺着指针，查找到位置 新增一个元素 删除元素\r#\r顺着指针，查找到位置 删除一个元素 "},{"id":122,"href":"/framework/spring/ioc/bean-injection/","title":"Bean 注入","section":"IoC","content":"\rBean 注入\r#\r自动装配方式\r#\r方式 描述 no 默认模式，没有自动装配 byName 由属性名自动装配。 byType 由属性数据类型自动装配。 constructor 类似于 byType，但该类型适用于构造函数参数类型。 Autodetect 首先尝试通过 constructor 使用自动装配来连接，如果它不执行，再尝试通过 byType 来自动装配。 Bean 注入\r#\r@Resource、@Autowired 两者功能相同，都可以标注在字段和setter方法 @Autowired\r#\rSpring 提供的注解 默认按 byType 方式进行装配 可配合 @Qualifier，改为按 byName 方式进行装配 @Resource\r#\rJ2EE 提供的注解，Spring 做了支持 默认按 byName 方式进行装配 属性 name 和 type，装配顺序： 如果同时指定了 name 和 type，则寻找唯一匹配的 bean 进行装配 如果指定了 name，则按 byName 方式进行装配 如果指定了 type，按 byType 方式进行装配 如果未指定 name 和 type，则按 byName 方式进行装配 "},{"id":123,"href":"/program-lang/java/thread/container/ConcurrentHashMap/","title":"ConcurrentHashMap","section":"并发容器","content":"\rConcurrentHashMap\r#\rConcurrentHashMap\n"},{"id":124,"href":"/service-manage/deprecated-frame/feign/","title":"Feign","section":"日落组件","content":"\rFeign\r#\rFeign\r#\r服务调用 Feign 集成了 Ribbon，是一个声明式的Web服务客户端 使得编写Web服务客户端变得非常容易，只需要创建一个接口，然后在上面添加注解即可。 "},{"id":125,"href":"/program-lang/java/container/Map/HashTable/","title":"HashTable","section":"Map","content":"\rHashTable\r#\r概述\r#\r是一个哈希表，存储的是键值对 (key-value) 映射。 和 HashMap 很相似，不同的是，HashTable 是线程安全的 特点\r#\r键 不允许为null，不允许重复 值 不允许为null，允许重复 顺序 无序 多线程 线程安全 继承关系\r#\rpublic class Hashtable\u0026lt;K,V\u0026gt; extends Dictionary\u0026lt;K,V\u0026gt; implements Map\u0026lt;K,V\u0026gt;, Cloneable, java.io.Serializable Dictionary、Map接口 提供了键值对的骨干功能 Cloneable接口 支持克隆 Serializable接口 支持序列化 成员变量\r#\r// 保存key-value的数组。 private transient Entry\u0026lt;?,?\u0026gt;[] table; // 元素的个数 private transient int count; // 阈值，用于判断是否需要调整Hashtable的容量（threshold = 容量*加载因子） private int threshold; // 加载因子 private float loadFactor; // Hashtable被改变的次数 private transient int modCount = 0; // 内部类，每一个Entry本质上是一个单向链表 private static class Entry\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { final int hash; final K key; V value; Entry\u0026lt;K,V\u0026gt; next; //... } 构造方法\r#\r// 默认 public Hashtable() { this(11, 0.75f); } // 指定初始容量 public Hashtable(int initialCapacity) { this(initialCapacity, 0.75f); } // 指定初始容量、加载因子 public Hashtable(int initialCapacity, float loadFactor) { //... } // 指定集合，转化为Hashtable public Hashtable(Map\u0026lt;? extends K, ? extends V\u0026gt; t) { this(Math.max(2*t.size(), 11), 0.75f); //... } 扩容机制\r#\r当元素的个数大于阈值时，会进行扩容 扩容的新容量为：旧容量 * 2 + 1 protected void rehash() { int oldCapacity = table.length; Entry\u0026lt;?,?\u0026gt;[] oldMap = table; // 新数组的容量=旧数组长度*2+1 int newCapacity = (oldCapacity \u0026lt;\u0026lt; 1) + 1; // 保证新数组的大小永远小于等于MAX_ARRAY_SIZE if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) { if (oldCapacity == MAX_ARRAY_SIZE) return; newCapacity = MAX_ARRAY_SIZE; } // 创建新数组 Entry\u0026lt;?,?\u0026gt;[] newMap = new Entry\u0026lt;?,?\u0026gt;[newCapacity]; modCount++; // 计算新的临界值 threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1); table = newMap; // 将旧数组中的元素迁移到新数组中 for (int i = oldCapacity ; i-- \u0026gt; 0 ;) { for (Entry\u0026lt;K,V\u0026gt; old = (Entry\u0026lt;K,V\u0026gt;)oldMap[i] ; old != null ; ) { Entry\u0026lt;K,V\u0026gt; e = old; old = old.next; //计算新数组下标 int index = (e.hash \u0026amp; 0x7FFFFFFF) % newCapacity; // 头插法的方式迁移旧数组的元素 e.next = (Entry\u0026lt;K,V\u0026gt;)newMap[index]; newMap[index] = e; } } } "},{"id":126,"href":"/program-base/network/http/","title":"HTTP","section":"网络","content":"\rHTTP 协议\r#\rHyper Text Transfer Protocol，超文本传输协议，是一种网络通信协议 用于将超文本标记语言（HTML）文档从Web服务器传送到本地浏览器 基于客户端/服务端（C/S）模型，将浏览器为客户端，通过URL向服务端发送所有请求 工作过程\r#\r客户与服务器建立连接 客户向服务器提出请求 服务器接受请求，并根据请求返回相应的文件作为应答 客户与服务器关闭连接 其他\r#\rHTTP 的默认端口号为80 HTTP 是无连接的，每次连接只处理一个请求 HTTP 是媒体独立的，可以发送任何类型的数据 HTTP 是无状态的，对于事务处理没有记忆能力 "},{"id":127,"href":"/program-base/network/http/https/","title":"HTTPS","section":"HTTP","content":"\rHTTPS 协议\r#\rHTTPS\r#\rHypertext Transfer Protocol Secure，超文本传输安全协议 是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议 主要作用：数据保密性、数据完整性、身份校验安全性 默认端口：443 工作原理\r#\rHTTPS 优点\r#\r使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； HTTPS 要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 谷歌曾称“比起同等 HTTP 网站，采用 HTTPS 加密的网站在搜索结果中的排名将会更高”。 HTTPS 缺点\r#\rHTTPS 协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电； HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响； SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。 SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。 HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。 "},{"id":128,"href":"/program-lang/java/library/java.time/","title":"java.time","section":"基础类库","content":"\r日期时间\r#\rJava8 Time API\r#\r新增的日期时间类都是不可变的 Instant 时间戳 LocalDateTime 年月日时分秒毫秒 LocalDate 年月日 LocalTime 时分秒毫秒 转换：新旧日期时间\r#\rDate \u0026lt;\u0026mdash;\u0026gt; Instant\n// 新旧日期类，都是通过Instant进行互转 Date now = new Date(); Instant instant = now.toInstant(); Date date = Date.from(instant); Instant \u0026lt;\u0026mdash;\u0026gt; ZonedDateTime、LocalDateTime、LocalDate、LocalTime\nInstant now = Instant.now(); // Instant \u0026lt;=\u0026gt; ZonedDateTime ZonedDateTime zonedDateTime = now.atZone(ZoneId.systemDefault()); Instant instant = zonedDateTime.toInstant(); // Instant \u0026lt;=\u0026gt; LocalDateTime LocalDateTime localDateTime = now.atZone(ZoneId.systemDefault()).toLocalDateTime(); Instant instant = localDateTime.atZone(ZoneId.systemDefault()).toInstant(); // Instant \u0026lt;=\u0026gt; LocalDate LocalDate localDate = now.atZone(ZoneId.systemDefault()).toLocalDate(); Instant instant = localDate.atStartOfDay(ZoneId.systemDefault()).toInstant(); // Instant =\u0026gt; LocalTime LocalTime localTime = now.atZone(ZoneId.systemDefault()).toLocalTime(); LocalDateTime \u0026lt;\u0026mdash;\u0026gt; LocalDate、LocalTime\nLocalDate now = LocalDate.now(); LocalDateTime localDateTime = localDate.atStartOfDay(); LocalDate localDate = localDateTime.toLocalDate(); LocalTime localTime = localDateTime.toLocalTime(); 转换：字符串与日期时间\r#\rString \u0026lt;\u0026mdash;\u0026gt; Date\nSimpleDateFormat format = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); Date date = format.parse(\u0026#34;2022-01-01 01:01:01\u0026#34;); String dateStr dateStr = format.format(date); // 2022-01-01 01:01:01 dateStr = date.toString(); // Sat Jan 01 01:01:01 CST 2022 String \u0026lt;\u0026mdash;\u0026gt; LocalDateTime\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); LocalDateTime localDateTime = LocalDateTime.parse(\u0026#34;2022-01-01 01:01:01\u0026#34;, formatter); String localDateTimeStr; localDateTimeStr = localDateTime.format(formatter); // 2022-01-01 01:01:01 localDateTimeStr = localDateTime.toString(); // 2022-01-01T01:01:01 String \u0026lt;\u0026mdash;\u0026gt; LocalDate\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd\u0026#34;); LocalDate localDate = LocalDate.parse(\u0026#34;2022-01-01\u0026#34;, formatter); String localDateStr; localDateStr = localDate.format(formatter); // 2022-01-01 localDateStr = localDate.toString(); // 2022-01-01 String \u0026lt;\u0026mdash;\u0026gt; LocalTime\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\u0026#34;HH:mm:ss\u0026#34;); LocalTime localTime = LocalTime.parse(\u0026#34;01:01:01\u0026#34;, formatter); String localTimeStr; localTimeStr = localTime.format(formatter); // 01:01:01 localTimeStr = localTime.toString(); // 01:01:01 获取：当前日期时间\r#\r// 2020-03-25T13:18:51.052775200Z System.out.println(Instant.now()); // 2020-03-25T21:18:51.064769800 System.out.println(LocalDateTime.now()); // 2020-03-25 System.out.println(LocalDate.now()); // 21:18:51.064769800 System.out.println(LocalTime.now()); // 2020 System.out.println(Year.now()); // 2020-03 System.out.println(YearMonth.now()); // --03-25 System.out.println(MonthDay.now()); 获取：指定日期时间\r#\r// 2020-03-25T21:44:32 LocalDateTime.of(2020, 3, 25, 21, 44, 32); // 2020-03-25 LocalDate.of(2020, 3, 25); // 21:44:32 LocalTime.of(21, 44, 32); // 2020 Year.of(2020); // 2020-03 YearMonth.of(2020, 3); // --03-25 MonthDay.of(3, 25); // 指定日期时间 LocalDateTime localDateTime = LocalDateTime.of(2020, 3, 25, 21, 44, 32); // 这一天的开始时间 localDateTime.toLocalDate().atStartOfDay(); // 这一天的开始时间 localDateTime.toLocalDate().atTime(LocalTime.MAX); // 30小时后 localDateTime.plusHours(30); // 30分钟后 localDateTime.plusMinutes(30); 间隔：Period\r#\r时间间隔：年数，月数，天数 只能比较LocalDate LocalDate localDate1 = LocalDate.of(2020, 1, 15); LocalDate localDate2 = LocalDate.now(); Period period = Period.between(localDate1, localDate2); // 10 System.out.println(period.getDays()); // 2 System.out.println(period.getMonths()); 间隔：Duration\r#\r时间间隔：秒数，纳秒数 能比较包含了time的类，如LocalDateTime，LocalTime和Instant等 LocalDateTime localDateTime1 = LocalDateTime.of(2020, 1, 15, 8, 21, 12); LocalDateTime localDateTime2 = LocalDateTime.now(); Duration between = Duration.between(localDateTime1, localDateTime2); // 70 System.out.println(between.toDays()); // 1694 System.out.println(between.toHours()); 间隔：ChronoUnit\r#\r表示时间单位 LocalDateTime localDateTime1 = LocalDateTime.of(2020, 1, 15, 8, 21, 12); LocalDateTime localDateTime2 = LocalDateTime.now(); // 0 localDateTime1.until(localDateTime2, ChronoUnit.YEARS); // 2 localDateTime1.until(localDateTime2, ChronoUnit.MONTHS); // 70 localDateTime1.until(localDateTime2, ChronoUnit.DAYS); // 1694 localDateTime1.until(localDateTime2, ChronoUnit.HOURS); // 101678 localDateTime1.until(localDateTime2, ChronoUnit.MINUTES); // 6100682 localDateTime1.until(localDateTime2, ChronoUnit.SECONDS); // 0 ChronoUnit.YEARS.between(localDateTime1, localDateTime2) ...... 比较\r#\rLocalDateTime localDateTime1 = LocalDateTime.of(2020, 3, 25, 6, 44, 32); LocalDateTime localDateTime2 = LocalDateTime.now(); // 是否为同一天 true localDateTime1.toLocalDate().equals(localDateTime2.toLocalDate()); // localDateTime1是否在localDateTime2之前 true localDateTime1.isBefore(localDateTime2); // localDateTime1是否在localDateTime2之后 false localDateTime1.isAfter(localDateTime2); #\r"},{"id":129,"href":"/program-lang/java/container/Set/LinkedHashSet/","title":"LinkedHashSet","section":"Set","content":"\rLinkedHashSet\r#\r概述\r#\rLinkedHashSet 基于 LinkedHashMap 实现，是 HashSet 的一个扩展版本 特点\r#\r顺序 有序 元素 允许为 null，不允许重复 多线程 线程不安全 继承关系\r#\rpublic class LinkedHashSet\u0026lt;E\u0026gt; extends HashSet\u0026lt;E\u0026gt; implements Set\u0026lt;E\u0026gt;, Cloneable, java.io.Serializable HashSet、Set接口 提供了 Set 接口的骨干功能 Cloneable接口 支持克隆 Serializable接口 支持序列化 构造方法\r#\r// 默认 public LinkedHashSet() { super(16, .75f, true); } // 指定初始容量 public LinkedHashSet(int initialCapacity) { super(initialCapacity, .75f, true); } // 指定初始容量、负载因子 public LinkedHashSet(int initialCapacity, float loadFactor) { super(initialCapacity, loadFactor, true); } // 指定集合，转化为LinkedHashSet public LinkedHashSet(Collection\u0026lt;? extends E\u0026gt; c) { super(Math.max(2*c.size(), 11), .75f, true); //... } // 父类HashSet的构造方法 // 使用 LinkedHashMap 的 key 保存元素 HashSet(int initialCapacity, float loadFactor, boolean dummy) { map = new LinkedHashMap\u0026lt;\u0026gt;(initialCapacity, loadFactor); } "},{"id":130,"href":"/program-lang/java/container/List/LinkedList/","title":"LinkedList","section":"List","content":"\rLinkedList\r#\r概述\r#\r是一种双向链表 特点\r#\r顺序 有序 元素 允许为 null，允许重复 效率 查询慢，增删快 多线程 线程不安全 继承关系\r#\rpublic class LinkedList\u0026lt;E\u0026gt; extends AbstractSequentialList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, Deque\u0026lt;E\u0026gt;, Cloneable, java.io.Serializable AbstractSequentialList、List接口 提供了列表的骨干功能 Deque接口 提供了双端队列的骨干功能 Cloneable接口 支持克隆 Serializable接口 支持序列化 成员变量\r#\r// 元素的个数 transient int size = 0; // 头节点 transient Node\u0026lt;E\u0026gt; first; // 尾节点 transient Node\u0026lt;E\u0026gt; last; // 节点（内部类） private static class Node\u0026lt;E\u0026gt; { E item; Node\u0026lt;E\u0026gt; next; Node\u0026lt;E\u0026gt; prev; Node(Node\u0026lt;E\u0026gt; prev, E element, Node\u0026lt;E\u0026gt; next) { this.item = element; this.next = next; this.prev = prev; } } 构造方法\r#\r// 默认 public LinkedList() { } // 指定集合，转化为LinkedList public LinkedList(Collection\u0026lt;? extends E\u0026gt; c) { //... } "},{"id":131,"href":"/interview/core/03-mysql/","title":"MySQL","section":"重点面试题","content":"\r\u0026ndash; 如何定位慢查询？\r#\r表象：页面加载过慢、接口压测响应时间过长（超过1s） 方案一：开源工具 Arthas、Skywalking 方案二：MySQL自带慢日志 可以在MySQL的系统配置文件中开启慢查询日志，并设置SQL执行时间超过多少就记录到日志文件 \u0026ndash; 如何分析慢 SQL 语句？\r#\r使用 EXPLAIN、DESC 命令来分析 SQL 语句的执行情况 possible_key\t当前sql可能会使用到的索引 key 当前sql实际命中的索引 key_len 索引占用的大小 type\t当前sql的连接的类型 extra\t额外的优化建议 1. 通过key和key_len字段，检查是否命中了索引（索引本身存在是否有失效的情况） 2. 通过type字段，查看sql是否有进一步的优化空间，是否存在全索引扫描或全盘扫描 3. 通过extra字段，判断是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复 \u0026ndash; 什么是索引？\r#\r索引（index）是帮助MySQL高效获取数据的数据结构(有序) 提高数据检索的效率，降低数据库的IO成本（不需要全表扫描） 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗 \u0026ndash; 索引类型\r#\r索引 说明 普通索引 最基本的索引，没有任何限制 唯一索引 索引列的值必须是唯一的，允许有空值 主键索引 索引列的值必须是唯一的，不允许有空值，一张表中只能定义一个主键 全文索引 只能在文本类型CHAR、VARCHAR、TEXT类型字段上创建全文索引 组合索引 由多个列组合创建的索引，用于组合查询优化 \u0026ndash; 索引的底层数据结构是什么？\r#\rMySQL的默认存储引擎InnoDB使用的是B+树作为索引的存储结构。 选择B+树的原因： 1. 节点可以有更多子节点，路径更短； 2. 磁盘读写代价更低，非叶子节点只存储键值和指针，叶子节点存储数据； 3. B+树适合范围查询和扫描，因为叶子节点形成了一个双向链表。 \u0026ndash; B树和B+树的区别？\r#\r1. B树的非叶子节点和叶子节点都存放数据，而B+树的所有数据只出现在叶子节点，这使得B+树在查询时效率更稳定。 2. B+树在进行范围查询时效率更高，因为所有数据都在叶子节点，并且叶子节点之间形成了双向链表。 \u0026ndash; 什么是聚簇索引？非聚簇索引？\r#\r聚簇索引：\t是指数据与索引放在一起，B+树的叶子节点保存了整行数据，通常只有一个聚簇索引，一般是由主键构成。 非聚簇索引：\t是指数据与索引分开存储，B+树的叶子节点保存的是主键值，可以有多个非聚簇索引，通常自定义的索引都是非聚簇索引。 \u0026ndash; 什么是回表查询？\r#\r回表查询：\t是指通过非聚簇索引找到对应的主键值，然后再通过主键值查询聚簇索引中对应的整行数据的过程。 \u0026ndash; 什么是覆盖索引？\r#\r覆盖索引：\t是指在SELECT查询中，返回的列全部能在索引中找到，避免了回表查询，提高了性能。 \u0026ndash; MySQL超大分页怎么处理？\r#\r在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。 可以通过覆盖索引加子查询形式进行优化： 首先查询数据的ID字段进行分页，然后根据ID列表用子查询来过滤只查询这些ID的数据， 因为查询ID时使用的是覆盖索引，所以效率可以提升。 \u0026ndash; 索引创建原则有哪些？\r#\r1. 对于数据量较大，且查询比较频繁的表建立索引。（单表超过10万数据） 2. 选择查询频繁的字段作为索引，如查询条件、排序字段或分组字段。 3. 尽量选择区分度较高的字段作为索引，尽量建立唯一索引。 4. 尽量使用复合索引，覆盖SQL的返回值。 5. 对于长度较长的字段，考虑使用前缀索引。 6. 控制索引数量，因为索引虽然可以提高查询速度，但也会影响插入、更新的速度。 \u0026ndash; 什么情况下索引会失效？\r#\r1. 使用了联合索引，但没有遵循最左前缀法则，会导致索引失效 2. 使用了联合索引，但在中间使用了范围查询，会导致右边的条件索引失效。 3. 在索引字段上进行了运算或类型转换，会导致索引失效 4. 使用了以%开头的Like模糊查询，会导致索引失效 \u0026ndash; SQL的优化？\r#\r表设计优化\n创建表时，我们主要参考《嵩山版》阿里开发手册，选择字段类型时结合字段内容， 比如数值类型选择TINYINT、INT、BIGINT等， 字符串类型选择CHAR、VARCHAR或TEXT。 索引优化\n见条目：索引创建原则有哪些？ SQL语句优化\n1. SELECT语句务必指明字段名称（避免直接使用select * ） 2. SQL语句要避免造成索引失效的写法 3. 聚合查询时使用union all代替union（union会多一次过滤，效率低） 4. 避免在where子句中对字段进行表达式操作 5. 表关联时优先使用inner join，必须使用left/right join时，用作为驱动表 内连接会对两个表进行优化，优先把小表放到外边，把大表放到里边。left join 或 right join，不会重新调整顺序 主从复制，读写分离\n如果数据库的使用场景读的操作比较多的时候，为了避免写的操作所造成的性能影响 可以采用读写分离的架构。 读写分离解决的是，数据库的写入，影响了查询的效率。 分库分表\n\u0026ndash; 什么是事务？事务的特性？\r#\r事务是一个或者多个的数据库操作，要么全部执行成功，要么全部失败回滚 特性 ACID 说明 原子性 Atomicity 事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 一致性 Consistency 事务完成时，必须使所有的数据都保持一致状态 隔离性 Isolation 数据库系统提供的隔离机制，保证事务不受外部并发操作所影响 持久性 Durability 事务一旦提交或回滚，它对数据库中的数据的改变就是永久的 \u0026ndash; 事务并发问题？\r#\r问题 说明 脏读 在一个事务中，读到了另外一个事务还没有提交的“脏数据”。 不可重复读 在一个事务中，多次读取同一数据，由于其他事务的修改导致数据结果不一致 幻读 在一个事务中，读取到了其他事务插入的“幻行” \u0026ndash; 怎么解决事务并发问题？事务的隔离级别？\r#\r解决方案：对事务进行隔离 隔离级别 脏读 不可重复读 幻读 读未提交 Read uncommitted √ √ √ 读已提交 Read committed × √ √ 可重复读（默认级别） Repeatable Read × × √ 串行化 Serializable × × × \u0026ndash; undo log 和 redo log 的区别是什么？\r#\rredo log\t记录的是数据页的物理变化，用于服务宕机后的恢复，保证事务的持久性。 undo log\t记录的是逻辑日志，用于事务回滚时恢复原始数据，保证事务的原子性和一致性。 \u0026ndash; 事务中的隔离性是如何保证的？（你解释一下MVCC？）\r#\r事务的隔离性通过锁和多版本并发控制（MVCC）来保证， MVCC通过维护数据的多个版本来避免读写冲突，底层实现包括： 1. 隐藏字段： trx_id(事务id)，记录每一次操作的事务id，是自增的 roll_pointer(回滚指针)，指向上一个版本的事务版本记录地址 2. undo log： 记录了不同版本的数据，通过roll_pointer指针形成一个版本链表 3. read view： 定义了不同隔离级别下的快照读，决定了事务访问哪个版本的数据。 \u0026ndash; MySQL主从同步原理是什么？\r#\rMySQL主从复制的核心是二进制日志Binlog。步骤如下： 1. 主库在事务提交时，记录数据变更到Binlog。 2. 从库读取主库的Binlog，写入到从库的中继日志Relay Log。 3. 从库重做中继日志中的事件，反映到自己的数据中。 \u0026ndash; 有用过分库分表吗？\r#\r我们采用微服务架构，每个微服务对应一个数据库，是根据业务进行拆分的，这个其实就是垂直拆分。 \u0026ndash; 有使用过水平分库吗？\r#\r使用过。 当时业务发展迅速，某个表数据量超过1000万，单库优化后性能仍然很慢，因此采用了水平分库。 我们首先部署了3台服务器和3个数据库，使用mycat进行数据分片。 旧数据也按照ID取模规则迁移到了各个数据库中，这样各个数据库可以分摊存储和读取压力，解决了性能问题。 \u0026ndash; 数据库三范式？\r#\r第一范式：原子性，字段是最小数据单元 员工表，姓名字段仅包含员工的正式名称，就符合第一范式， 反之包含中文名、英文名、别名等，则意味着姓名字段是再拆分的 第二范式：唯一性，每一行都有唯一标识 员工表，定义工号作为主键 第三范式：独立性，非主键字段完全依赖于主键字段 员工表包含了部门编码，它引用到部门表中的部门编号这个主键，此时符合第三范式 如果在员工表中又包含一个部门名称，则造成了数据的冗余，不符合第三范式 \u0026ndash; 什么是视图？\r#\r是一个虚拟的表，它基于一个或多个数据库表的查询结果而创建，具有和物理表相同的功能。 视图的数据实际上存放在基表中，改变基表的数据会自动反映在其视图中 \u0026ndash; InnoDB、MyISAM\r#\rInnoDB：可靠性高或者要求事务处理的、表更新和查询都相当频繁的场景 MyISAM：做很多count的计算的、插入修改不频繁而查询非常频繁的场景 区别 InnoDB MyISAM 锁级别 行级锁 表级锁 主键 必须有 可以没有 事务、外键、自增列 支持 不支持 . 全文索引 不支持 支持 表的具体行数 不保存 保存 存储空间 占用较多 占用较少 \u0026ndash; delete、truncate、drop\r#\r区别 delete truncate drop 速度 慢 中 快 空间 不释放空间 恢复到初始大小 释放全部空间 表结构 不删 不删 删除 类型 DML DDL DDL 事务 支持 不支持 不支持 trigger 触发 不触发 不触发 生效时机 事务提交后生效 执行立即生效 执行立即生效 "},{"id":132,"href":"/database/oracle/plsql/","title":"PL/SQL","section":"Oracle","content":"\rPL/SQL\r#\rProcedural Language/SQL 是为标准 SQL 语言添加了过程化功能的一门程序设计语言 具有第三代语言特性，第三代程序设计语言是诸如 C、C++、Java 这类语言。 只能在 oracle 数据库中使用 功能特点\r#\r特点 说明 与 SQL 语言整合 PL/SQL 中可以执行 SQL 语句 结构化程序设计 PL/SQL 提供了顺序、分支、循环三种基本控制结构 面向对象开发 PL/SQL 提供了对象类型 模块化开发 PL/SQL 提供了块、子程序、包三种程序单元 显著提高性能 PL/SQL 允许一次性向数据库发送多条 SQL 语句，减小了网络开销 执行环境\r#\r"},{"id":133,"href":"/program-lang/java/thread/lock/ReentrantLock/","title":"ReentrantLock","section":"锁体系","content":"\rReentrantLock\r#\r"},{"id":134,"href":"/program-lang/java/thread/tool/Semaphore/","title":"Semaphore","section":"并发工具","content":"\rSemaphore\r#\r功能\r#\r信号灯 作为一种流量控制手段，用于控制同时访问特定资源的线程数量，保证合理的使用共享资源。 原理\r#\rSemaphore 管理一系列许可（仅维护许可的计数）。 线程通过 acquire() 获取许可。当没有可用的许可的时候，线程阻塞，直到有可用的许可为止。 线程通过 release() 释放许可。 方法\r#\r// 构造方法：设定许可数量 public Semaphore(int permits) // 构造方法：设定许可数量，公平/非公平模式 public Semaphore(int permits, boolean fair) // 获取许可 public void acquire() // 释放许可 public void release() // 获取剩余许可数量 public int drainPermits() 示例\r#\r// 抢车位 public class Test { public static void main(String[] args) { // 模拟3个停车位 Semaphore semaphore = new Semaphore(3); // 模拟6部汽车 for (int i = 1; i \u0026lt;= 6; i++) { new Thread(() -\u0026gt; { try { String thread = Thread.currentThread().getName(); // 抢到资源 semaphore.acquire(); System.out.println(thread + \u0026#34;\\t抢到车位\u0026#34;); sleep(3); System.out.println(thread + \u0026#34;\\t停3秒离开车位\u0026#34;); } catch (InterruptedException e) { e.printStackTrace(); } finally { // 释放资源 semaphore.release(); } }, String.valueOf(i)).start(); } } private static void sleep(long timeout) { try { TimeUnit.SECONDS.sleep(timeout); } catch (InterruptedException e) { e.printStackTrace(); } } } "},{"id":135,"href":"/program-lang/java/container/Set/","title":"Set","section":"集合容器","content":"\r"},{"id":136,"href":"/program-base/linux/shell/","title":"Shell","section":"Linux","content":"\rShell\r#\r是一种命令行解释器，它是用户与操作系统内核之间的接口 提供了一种交互式的方式，使用户可以通过命令来操作计算机，执行各种任务和管理系统资源 "},{"id":137,"href":"/service-manage/springboot/","title":"Spring Boot","section":"服务治理","content":"\rSpring Boot\r#\r是一个用来简化新 Spring 应用的初始搭建以及开发过程的框架 定制 Spring Boot 项目 中文参考文档 核心功能\r#\r可独立运行 Spring 项目 内嵌 servlet 容器 提供 starter 简化 Maven 配置 自动配置 Spring 准生产的应用监控 无代码生成和xml配置 优点\r#\r快速搭建项目 对主流框架无配置集成 项目可独立运行，不依赖 servlet 容器 提供运行时的应用监控 极大提高开发、部署效率 与云计算天然集成 "},{"id":138,"href":"/program-lang/java/thread/theory/volatile/","title":"volatile","section":"并发理论","content":"\rvolatile\r#\r概述\r#\rvolatile：是一种比sychronized关键字更轻量级的同步机制，用来确保将变量的更新操作通知到其他线程。 保证所修饰变量对所有的线程的可见性 禁止指令重排优化 不保证原子性 实现原理\r#\r对于volatile所修饰变量的写操作，在生成汇编代码时，会增加Lock前缀指令 缓存一致性：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期 内存语义\r#\r写volatile变量会重新刷新到主内存中，其他线程读volatile变量，会重新从主内存中读取新值 内存语义的实现\r#\r在生成字节码时，编译器会在指令序列中插入内存屏障，来禁止特定类型的处理器重排序 StoreStore屏障 禁止上面的普通写和下面的volatile写重排序 StoreLoad屏障 防止上面的volatile写与下面可能有的volatile读/写重排序 LoadLoad屏障 禁止下面所有的普通读操作和上面的volatile读重排序 LoadStore屏障 禁止下面所有的普通写操作和上面的volatile读重排序 解决：不保证原子性\r#\r解决办法：使用 synchronized 修饰、使用 AtomicInteger 类型 public class Singleton { //volatile：禁止指令重排 private static volatile Singleton instance = null; private Singleton() { } // 双重检测机制 public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } } "},{"id":139,"href":"/program-lang/web/html/list/","title":"列表标签","section":"HTML","content":"\r列表标签\r#\r标签 说明 \u0026lt;ul\u0026gt; 定义一个无序列表（属性type：disc、square、circle） \u0026lt;ol\u0026gt; 定义一个有序列表（属性type：1、a、A、ⅰ、Ⅰ） \u0026lt;li\u0026gt; 定义一个列表项 \u0026lt;dl\u0026gt; 定义一个定义列表 \u0026lt;dt\u0026gt; 定义一个定义列表项 \u0026lt;dd\u0026gt; 定义一个定义列表项描述 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Coffee\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Milk\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;Coffee\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Milk\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;Coffee\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;Black hot drink\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;Milk\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;White cold drink\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; "},{"id":140,"href":"/program-lang/web/css/style/list/","title":"列表样式","section":"CSS 样式","content":"\r列表样式\r#\r属性\r属性说明\r属性值\r属性值说明\rlist-style\r简写属性\r\u0026nbsp;\r空格分隔各值，不分顺序\rlist-style-image\r列表项标志的图片\rnone\r无图片，默认\rURL\r图片路径\rlist-style-position\r列表项标志的位置\routside\r标记在文本外，文本与文本对齐。默认\rinside\r标记在文本内，文本与标记对齐\rlist-style-type\r列表项标志的类型\rnone\r无标记\rdisc\r实心圆，默认\rcircle\r空心圆\rsquare\r实心方块\rdecimal\r数字\rlower-alpha\r小写英文字母(a、b、c、...)\rupper-alpha\r大写英文字母(A、B、C、...)\rlower-roman\r小写罗马数字(i、ii、iii、...)\rupper-roman\r大写罗马数字(I、II、III、...)\r"},{"id":141,"href":"/framework/springmvc/params-bind/","title":"参数绑定","section":"Spring MVC","content":"\r参数绑定\r#\r默认支持的类型\r#\rHttpServletRequest HttpServletResponse HttpSession Model/ModelMap 简单类型\r#\rrequest入参、处理器方法形参，名称相同，可免注解\nrequest入参、处理器方法形参，名称不同，使用@RequestParam\n// 属性required，否必须传入 // 属性defaultValue，设置默认值 public String editItem(String id, @RequestParam(value = \u0026#34;name\u0026#34;, required = true) String itemName){ //...... } 简单pojo\r#\r前提条件：接收参数的pojo，内部属性为简单类型，且与request入参名称相同\n//pojo类 public class Label{ private String labelId; private String labelName; //... } //处理器类 @Controller @RequestMapping(method=RequestMethod.POST) public class LabelController { @RequestMapping(\u0026#34;/addLabel\u0026#34;) public ActionResult addLabel(Label label) { //... } } 包装类型pojo\r#\r包装类型pojo：指内部属性不止简单类型，还有引用类型\n方式一：通过HttpServletRequest参数，进行接收\n方式二：通过点来绑定，如示例\n//页面参数 \u0026lt;input name=\u0026#34;parent.name\u0026#34; /\u0026gt; //pojo public class Person{ private String id; private String name; //... } public class PersonVo{ private String id; private Person parent; private Person son; //... } //处理器类 @Controller @RequestMapping(method=RequestMethod.POST) public class PersonController { @RequestMapping(\u0026#34;/setPerson\u0026#34;) public ActionResult setPerson(PersonVo vo) { //... } } 数组\r#\r直接传递\n@RequestMapping(\u0026#34;/deleteItems\u0026#34;) public ActionResult deleteItems(Intege[] item_ids) { //... } List、Map\r#\r需要绑定在对象上\n//pojo public class UserForm { private List\u0026lt;User\u0026gt; userList; private Map\u0026lt;String, User\u0026gt; userMap; //... } //处理器类 @Controller @RequestMapping(method=RequestMethod.POST) public class UserController { @RequestMapping(\u0026#34;/userForm\u0026#34;) public ActionResult userForm(UserForm userForm) { //... } } "},{"id":142,"href":"/algorithm/huawei-od/%E5%8F%82%E8%80%83%E9%A2%981/","title":"参考题 - 1","section":"华为OD","content":"\r01. 字符串反转\r#\r描述\n接受一个只包含小写字母的字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000） 输入描述：输入一行，为一个只包含小写字母的字符串。 输出描述：输出该字符串反转后的字符串。 输入：abcd 输出：dcba 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); StringBuilder sb = new StringBuilder(str); sb.reverse(); System.out.println(sb); } 02. 数字颠倒\r#\r描述\n输入一个整数，将这个整数以字符串的形式逆序输出 程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001 数据范围：0≤n≤2^30−1 输入描述：输入一个int整数 输出描述：将这个整数以字符串的形式逆序输出 输入：1516000 输出：0006151 题解\n同01题 03. 表达式求值\r#\r描述\n给定一个字符串描述的算术表达式，计算出结果值。 输入字符串长度不超过 100 ，合法的字符包括 +, -, *, /, (, ),0-9 数据范围：运算过程中和最终结果均满足∣val∣≤2^31 −1 ，即只进行整型运算，确保输入的表达式合法 输入描述：输入算术表达式 输出描述：计算出结果值 输入：400+5 输出：405 题解\npublic static void main(String[] args) throws ScriptException { Scanner sc = new Scanner(System.in); String line = sc.nextLine(); ScriptEngine engine = new ScriptEngineManager().getEngineByName(\u0026#34;js\u0026#34;); System.out.println(engine.eval(line)); } 04. 字符逆序\r#\r描述\n将一个字符串str的内容颠倒过来，并输出。 数据范围：1≤len(str)≤10000 输入描述：输入一个字符串，可以有空格 输出描述：输出逆序的字符串 输入：I am a student 输出：tneduts a ma I 题解\npublic static void main(String[] args){ Scanner sc = new Scanner(System.in); String line = sc.nextLine(); StringBuilder res = new StringBuilder(line); System.out.println(res.reverse()); } 05. 尼科彻斯定力\r#\r描述\n验证尼科彻斯定理，即：任何一个整数m的立方都可以写成m个连续奇数之和。 例如： 1^3=1 2^3=3+5 3^3=7+9+11 4^3=13+15+17+19 输入一个正整数m（m≤100），将m的立方写成m个连续奇数之和的形式输出。 数据范围：1≤m≤100 输入描述：输入一个int整数 输出描述：输出分解后的string 输入：6 输出：31+33+35+37+39+41 题解\n// 由等差数列公式，公差d=2 // 可得a1=m(m-1)+1 public static void main(String[] args){ Scanner sc = new Scanner(System.in); int m = sc.nextInt(); int a1 = m * (m - 1) + 1; StringBuilder sb = new StringBuilder(Integer.toString(a1)); for(int i = 1; i \u0026lt; m; i++){ a1 = a1 + 2; sb.append(\u0026#34;+\u0026#34;); sb.append(a1); } System.out.println(sb); } 06. 公共子串计算\r#\r描述\n给定两个只包含小写字母的字符串，计算两个字符串的最大公共子串的长度。 注：子串的定义指一个字符串删掉其部分前缀和后缀（也可以不删）后形成的字符串。 数据范围：字符串长度：1≤s≤150 输入描述：输入两个只包含小写字母的字符串 输出描述：输出一个整数，代表最大公共子串的长度 输入：asdfas werasdfaswer 输出：6 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chs1 = sc.nextLine().toCharArray(); char[] chs2 = sc.nextLine().toCharArray(); int maxLen = 0; for (int i = 0; i \u0026lt; chs1.length; i++) { for (int j = 0; j \u0026lt; chs2.length; j++) { int t1 = i; int t2 = j; int count = 0; while (chs1[t1] == chs2[t2]) { t1++; t2++; count++; maxLen = Math.max(count, maxLen); if (t1 == chs1.length || t2 == chs2.length) { break; } } } } System.out.println(maxLen); } 07. 求最大连续bit数\r#\r描述\n求一个int类型数字对应的二进制数字中1的最大连续数，例如3的二进制为00000011，最大连续2个1 数据范围：数据组数：1≤t≤5 ，1≤n≤500000 输入描述：输入一个int类型数字 输出描述：输出转成二进制之后连续1的个数 输入：200 输出：2 题解\npublic static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String input = null; while ((input = br.readLine()) != null) { char[] binary = Integer.toBinaryString(Integer.parseInt(input)).toCharArray(); int max = 0; // 最大连续数 int count = 0; // 当前连续数 for (char b : binary) { if (b == \u0026#39;1\u0026#39;) { count++; if (count \u0026gt; max) { max = count; } } else { count = 0; } } System.out.println(max); } } 08. 最长回文子串\r#\r描述\n给定一个仅包含小写字母的字符串，求它的最长回文子串的长度。所谓回文串，指左右对称的字符串。 所谓子串，指一个字符串删掉其部分前缀和后缀（也可以不删）的字符串 数据范围：字符串长度1≤s≤350 输入描述：输入一个仅包含小写字母的字符串 输出描述：返回最长回文子串的长度 输入：cdabbacc 输出：4 说明：abba为最长的回文子串 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String line = sc.nextLine(); int maxLen = 0; for (int i = 0; i \u0026lt; line.length(); i++) { for (int j = i + 1; j \u0026lt;= line.length(); j++) { // 回文字符串 反转后与其自身相等 String sub = line.substring(i, j); String subRev = new StringBuilder(sub).reverse().toString(); if (sub.equals(subRev)) { maxLen = Math.max(maxLen, sub.length()); } } } System.out.println(maxLen); } 09. 等差数列\r#\r描述\n等差数列 2，5，8，11，14。。。。（从 2 开始的 3 为公差的等差数列） 输出求等差数列前n项和 数据范围：1≤n≤1000 输入描述：输入一个正整数n。 输出描述：输出一个相加后的整数。 输入：2 输出：7 说明：2+5=7 输入：275 输出：113575 题解\n// 等差数列求和公式 public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int sum = 2 * n + (n * (n - 1) * 3) / 2; System.out.println(sum); } 10. 密码强度等级\r#\r描述\n密码按如下规则进行计分，并根据不同的得分为密码进行安全等级划分。 一、密码长度: 5 分: 小于等于4 个字符 10 分: 5 到7 字符 25 分: 大于等于8 个字符 二、字母: 0 分: 没有字母 10 分: 密码里的字母全都是小（大）写字母 20 分: 密码里的字母符合”大小写混合“ 三、数字: 0 分: 没有数字 10 分: 1 个数字 20 分: 大于1 个数字 四、符号: 0 分: 没有符号 10 分: 1 个符号 25 分: 大于1 个符号 五、奖励（只能选符合最多的那一种奖励）: 2 分: 字母和数字 3 分: 字母、数字和符号 5 分: 大小写字母、数字和符号 最后的评分标准: \u0026gt;= 90: 非常安全 \u0026gt;= 80: 安全（Secure） \u0026gt;= 70: 非常强 \u0026gt;= 60: 强（Strong） \u0026gt;= 50: 一般（Average） \u0026gt;= 25: 弱（Weak） \u0026gt;= 0: 非常弱（Very_Weak） 对应输出为：VERY_SECURE、SECURE、VERY_STRONG、STRONG、AVERAGE、WEAK、VERY_WEAK 请根据输入的密码字符串，进行安全评定。 注： 字母：a-z, A-Z 数字：0-9 符号包含如下： (ASCII码表可以在UltraEdit的菜单view-\u0026gt;ASCII Table查看) !\u0026#34;#$%\u0026amp;\u0026#39;()*+,-./ (ASCII码：0x21~0x2F) :;\u0026lt;=\u0026gt;?@ (ASCII码：0x3A~0x40) [\\]^_` (ASCII码：0x5B~0x60) {|}~ (ASCII码：0x7B~0x7E) 提示：1≤字符串的长度≤300 输入描述：输入一个string的密码 输出描述：输出密码等级 输入：38$@NoNoN 输出：VERY_SECURE 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chs = sc.nextLine().toCharArray(); int score = 0; //统计长度 int len = chs.length; if (len \u0026lt;= 4) score += 5; else if (len \u0026lt; 8) score += 10; else score += 25; //遍历获取大小写字母、数字、符号数目 int upCount = 0; int lowCount = 0; int numCount = 0; int sigCount = 0; for (char ch : chs) { if (Character.isUpperCase(ch)) ++upCount; else if (Character.isLowerCase(ch)) ++lowCount; else if (Character.isDigit(ch)) ++numCount; else ++sigCount; } //字母分数 if ((upCount \u0026gt; 0 \u0026amp;\u0026amp; lowCount == 0) || (upCount == 0 \u0026amp;\u0026amp; lowCount \u0026gt; 0)) score += 10; else if (upCount \u0026gt; 0 \u0026amp;\u0026amp; lowCount \u0026gt; 0) score += 20; //数字分数 if (numCount == 1) score += 10; else if (numCount \u0026gt; 1) score += 20; //符号分数 if (sigCount == 1) score += 10; else if (sigCount \u0026gt; 1) score += 25; //奖励分数 if (numCount \u0026gt; 0 \u0026amp;\u0026amp; upCount \u0026gt; 0 \u0026amp;\u0026amp; lowCount \u0026gt; 0 \u0026amp;\u0026amp; sigCount \u0026gt; 0) score += 5; else if (numCount \u0026gt; 0 \u0026amp;\u0026amp; sigCount \u0026gt; 0 \u0026amp;\u0026amp; (upCount \u0026gt; 0 || lowCount \u0026gt; 0)) score += 3; else if (numCount \u0026gt; 0 \u0026amp;\u0026amp; (upCount \u0026gt; 0 || lowCount \u0026gt; 0)) score += 2; //评分 if (score \u0026gt;= 90) System.out.println(\u0026#34;VERY_SECURE\u0026#34;); else if (score \u0026gt;= 80) System.out.println(\u0026#34;SECURE\u0026#34;); else if (score \u0026gt;= 70) System.out.println(\u0026#34;VERY_STRONG\u0026#34;); else if (score \u0026gt;= 60) System.out.println(\u0026#34;STRONG\u0026#34;); else if (score \u0026gt;= 50) System.out.println(\u0026#34;AVERAGE\u0026#34;); else if (score \u0026gt;= 25) System.out.println(\u0026#34;WEAK\u0026#34;); else System.out.println(\u0026#34;VERY_WEAK\u0026#34;); } 11. 字符个数统计\r#\r描述\n编写一个函数，计算字符串中含有的不同字符的个数。字符在 ASCII 码范围内( 0~127 ，包括 0 和 127 )，换行表示结束符，不算在字符里。不在范围内的不作统计。多个相同的字符只计算一次 例如，对于字符串 abaca 而言，有 a、b、c 三种不同的字符，因此输出 3 。 数据范围：1≤n≤500 输入描述：输入一行没有空格的字符串。 输出描述：输出 输入字符串 中范围在(0~127，包括0和127)字符的种数。 输入：abc 输出：3 题解\n// 数组下标不重复，且有序 public static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chs = sc.nextLine().toCharArray(); int[] temArr = new int[128]; int count = 0; for (char ch : chs) { if (temArr[ch] == 0) { count++; temArr[ch] = 1; } } System.out.println(count); } 12. 截取字符串\r#\r描述\n输入一个字符串和一个整数 k ，截取字符串的前k个字符并输出 数据范围：字符串长度满足 1≤n≤1000，1≤k≤n 输入描述：1.输入待截取的字符串。2.输入一个正整数k，代表截取的长度 输出描述：截取后的字符串 输入：abABCcDEF 6 输出：abABCc 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); int k = Integer.parseInt(sc.nextLine()); System.out.println(str.substring(0, k)); } 13. 查找组成一个偶数最接近的两个素数\r#\r描述\n任意一个偶数（大于2）都可以由2个素数组成，组成偶数的2个素数有很多种情况，本题目要求输出组成指定偶数的两个素数差值最小的素数对。 数据范围：输入的数据满足 4≤n≤1000 输入描述：输入一个大于2的偶数 输出描述：从小到大输出两个素数 输入：20 输出：7 13 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m1 = n / 2; int m2 = n / 2; while (!isPrime(m1) || !isPrime(m2)) { m1--; m2++; } System.out.println(m1); System.out.println(m2); } public static boolean isPrime(int n) { for (int i = 2; i \u0026lt;= n / 2; i++) { if (n % i == 0) { return false; } } return true; } 14. 统计字符\r#\r描述\n输入一行字符，分别统计出包含英文字母、空格、数字和其它字符的个数。 数据范围：输入的字符串长度满足 1≤n≤1000 输入描述：输入一行字符串，可以有空格 输出描述：统计其中英文字符，空格字符，数字字符，其他字符的个数 输入：1qazxsw23 edcvfr45tgbn hy67uj m,ki89ol.\\\\/;p0-=\\\\][ 输出：26 3 10 12 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); String str1 = str.replaceAll(\u0026#34;[^a-zA-Z]\u0026#34;, \u0026#34;\u0026#34;); String str2 = str.replaceAll(\u0026#34;[^ ]\u0026#34;, \u0026#34;\u0026#34;); String str3 = str.replaceAll(\u0026#34;[^0-9]\u0026#34;, \u0026#34;\u0026#34;); String str4 = str.replaceAll(\u0026#34;[a-zA-Z0-9 ]\u0026#34;, \u0026#34;\u0026#34;); System.out.println(str1.length()); System.out.println(str2.length()); System.out.println(str3.length()); System.out.println(str4.length()); } 15. 字符串排序\r#\r描述\n给定 n 个字符串，请对 n 个字符串按照字典序排列。 数据范围：1≤n≤1000，字符串长度满足 1≤len≤100 输入描述：输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。 输出描述：数据输出n行，输出结果为按照字典序排列的字符串。 输入：5 cap to cat boat boot 输出：boat boot cap cat to 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int sum = Integer.parseInt(sc.nextLine()); String[] arr = new String[sum]; for (int i = 0; i \u0026lt; sum; i++) { arr[i] = sc.nextLine(); } Arrays.sort(arr); Arrays.stream(arr).forEach(System.out::println); } 16. 进制转换\r#\r描述\n写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。 数据范围：保证结果在1≤n≤2^31−1 输入描述：输入一个十六进制的数值字符串。 输出描述：输出该数值的十进制字符串。不同组的测试用例用\\n隔开。 输入：0xAA 输出：170 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine().substring(2); int val = Integer.parseInt(str, 16); System.out.println(val); } 17. 找出字符串中第一个只出现一次的字符\r#\r描述\n找出字符串中第一个只出现一次的字符 数据范围：输入的字符串长度满足1≤n≤1000 输入描述：输入一个非空字符串 输出描述：输出第一个只出现一次的字符，如果不存在输出-1 输入：asdfasdfo 输出：o 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); for (int i = 0; i \u0026lt; str.length(); i++) { char ch = str.charAt(i); if (str.indexOf(ch) == str.lastIndexOf(ch)) { System.out.println(ch); return; } } System.out.println(-1); } 18. 输入n个整数，输出其中最小的K个\r#\r描述\n输入n个整数，找出其中最小的k个整数并按升序输出 本题有多组输入样例 数据范围：1≤n≤1000，输入的整数满足 1≤val≤10000 输入描述：第一行输入两个整数n和k，第二行输入一个整数数组 输出描述：从小到大输出最小的k个整数，用空格分开。 输入：5 2 1 3 5 7 2 输出：1 2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); int k = sc.nextInt(); int[] arr = new int[n]; for (int i = 0; i \u0026lt; n; i++) { arr[i] = sc.nextInt(); } Arrays.sort(arr); StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; k; i++) { sb.append(arr[i]).append(\u0026#34; \u0026#34;); } System.out.println(sb.toString().trim()); } } 19. 字符串字符匹配\r#\r描述\n判断短字符串S中的所有字符是否在长字符串T中全部出现。 请注意本题有多组样例输入。 数据范围：1≤len(S),len(T)≤200 输入描述：输入两个字符串。第一个为短字符串，第二个为长字符串。两个字符串均由小写字母组成。 输出描述：如果短字符串的所有字符均在长字符串中出现过，则输出字符串\u0026#34;true\u0026#34;。否则输出字符串\u0026#34;false\u0026#34;。 输入：bc abc 输出：true 说明：其中abc含有bc，输出\u0026#34;true\u0026#34; 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String shortStr = sc.nextLine(); String longStr = sc.nextLine(); Set\u0026lt;Character\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; shortStr.length(); ++i) { set.add(shortStr.charAt(i)); } for (int i = 0; i \u0026lt; longStr.length(); ++i) { set.remove(longStr.charAt(i)); } System.out.println(set.isEmpty()); } } "},{"id":143,"href":"/program-lang/java/feature/reflection/","title":"反射机制","section":"语言特性","content":"\r反射机制\r#\r概述\r#\r是一种动态获取程序信息以及动态调用对象的功能 是Java被视为动态语言的关键 功用\r#\r在运行时，判断任意一个类所具有的成员变量和方法 在运行时，判断任意一个对象所属的类 在运行时，调用任意一个对象的方法 在运行时，构造任意一个类的对象 在运行时，获取泛型信息 在运行时，处理注解 生成动态代理 反射API\r#\rjava.lang.Class：代表一个类 java.lang.reflect.Field：代表类的成员变量 java.lang.reflect.Method：代表类的方法 java.lang.reflect.Constructor：代表类的构造器 java.lang.reflect.Array：提供了动态创建和访问 Java 数组的方法 java.lang.Class\r#\r获取 Class 实例\n// 1 通过类属性 Class clazz1 = Person.class; // 2 通过实例对象 Person person = new Person(); Class clazz2 = person.getClass(); // 3 通过类名（常用） Class clazz3 = Class.forName(\u0026#34;com.test.Person\u0026#34;); // 4 通过了类加载器（不常用） ClassLoader classLoader = Test.class.getClassLoader(); Class clazz4 = classLoader.loadClass(\u0026#34;com.test.Person\u0026#34;); // 注：每个类对应的Class实例在运行过程中都是唯一的 // 即clazz1、clazz2、clazz3、clazz4是同一个实例 方法摘要\n方法 描述 方法 描述 getConstructor() 获取 Constructor 对象 getClassLoader() 获取类加载器 getConstructors() 获取所有Constructor 对象 getSuperclass() getField() 获取指定 Field 对象 getInterfaces() getFields() 获取所有 Field 对象 getAnnotation() getDeclaredField() 获取指定 Field 对象（包括私有） getAnnotations() getDeclaredFields() 获取所有 Field 对象（包括私有） \u0026hellip; getMethod( 获取指定 Method 对象 getMethods() 获取所有 Method 对象 newInstance() 创建Class对象所代表类的实例 示例\r#\r@Data public class Person { private String name; private Integer age; } public class Test { public static void main(String[] args) throws Exception { Class\u0026lt;?\u0026gt; c = Class.forName(\u0026#34;com.test.Person\u0026#34;); Method[] methods = c.getDeclaredMethods(); Method[] methods2 = c.getMethods(); System.out.println(\u0026#34;本类方法：\u0026#34; + Arrays.toString(methods) + \u0026#34;\\n\u0026#34;); System.out.println(\u0026#34;本类及父类方法：\u0026#34; + Arrays.toString(methods2) + \u0026#34;\\n\u0026#34;); for (Method method : methods) { System.out.println(method.toString()); System.out.println(method.toGenericString() + \u0026#34;\\n\u0026#34;); } Person person = (Person) c.getDeclaredConstructor().newInstance(); Method nameMethod = c.getDeclaredMethod(\u0026#34;setName\u0026#34;, String.class); nameMethod.invoke(person, \u0026#34;瓜田李下\u0026#34;); Method ageMethod = c.getDeclaredMethod(\u0026#34;setAge\u0026#34;, Integer.class); ageMethod.invoke(person, 24); System.out.println(person.toString()); } } "},{"id":144,"href":"/database/mysql/grammar/variable-function/","title":"变量、函数","section":"基本语法","content":"\r变量\r#\r局部变量：仅在结构体语句块中有效 会话变量：在当前用户的当次连接有效 全局变量：全局有效 系统变量\r#\rshow variables [like \u0026#39;...\u0026#39;]; -- 查询多个 select @@varName; -- 查询单个 set varName = value; -- 局部修改（会话级别） set global varName = value; -- 全局修改 set @@global.varName = value; -- 全局修改 -- 示例：修改自动编号步长 SET GLOBAL auto_increment_increment = 1; 会话变量\r#\r-- 设置 set @varName = value; set @varName := value; -- 查看 select @varName; -- 示例 SELECT @name := stu_name,@age := stu_age FROM student WHERE stu_id = \u0026#39;1\u0026#39;; SELECT stu_name,stu_age FROM student WHERE stu_id = \u0026#39;1\u0026#39; INTO @name,@age; 局部变量\r#\r-- 设置 declare varName dataType [attribute]; -- 示例 declare age int default 18; 函数\r#\r内置函数\r#\rMySQL 内置函数 自定义函数\r#\r自定义函数是属于用户级别的，只有当前客户端对应的数据库中可以使用\n函数内部不能使用select指令，因为select一旦执行就会立即返回。（例外情况：select 字段 into @变量;）\n# 定义函数 # 修改语句结束符 create function 函数名(形参) returns 返回值类型 begin 函数体 return 返回值数据; end 语句结束符 复原语句结束符 # 查看函数 show function status [like \u0026#39;...\u0026#39;]; show create function 函数名; # 调用函数 select 函数名(实参列表); # 删除函数 drop function 函数名; -- 示例 DELIMITER $$ CREATE FUNCTION hello() RETURNS VARCHAR(255) BEGIN RETURN \u0026#39;Hello world, mysql\u0026#39;; END $$ DELIMITER ; "},{"id":145,"href":"/program-lang/java/jvm/gc/collect/","title":"回收算法","section":"垃圾回收","content":"\r回收算法\r#\r标记 - 清除（Mark-Sweep）\r#\r原理：\n标记：扫描内存空间，对存活的对象进行标记 清除：扫描内存空间，回收未标记的对象。 缺点：\n两次扫描，效率低 会产生内存碎片 标记 - 整理（Mark-Compact）\r#\r原理：\n标记：扫描内存空间，对存活的对象进行标记 压缩：再次扫描，并整理存活的对象 优缺点：\n没有内存碎片 移动对象需要成本 复制算法（Copying）\r#\r原理：\n从 From 区找到存活的对象，复制到 To 区。 From、To区交互身份，进行下一轮垃圾收集。 优缺点：\n没有标记清除过程，效率高。 没有内存碎片，能进行快速内存分配 可用内存被压缩到了原来的一半，内存利用率较低 分代收集\r#\r原理： 根据对象的生命周期的不同将内存划分为几块，然后根据各块的特点采用最适当的收集算法 对于新生代（大批对象死去、只有少量对象存活），一般使用复制算法 对于老年代（对象存活率高、没有额外空间进行分配担保），一般使用标记-整理算法 分区收集\r#\r原理：将整个堆空间划分为连续的不同小区间，每个小区间独立使用，独立回收。 优点：可以控制一次回收多少个小区间，根据目标停顿时间，每次合理地回收若干个小区间(而不是整个堆)，从而减少一次GC所产生的停顿。 "},{"id":146,"href":"/program-lang/java/jvm/gc/","title":"垃圾回收","section":"虚拟机","content":"\rGC\r#\rGarbage Collections 垃圾收集，释放无用对象所占内存空间 作用：可以有效的防止内存泄露，有效的使用空闲的内存 优点：提高编程效率、保护程序的完整性 缺点：影响程序性能 "},{"id":147,"href":"/dev-tool/git/command/","title":"基本命令","section":"Git","content":"\r基本命令\r#\r基本操作\r#\r创建仓库\r#\rgit init\r#\r# 初始化本地库 # git init [dir] $ git init git clone\r#\r# 从现有库中拷贝项目 # git clone \u0026lt;repository\u0026gt; \u0026lt;dir\u0026gt; $ git clone git://github.com/schacon/grit.git myDir 变更修改\r#\rgit add\r#\r# 添加文件/文件夹到暂存区 # git add [file1] [file2] ... $ git add README hello.php # 格式：git add [dir] $ git add . git rm\r#\r# 删除工作区和暂存区的文件 # git rm \u0026lt;file\u0026gt; $ git rm runoob.txt # 选项：-f 强制删除 $ git rm -f runoob.txt # 选项：--cached 仅从暂存区域移除，仍保留在工作区中 $ git rm --cached runoob.txt # 选项：-r 递归删除 $ git rm –r * git mv\r#\r# 移动或重命名一个文件 # git mv [file] [newfile] $ git mv test.log test.txt # 选项：-f 强制 $ git mv -f README README.md git commit\r#\r# 提交暂存区到本地仓库 # git commit -m [message] $ git commit -m \u0026#39;第一次版本提交\u0026#39; # 选项：-m 提交时添加注释信息 # 选项：-a 提交跟踪过的文件 $ git commit -am \u0026#39;第一次版本提交\u0026#39; # 选项：--amend 追加提交（修改最近一次的提交） $ git commit --amend 回退版本\r#\rgit reset\r#\r# 格式：git reset [--soft | --mixed | --hard] [HEAD] # 选项：--soft 在本地库移动 HEAD 指针 # 选项：--mixed 在本地库移动 HEAD 指针、重置暂存区 # 选项：--hard 在本地库移动 HEAD 指针、重置暂存区、重置工作区 $ git reset HEAD^ # 回退所有内容到上一个版本 $ git reset HEAD^ hello.php # 回退 hello.php 文件的版本到上一个版本 $ git reset 052e # 回退到指定版本 # 后退 n 个版本 $ git reset --hard HEAD^^ # n 为 ^ 的个数 $ git reset --hard HEAD~2 # n 为 ~ 后的数字 远程操作\r#\rgit remote\r#\r# 查看远程库 $ git remote -v # 显示所有 $ git remote show [remote] # 显示某个 # 新增远程库 # git remote add [库别名] [远程地址] $ git remote add origin https://github.com/ArdaData/xxx.git # 删除远程库 # git remote add [库别名] [远程地址] $ git remote add origin https://github.com/ArdaData/xxx.git git fetch、git merge\r#\r# 拉取远程代码 # git fetch [库别名] [分支名] $ git fetch origin # 合并到工作区 # git merge [库别名 / 分支名] $ git merge origin/master git pull\r#\r# 拉取远程代码并合并 # git pull \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt; $ git pull origin master # 合并到当前分支 $ git pull origin master:brantest # 合并到brantest分支 git push\r#\r# 推送到远程并合并 # git push \u0026lt;远程主机名\u0026gt; \u0026lt;本地分支名\u0026gt;:\u0026lt;远程分支名\u0026gt; $ git push origin master # 合并到master分支 $ git push origin master:brantest # 合并到brantest分支 # 选项：--force 强制推送 $ git push --force origin master 分支操作\r#\rgit branch\r#\r# 查看分支 $ git branch -v # 创建分支 $ git branch mybranch # 删除分支 $ git branch -d mybranch git checkout\r#\r# 切换分支 $ git checkout mybranch # 创建并切换分支 $ git checkout -b mybranch git merge\r#\r# 合并分支 $ git merge mybranch 查看操作\r#\r查看差异\r#\rgit status\r#\r# 查看仓库当前的状态，显示有变更的文件 $ git status # 选项：-s 精简显示 $ git status -s git diff\r#\r# 对比暂存区和工作区的差异 $ git diff [file] # 对比暂存区和最后一次提交(HEAD)的差异 $ git diff --cached [file] # 对比工作区/暂存区和最后一次提交(HEAD)的差异（~X: 表示前第X个版本） $ git diff HEAD $ git diff HEAD~X # 比较两个分支上最后提交的内容的差别 $ git diff \u0026lt;分支名1\u0026gt; \u0026lt;分支名2\u0026gt; # 选项：--stat 精简显示 $ git diff --stat 查看日志\r#\rgit log\r#\r# 查看历史提交记录 $ git log # 选项：--oneline 精简显示 $ git log --oneline # 选项：--reverse 逆向显示 $ git log --reverse git blame\r#\r# 查看指定文件的提交记录 # git blame \u0026lt;file\u0026gt; $ git blame README.txt 查看命令\r#\rgit help\r#\r# 在网页中，查看帮助文档 $ git help \u0026lt;command\u0026gt; $ git \u0026lt;command\u0026gt; --help "},{"id":148,"href":"/database/mysql/advanced-feature/store-procedure/","title":"存储过程","section":"高级特性","content":"\r存储过程\r#\r定义\r#\rstored procedure，是一组为了完成特定功能的SQL 语句集，存储在数据库中， 经过第一次编译后再次调用不需要再次编译（效率比较高） 存储过程管理\r#\r# 创建 修改语句结束符 create procedure 过程名字([参数列表]) begin 过程体 end 语句结束符 修改语句结束符（改回来） # 查询 show procedure status [like \u0026#39;...\u0026#39;]; show create procedure 过程名; # 使用 call 过程名([实参列表]); # 删除 drop procedure 过程名; -- 示例 DELIMITER $$ CREATE PROCEDURE proc_countUser() BEGIN SELECT COUNT(*) FROM t_user; END $$ DELIMITER ; 存储过程的形参类型\r#\rIN：参数从外部传入，供过程内部使用。默认类型 OUT：参数从过程内部传出，供外部使用。 INOUT：参数从外部传入，过程内部使用后，又传出，供外部使用。 DELIMITER $$ CREATE PROCEDURE set_counter(INOUT count INT(4),IN inc INT(4)) BEGIN SET count = count + inc; END $$ DELIMITER ; 存储过程 vs 函数\r#\r区别 存储过程 函数 标识符 PROCEDURE FUNCTION 返回值 无 有 使用 不能在select语句中使用 可以在select语句中使用 "},{"id":149,"href":"/program-lang/java/thread/thread/thread-daemon/","title":"守护线程","section":"线程基础","content":"\r守护线程\r#\r概述\r#\r在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 守护线程的作用是为其他线程的运行提供便利服务 守护线程最典型的应用就是 GC (垃圾回收器) 创建守护线程\r#\r不能把正在运行的常规线程设置为守护线程，必须在线程启动前设置为守护线程，否则会抛异常。 在Daemon线程中产生的新线程也是Daemon的。 不要认为所有的应用都可以分配给Daemon来进行服务，比如读写操作或者计算逻辑。 Thread daemonTread = new Thread(); // 设定 daemonThread 为 守护线程，default false(非守护线程) daemonThread.setDaemon(true); // 验证当前线程是否为守护线程，返回 true 则为守护线程 daemonThread.isDaemon(); 为什么要用守护线程？\r#\r在JVM实例中，如果存在任何一个未结束的非守护线程，守护线程就全部工作 当非守护线程全部结束后，则JVM 进程即会退出，守护线程会随着JVM一同结束工作 守护线程拥有自动结束自己生命周期的特性，而非守护线程不具备这个特点 "},{"id":150,"href":"/program-lang/web/css/position/position/","title":"定位","section":"CSS 位置","content":"\r定位\r#\r属性\r属性说明\r属性值\r属性值说明\rposition\r定位\rstatic\r没有定位，默认值\rfixed\r绝对定位，相对于浏览器窗口，脱离标准流\rabsolute\r绝对定位，相对于父元素，脱离标准流\rrelative\r相对定位，相对于自身正常位置\rinherit\r继承\rz-index\r层级\rauto\r与父元素相等，默认\rnumber\r层级数值\rinherit\r继承\rtop\u0026nbsp;\nbottom\u0026nbsp;\nleft\u0026nbsp;\nright\r上下左右\rauto\r浏览器计算，默认\rsize\r数值\rinherit\r继承\r"},{"id":151,"href":"/database/mysql/mysql-tuning/engine-tuning/","title":"引擎优化","section":"性能调优","content":"\r引擎优化\r#\rInnoDB\r#\r禁用唯一性检查\n-- 唯一性校验会降低插入记录的速度， -- 可以在插入记录之前禁用唯一性检查，插入数据完成后再开启 -- 禁用唯一性检查 SET UNIQUE_CHECKS = 0; -- 开启唯一性检查 SET UNIQUE_CHECKS = 1; 禁用外键检查\n-- 插入数据之前执行禁止对外键的检查，数据插入完成后再恢复，可以提高插入速度。 -- 禁用外键检查 SET foreign_key_checks = 0; -- 开启外键检查 SET foreign_key_checks = 1; 禁止自动提交\n-- 插入数据之前执行禁止事务的自动提交，数据插入完成后再恢复，可以提高插入速度。 -- 禁用自动提交 SET autocommit = 0; -- 开启自动提交 SET autocommit = 1; MyISAM\r#\r禁用索引\n-- 插入大量数据，建立索引会降低插入数据速度。 -- 可以在批量插入数据之前禁用索引，数据插入完成后再开启 -- 禁用索引 ALTER TABLE table_name DISABLE KEYS -- 开启索引 ALTER TABLE table_name ENABLE KEYS 批量插入数据\n-- 一次性插入多条数据较快 -- 插入单条数据 insert into 表名 values(列值, ....); -- 插入多条数据 insert into 表名 values(列值, ....),(列值, ....),...; 禁用唯一性检查（同InnoDB）\n使用LOAD DATA INFILE\n当需要批量导入数据时，使用LOAD DATA INFILE语句比INSERT语句插入速度快很多。 "},{"id":152,"href":"/database/oracle/plsql/control-sentence/","title":"控制语句","section":"PL/SQL","content":"\r控制语句\r#\r分支语句\r#\rIF-THEN\r#\r-- 语法 IF condition THEN statements; END IF; -- 示例 DECLARE a NUMBER(2) := 10; BEGIN IF a \u0026lt; 20 THEN DBMS_OUTPUT.put_line(\u0026#39;a is less than 20 \u0026#39; ); END IF; END; IF-THEN-ELSE\r#\r-- 语法 IF condition THEN statements1; ELSE statements2; END IF; -- 示例 DECLARE a NUMBER(3) := 100; BEGIN IF a \u0026lt; 20 THEN DBMS_OUTPUT.put_line(\u0026#39;a is less than 20 \u0026#39; ); ELSE DBMS_OUTPUT.put_line(\u0026#39;a is not less than 20 \u0026#39; ); END IF; END; IF-THEN-ELSIF\r#\r-- 语法 IF condition1 THEN statements1; ELSIF condition2 THEN statements2; ELSE statements3; END IF; -- 示例 DECLARE a NUMBER(3) := 100; BEGIN IF a = 10 THEN DBMS_OUTPUT.put_line(\u0026#39;Value of a is 10\u0026#39; ); ELSIF a = 20 THEN DBMS_OUTPUT.put_line(\u0026#39;Value of a is 20\u0026#39; ); ELSIF a = 30 THEN DBMS_OUTPUT.put_line(\u0026#39;Value of a is 30\u0026#39; ); ELSE DBMS_OUTPUT.put_line(\u0026#39;None of the values is matching\u0026#39;); END IF; END; CASE（检测式）\r#\r-- 语法 CASE selector WHEN value1 THEN statements1; WHEN value2 THEN statements2; WHEN value3 THEN statements3; ... ELSE statementsN; -- default case END CASE; -- 示例 DECLARE grade char(1) := \u0026#39;A\u0026#39;; BEGIN CASE grade WHEN \u0026#39;A\u0026#39; THEN DBMS_OUTPUT.put_line(\u0026#39;Excellent\u0026#39;); WHEN \u0026#39;B\u0026#39; THEN DBMS_OUTPUT.put_line(\u0026#39;Very good\u0026#39;); WHEN \u0026#39;C\u0026#39; THEN DBMS_OUTPUT.put_line(\u0026#39;Well done\u0026#39;); WHEN \u0026#39;D\u0026#39; THEN DBMS_OUTPUT.put_line(\u0026#39;You passed\u0026#39;); WHEN \u0026#39;F\u0026#39; THEN DBMS_OUTPUT.put_line(\u0026#39;Better try again\u0026#39;); ELSE DBMS_OUTPUT.put_line(\u0026#39;No such grade\u0026#39;); END CASE; END; CASE（搜索式）\r#\r选择器隐式被设为 True -- 语法 CASE [True | False] WHEN condition1 THEN statements1; WHEN condition2 THEN statements2; WHEN condition3 THEN statements3; ... ELSE statementsN; -- default case END CASE; -- 示例 DECLARE grade char(1) := \u0026#39;B\u0026#39;; BEGIN CASE WHEN grade = \u0026#39;A\u0026#39; THEN DBMS_OUTPUT.put_line(\u0026#39;Excellent\u0026#39;); WHEN grade = \u0026#39;B\u0026#39; THEN DBMS_OUTPUT.put_line(\u0026#39;Very good\u0026#39;); WHEN grade = \u0026#39;C\u0026#39; THEN DBMS_OUTPUT.put_line(\u0026#39;Well done\u0026#39;); WHEN grade = \u0026#39;D\u0026#39; THEN DBMS_OUTPUT.put_line(\u0026#39;You passed\u0026#39;); WHEN grade = \u0026#39;F\u0026#39; THEN DBMS_OUTPUT.put_line(\u0026#39;Better try again\u0026#39;); ELSE DBMS_OUTPUT.put_line(\u0026#39;No such grade\u0026#39;); END CASE; END; 循环语句\r#\rLOOP\r#\rEXIT 、EXIT WHEN 强制退出循环 CONTINUE、CONTINUE WHEN 退出本次循环，进入下次循环 -- 语法 LOOP statements; END LOOP; -- 示例 DECLARE x NUMBER := 10; BEGIN LOOP DBMS_OUTPUT.put_line(x); x := x + 10; IF x \u0026gt; 50 THEN EXIT; -- EXIT WHEN x \u0026gt; 50; END IF; END LOOP; END; WHILE LOOP\r#\r-- 语法 WHILE condition LOOP statements; END LOOP; -- 示例 DECLARE a NUMBER(2) := 10; BEGIN WHILE a \u0026lt; 20 LOOP DBMS_OUTPUT.put_line(\u0026#39;value of a: \u0026#39; || a); a := a + 1; END LOOP; END; FOR LOOP\r#\r-- 语法 FOR counter IN begin_value .. final_value LOOP statements; END LOOP; -- 示例 DECLARE a NUMBER(2); BEGIN FOR a IN 10 .. 20 LOOP DBMS_OUTPUT.put_line(\u0026#39;value of a: \u0026#39; || a); END LOOP; END; 其他语句\r#\rGOTO\r#\r无条件跳转语句，配合标签使用 不建议使用 -- 示例 DECLARE a NUMBER(2) := 10; BEGIN \u0026lt;\u0026lt;loopstart\u0026gt;\u0026gt; WHILE a \u0026lt; 20 LOOP DBMS_OUTPUT.put_line (\u0026#39;value of a: \u0026#39; || a); a := a + 1; IF a = 15 THEN a := a + 1; GOTO loopstart; END IF; END LOOP; END; NULL\r#\r表示不做任何操作 "},{"id":153,"href":"/program-design/data-algorithm/sort/insertion/","title":"插入排序","section":"排序","content":"\r插入排序\r#\r算法步骤\r#\r将第一个元素看做一个有序序列，把其余元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。 类似扑克牌 动图演示\r#\r代码实现\r#\rpublic class InsertSort implements IArraySort { @Override public int[] sort(int[] arr) throws Exception { // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的 for (int i = 1; i \u0026lt; arr.length; i++) { // 记录要插入的数据 int tmp = arr[i]; // 从已经排序的序列最右边的开始比较，找到比其小的数 int j = i; while (j \u0026gt; 0 \u0026amp;\u0026amp; tmp \u0026lt; arr[j - 1]) { arr[j] = arr[j - 1]; j--; } // 存在比其小的数，插入 if (j != i) { arr[j] = tmp; } } return arr; } } "},{"id":154,"href":"/database/mysql/mysql-command/line/","title":"数据行管理","section":"基础命令","content":"\r数据行管理\r#\r插入\r#\r# 省略部分列名：列名与列值必须相对应 insert into 表名(列名, ...) values(列值, ...); # 省略全部列名：需提供表所有列的值 insert into 表名 values(列值, ....); -- 示例 INSERT INTO table_name ( field1,field2,...,fieldN )VALUES( value1,value2,...,valueN ); 删除\r#\rdelete from 表名 [where 条件]; -- 示例 DELETE FROM table_name WHERE field1 = value1; 修改\r#\rupdate 表名 set 列名=值, ... [where 条件]; -- 示例 UPDATE table_name a SET a.field1= value1, a.field2= value2, ... , a.fieldN= valueN WHERE field1 = value1; 查询\r#\rselect [*]/[列名，...] from 表名 [where 条件]; -- 示例 SELECT field1, field2, ..., fieldN FROM table_name WHERE field1 = value1; "},{"id":155,"href":"/program-design/data-structure/stack/","title":"栈","section":"数据结构","content":"\r栈\r#\r栈\r#\rStack 是一种特殊的线性表 限制仅允许在线性表的一端，进行插入和删除操作 特点\r#\r后进先出（Last In First Out，简称LIFO） 入栈出栈\r#\r"},{"id":156,"href":"/program-lang/java/grammar/process-control/","title":"流程控制","section":"基本语法","content":"\r流程控制\r#\rif\r#\r// 格式 if (布尔表达式){ // 如果true,执行... } else { // 如果false,执行... } //示例 int i = 30; if (i \u0026lt; 20) { System.out.print(\u0026#34;true\u0026#34;); } else { System.out.print(\u0026#34;false\u0026#34;); } for\r#\r// 格式 for (初始化; 布尔表达式; 步进) { // 循环内容 } // 增强 for 循环 for (变量类型 变量 : 数组或集合){ // 循环内容 } // 示例 for (int i = 0; i \u0026lt; 10; i++) { System.out.println(\u0026#34;value of i : \u0026#34; + i); } while\r#\r// 格式 while (布尔表达式) { // 循环内容 } // 示例 int i = 10; while (i \u0026lt; 20) { i++; System.out.println(\u0026#34;value of i : \u0026#34; + i); } do\u0026hellip;while\r#\r// 格式 do { // 循环内容 } while (布尔表达式); //示例 int i = 10; do { i++; System.out.println(\u0026#34;value of i : \u0026#34; + i); } while (i \u0026lt; 20); switch\r#\r支持的判断类型\nbyte、short、int 、char，JDK1.7 增加 String 可以有多个 case 语句\n先执行 case 语句，无匹配才执行 default 语句\n只有遇到 break，才会跳出 switch 语句，否则会继续执行下去\n// 格式 switch(expression){ case value : // 语句 break; case value : // 语句 break; ... default : // 语句 } // 示例 int i = 5; switch (i) { case 0: System.out.println(\u0026#34;0\u0026#34;); break; case 1: System.out.println(\u0026#34;1\u0026#34;); break; case 2: System.out.println(\u0026#34;2\u0026#34;); break; default: System.out.println(\u0026#34;default\u0026#34;); } break \u0026amp; continue\r#\rbreak：跳出循环体 continue ：跳出本次循环，进入下次循环 "},{"id":157,"href":"/algorithm/leetcode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","title":"滑动窗口","section":"leetcode","content":"\r滑动窗口\r#\r滑动窗口\r#\r使用两个指针划出一个窗口，并维护窗口数据的有效性 无重复字符的最长子串\r#\r原题\n给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。 输入: s = \u0026#34;abcabcbb\u0026#34; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026#34;abc\u0026#34;，所以其长度为 3。 题解\n1、窗口内是无重复子串 2、在窗口右端追加一个字符，则要判断窗口内是否已经存在该字符 3、如果存在，则要去除窗口内重复字符位置左端的所有字符 // 滑动窗口 public class Main { public int lengthOfLongestSubstring(String s) { // 窗口 Set\u0026lt;Character\u0026gt; occ = new HashSet\u0026lt;\u0026gt;(); int ans = 0; int left = 0; for (int right = 0; right \u0026lt; s.length(); right++) { while (occ.contains(s.charAt(right))) { occ.remove(s.charAt(left++)); } occ.add(s.charAt(right)); ans = Math.max(ans, right - left + 1); } return ans; } } // 加入哈希 public class Main { public int lengthOfLongestSubstringHash(String s) { HashMap\u0026lt;Character, Integer\u0026gt; keyIndex = new HashMap\u0026lt;\u0026gt;(); int length = s.length(); int maxLength = 0; int lashIndex = 0; for (int i = 0; i \u0026lt; length ; i++) { final char c = s.charAt(i); if (keyIndex.containsKey(c)) { lashIndex = Math.max(keyIndex.get(c) + 1, lashIndex); } keyIndex.put(c, i); int currLength = i - lashIndex + 1; if (maxLength \u0026lt; currLength) { maxLength = currLength; } } return maxLength; } } 找到字符串中所有字母异位词\r#\r原题\n给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。 输入: s = \u0026#34;cbaebabacd\u0026#34;, p = \u0026#34;abc\u0026#34; 输出: [0,6] 解释: 起始索引等于 0 的子串是 \u0026#34;cba\u0026#34;, 它是 \u0026#34;abc\u0026#34; 的异位词。 起始索引等于 6 的子串是 \u0026#34;bac\u0026#34;, 它是 \u0026#34;abc\u0026#34; 的异位词。 题解\npublic class Main { public List\u0026lt;Integer\u0026gt; findAnagrams(String s, String p) { List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); if (s.length() \u0026lt; p.length()) { return ans; } // 窗口 int[] sCount = count(s, p.length() - 1); int[] target = count(p, p.length()); for (int i = 0; i \u0026lt; s.length() - p.length() + 1; i++) { sCount[s.charAt(i + p.length() - 1) - \u0026#39;a\u0026#39;]++; if (Arrays.equals(target, sCount)) { ans.add(i); } sCount[s.charAt(i) - \u0026#39;a\u0026#39;]--; } return ans; } private int[] count(String s, int end) { int[] ans = new int[26]; for (int i = 0; i \u0026lt; end; i++) { final int c = s.charAt(i) - \u0026#39;a\u0026#39;; ans[c]++; } return ans; } } "},{"id":158,"href":"/algorithm/dir/","title":"目录","section":"算法题","content":"\r素数\r#\r// 判断 n 是否为素数 private static boolean isPrime(int n) { if (n \u0026lt; 2) { return false; } for (int i = 2; i \u0026lt;= Math.sqrt(n); i++) { if (n % i == 0) { return false; } } return true; } 互质\r#\r// 计算它们的最大公约数，如果最大公约数为1，则说明两个数互质 private static boolean isRelativePrime(int x, int y) { // 两个数辗转相除 while (y \u0026gt; 0) { int mod = x % y; x = y; y = mod; } return x == 1; } 并查集\r#\r// 并查集 static class UnionFindSet { int[] fa; // 初始化，设置i的父节点fa[i]为自身 public UnionFindSet(int n) { this.fa = new int[n]; for (int i = 0; i \u0026lt; n; i++) { fa[i] = i; } } // 查找x的根节点 public int findRoot(int x) { // 递归中断条件：根节点为自身 if (fa[x] == x) { return x; } // 递归：查询x的根节点 int root = findRoot(fa[x]); // 递归路径压缩：直接设置x的父节点为根 fa[x] = root; return root; } // 合并节点x、y public void union(int x, int y) { // 查找xy两者的根节点 int xFa = this.findRoot(x); int yFa = this.findRoot(y); // 合并：将xy两者的根节点设为一样 fa[xFa] = yFa; } } DFS\r#\rint area(int[][] grid, int r, int c) { // 判断 base case if (!inArea(grid, r, c)) { return 0; } // 如果这个格子不是岛屿，直接返回 if (grid[r][c] != 1) { return 0; } // 将格子标记为「已遍历过」 grid[r][c] = 2; // 访问上、下、左、右四个相邻结点 return 1 + area(grid, r - 1, c) + area(grid, r + 1, c) + area(grid, r, c - 1) + area(grid, r, c + 1); } // 判断坐标 (r, c) 是否在网格中 boolean inArea(int[][] grid, int r, int c) { return 0 \u0026lt;= r \u0026amp;\u0026amp; r \u0026lt; grid.length \u0026amp;\u0026amp; 0 \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt; grid[0].length; } 打印\r#\r/* %f : 输出浮点数 %.nf : 控制小数点后的位数，n为数字 %c : 输出字符 %d : 输出十进制整数 %o : 输出八进制整数 %x : 输出十六进制整数 %X : 输出大写十六进制整数 */ System.out.printf(\u0026#34;%.2f%n\u0026#34;, d); // %02d 表示将整数值按照至少占据两个字符的方式输出，不足两位时会在前面补零 // %n 表示一个换行符 System.out.printf(\u0026#34;%02d:%02d%n\u0026#34;, hour, minute); 其他\r#\r全排列 如果：一共n个元素，其中某元素A重复x次，某元素B重复了y次， 那么：最终不重复全排列个数 = n! / x! / y! 生成哈夫曼树的固定思路： 取出优先队列中前两个权值最小的节点，作为新节点的左右子树 水仙花数\r#\r// 或者预先计算水仙花数表 // 3 位：153, 370, 371, 407 // 4 位：1634, 8208, 9474 // 5 位：54748, 92727, 93084 // 6 位：548834 // 7 位：1741725, 4210818, 9800817, 9926315 必会 1. 数组 2. 字符串 3. 排序 4. 贪心 5. 递归 6. 循环 7. 滑窗 8. 栈 9. 进制转换 10. 位运算 11. 队列 12. 哈希表 13. 链表 14. 线性表 15. 二分查找 进阶 1. 图 2. 树 3. DFS搜索 4. BFS搜索 5. 动态规划 6. 前缀和 7. 排列组合 8. 矩阵 9. 双指针 10. 回溯 11. 状态机 12. 并查集 13. 正则表达式 14. 分治 15. 枚举 16. 统计 建议 必会部分知识点倾向于出现在100分题中，进阶知识点倾向于出现在200分题中。 建议必会部分优先掌握1-10知识点， 进阶部分优先掌握1-4知识点，这部分出现频次高，短时间内刷题性价比高。 import java.util.Scanner; // 注意类名必须为 Main, 不要有任何 package xxx 信息 public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 注意 hasNext 和 hasNextLine 的区别 while (in.hasNext()) { // 注意 while 处理多个 case Long a = in.nextLong(); Long b = in.nextLong(); System.out.println(a + b); } } } ASCII 48-57：0-9\r65-90：A-Z\r97-122：a-z 输入 //1. Scanner in = new Scanner(System.in); // InputStream is = System.in; // BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); ## 1\r- 原题\r```html\r```\r- 题解\r```html\r```\r```java\rpublic class Main {\r}\r```\r"},{"id":159,"href":"/program-base/linux/cmd/sys/","title":"系统管理","section":"常用命令","content":"\r系统管理\r#\rtop / htop - 显示当前运行的进程\nfree - 显示内存和交换区的使用情况\ndf - 报告文件系统磁盘空间使用情况\ndu - 估计文件空间使用量\nps - 报告当前进程状态\nkill - 发送信号到进程\nifconfig / ip - 网络接口配置\nping - 检测主机是否在网络中\nnetstat - 显示网络状态信息\n"},{"id":160,"href":"/interview/core/08-concurrent/%E7%BA%BF%E7%A8%8B%E6%B1%A0/","title":"线程池","section":"并发编程","content":"\r\u0026ndash; 线程池的核心参数？\r#\r\u0026ndash; 线程池的工作原理？\r#\r1. 创建线程池后，等待提交过来的任务请求 2. 当调用execute()添加一个新任务时，线程池会做如下判断： a. 如果当前运行的线程数量还小于corePoolSize，则会创建新线程来执行新任务 b. 如果当前运行的线程数量不小于corePoolSize，则会将提交的任务放入阻塞队列中 c. 如果当前阻塞队列满了，且当前运行的线程数量还小于maximumPoolSize，则创建线程运行这个任务 d. 如果当前阻塞队列满了，且当前运行的线程数量不小于maximumPoolSize，则启动拒绝策略 3. 当一个线程完成任务时，它会从队列中取下一个任务来执行 4. 当一个线程空闲超过一定时间，并且此时当前运行的线程大于corePoolSize时，这个线程会被销毁 \u0026ndash; 线程池的阻塞队列？\r#\r阻塞队列： ArrayBlockingQueue\t于数组结构的有界阻塞队列，先进先出。 LinkedBlockingQueue\t基于链表结构的有界阻塞队列，先进先出。 DelayedWorkQueue\t是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的 SynchronousQueue\t存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。 ArrayBlockingQueue LinkedBlockingQueue 强制有界 默认无界，支持有界 底层是数组 底层是链表 提前初始化 Node 数组 是懒惰的，创建节点的时候添加数据 Node需要是提前创建好的 入队会生成新 Node 一把锁 两把锁（头尾） \u0026ndash; 线程池的拒绝策略？\r#\rAbortPolicy\t默认策略，直接丢弃任务，抛出异常 CallerRunsPolicy\t用调用者所在的线程来执行任务 DiscardPolicy\t直接丢弃任务，也不抛出异常 DiscardOldestPolicy\t丢弃等待队列中最旧的任务，并执行当前任务 \u0026ndash; 线程池的种类？\r#\r1. newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 2. newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 3. newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 4. newScheduledThreadPool 创建一个执行延迟任务的线程池，支持定时及周期性任务执行。 \u0026ndash; 为什么不建议用Executors创建线程池？\r#\r如果使用Executors创建线程池的话，它允许的请求队列默认长度是Integer.MAX_VALUE， 这样的话，有可能导致堆积大量的请求，从而导致OOM（内存溢出） 一般使用ThreadPoolExecutor来创建线程池，这样可以明确规定线程池的参数，避免资源的耗尽。 \u0026ndash; 如何确定核心线程数？\r#\r1. IO密集型任务 高并发、任务执行时间短的任务，如文件读写、DB读写、网络请求等， 推荐设置：核心线程数 = CPU核数 * 2 + 1 2. CPU密集型任务 并发不高、任务执行时间长的任务，如计算型代码、Bitmap转换、Gson转换等 推荐设置：核心线程数 = CPU核数 + 1 \u0026ndash; 你们的项目中哪里用到了多线程？\r#\r批量导入： 使用了线程池+CountDownLatch批量把数据库中的数据导入到了ES(任意)中，避免OOM 数据汇总： 调用多个接口来汇总数据，如果所有接口（或部分接口）的没有依赖关系，就可以使用线程池+future来提升性能 异步线程（线程池）： 为了避免下一级方法影响上一级方法（性能考虑）， 可使用异步线程调用下一个方法（不需要下一级方法返回值），可以提升方法响应时间 "},{"id":161,"href":"/program-lang/java/thread/threadpool/threadpool-operate/","title":"线程池 - 操作","section":"线程池","content":"\r线程池操作\r#\rExecutorService\r#\r方法 描述 execute() 向线程池提交新任务，无返回值 submit() 向线程池提交新任务，返回 Future shutdown() 1、停止接收新任务2、线程池中，已经提交的任务会继续执行，执行完毕后关闭线程池 shutdownNow() 1、停止接收新任务2、试图关闭正在执行的任务3、移除线程池队列中等待执行的任务 isShutdown() 线程池是否关闭 isTerminated() 判断线程池关闭后所有的任务是否都执行完了仅当 shutdown()/shutdownNow() 被调用后才有效 awaitTermination() 阻塞，直到以下情况出现：1、超时；2、当前线程中断；3、所有任务已经执行完成 创建线程池\r#\r使用 ThreaPoolExecutor 构造函数，创建线程池，参数自定义\npublic class MyRunnable implements Runnable { @Override public void run() { System.out.println(Thread.currentThread().getName() + \u0026#34; is running...\u0026#34;); } } public class Test { public static void main(String[] args) throws Exception { ExecutorService threadPool = new ThreadPoolExecutor( 2, 5, 1L, TimeUnit.SECONDS, new LinkedBlockingDeque\u0026lt;\u0026gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy() ); MyRunnable myRunnable = new MyRunnable(); try { for (int i = 0; i \u0026lt; 10; i++) { threadPool.execute(myRunnable); } } catch (Exception ex) { System.out.println(ex.getMessage()); } finally { threadPool.shutdown(); } } } 关闭线程池\r#\r首先任务要能够响应中断 关闭流程： 调用shutdown() ： 禁止提交新的任务 调用awaitTermination() ：等待任务执行完成 调用shutdownNow() ：强制关闭那些执行任务过长（可能无法正常停止）的任务 配置线程数量\r#\r最佳线程数量 = （线程等待时间 / 线程CPU时间 + 1）* CPU核心\n比如平均每个线程CPU运行时间为0.5s，而线程等待时间（非CPU运行时间，比如IO）为1.5s， CPU核心数为8，那么根据上面这个公式估算得到：(1.5/0.5+1)*8=32 "},{"id":162,"href":"/program-lang/java/oop/Inheritance/","title":"继承","section":"面向对象","content":"\r继承\r#\r继承\r#\r指继承父类的状态和行为，创建子类的过程。 不支持多继承。 特性\r#\r子类拥有父类非 private 的属性、方法 子类可以对父类进行扩展 子类可以重写父类方法 支持单继承、多重继承 提高类之间的耦合性 格式\r#\rclass 父类 { //... } class 子类 extends 父类 { //... } this \u0026amp; super\r#\rthis 指向自己的引用 this() 调用自己的构造方法 super 指向父类的引用 super() 调用父类的构造方法 class Animal { public void eat() { System.out.println(\u0026#34;animal : eat\u0026#34;); } } class Dog extends Animal { public void eat() { System.out.println(\u0026#34;dog : eat\u0026#34;); } public void eatTest() { this.eat(); // this 调用自己的方法 super.eat(); // super 调用父类方法 } } extends \u0026amp; implements\r#\rpublic class Animal { private String name; public Animal(String myName) { this.name=myName; } public void eat() { //... } } public class Dog extends Animal{ //... } public interface A { public void eat(); } public interface B { public void sleep(); } public class C implements A,B { //.... } "},{"id":163,"href":"/program-design/design-pattern/behavioural/","title":"行为型","section":"设计模式","content":" 常用 不常用 行为型 状态、策略、模板迭代器、观察者、职责链 命令、中介解释器、访问者、备忘录 "},{"id":164,"href":"/program-design/design-pattern/","title":"设计模式","section":"程序设计","content":" 设计原则 描述 重要性 开闭原则 对扩展开放，对修改封闭 ★★★★★ 依赖倒转 面向接口编程，依赖于抽象而不依赖于具体。 ★★★★★ 单一职责 一个类的职责要单一，不能将太多的职责放到一个类中 ★★★★☆ 里式替换 一个可以接受父类对象的地方，必然可以接受其子类对象 ★★★★☆ 合成复用 尽量使用组合而不是继承，来达到软件复用的目的 ★★★★☆ 迪米特法则 一个类对自己依赖的类知道的越少越好 ★★★☆☆ 接口隔离 使用多个专门的接口来取代一个统一的接口 ★★☆☆☆ 类型 设计模式 数量 创造型 单例、工厂、原型、建造者 5 结构型 代理、桥接、外观、组合、享元、适配器、装饰器 7 行为型 状态、策略、模板、命令、迭代器、解释器、观察者、访问者、中介者、备忘录、职责链 11 "},{"id":165,"href":"/program-lang/java/thread/container/CopyOnWriteArrayList/","title":"CopyOnWriteArrayList","section":"并发容器","content":"\rCopyOnWriteArrayList\r#\r设计思想\r#\rCopy-On-Write（COW），是一种读写分离的思想 写线程写入数据的时候，会复制新建一个新容器。当数据更新完成后，再将旧容器引用指向新容器。 读线程感知数据更新是延时的，牺牲了数据实时性而保证数据最终一致性。 由于写线程写数据是在新容器写入的，因此读线程不会被阻塞。 应用场景\r#\r适用于读多写少的场景，比如系统的黑名单白名单设置 代码实现\r#\rarray private transient volatile Object[] array; get public E get(int index) { return get(getArray(), index); } final Object[] getArray() { return array; } private E get(Object[] a, int index) { return (E) a[index]; } add public boolean add(E e) { final ReentrantLock lock = this.lock; //1. 使用Lock,保证写线程在同一时刻只有一个 lock.lock(); try { //2. 获取旧数组引用 Object[] elements = getArray(); int len = elements.length; //3. 创建新的数组，并将旧数组的数据复制到新数组中 Object[] newElements = Arrays.copyOf(elements, len + 1); //4. 往新数组中添加新的数据 newElements[len] = e; //5. 将旧数组引用指向新的数组 setArray(newElements); return true; } finally { lock.unlock(); } } COW 缺点\r#\r内存占用问题：由于在写数据时，会复制数组，因此可能会出现内存使用瞬时增加，导致频繁的 GC 数据一致性问题：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性 COW \u0026amp; 读写锁\r#\r相同点： 两者都采用了读写分离的思想，并且读线程间是互不阻塞的 不同点： 当写线程在写数据时，COW采用延时更新策略不会阻塞读线程，而ReentrantReadWriteLock会阻塞读线程 COW保证数据的最终一致性，而ReentrantReadWriteLock保证数据的实时性 "},{"id":166,"href":"/program-lang/web/css/selector/","title":"CSS 选择器","section":"CSS","content":"\rCSS 选择器\r#\r选择器大全\r#\rCSS 选择器 简单选择器\r#\r选择器 示例 示例说明 * * 选择所有元素 #id #firstname 选择所有id=\u0026ldquo;firstname\u0026quot;的元素 .class .intro 选择所有class=\u0026ldquo;intro\u0026quot;的元素 标签选择器\r#\r选择器 示例 示例说明 element p 选择所有 \u0026lt;p\u0026gt; 元素 element,element div,p 选择所有 \u0026lt;div\u0026gt; 元素和 \u0026lt;p\u0026gt; 元素 element element div p 选择 \u0026lt;div\u0026gt; 元素内的所有 \u0026lt;p\u0026gt; 元素 element\u0026gt;element div\u0026gt;p 选择所有父级是 \u0026lt;div\u0026gt; 元素的 \u0026lt;p\u0026gt; 元素 element+element div+p 选择所有紧跟在 \u0026lt;div\u0026gt; 元素之后的第一个 \u0026lt;p\u0026gt; 元素 element~element div~p 选择 \u0026lt;div\u0026gt; 元素之后的每一个 \u0026lt;p\u0026gt; 元素 属性选择器\r#\r选择器 示例 示例说明 [attribute] [target] 选择带有 target 属性的所有元素 [attribute=value] [target=-blank] 选择使用 target=\u0026quot;-blank\u0026rdquo; 的所有元素 [attribute~=value] [title~=flower] 选择标题属性包含单词 \u0026ldquo;flower\u0026rdquo; 的所有元素 [attribute|=value] [lang|=en] 选择 lang 属性等于 en，或者以 en- 为开头的所有元素 [attribute^=value] a[src^=\u0026ldquo;https\u0026rdquo;] 选择每一个 src 属性的值以 \u0026ldquo;https\u0026rdquo; 开头的 \u0026lt;a\u0026gt; 元素 [attribute$=value] a[src$=\u0026quot;.pdf\u0026rdquo;] 选择每一个 src 属性的值以 \u0026ldquo;.pdf\u0026rdquo; 结尾的 \u0026lt;a\u0026gt; 元素 [attribute*=value] a[src*=\u0026ldquo;abc\u0026rdquo;] 选择每一个 src 属性的值包含子字符串 \u0026ldquo;abc\u0026rdquo; 的 \u0026lt;a\u0026gt; 元素 伪元素选择器\r#\r伪类 说明 :link 未被访问的链接 :visited 已被访问的链接 :hover 鼠标悬浮于上方的元素 :active 被激活的元素 :focus 拥有键盘输入焦点的元素 :first-child 元素的第一个子元素 :lang 带有 lang 属性的元素 :first-letter 文本的第一个字母 :first-line 文本的首行 :before 元素之前 :after 元素之后 \u0026hellip;\u0026hellip; 优先级\r#\r不同样式表 行内样式\u0026gt;内部样式\u0026gt;外部样式 同一样式表 权值相同：就近原则 权值不同：根据权重 选择器 权重值 !important 最高，示例：div{color:red !important} 行内样式 1000 ID选择器 100 类选择器、伪类 10 标签选择器 1 通配符选择器 0 "},{"id":167,"href":"/program-lang/java/thread/tool/Exchanger/","title":"Exchanger","section":"并发工具","content":"\rExchanger\r#\r功能\r#\r交换器 是一个用于线程间协作的工具类，用于两个线程间交换数据。 原理\r#\rExchanger提供了一个交换的同步点，在这个同步点两个线程能够交换数据。 如果一个线程先执行exchange()，那它会阻塞等待另一个线程也执行 exchange()。 当两个线程就都达到了同步点，它们就可以交换数据。 方法\r#\r// 构造方法 public Exchanger() // 交换 public V exchange(V x) // 交换（超时限制） public V exchange(V x, long timeout, TimeUnit unit) 示例\r#\rpublic class Test { public static void main(String[] args) { Exchanger\u0026lt;String\u0026gt; exchanger = new Exchanger\u0026lt;\u0026gt;(); new Thread(() -\u0026gt; { try { String out=\u0026#34;20块钱\u0026#34;; String in = exchanger.exchange(out); System.out.println(\u0026#34;张三：付出了\u0026#34;+out+\u0026#34;，获得了\u0026#34;+in); } catch (InterruptedException e) { e.printStackTrace(); } }).start(); new Thread(() -\u0026gt; { try { String out=\u0026#34;一条鲤鱼\u0026#34;; String in = exchanger.exchange(out); System.out.println(\u0026#34;李四：付出了\u0026#34;+out+\u0026#34;，获得了\u0026#34;+in); } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } } // 李四：付出了一条鲤鱼，获得了20块钱 // 张三：付出了20块钱，获得了一条鲤鱼 "},{"id":168,"href":"/program-lang/java/thread/theory/final/","title":"final","section":"并发理论","content":"\rfinal\r#\r概述\r#\rfinal，即最终、不可变 可以用来修饰类、方法和变量 用法\r#\r修饰类\nfinal 修饰的类，不能被继承 final 类中的方法，都会被隐式地指定为 final 方法 ​\n修饰方法\nfinal 修饰的方法，不能被重写，但可以被重载 private 修饰的方法，都会隐式地指定为 final 方法 ​\n修饰变量\nfinal 修饰的变量，在初始化后，不能被修改 final 变量，如果是引用类型，引用不能再指向其他对象，但对象内容是可以修改的 重排序规则\r#\r编译器和处理器要遵守两个重排序规则：\n在构造函数内对 final 域的写入，与随后把此被构造对象的引用赋值给一个变量，这两个操作之间不能重排序 初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序 通俗理解就是：\n对象构造函数内有final域，必须先用构造函数构造对象，再把对象赋给其他引用 如果对象有final域，必须先读对象的引用，再读final域 "},{"id":169,"href":"/dev-tool/git/operate/","title":"Git 使用","section":"Git","content":"\rGit 使用\r#\rGitHub\r#\r免密提交\r#\r生成 SSH Key 文件\n$ ssh-keygen -t rsa -C \u0026#34;youremail@example.com\u0026#34; 打开 ~/.ssh/id_rsa.pub，复制里面的 key\n回到 github 上，进入Settings，选择 SSH and GPG keys，点击 New SSH key，设置标题，粘贴 key\n验证\n$ ssh -T git@github.com Hi origin! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. TortoiseGit\r#\r与 GitHub 共用密码\r#\r现象：TortoiseGit 不能共用ssh-keygen产生的密钥\n原因：TortoiseGit 使用扩展名为ppk的密钥，而不是ssh-keygen生成的rsa密钥\n方式一：安装 TortoiseGit 安装过程中，选择使用OpenSSH方式\n方式二：设置 TortoiseGit 网络的ssh客户端位置为 Git\\usr\\bin\\ssh.exe 实际问题\r#\rCHERRY_PICK_HEAD exists\r#\r错误日志\n解决方法\n$ git cherry-pick --abort 删除敏感提交记录\r#\r# 回退：前i次的版本，--soft代表只删除服务器记录，不删除本地 git reset --soft HEAD~i # 强制推送，master代表当前分支 git push origin master --force # 再把本地的文件提交一次就行了 "},{"id":170,"href":"/service-manage/deprecated-frame/hystrix/","title":"Hystrix","section":"日落组件","content":"\rHystrix\r#\rHystrix\r#\r服务降级 是一个用于处理分布式系统的延迟和容错的开源库 能保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性 工作原理\r#\r当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝）， 向调用方返回一个符合预期的、可处理的备选响应，而不是长时间的等待或者抛出调用方无法处理的异常， 这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中蔓延乃至雪崩。 扇入、扇出\r#\r扇入：表示一个模块被多个模块调用 扇出：表示一个模块调用多个模块。 雪崩效应\r#\r分布式系统环境下，应用程序有众多依赖关系。某些情况下，许多依赖不可避免的会调用失败。 如果扇出链路上某个微服务不可用，对其的调用就会占用越来越多的系统资源，进而引起系统崩溃。 这种因“服务提供者的不可用”导致“服务调用者不可用”，并将不可用逐渐放大的现象，即“雪崩效应”。 服务熔断\r#\r当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用 服务降级\r#\r从整个系统的负荷情况考虑，对某些负荷会比较高的某些功能（业务场景），当其熔断后将不再被调用。 此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。达到虽服务水平下降但还可用的目的。 服务降级处理是在客户端实现完成的，与服务端没有关系 "},{"id":171,"href":"/program-lang/java/library/java.util.stream/","title":"java.util.stream","section":"基础类库","content":"\rJava8 流\r#\rStream\r#\r是一个来自数据源的元素队列，并支持聚合操作 元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。 数据源流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。 聚合操作类似 SQL 语句一样的操作， 比如 filter, map, reduce, find, match, sorted 等 基础特征 管道：中间操作都会返回流对象本身 内部迭代：通过访问者模式实现 创建流\r#\rString[] array = {\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}; Path pathObj = Paths.get(\u0026#34;filePath\u0026#34;); Collection\u0026lt;String\u0026gt; collection = Lists.newArrayList(); SecureRandom random = SecureRandom.getInstanceStrong(); // 序列 Stream.of(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); // 数组 Arrays.stream(array); // 集合 collection.stream(); // 文件 Files.lines(pathObj); Files.list(pathObj); // 函数 Stream.iterate(0, n -\u0026gt; n + 3).limit(10); Stream.generate(random::nextInt).limit(10); Stream.generate(() -\u0026gt; (int) (System.nanoTime() % 100)).limit(10); 中间操作\r#\rStream\u0026lt;User\u0026gt; stream = Stream.of(new User()); // 排序（反序） stream.sorted(); stream.sorted(Comparator.comparing(User::getAge).reversed()); // 筛选 stream.filter(User::isMale); // 去重 stream.distinct(); // 截断 stream.limit(10); // 跳过 stream.skip(10); // 映射 stream.map(User::getName); // 流扁平化 stream.map(User::getName).map(s -\u0026gt; s.split(\u0026#34;\u0026#34;)).flatMap(Arrays::stream); 终端操作\r#\rStream\u0026lt;Integer\u0026gt; stream = Stream.of(1, 2, 3, 4, 5); // 匹配 stream.anyMatch(n -\u0026gt; n == 5); // 是否有一个元素匹配 stream.allMatch(n -\u0026gt; n == 5); // 是否全部元素都匹配 stream.noneMatch(n -\u0026gt; n == 5); // 是否全部元素都不匹配 // 查找 stream.findAny(); // 查找任意元素 stream.findFirst(); // 查找第一个元素 // 归约 stream.reduce(Integer::sum); // 求和 stream.reduce(Integer::min); // 最小值 stream.reduce(Integer::max); // 最大值 stream.reduce(1, (n1, n2) -\u0026gt; n1 * n2); // 从1开始，连乘元素 // 统计格式 stream.count(); // 遍历 stream.forEach(System.out::println); // 收集 stream.collect(Collectors.toList()); // List\u0026lt;T\u0026gt; stream.collect(Collectors.toSet()); // Set\u0026lt;T\u0026gt; stream.collect(Collectors.toMap(String::valueOf, n -\u0026gt; \u0026#34;\u0026#34;)); // Map\u0026lt;String,String\u0026gt; stream.collect(Collectors.groupingBy(String::valueOf)); // Map\u0026lt;String,List\u0026lt;T\u0026gt;\u0026gt;，分组 数值流\r#\rIntStream stream; Stream\u0026lt;User\u0026gt; objStream = Stream.of(new User()); // 由数值范围创建 stream = IntStream.range(1, 100); // 不包含结束值100 stream = IntStream.rangeClosed(1, 100); // 包含结束值100 // 由对象流映射 stream = objStream.mapToInt(User::getAge); // 聚合函数 stream.sum(); stream.min(); stream.max(); stream.count(); // 转换回对象流 stream.boxed(); "},{"id":172,"href":"/program-lang/java/container/Map/LinkedHashMap/","title":"LinkedHashMap","section":"Map","content":"\rLinkedHashMap\r#\r概述\r#\rLinkedHashMap 是 HashMap 的子类，可以认为是等同于 HashMap+LinkedList，哈希表+双向链表 特点\r#\r键 允许为null（放在第一位），不允许重复 值 允许为null，允许重复 顺序 有序 多线程 线程不安全 继承关系\r#\rpublic class LinkedHashMap\u0026lt;K,V\u0026gt; extends HashMap\u0026lt;K,V\u0026gt; implements Map\u0026lt;K,V\u0026gt; 成员变量\r#\r// 控制访问顺序：false：基于插入顺序；true：基于访问顺序 final boolean accessOrder; // 其他变量从HashMap中继承 构造方法\r#\r// 默认 public LinkedHashMap() { super(); accessOrder = false; } // 指定初始容量 public LinkedHashMap(int initialCapacity) { super(initialCapacity); accessOrder = false; } // 指定初始容量、负载因子 public LinkedHashMap(int initialCapacity, float loadFactor) { super(initialCapacity, loadFactor); accessOrder = false; } // 指定初始容量、负载因子、accessOrder public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) { super(initialCapacity, loadFactor); this.accessOrder = accessOrder; } // 指定集合，转化为LinkedHashMap public LinkedHashMap(Map\u0026lt;? extends K, ? extends V\u0026gt; m) { super(); accessOrder = false; //... } 底层数据结构\r#\r"},{"id":173,"href":"/database/oracle/","title":"Oracle","section":"数据存储","content":"\rOracle\r#\rOracle Database，是一个适合于大中型企业的关系数据库管理系统。 是美国 Oracle 公司的核心产品，其服务是收费的。 物理结构\r#\r文件 作用 后缀 数据文件 存放数据库数据，若干个数据文件组成表空间 .dbf 控制文件 存放数据库的物理结构信息 .ctl 重做日志文件 记录数据库所有修改信息的文件 .log 归档日志文件 对写满的重做日志文件进行保存复制 .log 参数文件 记录Oracle数据库的基本参数信息 告警文件 记录数据库启动后，用户操作上的或数据库本身的问题 逻辑结构\r#\r逻辑结构 说明 块 Block 最小的逻辑存储单元 ，所有数据的存取都是以块为单位进行的 区 Extent 是一组连续的块构成的存储结构，是Oracle存储分配的最小单位 段 Segment 是为特定的数据对象（如表、索引、回滚等）分配的一系列数据区 表空间 Tablespace 是数据库的最大逻辑划分区域，由若干个数据文件组成。所有数据对象都存储在表空间上 块 Block： 1、块头：包含了该数据块一般的属性信息，如数据块的物理地址、所属段类型等 2、表目录：如果数据块中存储的数据是某个表的数据，则这里存放该表的信息 3、行目录：用来存储数据块中有效的行信息 4、空余空间：指数据块还没有使用的存储空间 5、行空间：表或者索引的数据存储在行空间中，所以行空间是数据块中已经使用的存储空间 段 Segment： 1、数据段：用来存储表中所有数据； 2、索引段：用来存储表中索引的所有数据； 3、临时段：用于存储表排序或汇总时产生的临时数据 4、LOB段：LOB 用来存储表中大型数据对象，例如 CLOB 与 BLOB 5、回退段：用于存储用户数据被修改之前的位置和值； 当要对用户的数据进行回退操作时，就要使用回退段。 直观图 "},{"id":174,"href":"/program-lang/java/container/Queue/","title":"Queue","section":"集合容器","content":"\r"},{"id":175,"href":"/program-lang/java/thread/lock/ReentrantReadWriteLock/","title":"ReentrantReadWrite...","section":"锁体系","content":"\rReentrantReadWriteLock\r#\r"},{"id":176,"href":"/program-base/network/rpc/","title":"RPC","section":"网络","content":"\rRPC\r#\rRemote Procedure Call，远程过程调用 是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议 RPC 使得程序能够像访问本地系统资源一样，去访问远端系统资源 主流 RPC 框架：Dubbo/Dubbox、Google gRPC、Spring Boot/Spring Cloud RPC 组件\r#\r客户端(Client)\t服务调用者 客户端存根(Client Stub)\t存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端 服务端存根(Server Stub)\t接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理 服务端(Server)\t服务提供者 RPC 原理\r#\rRPC 架构\r#\r"},{"id":177,"href":"/service-manage/springcloud/","title":"Spring Cloud","section":"服务治理","content":"\rSpring Cloud\r#\r分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务全家桶 中文参考文档 推荐：Nacos、LoadBalancer、OpenFeign、sentienl、gateway 停更：Eureka、Feign、Hystrix、Zuul、Config、Bus Spring Cloud \u0026amp; Spring Boot\r#\rSpringBoot 专注于快速、方便的开发单个微服务个体 SpringCloud 是关注全局的微服务协调治理框架，它将 SpringBoot 开发的一个个单体微服务整合并管理起来。 SpringBoot 可以离开 SpringCloud 独立使用开发项目，但是 SpringCloud 离不开 SpringBoot，属于依赖的关系。 "},{"id":178,"href":"/database/mysql/mysql-tuning/sql-tuning/","title":"SQL优化","section":"性能调优","content":"\rSQL优化\r#\r避免使用双引号，用单引号代替 避免使用 *，用具体列名代替 避免使用 in，用 exist 代替 尽量使用UNION ALL代替UNION 尽量使用预编译：性能更好、防止SQL注入 尽量少做重复的工作 尽量避免耗时操作：DISTINCT、UNION、MINUS、INTERSECT、ORDER BY 尽量避免使用游标 尽量避免使用临时表 尽量避免大事务操作 尽量避免向客户端返回大数据量 分析 sql 语句：分析慢查询日志 利用分析工具：Explain、Profile "},{"id":179,"href":"/program-design/design-pattern/creational/04-prototype/","title":"原型模式","section":"创建型","content":"\r原型模式\r#\r概述\r#\r英文：Prototype Pattern 简述：通过拷贝原型创建新的对象 归纳：拔一根猴毛，吹出千万个 目的：高效创建对象 案例：克隆 示例\r#\r// 原型类：实现Cloneable接口 public class Prototype implements Cloneable { private String name; // setter、getter... // clone方法 public Object clone(){ try { return super.clone(); } catch (Exception e) { e.printStackTrace(); return null; } } } public class Test { public static void main(String[] args) { Prototype pro1=new Prototype(); pro1.setName(\u0026#34;张三\u0026#34;); //以pro1为原型，克隆得到pro2 Prototype pro2=(Prototype)pro1.clone(); System.out.println(pro1.getName()); System.out.println(pro2.getName()); } } 应用\r#\r主要解决: 在运行期建立和删除原型 应用场景： 细胞分裂。 JAVA 中的 Object clone() 方法。 注意事项： 克隆过程中，不会执行被克隆类的构造方法 浅拷贝：Object类的clone()只拷贝类方法、类成员（基本数据类型+String类型） 深拷贝：对引用数据类型的类成员也进行拷贝 "},{"id":180,"href":"/program-lang/java/jvm/gc/collector/","title":"垃圾收集器","section":"垃圾回收","content":"\r垃圾收集器\r#\r回收方式\r#\r串行（Serial）、并行（Parallel）、并发（Concurrent）、STW 七大收集器\r#\r收集器：Serial 、Serial Old\r#\r单个垃圾收集线程串行工作，会暂停所有用户线程，不适合服务器环境 Serial：新生代，复制算法 Serial Old：老年代，标记 - 整理算法 收集器：ParNew\r#\rSerial 收集器的多线程（即并行）版本 ParNew：新生代，复制算法 收集器：Parallel Scavenge / Old\r#\r多个垃圾收集线程并行工作，会暂停所有用户线程，适合科学算/大数据处理等弱交互场景 Parallel Scavenge：新生代，复制算法，可控制吞吐量 Parallel Old：老年代，标记 - 整理算法 收集器：CMS\r#\r概述\r#\r用户线程和垃圾收集线程并发执行，互联网公司多用它，适用对响应时间有要求的场景 Concurrent Mark Sweep：老年代，标记 - 清除算法 优缺点\r#\r并发收集低停顿，但对CPU资源压力大，且会产生大量碎片 步骤\r#\r初始标记（CMS initial mark） 并发标记（CMS concurrent mark） 重新标记（CMS remark） 并发清除（CMS concurrent sweep） 收集器：G1\r#\r概述\r#\r将堆内存分割成不同的区域然后并发的对其进行垃圾回收 面向服务端应用，适用于多处理器和大容量内存环境 G1：整体上采用标记-整理算法，局部是采用复制算法 步骤\r#\r初始标记（Initial Marking） 并发标记（Concurrent Marking） 最终标记（Final Marking） 筛选回收（Live Data Counting and Evacuation） 原理\r#\rGarbage First\n通过把Java堆分成大小相等的多个独立区域 回收时计算出每个区域回收所获得的空间以及所需时间的经验值， 根据记录两个值来判断哪个区域最具有回收价值，所以叫Garbage First（垃圾优先） G1 堆空间划分\n在G1算法中，堆内存被划分为多个大小相等的区域（Region），每个 Region 都可能是 Eden区， Survivor区或者 Old 区。所有的 Eden 区和 Survivor 区合起来就是新生代，所有的 Old 区合起来就是老年代。 特点\r#\r特点 说明 并行且并发 G1 回收过程中，可以有多个Gc线程同时工作，也不会完全阻塞工作线程 分代收集 G1 依旧区分 Eden、Survivor、老年代 空间整合 G1 整体上采用标记-整理算法，局部是采用复制算法，不会产生内存空间碎片 可预测的停顿 G1 能让用户明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。 G1 相关参数\r#\r参数 说明 -XX:+UseG1GC 开启 G1 -XX:G1HeapRegionSize=n 设置Region大小，值是2的幂，范围是1MB到32MB -XX:MaxGCPauseMillis=n 设置最大GC停顿时间，JVM会尽可能让停顿小于这个时间 G1 与 CMS 对比\r#\rG1 基于标记-整理算法，不产生内存碎片 G1 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收 "},{"id":181,"href":"/database/mysql/mysql-command/composite-query/","title":"复合查询","section":"基础命令","content":"\r复合查询\r#\r条件查询\r#\rselect [distinct去重] 字段列表 from数据源 where条件 group by分组 having条件 order by排序 limit分页; where having 原理 一条条从磁盘读取数据，判断条件，放入内存 将所有数据读入内存，在内存内部，逐条判断 使用别名 不能 可以 使用聚合函数 不能 可以 联合查询\r#\r将多个子查询的结果，组合到一个结果集合中。（子查询所查询的列数量须相同） -- 格式 SELECT expression1, expression2, ... expression_n FROM tables [WHERE conditions] UNION [ALL | DISTINCT] SELECT expression1, expression2, ... expression_n FROM tables [WHERE conditions]; -- 示例 SELECT country, name FROM Websites WHERE country=\u0026#39;CN\u0026#39; UNION ALL SELECT country, app_name FROM apps WHERE country=\u0026#39;CN\u0026#39; ORDER BY country; 连接查询\r#\r内连接：INNER JOIN，获取两个表中，符合字段匹配关系的记录 左连接：LEFT JOIN，获取左表所有记录，即使右表没有对应匹配的记录 右连接：RIGHT JOIN，获取右表所有记录，即使左表没有对应匹配的记录 -- 示例 SELECT a.id, a.author, b.book FROM a_tb a INNER JOIN b_tb b ON a.author = b.author; 子查询\r#\r指在一条select语句中，嵌入了另外一条select语句，那么被嵌入的select语句称之为子查询语句。 关键字：IN、ANY、SOME、ALL -- 子查询返回单一值 SELECT * FROM article WHERE user_id = ( SELECT user_id FROM user WHERE user_name=\u0026#39;Jack\u0026#39; LIMIT 1 ); -- 子查询返回列 SELECT * FROM article WHERE user_id IN( SELECT user_id FROM user WHERE status=1 ); -- 子查询返回行 SELECT * FROM article WHERE (title,content,uid) = ( SELECT title,content,uid FROM blog WHERE bid=2 ); -- 子查询返回表 SELECT * FROM article WHERE (title,content,uid) IN ( SELECT title,content,uid FROM blog ); -- 子查询返回值列表 SELECT * FROM table1 WHERE city=\u0026#39;hangzhou\u0026#39; and exists( select * from table2 where table1.customer_id=table2.customer_id ); "},{"id":182,"href":"/program-lang/java/oop/polymorphism/","title":"多态","section":"面向对象","content":"\r多态\r#\r概念\r#\r多态：指允许不同子类对象对同一消息作出不同的响应 前提：继承、重写、父类引用指向子类对象 示例\r#\rabstract class Animal { public abstract void run(); } class Cat extends Animal { public void run() { System.out.println(\u0026#34;猫跑了......\u0026#34;); } } class Dog extends Animal { public void run() { System.out.println(\u0026#34;狗跑了......\u0026#34;); } } class Lady { private Animal pet; Lady(Animal pet) { this.pet = pet; } public void myPetRun(){ pet.run(); } } public class Test { public static void main(String args[]){ Cat c = new Cat(); Dog d = new Dog(); Lady l1 = new Lady(c); Lady l2 = new Lady(d); l1.myPetRun(); l2.myPetRun(); } } // 测试结果 猫跑了...... 狗跑了...... "},{"id":183,"href":"/algorithm/leetcode/%E5%AD%90%E4%B8%B2/","title":"子串","section":"leetcode","content":"\r子串\r#\r子串\r#\r长串数据中一段连续的数据 和为 K 的子数组\r#\r原题\n给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。 子数组是数组中元素的连续非空序列。 输入：nums = [1,1,1], k = 2 输出：2 题解\n1、遍历数组，计算nums[0]到nums[i]的和pre 2、使用哈希表存储键值对，键为pre，值为次数 3、如果哈希表存在键pre-k，则代表存在一个子数组，该子数组末端到nums[i]之间的数字之和等于k 问题转为：pre[i]−pre[j−1]==k （前缀和之差为k，代表这两个前缀之间的数字相加就是K） public class Main { public int subarraySum(int[] nums, int k) { HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(0, 1); int pre = 0; int count = 0; for (int i = 0; i \u0026lt; nums.length; i++) { pre += nums[i]; if (map.containsKey(pre - k)) { count += map.get(pre - k); } map.put(pre, map.getOrDefault(pre, 0) + 1); } return count; } } 1\r#\r原题\n题解\npublic class Main { } 1\r#\r原题\n题解\npublic class Main { } "},{"id":184,"href":"/program-lang/java/thread/threadpool/ScheduledThreadPoolExecutor/","title":"定时线程池","section":"线程池","content":"\rScheduledThreadPoolExecutor\r#\r"},{"id":185,"href":"/database/oracle/plsql/exception/","title":"异常处理","section":"PL/SQL","content":"\r异常处理\r#\r处理异常\r#\r-- 语法 DECLARE \u0026lt;declarations section\u0026gt; BEGIN \u0026lt;executable command(s)\u0026gt; EXCEPTION \u0026lt;exception handling goes here \u0026gt; WHEN exception1 THEN exception1-handling-statements WHEN exception2 THEN exception2-handling-statements WHEN exception3 THEN exception3-handling-statements ........ WHEN others THEN exception3-handling-statements END; -- 示例 DECLARE c_id customers.id%type := \u0026amp;cc_id; c_name customers.name%type; c_addr customers.address%type; -- 声明自定义异常 ex_invalid_id EXCEPTION; BEGIN IF c_id \u0026lt;= 0 THEN -- 触发自定义异常 RAISE ex_invalid_id; ELSE SELECT name, address INTO c_name, c_addr FROM customers WHERE id = c_id; DBMS_OUTPUT.put_line (\u0026#39;姓名: \u0026#39;|| c_name); DBMS_OUTPUT.put_line (\u0026#39;地址: \u0026#39;|| c_addr); END IF; -- 处理异常 EXCEPTION WHEN ex_invalid_id THEN DBMS_OUTPUT.put_line(\u0026#39;编号ID必须要大于0!\u0026#39;); WHEN no_data_found THEN DBMS_OUTPUT.put_line(\u0026#39;未找到指定ID的客户信息!\u0026#39;); WHEN others THEN DBMS_OUTPUT.put_line(\u0026#39;Error!\u0026#39;); END; 自定义异常\r#\r用户自己定义的异常 需使用 RAISE 语句显式的抛出异常 预定义异常\r#\r系统定义的异常 当程序违反特定数据库规则时自动触发 异常 Oracle错误号 描述 DUP_VAL_ON_INDEX ORA-00001 违反唯一约束条件 INVALID_CURSOR ORA-01001 无效的游标 NOT_LOGGED_ON ORA-01012 没有登录 LOGIN_DENIED ORA-01017 用户名/口令无效; 登录被拒绝 NO_DATA_FOUND ORA-01403 未找到任何数据 TOO_MANY_ROWS ORA-01422 实际返回行数超过请求行数 ZERO_DIVIDE ORA-01476 除数为 0 INVALID_NUMBER ORA-01722 无效数字 STORAGE_ERROR ORA-06500 内存溢出 PROGRAM_ERROR ORA-06501 PL/SQL: 内部错误 VALUE_ERROR ORA-06502 PL/SQL: 数字或值错误 ROWTYPE_MISMATCH ORA-06504 PL/SQL：返回结果集变量的类型错误 ACCESS_INTO_NULL ORA-06530 引用未初始化的组合 COLLECTION_IS_NULL ORA-06531 未初始化集合错误的引用 CASE_NOT_FOUND ORA-06592 当执行CASE语句时,没有发现CASE SELF_IS_NULL ORA-30625 不允许空自参数上的方法调度 raise_application_error\r#\r抛出自定义的错误信息：raise_application_error(code错误码, \u0026lsquo;错误信息\u0026rsquo;) -- 示例 DECLARE v_sal emp.sal%type; v_sal_error EXCEPTION; BEGIN SELECT sal INTO v_sal FROM emp WHERE empno = \u0026amp;empno; IF (v_sal \u0026lt; 3000) THEN raise_application_error(-20000, \u0026#39;薪资问题，小伙子注意啦，要开除啦\u0026#39;); END IF; END; "},{"id":186,"href":"/program-design/data-algorithm/sort/merge/","title":"归并排序","section":"排序","content":"\r归并排序\r#\r归并操作\r#\r将已有序的子序列合并，得到完全有序的序列 算法步骤\r#\r申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 动图演示\r#\r代码实现\r#\rpublic class MergeSort implements IArraySort { @Override public int[] sort(int[] arr) throws Exception { if (arr.length \u0026lt; 2) { return arr; } int middle = (int) Math.floor(arr.length / 2); int[] left = Arrays.copyOfRange(arr, 0, middle); int[] right = Arrays.copyOfRange(arr, middle, arr.length); return merge(sort(left), sort(right)); } protected int[] merge(int[] left, int[] right) { int[] result = new int[left.length + right.length]; int i = 0; while (left.length \u0026gt; 0 \u0026amp;\u0026amp; right.length \u0026gt; 0) { if (left[0] \u0026lt;= right[0]) { result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); } else { result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); } } while (left.length \u0026gt; 0) { result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); } while (right.length \u0026gt; 0) { result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); } return result; } } "},{"id":187,"href":"/interview/core/04-micro-service/","title":"微服务","section":"重点面试题","content":"\r\u0026ndash; SpringCloud 组件有哪些？\r#\rNacos\t服务注册与配置中心\tRibbon\t负载均衡\tFeign\t服务调用\tSentinel\t服务保护\tGateway\tAPI网关\t\u0026ndash; Eureka 如何实现服务注册发现？\r#\r服务注册：服务提供者将自己的信息（如服务名称、IP、端口等）注册到Eureka。 服务发现：消费者从Eureka获取服务列表信息，并利用负载均衡算法选择一个服务进行调用。 服务监控：服务提供者定期向Eureka发送心跳以报告健康状态；如果Eureka在一定时间内未接收到心跳，将服务实例从注册中心剔除。 \u0026ndash; Nacos 与 Eureka的区别？\r#\r共同点： 两者都支持服务注册与发现，以及心跳检测作为健康检查机制。 不同点： 1. Nacos支持服务端主动检测服务提供者状态，而Eureka依赖客户端心跳。 2. Nacos区分临时实例和非临时实例，采用不同的健康检查策略。 3. Nacos支持服务列表变更的消息推送，使服务更新更及时。 4. Nacos集群默认采用AP模式，但在存在非临时实例时，会采用CP模式；而Eureka始终采用AP模式。 5. Nacos还支持了配置中心 \u0026ndash; 如何实现负载均衡的？\r#\r使用SpringCloud的Ribbon组件来实现客户端负载均衡。Feign已经集成了Ribbon。 当发起远程调用时，Ribbon首先从注册中心获取服务地址列表，然后根据负载均衡策略选择一个服务实例进行调用。 \u0026ndash; Ribbon 负载均衡策略有哪些？\r#\rRandomRule\t随机 RoundRobinRule\t轮询 RetryRule\t重试 WeightedResponseTimeRule\t响应时间加权，响应时间越长，权重越小 BestAvailableRule\t最低并发，优先选择并发量最小的服务器 ZoneAvoidanceRule\t区域感知，优先选择同一区域中可用的服务器 \u0026ndash; 如何自定义 Ribbon 负载均衡策略？\r#\r提供了两种方式： 1，创建类实现IRule接口，可以指定负载均衡策略（全局） 2，在客户端的配置文件中，可以配置某一个服务调用的负载均衡策略（局部） \u0026ndash; 什么是服务雪崩？怎么解决？\r#\r服务雪崩：是指一个服务的失败，导致整条链路的服务都相继失败的情况 解决方案： 1. 服务降级：在请求量突增时，主动降低服务的级别，确保核心服务可用。 2. 服务熔断：当服务调用失败率达到一定阈值时，熔断机制会启动，防止系统过载。 \u0026ndash; 如何对微服务进行监控？\r#\r使用SkyWalking进行微服务监控： 1. SkyWalking能够监控接口、服务和物理实例的状态，帮助我们识别和优化慢服务。 2. skywalking能够设置告警规则，一旦检测到异常，系统会通过短信或邮件通知相关负责人。 \u0026ndash; 常见的限流算法？\r#\r固定窗口算法\t又称计算器算法，使用计数器在周期内累加访问次数，当达到设定的限流值时，触发限流策略。 下一个周期开始时，进行清零，重新计数。 滑动窗口算法\t将时间周期分为N个小周期，分别记录每个小周期内访问次数。 跟随时间的滑动，删除超限的小周期数据，以便更精确地控制流量。 漏桶算法\t使用一个固定容量、固定流出速度的漏桶，访问请求到达后，直接放入漏桶中。 如果漏桶未满，请求将被接受并排队等待处理；如果漏桶已满，则根据算法策略处理。 令牌桶算法\t使用一个固定容量、固定速率添加令牌的令牌桶，请求到达时向令牌桶请求令牌。 如获取到令牌则通过请求，否则触发限流策略 \u0026ndash; 什么是 CAP 理论？BASE 理论？\r#\rCAP 1. 一致性（Consistency） 用户访问分布式系统中的任意节点，得到的数据必须一致 2. 可用性（Availability） 用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝 3. 分区容错性（Partition tolerance） 分区：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。 容错：在集群出现分区时，整个系统也要持续对外提供服务 CAP 理论 包含一致性、可用性、分区容错性 分布式系统节点通过网络连接，一定会出现分区问题（P） 当分区出现时，系统的一致性（C）和可用性（A）就无法同时满足 BASE 理论 是分布式系统设计中对CAP理论中AP方案的延伸， 强调通过基本可用、软状态和最终一致性来实现系统设计。 \u0026ndash; 分布式事务解决方案？\r#\r解决分布式事务的思想： AP：最终一致思想，各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据 CP：强一致思想，各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚 方案：seata XA模式，CP，需要互相等待各个分支事务提交，可以保证强一致性，性能差 AT模式，AP，底层使用undo log实现，性能好 TCC模式，AP，性能较好，不过需要人工编码实现 方案：MQ MQ模式实现分布式事务，在A服务写数据的时候，需要在同一个事务内发送消息到另外一个事务，异步，性能最好 \u0026ndash; 什么是分布式幂等性？如何保证？\r#\r幂等性： 多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致。 实现方案： 1. 如果是新增数据，可以使用数据库的唯一索引 2. 如果是新增或修改数据，可以使用分布式锁、Token+Redis token+redis： 第一次请求，生成一个唯一token存入redis，返回给前端； 第二次请求，业务处理，携带之前的token，到redis进行验证， 如果存在，可以执行业务，删除token；如果不存在，则直接返回，不处理业务。 \u0026ndash; xxl-job 路由策略有哪些？\r#\rxxl-job支持多种路由策略，包括轮询、故障转移和分片广播等 \u0026ndash; xxl-job 任务执行失败怎么解决？\r#\r1. 选择故障转移路由策略，优先使用健康的实例执行任务。 2. 设置任务重试次数。 3. 通过日志记录和邮件告警通知相关负责人。 \u0026ndash; xxl-job 如果有大数据量的任务同时都需要执行，怎么解决？\r#\r可以通过部署多个实例并使用分片广播路由策略来分散任务负载。 在任务执行代码中，根据分片信息和总数对任务进行分配。 16. xxl-job路由策略有哪些？ 候选人： xxl-job支持多种路由策略，包括轮询、故障转移和分片广播等。 17. xxl-job任务执行失败怎么解决？ 候选人： 面对任务执行失败，我们可以： 1. 选择故障转移路由策略，优先使用健康的实例执行任务。 2. 设置任务重试次数。 3. 通过日志记录和邮件告警通知相关负责人。 18. 如果有大数据量的任务同时都需要执行，怎么解决？ 候选人： 我们可以通过部署多个实例并使用分片广播路由策略来分散任务负载。在任务执行代码中，根据分片信息和总数对任务进行分配。 "},{"id":188,"href":"/program-lang/java/grammar/array/","title":"数组","section":"基本语法","content":"\r数组\r#\r概述\r#\r数组是相同类型数据的有序集合，代表着一串连续的内存空间 特点\r#\r数组元素必须是相同类型 数组一旦被创建，其长度就是不可变的 数组元素的索引（下标），从 0 开始 数值类型元素的默认值为 0，引用类型元素的默认值为 null 创建数组\r#\r// 一维数组 dataType[] arrayRefVar; dataType[] arrayRefVar = new dataType[arraySize]; dataType[] arrayRefVar = {value0, value1, ..., valuek}; // 示例 int[] arr1; int[] arr2 = new int[2]; int[] arr3 = {1, 2, 3} // 多维数组 dataType[][] arrayRefVar = new dataType[arraySize1][arraySize2]; dataType[][] arrayRefVar = {{value0, value1, ..., valuek},{...},...}; // 示例 int[][] arr1 = new int[2][3]; int[][] arr2 = {{1, 2, 3},{4, 5},{6, 7, 8, 9}}; 操作数组\r#\rint a,b; int[] arr = {0, 1, 2, 3}; a = arr[0]; // 元素引用 b = arr.length; // 数组长度 "},{"id":189,"href":"/program-lang/web/css/position/float/","title":"浮动","section":"CSS 位置","content":"\r浮动\r#\r属性\r属性说明\r属性值\r属性值说明\rfloat\r浮动\rnone\r不浮动，默认\rleft\r左浮动\rright\r右浮动\rinherit\r继承\rclear\r清除浮动\rnone\r两侧元素，允许浮动，默认值。\rleft\r左侧元素，不允许浮动\rright\r右侧元素，不允许浮动\rboth\r两侧元素，不允许浮动\rinherit\r继承\r浮动规则\r#\r浮动元素 不会重叠 不会上下浮动 会脱离标准流 浮动元素的外边距，不会超过父元素内边距 非浮动元素的文本，会环绕浮动元素周围 "},{"id":190,"href":"/program-base/linux/cmd/user/","title":"用户权限","section":"常用命令","content":"\r用户权限\r#\ruseradd - 添加用户\nusermod - 修改用户属性\nuserdel - 删除用户\ngroupadd - 添加用户组\npasswd - 更改用户密码\nsu - 切换用户身份\nchmod - 改变文件或目录权限\nchown - 改变文件或目录的所有者\n"},{"id":191,"href":"/program-lang/java/thread/thread/thread-state/","title":"线程状态","section":"线程基础","content":"\r线程状态\r#\r线程状态\r#\r状态码 状态 说明 NEW 初始状态 线程被构建，但是还没有调用 start() 方法 RUNNABLE 运行状态 线程已经启动，拥有执行资格，如果取得执行资源则执行 BLOCKED 阻塞状态 线程挂起，阻塞于锁 WAITING 等待状态 线程等待中，需要被显式地唤醒，否则会无限期等待 TIMED_WAITING 超时等待 线程等待中，在达到一定时间后，会自动唤醒 TERMINATED 终止状态 线程已经执行完毕 状态转换\r#\r方法 调用者 描述 对象锁 唤醒 Thread.sleep(t) 当前线程 休眠当前线程 不释放 一定时间后自动唤醒 Thread.yield() 当前线程 让出执行资源，休眠当前线程 不释放 由系统进行调度 thread.join()thread.join(t) 其他线程 加入其他线程，休眠当前线程 不释放 其他线程执行完后唤醒一定时间后自动唤醒 object.wait()object.wait(t) 锁对象 使线程进入等待队列 释放 notify()/notifyAll() 唤醒一定时间后自动唤醒 线程方法\r#\rjava.lang.Thread\r#\r成员方法 描述 静态方法 描述 start() 开始执行线程 setName() 修改线程名称 run() 线程体方法 setPriority() 设置线程优先级（1~10） yield() 使当前线程暂停 setDaemon() 标记线程为用户线程 sleep() 使当前线程休眠 currentThread() 获取当前正在执行的线程对象 join() 当前线程中，加入其他线程 holdsLock() 当前线程是否持有指定锁 interrupt() 中断线程 dumpStack() 打印当前线程的堆栈信息 isAlive() 线程是否处于活动状态 java.lang.Object\r#\r方法 描述 notify() 唤醒在此对象监视器上等待的单个线程。 notifyAll() 唤醒在此对象监视器上等待的所有线程。 wait() 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待 sleep() \u0026amp; wait()\r#\rsleep() wait() 所属类 java.lang.Thread java.lang.Object 对象锁 不释放 释放 使用位置 任意地方 只能在同步块中使用 捕获异常 需要 不需要 "},{"id":192,"href":"/program-lang/web/css/style/background/","title":"背景样式","section":"CSS 样式","content":"\r背景样式\r#\r属性\r属性说明\r属性值\r属性值说明\rbackground\r简写\r\u0026nbsp;\r空格分隔各值，不分顺序\rbackground-color\r背景颜色\rtransparent\r透明色，默认\rcolor\r颜色值\rbackground-image\r背景图片\rnone\r无图片，默认\rurl('URL')\r图片路径\rbackground-repeat\r背景图片重复\rrepeat\r默认。垂直方向及水平方向重复\rrepeat-x\r水平方向重复\rrepeat-y\r垂直方向重复\rno-repeat\r不重复\rbackground-attachment\r背景图片滚动\rscroll\r跟随滚动。默认\rfixed\r固定\rbackground-position\r背景图片起始位置\r当只有一个值时，第二个值默认为居中\rx%、y%\r百分比，默认0% 0%\rx、y\r数值\rtop\r上\rbottom\r下\rleft\r左\rright\r右\rcenter\r中\r示例\r#\rbody{ background-image:url(\u0026#39;/i/eg_bg_03.gif\u0026#39;); background-repeat:no-repeat; background-position:66% 33%; } "},{"id":193,"href":"/database/mysql/advanced-feature/trigger/","title":"触发器","section":"高级特性","content":"\r触发器\r#\r定义\r#\r触发器是一种特殊类型的存储过程，通过触发事件而被执行。 优点： 实现相关表的级联更改。 通过触发器进行安全校验，保证数据安全 缺点： 过分依赖触发器，会影响数据库结构，增加了维护难度。 由于执行触发器不可见，很难弄清数据库层情况 对数据库服务器资源的开销较大 建议： 尽量不使用触发器 如果要使用，需确保触发器高效低耗 触发器管理\r#\r触发时机：before/after 触发事件：insert/update/delete # 创建 修改语句结束符 create trigger 触发器名 触发时机 触发事件 on 表名 for each row begin 执行体 end 语句结束符 修改语句结束符 # 查看 show triggers [like \u0026#39;...\u0026#39;]; show create trigger 触发器名; # 删除 drop trigger 触发器名; -- 示例 DELIMITER $$ CREATE TRIGGER demo BEFORE DELETE ON users FOR EACH ROW BEGIN INSERT INTO logs VALUES(NOW()); INSERT INTO logs VALUES(NOW()); END $$ DELIMITER ; 触发器新旧数据\r#\r触发器，针对数据表中的每一行，会记录其操作前后的数据 -- 在触发器中，可通过“old/new.字段名”，来获取对应数据 -- old：记录操作前的数据。 -- new：记录操作后的数据 -- 示例：商品自动扣除库存 DELIMITER $$ CREATE TRIGGER demo AFTER INSERT ON my_orders FOR EACH ROW BEGIN UPDATE my_goods SET inv = inv -NEW.goods_num WHERE id = NEW.goods_id; END $$ DELIMITER ; "},{"id":194,"href":"/database/mysql/grammar/sentence/","title":"语句","section":"基本语法","content":"\r语句\r#\r分支结构\r#\rif 语句\r#\r作为表达式，嵌套在其他语句中使用，可以放在任何地方\n作为独立的语句去使用，只能放在 begin...end 中\n# 格式：作为表达式 if(条件, 判断为ture返回, 判断为false返回) # 格式：作为独立语句 if 条件1 then 语句1; elseif 条件2 then 语句2; else 语句n; end if; -- 示例：判断 5\u0026lt;10，true返回“大”，false返回“小” select if(5\u0026lt;10, \u0026#39;大\u0026#39;, \u0026#39;小\u0026#39;); -- 示例：创建函数，根据传入的成绩来显示等级 drop function if exists testIf; delimiter $ create function testIf(score int) returns char(3) begin if score\u0026gt;=90 then return \u0026#39;优秀\u0026#39;; elseif score\u0026gt;=80 then return \u0026#39;良好\u0026#39;; elseif score\u0026gt;=60 then return \u0026#39;及格\u0026#39;; else return \u0026#39;不及格\u0026#39;; end if; end$ select testIf(66) as \u0026#39;成绩\u0026#39;; case 语句\r#\r作为表达式，嵌套在其他语句中使用，可以放在任何地方\n作为独立的语句去使用，只能放在 begin...end 中\nelse可以省略，没有满足的条件则返回null\n# 格式：作为表达式 case 字段|表达式|变量 when 常量1 then 返回值1 when 常量2 then 返回值2 else 默认返回值 end # 格式：作为独立语句 case when 条件1 then 语句1; when 条件2 then 语句2; else 语句n; end case; -- 示例：查询读者性别 select readerName, sex, case sex when \u0026#39;男\u0026#39; then \u0026#39;是个爷们\u0026#39; when \u0026#39;女\u0026#39; then \u0026#39;是个姑娘\u0026#39; else \u0026#39;未知\u0026#39; end as \u0026#39;gender\u0026#39; from reader; -- 示例：创建存储过程，根据传入的成绩来显示等级 drop procedure if exists testCase; delimiter $ create procedure testCase(in score int) begin case when score\u0026gt;=90 then select \u0026#39;优秀\u0026#39; as \u0026#39;成绩\u0026#39;; when score\u0026gt;=80 then select \u0026#39;良好\u0026#39; as \u0026#39;成绩\u0026#39;; when score\u0026gt;=60 then select \u0026#39;及格\u0026#39; as \u0026#39;成绩\u0026#39;; else select \u0026#39;不及格\u0026#39; as \u0026#39;成绩\u0026#39;; end case; end $ call testCase(95); 循环结构\r#\r只能放在 begin...end 中 while\r#\r先判断，后循环\n# 格式 [标签:] while 循环条件 do 循环体; end while [标签]; -- 示例：批量插入 drop procedure if exists pro_while; delimiter $ create procedure pro_while(in insertCount int) begin declare i int default 1; -- 声明并初始化局部变量 i while i \u0026lt;= insertCount do insert into reader(readerNo, readerName, sex) values(i, concat(i, \u0026#39;号读者\u0026#39;), \u0026#39;男\u0026#39;); set i = i + 1; -- 循环变量更新 end while; end$ call pro_while(5); -- 插入 5 条记录 repeat\r#\r先执行后判断\n# 格式 [标签:] repeat 循环体; until 结束循环的条件 # 注意此处没有分号 end repeat [标签]; -- 示例：批量插入 drop procedure if exists pro_while; delimiter $ create procedure pro_while(in insertCount int) begin declare i int default 1; -- 声明并初始化局部变量 i repeat insert into reader(readerNo, readerName, sex) values(i, concat(i, \u0026#39;号读者\u0026#39;), \u0026#39;男\u0026#39;); set i = i + 1; -- 循环变量更新 until i \u0026gt;= insertCount end repeat; end$ call pro_while(5); -- 插入 4 条记录 loop\r#\r无限循环\n# 格式 [标签:] loop 循环体; end loop [标签]; -- 示例：批量插入 drop procedure if exists pro_while; delimiter $ create procedure pro_while(in insertCount int) begin declare i int default 1; -- 声明并初始化局部变量 i halt: loop insert into reader(readerNo, readerName, sex) values(i, concat(i, \u0026#39;号读者\u0026#39;), \u0026#39;男\u0026#39;); if i \u0026gt;= insertCount then leave halt; -- leave 控制语句 end if; set i = i + 1; -- 循环变量更新 end loop halt; end$ call pro_while(5); -- 插入 5 条记录 标签\r#\r为某些特定的结构进行命名，方便在某些地方使用 在 mysql 中，没有 continue/break，只有 iterate/leave -- 创建存储过程 CREATE PROCEDURE example_iterate(OUT sum INT) BEGIN DECLARE i INT DEFAULT 0; DECLARE s INT DEFAULT 0; loop_label:LOOP SET i = i+1; IF i \u0026gt; 10 THEN LEAVE loop_label; -- leave：退出整个循环 END IF; IF (i mod 2) THEN SET s = s+i; ELSE ITERATE loop_label; -- iterate：退出本次循环，继续下一个循环 END IF; END LOOP; SET sum = s; END; -- 调用存储过程 CALL example_iterate(@sum); SELECT @sum; "},{"id":195,"href":"/program-lang/web/html/link/","title":"链接标签","section":"HTML","content":"\rURL\r#\r.代表当前网页所在目录，可省略 ..代表当前网页所在目录的上一级目录 //绝对路径 \u0026lt;img src=\u0026#34;D:/html/img.png\u0026#34; /\u0026gt; //相对路径 \u0026lt;img src=\u0026#34;../img.png\u0026#34; /\u0026gt; \u0026lt;a\u0026gt;\r#\r定义一个链接 属性： title：链接提示文字 href：链接地址 target：在何处打开链接：_blank、_parent、_self、_top //链接到资源 \u0026lt;a href=\u0026#34;https://www.baidu.com/\u0026#34; /\u0026gt; \u0026lt;a href=\u0026#34;../xxx.html\u0026#34; /\u0026gt; \u0026lt;a href=\u0026#34;../xxx.rar\u0026#34; /\u0026gt; //链接到邮件 \u0026lt;a href=\u0026#34;mailto:xxx@qq.com\u0026#34; /\u0026gt; //定义锚点 \u0026lt;a name=\u0026#34;mark\u0026#34; /\u0026gt; //链接到锚点 \u0026lt;a href=\u0026#34;#mark\u0026#34; /\u0026gt; \u0026lt;a href=\u0026#34;../xxx.html#\u0026gt;mark\u0026#34; /\u0026gt; \u0026lt;img\u0026gt;\r#\r定义一个图像 属性： src：定义图像的URL alt：定义图像的替代文本 width：定义图像的宽 height：定义图像的高 \u0026lt;img src=\u0026#34;xxx.png\u0026#34; alt=\u0026#34;xxx\u0026#34; width=\u0026#34;40\u0026#34; height=\u0026#34;40\u0026#34; /\u0026gt; "},{"id":196,"href":"/program-design/data-structure/queue/","title":"队列","section":"数据结构","content":"\r队列\r#\r队列\r#\rQueue 是一种特殊的线性表 限制仅允许在线性表的一端进行插入，在另一端进行删除 特点\r#\r先进先出（First In First Out，简称FIFO） 入队出队\r#\r"},{"id":197,"href":"/program-lang/java/thread/theory/CAS/","title":"CAS","section":"并发理论","content":"\rCAS 算法\r#\rCAS\r#\r比较并交换，Compare-And-Swap，是一种无锁算法 基于硬件原语实现，能够在不使用锁的情况下实现多线程之间的变量同步 Java CAS硬件底层接口 ：sun.misc.Unsafe CAS 机制\r#\r涉及到三个参数，数据所在的内存地址 V，旧的预期值 A，要修改的更新值 B 从 V 取值，和 A 做比较，如果相等，则更新为 B。如果不相等则重试 一般情况下是一个自旋操作，即不断的重试。 CAS 缺点\r#\r自旋时间长开销很大 只能保证一个共享变量的原子性 存在 ABA 问题 ABA 问题\r#\r在 CAS 操作中，内存中某时刻的值与下一时刻再次读取的值相等，并不意味着数据没有被修改 存在这种情况：在这段时间内，其他线程将 A 值改成 B 值，又改回 A 值。而CAS却误认为数据未被修改 解决方案： 1、加版本号（时间戳）； 2、时间戳原子引用：AtomicStampedReference\u0026lt;V\u0026gt; "},{"id":198,"href":"/program-lang/java/container/Map/ConcurrentHashMap/","title":"ConcurrentHashMap","section":"Map","content":"\rConcurrentHashMap\r#\r概述\r#\rConcurrentHashMap 是 HashMap 的扩展版本，支持并发，是线程安全的 特点\r#\r键 不允许为null，不允许重复 值 不允许为null，允许重复 顺序 无序 多线程 线程安全 继承关系\r#\rpublic class ConcurrentHashMap\u0026lt;K,V\u0026gt; extends AbstractMap\u0026lt;K,V\u0026gt; implements ConcurrentMap\u0026lt;K,V\u0026gt;, Serializable { 构造方法\r#\r// 默认 public ConcurrentHashMap() { } // 指定初始容量 public ConcurrentHashMap(int initialCapacity) { //... } // 指定初始容量、负载因子 public ConcurrentHashMap(int initialCapacity, float loadFactor) { this(initialCapacity, loadFactor, 1); } // 指定初始容量、负载因子、并发级别 public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) { //... } // 指定集合，转化为ConcurrentHashMap public ConcurrentHashMap(Map\u0026lt;? extends K, ? extends V\u0026gt; m) { //... } 线程同步\r#\rJDK1.7\r#\r通过锁分离（分段锁）的思路解决了多线程的安全问题 ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。 JDK1.8\r#\r抛弃了Segment分段锁机制，利用 CAS+Synchronized 来保证并发更新的安全 "},{"id":199,"href":"/program-lang/java/thread/lock/Condition/","title":"Condition","section":"锁体系","content":"\rCondition\r#\r"},{"id":200,"href":"/program-lang/java/thread/threadpool/FutureTask/","title":"FutureTask","section":"线程池","content":"\rFutureTask\r#\r"},{"id":201,"href":"/program-lang/java/library/java.util.function/","title":"java.util.function","section":"基础类库","content":"\r函数式接口\r#\r概述\r#\rFunctional Interface 就是一个有且仅有一个抽象方法，但可以有多个非抽象方法的接口 可以被隐式转换为 lambda 表达式，使用 @FunctionalInterface 进行检测 // JDK 1.8 之前已有的常用函数式接口 @FunctionalInterface public interface Runnable { void run(); } @FunctionalInterface public interface Callable\u0026lt;V\u0026gt; { V call() throws Exception; } @FunctionalInterface public interface Comparator\u0026lt;T\u0026gt; { int compare(T var1, T var2); } java.util.function\r#\rConsumer\r#\r消费型 接受数据，没有返回值 // 消费一个数据 public interface Consumer\u0026lt;T\u0026gt; { void accept(T t); } // 消费两个数据 public interface BiConsumer\u0026lt;T, U\u0026gt; { void accept(T t, U u); } 接口 函数 IntConsumer void accept(int value); LongConsumer void accept(long value); DoubleConsumer void accept(double value); ObjIntConsumer\u0026lt;T\u0026gt; void accept(T t, int value); ObjLongConsumer\u0026lt;T\u0026gt; void accept(T t, long value); ObjDoubleConsumer\u0026lt;T\u0026gt; void accept(T t, double value); Supplier\r#\r供给型 无需接受数据，返回一个结果 // 无参数，返回一个结果 public interface Supplier\u0026lt;T\u0026gt; { T get(); } 接口 函数 IntSupplier int getAsInt(); LongSupplier long getAsLong(); DoubleSupplier double getAsDouble(); BooleanSupplier boolean getAsBoolean(); Predicate\r#\r断言型 接受一个数据，返回布尔值 // 接受一个数据，返回布尔值 public interface Predicate\u0026lt;T\u0026gt; { boolean test(T t); } // 接受两个数据，返回布尔值 public interface BiPredicate\u0026lt;T, U\u0026gt; { boolean test(T t, U u); } 接口 函数 IntPredicate boolean test(int value); LongPredicate boolean test(long value); DoublePredicate boolean test(double value); Function\r#\r函数型 接受数据，返回一个值 // 接受一个数据，返回一个结果 public interface Function\u0026lt;T, R\u0026gt; { R apply(T t); } // 接受两个数据，返回一个结果 public interface BiFunction\u0026lt;T, U, R\u0026gt; { R apply(T t, U u); } 接口 函数 IntFunction\u0026lt;R\u0026gt; R apply(int value); LongFunction\u0026lt;R\u0026gt; R apply(long value); DoubleFunction\u0026lt;R\u0026gt; R apply(double value); ToIntBiFunction\u0026lt;T, U\u0026gt; int applyAsInt(T t, U u); ToIntFunction\u0026lt;T\u0026gt; int applyAsInt(T value); LongToIntFunction int applyAsInt(long value); DoubleToIntFunction int applyAsInt(double value); ToLongBiFunction\u0026lt;T, U\u0026gt; long applyAsLong(T t, U u); ToLongFunction\u0026lt;T\u0026gt; long applyAsLong(T value); IntToLongFunction long applyAsLong(int value); DoubleToLongFunction long applyAsLong(double value); ToDoubleBiFunction\u0026lt;T, U\u0026gt; double applyAsDouble(T t, U u); ToDoubleFunction\u0026lt;T\u0026gt; double applyAsDouble(T value); IntToDoubleFunction double applyAsDouble(int value); LongToDoubleFunction double applyAsDouble(long value); Operator\r#\r操作同类型数据 接口 函数 UnaryOperator\u0026lt;T\u0026gt; T apply(T t); IntUnaryOperator int applyAsInt(int operand); LongUnaryOperator long applyAsLong(long operand); DoubleUnaryOperator double applyAsDouble(double operand); BinaryOperator\u0026lt;T\u0026gt; T apply(T t1, T t2); IntBinaryOperator int applyAsInt(int left, int right); LongBinaryOperator long applyAsLong(long left, long right); DoubleBinaryOperator double applyAsDouble(double left, double right); "},{"id":202,"href":"/service-manage/zookeeper/","title":"Zookeeper","section":"服务治理","content":"\rZookeeper\r#\r是一个开源的，分布式的，为分布式应用提供协调服务的框架 特点\r#\r由一个领导者（leader）和多个跟随者（follower）组成集群 集群只要有半数以上节点存活，就能正常服务 数据一致性：每个server保存一份相同的数据副本，client无论连接到哪个server，数据都是一致的。 请求顺序性：来自同一个client的更新请求按其发送顺序依次执行。 原子性：一次数据更新要么成功，要么失败。 实时性：在一定时间范围内，client能读到最新数据。 应用\r#\r统一命名服务 统一配置管理 统一集群管理 服务器节点动态上下线 软负载均衡等 "},{"id":203,"href":"/service-manage/deprecated-frame/zuul/","title":"Zuul","section":"日落组件","content":"\rZuul\r#\rZuul\r#\r服务网关 路由：将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础 过滤：对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础 "},{"id":204,"href":"/interview/core/05-middleware/","title":"中间件","section":"重点面试题","content":"\r\u0026ndash; RabbitMQ 如何保证消息不丢失？\r#\r1. 开启生产者确认机制 确保消息能被送达队列，如有错误则记录日志并修复数据。 2. 开启持久化功能 确保消息在未消费前不会在队列中丢失，需要对交换机、队列和消息本身都进行持久化。 3. 对消费者开启自动确认机制，并设置重试次数。 多次重试失败后将消息投递到异常交换机，交由人工处理。 \u0026ndash; RabbitMQ 消息的重复消费问题如何解决？\r#\r1. 通过业务唯一标识检查数据库中数据是否存在，若不存在则处理消息，若存在则忽略，避免重复消费。 2. 使用Redis分布式锁或数据库锁来确保操作的幂等性。 \u0026ndash; RabbitMQ 中死信交换机了解吗？\r#\r死信： 当消息超时未消费、拒绝被消费，或者消息队列满了，消息就会成为死信。 死信交换机： 用于接收死信投递的交换机， 可以在消息队列中配置dead-letter-exchange属性，来声明死信交换机。 延迟队列： 指进入队列的消息会被延迟消费的队列 用于超时订单、限时优惠、定时发布等业务， 可以通过死信交换机、消息存活时间TTL来实现。也可以通过安装插件DelayExchange来实现。 \u0026ndash; RabbitMQ 延迟队列有了解过吗？\r#\r延迟队列： 指进入队列的消息会被延迟消费的队列 应用场景： 超时订单、限时优惠、定时发布... 功能实现： 1. 通过死信交换机 + 消息存活时间TTL来实现 2. 通过安装插件DelayExchange来实现 \u0026ndash; RabbitMQ 消息堆积怎么解决？\r#\r1. 提高消费者消费能力，如使用多线程。 2. 增加消费者数量，采用工作队列模式，让多个消费者并行消费同一队列。 3. 扩大队列容量，使用RabbitMQ的惰性队列，支持数百万条消息存储，直接存盘而非内存。 \u0026ndash; RabbitMQ 的高可用机制了解吗？\r#\r保证高可用性： 普通集群、镜像集群、仲裁队列集群 镜像集群： 1. 结构是一主多从，从就是镜像，主节点处理所有操作并同步给从节点 2. 若主节点宕机，从节点可接替为新的主节点（可能会出现数据丢失） 仲裁队列集群： 主从模式，基于Raft协议实现强一致性数据同步，简化了配置，防止数据丢失提高了数据安全性。 \u0026ndash; Kafka 如何保证消息不丢失？\r#\r1. 生产者发送消息到Brocker丢失 设置异步发送，发送失败使用回调进行记录或重发 2. 消息在Brocker中存储丢失 在Broker中通过复制机制，设置acks参数为all，确保消息在所有副本中都得到保存。 3. 消费者从Brocker接收消息丢失 消费者手动提交消费成功的偏移量，避免自动提交可能导致的数据丢失或重复消费。 \u0026ndash; Kafka 消息的重复消费问题如何解决？\r#\r1. 禁用自动提交偏移量，手动控制偏移量的提交时机。 2. 确保消息消费的幂等性，例如通过唯一主键或分布式锁。 \u0026ndash; Kafka 如何保证消费的顺序性？\r#\r应用场景： 即时消息中的单对单聊天和群聊，必须保证发送方消息发送顺序与接收方的顺序一致。 充值转账两个渠道在同一个时间进行余额变更，短信通知必须要有顺序。 问题原因： 一个topic的数据可能存储在不同的分区中， 每个分区都有一个按照顺序的存储的偏移量，如果消费者关联了多个分区不能保证顺序性。 解决方案： 将消息存储在同一个分区，通过指定分区号或相同的业务key来实现。 \u0026ndash; Kafka 的高可用机制了解吗？\r#\r1. 集群部署 一个kafka集群由多个broker实例组成，单点故障不影响整体服务。 2. 复制机制 一个topic有多个分区，每个分区有多个分区副本，包含一个leader副本和多个follower副本 当leader发生故障时，会自动从follower中选举出新的leader，保证了系统的容错性、高可用性。 \u0026ndash; Kafka 复制机制中的 ISR 是什么？\r#\rIn-Sync Replicas，指与leader保持同步复制的follower副本。 当leader故障时，优先从ISR中选举新的leader，因为它们数据一致性更高。 分区副本分类： 1. ISR，与leader副本同步保存数据 2. 普通的副本，与leader副本异步保存数据 \u0026ndash; Kafka 的数据清理机制了解吗？\r#\r1. 根据消息的保留时间 当消息保存的时间超过了指定的时间，就会触发清理，默认是168小时（ 7天） 2. 根据topic的数据大小 当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息。（默认关闭） \u0026ndash; Kafka 中实现高性能的设计有了解过吗？\r#\r1. 消息分区：不受单台服务器的限制，提升数据处理能力。 2. 顺序读写：提高磁盘操作效率。 3. 消息压缩：减少磁盘IO和网络IO 4. 分批发送：将消息打包批量发送，减少网络开销 5. 页缓存：把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问 6. 零拷贝：减少上下文切换及数据拷贝 \u0026ndash; RabbitMQ、Kafka\r#\rRabbitMQ Kafka 单机吞吐量 万级 十万级 消息延迟 微秒级 毫秒级 消息批量操作 不支持 支持 事务 不支持 不支持 "},{"id":205,"href":"/database/oracle/plsql/transaction/","title":"事务处理","section":"PL/SQL","content":"\r事务处理\r#\r数据库事务\r#\r是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。 这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。 ACID：原子性、一致性、隔离性、持久性 开启事务\r#\r连接到数据库后执行第一个SQL语句。 在事务完成后发出的每个新的SQL语句。 结束事务\r#\r发出 COMMIT 或 ROLLBACK 语句时 发出 DDL/ DCL 语句时 执行 DML 语句失败时 退出 Oracle 工具时 提交事务\r#\rINSERT INTO customers (id,name,age,address,salary) VALUES (1, \u0026#39;Ramesh\u0026#39;, 32, \u0026#39;Ahmedabad\u0026#39;, 2000.00 ); -- 提交事务 COMMIT; 回滚事务\r#\rINSERT INTO customers (id,name,age,address,salary) VALUES (7, \u0026#39;Rajnish\u0026#39;, 27, \u0026#39;HP\u0026#39;, 9500.00 ); INSERT INTO customers (id,name,age,address,salary) VALUES (8, \u0026#39;Riddhi\u0026#39;, 21, \u0026#39;WB\u0026#39;, 4500.00 ); -- 保存点 SAVEPOINT sav1; UPDATE customers SET salary = salary + 1000; -- 回滚到保存点 ROLLBACK TO sav1; UPDATE customers SET salary = salary + 1000 WHERE ID = 7; UPDATE customers SET salary = salary + 1000 WHERE ID = 8; COMMIT; 自动事务\r#\r-- 开启事务自动提交 SET AUTOCOMMIT ON; -- 关闭事务自动提交 SET AUTOCOMMIT OFF; "},{"id":206,"href":"/program-base/linux/cmd/file-zip/","title":"压缩","section":"常用命令","content":"\r压缩\r#\rtar - 文件压缩与解压缩\ngzip / gunzip - 压缩或解压缩文件\nbzip2 / bunzip2 - 压缩或解压缩文件\n"},{"id":207,"href":"/program-design/design-pattern/creational/05-builder/","title":"建造者模式","section":"创建型","content":"\r建造者模式\r#\r概述\r#\r英文：Builder Pattern 简述：用来创建复杂的复合对象 归纳：高配中配和低配，想选哪配就哪配 目的：开放个性配置步骤 案例：选配 示例\r#\r// 被建造的复杂对象 public class House { private String baise; private String wall; private String roofed; // getter、setter //... } // 抽象建造者：主要用来指定建造步骤 public abstract class HouseBuilder { protected House house = new House(); //建设房屋的基本方法，建设根基、建设墙、建设屋顶 public abstract void buildBasic(); public abstract void buildWalls(); public abstract void roofed(); public House buildHouse() { return house; } } // 类似产品类：CommonHouse public class HighBuilding extends HouseBuilder{ @Override public void buildBasic() { System.out.println(\u0026#34;高楼地基\u0026#34;); } @Override public void buildWalls() { System.out.println(\u0026#34;高楼墙面\u0026#34;); } @Override public void roofed() { System.out.println(\u0026#34;高楼屋顶\u0026#34;); } } // 指挥类 public class HouseDirector { HouseBuilder houseBuilder = null; // 构造器创建bilder对象 public HouseDirector(HouseBuilder houseBuilder) { this.houseBuilder = houseBuilder; } // 建造房屋的流程交给指挥者 public House constructHouse() { houseBuilder.buildBasic(); houseBuilder.buildWalls(); houseBuilder.roofed(); return houseBuilder.buildHouse(); } } 应用\r#\r主要解决： 软件系统中，一个复杂对象的创建，通常由各个部分的子对象用一定的算法构成。 由于需求的变化，各子部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。 应用场景： 需要生成的对象具有复杂的内部结构 需要生成的对象内部属性本身相互依赖 注意事项： 与工厂模式的区别是：建造者模式更加关注与零件装配的顺序 "},{"id":208,"href":"/program-design/data-algorithm/sort/quick/","title":"快速排序","section":"排序","content":"\r快速排序\r#\r算法步骤\r#\r先从数列中取出一个数作为基准数。 分区过程：将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。 再对左右区间重复第二步，直到各区间只有一个数。 动图演示\r#\r代码实现\r#\rpublic class QuickSort implements IArraySort { @Override public int[] sort(int[] arr) throws Exception { return quickSort(arr, 0, arr.length - 1); } private int[] quickSort(int[] arr, int left, int right) { if (left \u0026lt; right) { int partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); } return arr; } private int partition(int[] arr, int left, int right) { // 设定基准值（pivot） int pivot = left; int index = pivot + 1; for (int i = index; i \u0026lt;= right; i++) { if (arr[i] \u0026lt; arr[pivot]) { swap(arr, i, index); index++; } } swap(arr, pivot, index - 1); return index - 1; } private void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } "},{"id":209,"href":"/program-lang/java/oop/abstraction/","title":"抽象","section":"面向对象","content":"\r抽象\r#\r抽象\r#\r是将一类对象的共同特征总结出来构造类的过程 抽象类\r#\r抽象方法：只有方法声明，没有方法实现 抽象类：包含抽象方法的类 特征： 抽象类不能实例化。 抽象类的非抽象子类必须实现父类抽象方法 抽象方法、抽象类必须被abstract修饰 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法 //示例 abstract class Animal{ String name; public abstract void run(); } class Dog extends Animal{ public void run(){ System.out.println(\u0026#34;run\u0026#34;); } } 接口\r#\r接口是一种特殊的抽象类，是抽象方法的集合。用 interface 定义。 特点 隐式抽象 支持多继承 没有构造方法 接口的方法都是公有的、隐式抽象的 接口的成员变量只能是public static final 的。 //示例 interface Animal{ public static final int id = 1; public void run(); public void eat(); } //接口继承接口 interface fish extends Animal{ //... } //类实现接口 public Dog implements Animal{ public void run(){ //具体实现... } public void eat(){ //具体实现... } } "},{"id":210,"href":"/program-design/data-structure/hash/","title":"散列表","section":"数据结构","content":"\r散列表\r#\r散列表\r#\rHash 也叫哈希表，是一种根据键值对 (key和value) 直接进行访问的数据结构 数据存储\r#\r使用哈希函数计算 key 的哈希值 再用哈希值对数组长度取模，得到其余数，即存放位置的数组下标 如果该位置已经存储了元素，则使用链表在已有元素的后面进行存储 数据查询\r#\r使用哈希函数计算 key 的哈希值， 再用哈希值对数组长度取模，得到存放位置的数组下标 对比参数key与节点key是否相同，如果相同则取出节点value 如果不相同，则对指向的链表进行线性查找 哈希冲突\r#\r两个不同的输入值，根据哈希函数计算出的哈希值取模结果相同的现象 "},{"id":211,"href":"/program-lang/java/grammar/method/","title":"方法","section":"基本语法","content":"\r方法\r#\r方法的定义\r#\r方法包含于类中 方法中不能定义方法 若无返回值，用 void 代替 // 格式 修饰符 返回值类型 方法名(参数类型 参数名){ ... 方法体 ... return 返回值; } // 示例 public static int age(int birthday){ //... } 方法的调用\r#\r// 格式 对象名.函数名（实参列表） // 示例 public int max(int a,int b){ if(a\u0026gt;b){ return a; } return b; } public static void main(String []args) { int larger = max(30, 40); //... } 重载 \u0026amp; 重写\r#\r重载 overload\n在一个类里面，方法名字相同，而参数不同 每个重载的方法都必须有独一无二的参数类型列表（参数个数、参数类型、参数顺序） 重写 override 是子类对父类方法的实现进行重新编写 方法名、参数列表均相同 重写方法抛出的异常，需宽于被重写方法 构造方法不能被重写 区别 区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常捕获 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问限制 可以修改 一定不能做更严格的限制（可以降低限制） 可变参数\r#\r在方法声明中，在指定参数类型后加一个省略号(\u0026hellip;)\npublic static void max(double... numbers) { //... } public static void main(String[] args) { int larger = max(30, 40, 50, 60); //... } "},{"id":212,"href":"/database/mysql/advanced-feature/mysql-index/","title":"索引","section":"高级特性","content":"\r索引\r#\r定义\r#\r索引是一种特殊的文件，它们包含着对所有记录的引用指针 优点：类似书的目录，可以极大地提高数据检索速度 缺点：维护索引会增加额外的开销 原则\r#\r最左侧原则：表的最左侧的一列，往往数据不会发生改变，不影响其他列的数据 命名短小原则：索引命名过长会使索引文件变大，损耗内存 分类\r#\r普通索引：最基本的索引，没有任何限制 唯一索引：索引列的值必须唯一 ，允许有空值 主键索引：一种特殊的唯一索引，一张表中只能定义一个，用来标识一条数据，不能为空 全文索引：仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时耗空间 聚合索引：覆盖多个数据列的索引 实现\r#\rB-Tree：比较适合用作\u0026rsquo;\u0026gt;\u0026lsquo;或\u0026rsquo;\u0026lt;\u0026lsquo;这样的范围查询，在MySQL中最为常用 R-Tree：用于处理多维数据的数据结构，可以对地理数据进行空间索引。运用较少 Hash：使用散列表来对数据进行索引。效率高于B-Tree，但是不支持范围查找和排序。运用较少 FullText：全文索引，是一种记录关键字与对应文档关系的倒排索引。 "},{"id":213,"href":"/program-lang/web/html/table/","title":"表格标签","section":"HTML","content":"\r表格标签\r#\r标签 说明 \u0026lt;table\u0026gt; 定义表格 \u0026lt;tr\u0026gt; 定义表格行 \u0026lt;td\u0026gt; 定义表格单元格 \u0026lt;th\u0026gt; 定义表头单元格 \u0026lt;caption\u0026gt; 定义表格标题 \u0026lt;thead\u0026gt; 定义表格页眉 \u0026lt;tbody\u0026gt; 定义表格主体 \u0026lt;tfoot\u0026gt; 定义表格页脚 标签属性\r#\r\u0026lt;table\u0026gt;\nwidth：表格宽度 border：边框宽度 cellspacing：单元格间距 cellpadding：单元格与内容间距 \u0026lt;td\u0026gt;、\u0026lt;th\u0026gt;\ncolspan：单元格横跨几列 rowspan：单元格横跨几行 共同属性\r#\r属性\r属性值\r属性值说明\r水平对齐：align\rleft\r左对齐（默认）\rright\r右对齐\rcenter\r居中对齐\rjustify\r拉伸对齐\rchar\r对齐指定字符\r垂直对齐：valign\rtop\r顶部对齐（默认）\rmiddle\r居中对齐\rbottom\r底部对齐\rbaseline\r基线对齐\r示例\r#\r\u0026lt;table border=\u0026#34;1\u0026#34; width=\u0026#34;70%\u0026#34; cellspacing=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;caption\u0026gt;表格标题\u0026lt;/caption\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;北京\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;上海\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;广州\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;...\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;...\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;...\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; "},{"id":214,"href":"/service-manage/deprecated-frame/config/","title":"Config","section":"日落组件","content":"\rConfig\r#\rConfig\r#\r配置中心 为微服务框架中的微服务提供统一的外部配置支持 工作原理\r#\rConfig Server：分布式配置中心，它是一个独立的微服务，用来连接配置服务器并为客户端提供配置信息 Config Client：通过配置中心，获取对应的配置来管理应用。 "},{"id":215,"href":"/service-manage/dubbo/","title":"Dubbo","section":"服务治理","content":"\rDubbo\r#\r是一款高性能、轻量级的开源Java RPC框架 Dubbo \u0026amp; Spring Cloud\r#\rDubbo Spring Cloud 所属厂商 阿里系的分布式服务治理框架 Apache 旗下的 Spring 体系下的微服务解决方案 通信机制 RPC 通信 基于 HTTP 的 REST 方式 技术维度 只是实现了服务治理 覆盖了微服务架构下的方方面面 "},{"id":216,"href":"/program-lang/java/thread/lock/LockSupport/","title":"LockSupport","section":"锁体系","content":"\rLockSupport\r#\r"},{"id":217,"href":"/program-design/design-pattern/structural/06-proxy/","title":"代理模式","section":"结构型","content":"\r代理模式\r#\r概述\r#\r英文：Proxy Pattern 简述：为其他对象提供一种代理以控制对这个对象的访问 归纳：没有资源没时间，得找别人来帮忙 目的：增强职责 案例：媒婆 示例\r#\r类型 区别 静态代理 手动生成代理类 动态代理 运用反射机制，动态生成代理类 JDK 动态代理 只能代理实现了接口的类 CGLib 动态代理 对目标类生成一个子类，并覆盖其中方法实现增强。 但因为采用的是继承，所以不能对final修饰的类进行代理 静态代理\r#\r// 被代理目标类 public interface Wow { void tbc(); } public class Blizzard implements Wow { @Override public void tbc() { System.out.println(\u0026#34;《魔兽世界》：燃烧的远征\u0026#34;); } } // 代理类 public class NetEasy implements Wow { private Blizzard blizzard; // 传递被代理对象 public NetEasy(Blizzard blizzard) { this.blizzard = blizzard; } // 控制被代理对象的行为 @Override public void tbc() { System.out.println(\u0026#34;网易代理《魔兽世界》开始\u0026#34;); blizzard.tbc(); System.out.println(\u0026#34;网易代理《魔兽世界》结束\u0026#34;); } } public class Test { public static void main(String[] args) { Wow wow = new NetEasy(new Blizzard()); wow.tbc(); } } 动态代理（JDK）\r#\rpublic class ProxyHandler implements InvocationHandler { private Object target; // 获取被代理对象 public Object newProxyInstance(Object target) { this.target = target; return Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); } // 操作被代理对象的行为 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\u0026#34;JDK：动态代理开始\u0026#34;); Object result = method.invoke(target, args); System.out.println(\u0026#34;JDK：动态代理结束\u0026#34;); return result; } } public class Test { public static void main(String[] args) { ProxyHandler handler = new ProxyHandler(new Blizzard()); Wow wow = (Wow) handler.newProxyInstance(); wow.tbc(); } } 动态代理（CGLIB）\r#\rpublic class CglibInterceptor implements MethodInterceptor { private Enhancer enhancer = new Enhancer(); // 获取被代理对象 public Object newProxyInstance(Class\u0026lt;?\u0026gt; clazz) { enhancer.setSuperclass(clazz); enhancer.setCallback(this); return enhancer.create(); } // 操作被代理对象的行为 @Override public Object intercept( Object target, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(\u0026#34;CGLIB：动态代理开始\u0026#34;); Object result = methodProxy.invokeSuper(target, args); System.out.println(\u0026#34;CGLIB：动态代理结束\u0026#34;); return result; } } public class Test { public static void main(String[] args) { CglibInterceptor interceptor = new CglibInterceptor(); Wow wow = (Wow) interceptor.newProxyInstance(Blizzard.class); wow.tbc(); } } 应用\r#\r主要解决： 直接访问对象时带来的问题（安全控制、进程外访问、对象创建开销大） 应用场景： Spring AOP、Windows 快捷方式 注意事项： 适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口 装饰器模式为了增强功能，而代理模式是为了加以控制 "},{"id":218,"href":"/program-base/linux/cmd/other/","title":"其他","section":"常用命令","content":"\r其他\r#\r"},{"id":219,"href":"/program-design/data-algorithm/sort/shell/","title":"希尔排序","section":"排序","content":"\r希尔排序\r#\r希尔排序\r#\r是插入排序的改进版本。 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序 待整个序列中的记录\u0026quot;基本有序\u0026quot;时，再对全体记录进行依次直接插入排序。 算法步骤\r#\r选择一个增量序列 t1，t2，……，tk，其中 ti \u0026gt; tj, tk = 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。 仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 动图演示\r#\r代码实现\r#\rpublic class ShellSort implements IArraySort { @Override public int[] sort(int[] arr) throws Exception { int length = arr.length; int temp; for (int step = length / 2; step \u0026gt;= 1; step /= 2) { for (int i = step; i \u0026lt; length; i++) { temp = arr[i]; int j = i - step; while (j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; temp) { arr[j + step] = arr[j]; j -= step; } arr[j + step] = temp; } } } } "},{"id":220,"href":"/program-design/data-structure/tree/","title":"树","section":"数据结构","content":"\r树\r#\r树\r#\rTree 是由结点和边组成的，不存在环的一种数据结构 是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合 特点\r#\r每个结点有零个或多个子结点 没有父结点的结点称为根结点 每一个非根结点有且只有一个父结点 除了根结点外，每个子结点可以分为多个不相交的子树 术语\r#\r度：结点的子树数目，如图：结点B的度为2 树的度：树中结点的最大度数，如图：树的度为3 树的深度：树中结点的最大层数，如图：树的深度为4 相互关系：祖先、后代、父子、兄弟 分支结点：度大于零的结点 叶子结点：度等于零的结点 分类\r#\r二叉树：一个结点最多只有两个子结点 满二叉树：除了最后一层，其它层的结点都有两个子结点 完全二叉树：除了最后一层，其他层的结点个数都要达到最大，且最后一层的结点从左到右排列 平衡二叉树：任意结点都满足：左右子树的高度差不大于1 二叉搜索树：任意结点都满足：左子结点 \u0026lt; 父结点 \u0026lt; 右子结点 树的遍历\r#\r前序遍历：根结点 ==\u0026gt; 左子树 ==\u0026gt; 右子树 中序遍历：左子树 ==\u0026gt; 根结点 ==\u0026gt; 右子树 后序遍历：左子树 ==\u0026gt; 右子树 ==\u0026gt; 根结点 依据【根结点】位置确定前/中/后序 "},{"id":221,"href":"/program-lang/java/thread/threadpool/","title":"线程池","section":"多线程","content":"\r线程池\r#\r一个容纳了多个线程的容器，里面的线程可以反复使用，避免频繁创建销毁线程。 作用\r#\r降低资源消耗 通过重复利用，降低线程创建和销毁造成的消耗 提高响应速度 当任务到达时，任务可以不需要等到线程创建就能立即执行 提高线程的可管理性 线程是稀缺资源，使用线程池可以进行统一分配，调优和监控 "},{"id":222,"href":"/interview/core/06-jvm/","title":"虚拟机","section":"重点面试题","content":"\r\u0026ndash; JVM 的组成部分，运行流程是什么？\r#\rJava Virtual Machine，Java程序的运行环境 好处：一次编写，到处运行，自动内存管理，垃圾回收机制 主要组成部分： 1. 类加载器，ClassLoader 2. 运行时数据区，Runtime Data Area 3. 执行引擎，Execution Engine 4. 本地库接口，Native Method Library 运行流程： 1. 类加载器把Java代码转换为字节码 2. 运行时数据区把字节码加载到内存中 3. 执行引擎将字节码翻译为底层系统指令，再交由CPU执行去执行， 4. 此时需要调用其他语言的本地库接口（Native Method Library）来实现整个程序的功能。 \u0026ndash; JVM 的内存结构？\r#\r\u0026ndash; JVM 的程序计数器？\r#\r线程私有的，每个线程一份。 内部保存的是字节码的行号，用于记录正在执行的字节码指令的地址。 是JVM规范中唯一一个没有规定出现OOM的区域，所以这个空间也不会进行GC。 \u0026ndash; JVM 的堆内存？\r#\r1. 堆是内存中一块线程共享的区域，主要用来保存对象实例，数组等 2. 当内存不够则抛出OutOfMemoryError异常 3. 堆内存又分为年轻代和老年代， 年轻代被划分为三部分，Eden区和两个大小严格相同的Survivor区 老年代主要保存生命周期长的对象，一般是一些老的对象 堆在JDK1.7和1.8中的区别 1.7中有一个永久代，存储的是类信息、静态变量、常量、编译后的代码 1.8移除了永久代，把数据存储到了本地内存的元空间中，防止内存溢出 \u0026ndash; JVM 的虚拟机栈？\r#\r什么是虚拟机栈？ 每个线程运行时所需要的内存，称为虚拟机栈 每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法 垃圾回收是否涉及栈内存？ 垃圾回收主要指就是堆内存，当栈帧弹栈以后，内存就会释放 栈内存分配越大越好吗？ 未必，默认的栈内存通常为1024k，栈帧过大会导致线程数变少 方法内的局部变量是否线程安全？ 如果方法内局部变量没有逃离方法的作用范围，它是线程安全的 如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全 什么情况下会导致栈内存溢出？ 栈帧过多导致栈内存溢出，典型问题：递归调用 栈帧过大导致栈内存溢出 \u0026ndash; JVM 的方法区？\r#\r方法区(Method Area)，是各个线程共享的内存区域 主要存储类的信息、运行时常量池，虚拟机启动的时候创建，关闭虚拟机时释放 如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError: Metaspace 介绍一下运行时常量池？ 可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息 当类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址 \u0026ndash; 堆和栈的区别？\r#\r1. 堆内存是用来存储Java对象和数组的的，会进行GC垃圾回收 栈内存一般会用来存储局部变量和方法调用，不会进行GC垃圾回收 2. 栈内存是线程私有的，而堆内存是线程共有的。 3. 两者异常错误不同，如果栈内存或者堆内存不足都会抛出异常。 堆空间不足：java.lang.OutOfMemoryError。 栈空间不足：java.lang.StackOverFlowError。 \u0026ndash; 说一下直接内存？\r#\r并不属于JVM中的内存结构，不由JVM进行管理。是虚拟机的系统内存 常见于 NIO 操作时，用于数据缓冲区，分配回收成本较高，但读写性能高，不受JVM内存回收管理 \u0026ndash; 什么是类加载器？\r#\rJVM只会运行二进制文件， 类加载器的作用就是将字节码文件加载到JVM中，从而让Java程序能够启动起来。 类加载器有哪些？ 1. 启动类加载器，BootStrap ClassLoader\t用于加载JAVA_HOME/jre/lib目录下的类库 2. 扩展类加载器，ExtClassLoader\t用于加载JAVA_HOME/jre/lib/ext目录中的类 3. 应用类加载器，AppClassLoader\t用于加载classPath下的类，也就是加载开发者自己编写的Java类 4. 自定义类加载器，CustomizeClassLoader\t自定义类继承ClassLoader，实现自定义类加载规则。 \u0026ndash; 什么是双亲委派机制？\r#\r一个类加载器在接到加载类的请求时，会先把任务委托给父加载器， 如果父加载器也有父加载器，则会继续向上委托，直至传递到顶层的启动类加载器 只有父加载器无法完成此加载任务时，才由下一级加载器去加载。 为什么采用双亲委派机制？ 1. 避免类的重复加载，保证类的唯一性 2. 避免Java的核心API被篡改 3. Java类随着类加载器一起具备了带有优先级的层级关系 \u0026ndash;说一下类加载的过程？\r#\r1. 加载\t查找和导入class文件 2. 验证\t保证加载类的准确性 3. 准备\t为类变量分配内存并设置类变量初始值 4. 解析\t把类中的符号引用转换为直接引用 5. 初始化\t对类的静态变量，静态代码块执行初始化操作 6. 使用\tJVM 开始从入口方法开始执行用户的程序代码 7. 卸载\t用户程序代码执行完毕后，JVM便开始销毁创建的Class对象。 \u0026ndash; 简述 Java 垃圾回收机制？（GC是什么？为什么要GC）\r#\rGC，Garbage Collection，即垃圾回收 Java提供了自动垃圾回收机制，为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题。 有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。 \u0026ndash; 对象什么时候可以被垃圾器回收？\r#\r如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾， 如果定位了垃圾，则有可能会被垃圾回收器回收。 引用计数法： 一个对象被引用了一次，在当前的对象头上递增一次引用次数。如果这个对象的引用次数为0，代表对象可回收。 当对象间出现了循环引用的话，则引用计数法就会失效 可达性分析法： 扫描堆中的对象，看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到表示对象可回收 哪些对象可以作为 GC Root ? 1. 方法区中类静态属性引用的对象 2. 方法区中常量引用的对象 3. 虚拟机栈（栈帧中的本地变量表）中引用的对象 4. 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象 \u0026ndash; 垃圾回收算法有哪些？\r#\r标记清除算法： 垃圾回收分为2个阶段，分别是标记和清除 效率高,有磁盘碎片，内存不连续 标记整理算法： 标记清除算法一样，将存活对象都向内存另一端移动，然后清理边界以外的垃圾， 无碎片，对象需要移动，效率低 复制算法： 将原有的内存空间一分为二，每次只用其中的一块，正在使用的对象复制到另一个内存空间中， 然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收; 无碎片，内存使用率低 \u0026ndash; 说一下JVM中的分代回收\r#\r堆的区域划分： 1. 堆被分为了两份：新生代和老年代比例是1:2 2. 对于新生代，内部又被分为了三个区域。Eden区，幸存者区survivor(分成from和to)比例是8:1:1 对象分代回收策略： 1. 新创建的对象，都会先分配到eden区 2. 当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象 3. 将存活对象采用复制算法复制到to中，复制完毕后，伊甸园和 from 内存都得到释放 4. 经过一段时间后伊甸园的内存又出现不足，标记eden区域to区存活的对象，将其复制到from区 5. 当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会提前晋升） \u0026ndash; MinorGC、 Mixed GC 、 FullGC的区别是什么\r#\rMinorGC： 即youngGC，发生在新生代的垃圾回收，暂停时间短（STW） MixedGC： 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有 FullGC： 新生代 + 老年代完整垃圾回收，暂停时间长（STW），应尽力避免 \u0026ndash; JVM 有哪些垃圾回收器？\r#\r串行垃圾收集器：Serial、Serial Old 并行垃圾收集器：ParNew、Parallel Old 并发垃圾收集器：CMS，作用在老年代 G1垃圾收集器：作用在新生代和老年代 \u0026ndash; 说一下 G1 垃圾回收器？\r#\r1. 应用于新生代和老年代，在JDK9之后默认使用G1 2. 划分成多个区域，每个区域都可以充当eden，survivor，old， humongous，其中 humongous 专为大对象准备 3. 采用复制算法 4. 响应时间与吞吐量兼顾 5. 分成三个阶段：新生代回收(stw)、并发标记(重新标记stw)、混合收集 6. 如果并发失败（即回收速度赶不上创建新对象速度），会触发FullGC \u0026ndash; Java 的四种引用类型？\r#\r强引用：最常见的引用类型，引用存在时，对象不会被回收 软引用：适用于内存敏感的缓存，当内存不足时，对象才会被回收 弱引用：适用于非重要对象，当垃圾收集器运行时，对象就可能被回收 虚引用：适用于对象回收跟踪，就和没有引用一样，在任何时候都可能被回收 // 强引用 String strongRef = new String(\u0026#34;abc\u0026#34;); // 软引用 SoftReference\u0026lt;String\u0026gt; softRef = new SoftReference\u0026lt;\u0026gt;(\u0026#34;abc\u0026#34;); // 弱引用 WeakReference\u0026lt;String\u0026gt; weakRef = new WeakReference\u0026lt;\u0026gt;(\u0026#34;abc\u0026#34;); // 虚引用 ReferenceQueue queue = new ReferenceQueue(); PhantomReference phantomRef = new PhantomReference(\u0026#34;abc\u0026#34;, queue); \u0026ndash; JVM 调优的参数可以在哪里设置？\r#\r1. 用war进行包部署时，在tomcat中设置 修改TOMCAT_HOME/bin/catalina.sh文件 2. 用jar包进行部署时，在启动参数设置 java -Xms512m -Xmx1024m -jar xxxx.jar \u0026ndash; JVM 调优的参数都有哪些？\r#\r-Xms1024m\t# 设置堆的初始内存大小 -Xmx1024m\t# 设置堆的最大内存大小 -Xss256k\t# 设置每个线程的堆栈大小 -XX:+UseG1GC\t# 启用G1垃圾回收器 -XX:+UseParallelGC\t# 启用并行垃圾回收器 -XXSurvivorRatio=8\t# 设置年轻代中Eden区和两个Survivor区的大小比例 -XX:MaxTenuringThreshold=10\t# 设置对象由年轻代晋升到老年代的阈值 \u0026ndash; JVM 调优的工具？\r#\r命令工具 jps\t查看JVM中运行的进程状态信息 jstack\t查看java进程内线程的堆栈信息。 jmap\t用于生成堆转储快照dump文件，及查看内存使用情况 jstat\tJVM统计监测工具，可以用来显示垃圾回收信息、类加载信息、新生代统计信息等。 jps jstack pid jmap -heap pid\t# 查看堆内存信息 jmap -dump:format=b,file=d:/heap.hprof pid\t# 生成dump文件 jstat -gcutil pid\t# 查看汇总垃圾回收信息 jstat -gc pid\t# 查看垃圾回收统计信息 可视化工具 jconsole\t用于对jvm的内存，线程，类的监控 VisualVM\t能够监控线程，内存情况 \u0026ndash; Java 内存泄露的排查思路？\r#\r堆：\tOutOfMemoryError:java heap space 元空间：\tOutOfMemoryError:Metaspace 虚拟机栈：\tStackOverFlowError 1. 获取dump文件 如果程序还在运行，则通过jmap命令，生成dump文件 如果程序已经中断，则可以通过配置启动参数，生成dump文件 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/app/dumps/ 2. 分析dump文件 使用VisualVM工具去分析dump文件 通过查看堆信息，定位问题代码 3. 修复问题 找到对应的代码，通过阅读上下文的情况，进行修复 \u0026ndash; CPU 飙高排查方案与思路？\r#\r1. 使用top命令，查看各个进程的cpu占用情况，找到占用较高的进程id 2. 使用ps命令，查看进程信息，找到占用较高的线程id 3. 使用jstack命令，查看进程内线程的堆栈信息 4. 最终定位问题 top ps H -eo pid,tid,%cpu | grep 40940\t# 40940为进程id jstack 40940\t# jstack打印的是进程内全部线程的堆栈信息，需要根据线程id（先转16进制）找到对应线程的堆栈信息 "},{"id":223,"href":"/program-lang/web/html/form/","title":"表单标签","section":"HTML","content":"\r\u0026lt;form\u0026gt;\r#\r属性 描述 accept-charset 字符集 action 提交目的地 URL method 提交方式，get、post target 打开方式，_blank 、_self、 _parent 、_top \u0026lt;form action=\u0026#34;xxx.php\u0026#34; method=\u0026#34;get\u0026#34;\u0026gt; 姓名：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; size=\u0026#34;15\u0026#34; placeholder=\u0026#34;请输入姓名\u0026#34; /\u0026gt; 密码：\u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;pwd\u0026#34; maxlength=\u0026#34;8\u0026#34; placeholder=\u0026#34;请输入密码\u0026#34; /\u0026gt; 照片：\u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;pic\u0026#34; /\u0026gt; 性别： \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;man\u0026#34; checked/\u0026gt;男 \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;woman\u0026#34; /\u0026gt;女 爱好： \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;read\u0026#34; checked/\u0026gt;读书 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;dance\u0026#34; /\u0026gt; 跳舞 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;sing\u0026#34; /\u0026gt; 唱歌 城市: \u0026lt;select name=\u0026#34;city\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;0\u0026#34; selected\u0026gt;__请选择__\u0026lt;/option\u0026gt; \u0026lt;optgroup label=\u0026#34;北方\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;bj\u0026#34;\u0026gt;北京\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;tj\u0026#34;\u0026gt;天津\u0026lt;/option\u0026gt; \u0026lt;/optgroup\u0026gt; \u0026lt;optgroup label=\u0026#34;南方\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;gz\u0026#34;\u0026gt;广州\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;sz\u0026#34;\u0026gt;深圳\u0026lt;/option\u0026gt; \u0026lt;/optgroup\u0026gt; \u0026lt;/select\u0026gt; 备注： \u0026lt;textarea name=\u0026#34;tips\u0026#34; cols=\u0026#34;5\u0026#34; rows=\u0026#34;5\u0026#34;\u0026gt; 这是一段多行文字 \u0026lt;/textarea\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;input\u0026gt;\r#\rtype 描述 hidden 隐藏 text 文本域 password 密码域 radio 单选框 checkbox 复选框 file 文件输入框 image 图片输入框 button 按钮 reset 重置按钮 submit 提交按钮 \u0026lt;select\u0026gt;\r#\r定义下拉列表 \u0026lt;select name=\u0026#34;cars\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;volvo\u0026#34;\u0026gt;Volvo\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;saab\u0026#34;\u0026gt;Saab\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;fiat\u0026#34;\u0026gt;Fiat\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;audi\u0026#34;\u0026gt;Audi\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;textarea\u0026gt;\r#\r定义多行文本 \u0026lt;textarea name=\u0026#34;message\u0026#34; rows=\u0026#34;10\u0026#34; cols=\u0026#34;30\u0026#34;\u0026gt; The cat was playing in the garden. \u0026lt;/textarea\u0026gt; \u0026lt;button\u0026gt;\r#\r定义按钮 \u0026lt;button type=\u0026#34;button\u0026#34; onclick=\u0026#34;alert(\u0026#39;Hello World!\u0026#39;)\u0026#34;\u0026gt; Click Me! \u0026lt;/button\u0026gt; \u0026lt;datalist\u0026gt;\r#\r定义选项列表 \u0026lt;input list=\u0026#34;browsers\u0026#34; name=\u0026#34;browser\u0026#34;\u0026gt; \u0026lt;datalist id=\u0026#34;browsers\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;Internet Explorer\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;Firefox\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;Chrome\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;Opera\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;Safari\u0026#34;\u0026gt; \u0026lt;/datalist\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; 其他\r#\rtype 描述 number 数值输入框 date 日期输入框 color 颜色输入框 range 范围输入框 month 年月输入框 week 年周输入框 time 时间输入框，无时区 datetime 时间输入框，有时区 datetime-local 时间输入框，日期和时间 email 邮箱输入框 tel 电话输入框 url url输入框 search 搜索框 \u0026hellip;\u0026hellip; 更多类型 "},{"id":224,"href":"/database/mysql/advanced-feature/view/","title":"视图","section":"高级特性","content":"\r视图\r#\r定义\r#\r视图是一种虚拟存在的表，对于使用视图的用户来说基本上是透明的 视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成 优点\r#\r简单：视图中数据即为目标数据，用户不需要关心对应的表的结构 安全：使用视图，可以限制用户只能访问他们被允许查询的结果集 数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响 视图管理\r#\r# 创建视图 create view 视图名 as select指令; # 使用视图 # 视图是一张虚拟表，可以直接把视图当做“表”来操作。 # 修改视图 alter view 视图名字 as 新select指令; # 删除视图 drop view 视图名; "},{"id":225,"href":"/database/oracle/plsql/object-oriented/","title":"面向对象","section":"PL/SQL","content":"\r面向对象\r#\r"},{"id":226,"href":"/database/mysql/advanced-feature/transaction/","title":"事务","section":"高级特性","content":"\r事务\r#\r定义\r#\rTransaction，一个最小的不可再分的工作单元，通常对应一个完整的业务 由事务开始和事务结束之间执行的全体操作组成 事务特性：ACID\r#\r原子性：Atomicity，事务应该当作一个单独单元的操作，要么成功，要么失败 一致性：Consistency，事务的执行不能破坏数据库数据的完整性和一致性 隔离性：Isolation，并发事务执行之间无影响 持久性：Durability，事务一旦执行成功，它对数据库的数据的改变必须是永久的 事务并发问题\r#\r脏读 一个事务处理过程里读取了另一个未提交的事务中的数据。 不可重复读 在一个事务中，对同一条记录，多次查询到的数据值不一致。（针对 update） 幻读 在一个事务中，对于多条记录，多次查询到的记录条数不一致。（针对 insert） 隔离级别\r#\r级别 隔离级别 描述 脏读 不可重复读 幻读 级别一 读未提交 可以读取到其他事务未提交的内容 √ √ √ 级别二 读已提交 只能读取到其他事务已经提交的数据 × √ √ 级别三 可重复读 整个事务过程中，对同数据的多次读取结果是相同的 × × √ 级别四 串行化 所有事务操作都依次顺序执行，性能最差 × × × 事务管理\r#\r# 开始一个事务 begin # 事务回滚 rollback # 事务确认 commit # 增加回滚点 savepoint 回滚点名; # 回到回滚点 rollback to 回滚点名; -- 创建数据表 create table runoob_transaction_test( id int(5)) engine=innodb; -- 开启事务 begin; -- 事务操作 insert into runoob_transaction_test value(5); insert into runoob_transaction_test value(6); -- 回滚事务 -- rollback; -- 提交事务 commit; "},{"id":227,"href":"/program-design/data-structure/heap/","title":"堆","section":"数据结构","content":"\r堆\r#\r堆\r#\rHeap 堆是一颗用数组实现的完全二叉树 堆中某个结点的值总是不大于或不小于其父结点的值 "},{"id":228,"href":"/interview/core/07-collection/","title":"常见集合","section":"重点面试题","content":"\r\u0026ndash; 数组\r#\r数组： Array，是一种用连续的内存空间存储相同数据类型数据的线性数据结构。 数组下标为什么从0开始？ 1. 寻址公式是：数组的首地址 + 索引 x 存储数据的类型大小 2. 在根据索引获取元素的时候，会用寻址公式来计算内存地址， 3. 如果数组的索引从1开始，寻址公式中，就需要增加一次减法操作，对于CPU来说就多了一次指令，性能不高。 数组的时间复杂度？ O(1)\t查询，已知下标 O(n)\t查询，未知下标 O(logn)\t查询，未知下标且数组有序 O(n)\t插入和删除（为了保证数组的内存连续性，需要挪动数组元素） \u0026ndash; 链表\r#\r单向链表： 物理存储单元上，非连续、非顺序的存储结构 链表中的每一个元素称之为结点，每个结点包括两个部分：存储数据元素的数据域、存储下一个结点地址的指针域 单向链表的时间复杂度？ O(n)\t查询操作 O(n)\t插入和删除操作（需要先遍历链表找到对应节点） 双向链表： 相比于单向链表，双向链表每个结点多包含一个前驱指针，指向上一个结点 时间复杂度与单向链表一样 对比单向链表： 双向链表需要额外的两个空间来存储后继结点和前驱结点的地址 支持双向遍历，这样也带来了双向链表操作的灵活性 \u0026ndash; ArrayList 底层原理？\r#\r1. 底层数据结构 ArrayList底层是用动态的数组实现的 2. 初始容量 初始容量为0，当第一次添加数据的时候才会初始化容量为10 3. 扩容逻辑 按原来容量的1.5倍进行扩容，每次扩容都需要拷贝数组 4. add()逻辑 计算数组新增一个元素后的新长度 如果新长度大于当前数组的容量，则调用grow()方法进行扩容（1.5倍） 确保数组能够保存新元素后，将新元素添加到size的位置上 返回true \u0026ndash; 如何实现数组和List之间的转换?\r#\r1. 数组转List 使用JDK中java.util.Arrays工具类的asList()方法 2. List转数组 使用List的toArray()方法。 无参toArray()方法返回 Object数组，传入初始化长度的数组对象，返回该对象数组 1. 用Arrays.asList转List后，如果修改了数组内容，list受影响吗? list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合， 在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址 2. List用toArray转数组后，如果修改了List内容，数组受影响吗? 数组不会受影响， 当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了 \u0026ndash; ArrayList、LinkedList 的区别？\r#\r底层数据结构\tArrayList 是动态数组的数据结构实现 LinkedList 是双向链表的数据结构实现 操作数据效率\tArrayList支持按照下标查询，LinkedList不支持下标查询 查找（未知索引）： 两者都需要遍历，时间复杂度都是O(n) 新增和删除，ArrayList需要挪动数组，LinkedList需要遍历链表，时间复杂度都是O(n) 内存空间占用\tArrayList底层是数组，内存连续，节省内存 LinkedList底层是双向链表，需要存储数据和两个指针，更占用内存 线程安全\tArrayList和LinkedList都不是线程安全的，如果需要保证线程安全，有两种方案： 1. 在方法内使用，局部变量则是线程安全的 2. 使用Collections.synchronizedList()方法进行包装 \u0026ndash; 二叉树\r#\r二叉树\t是一种树形数据结构，其中每个节点最多有两个子节点，通常称为左子节点和右子节点。 二叉搜索树\t是一种特殊的二叉树，其时间复杂度为O(logn)，具有以下性质： 1. 对于每个节点，其左子树中的所有节点值小于该节点的值。 2. 对于每个节点，其右子树中的所有节点值大于该节点的值。 红黑树\t是一种自平衡的二叉搜索树，其时间复杂度为O(logn)，具有以下性质： 1. 节点要么是红色,要么是黑色 2. 根节点是黑色 3. 叶子节点都是黑色的空节点 4. 红黑树中红色节点的子节点都是黑色 5. 从任一节点到叶子节点的所有路径都包含相同数目的黑色节点 在添加或删除节点的时候，如果不符合这些性质会发生旋转，以达到所有的性质，保证红黑树的平衡 \u0026ndash; 散列表\r#\r散列表： Hash Table，名哈希表/Hash表 根据键（Key）直接访问在内存存储位置值（Value）的数据结构 由数组演化而来的，利用了数组支持按照下标进行随机访问数据 散列冲突： 又称哈希冲突，哈希碰撞，指多个key映射到同一个数组下标位置 散列冲突-链表法（拉链）： 数组的每个下标位置称之为桶（bucket），每个桶(槽)会对应一条链表 hash冲突后的元素都放到相同槽位对应的链表中或红黑树中 \u0026ndash; HashMap 的实现原理？\r#\r1. 底层使用的数据结构是：数组+链表+红黑树 2. 当往HashMap中put元素时，利用key的hashCode重新hash，计算出当前元素在数组中的下标 a. 如果key相同，则覆盖原始值； b. 如果key不同，即出现了哈希冲突，则将当前的key-value放入链表或红黑树中 3. 获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。 \u0026ndash; HashMap 的jdk1.7和jdk1.8有什么区别？\r#\rJDK1.8之前采用的是拉链法，将链表和数组相结合。 也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。 JDK1.8在解决哈希冲突时有了较大的变化， 当链表长度大于阈值（默认为8） 时并且数组长度达到64时，将链表转化为红黑树，以减少搜索时间。 扩容resize() 时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表 \u0026ndash; HashMap 的常见属性？\r#\r// 默认的初始容量：16 static final int DEFAULT_INITIAL_CAPACITY = 1 \u0026lt;\u0026lt; 4; // 默认的加载因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 数组 transient HashMap.Node\u0026lt;K,V\u0026gt;[] table; // 数组长度 transient int size; // 结点结构 static class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { final int hash; final K key; V value; Node\u0026lt;K,V\u0026gt; next; //... } \u0026ndash; HashMap 的put()方法的具体流程?\r#\r1. 判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化） 2. 根据键值key计算hash值得到数组索引 3. 判断table[i]==null，条件成立，直接新建节点添加 4. 如果table[i]==null，不成立 - 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value - 判断table[i]是否是红黑树，如果是红黑树，则直接在树中插入键值对 - 遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8， 大于8的话把链表转换为红黑树，在红黑树中执行插入操作，遍历过程中若发现key已经存在直接覆盖value 5. 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组容量*加载因子），如果超过，进行扩容。 \u0026ndash; HashMap 的扩容机制？\r#\r1. 在添加元素或初始化的时候需要调用resize方法进行扩容， 第一次添加数据，初始化数组长度为16，以后每次扩容都是达到了扩容阈值（数组容量 * 加载因子0.75） 2. 每次扩容的时候，都是扩容之前容量的2倍； 3. 扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中 - 没有hash冲突的节点，则直接使用 e.hash \u0026amp; (newCap - 1) 计算新数组的索引位置 - 如果是红黑树，走红黑树的添加 - 如果是链表，则需要遍历链表，可能需要拆分链表， 判断(e.hash \u0026amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上 \u0026ndash; hashMap 的寻址算法?\r#\r1. 首先获取key对象的hashCode()， 2. 再调用hash()方法进行二次哈希，让哈希分布更为均匀 哈希值与右移16位的哈希值进行异或运算：(h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16) 3. 最后 (capacity – 1) \u0026amp; hash 得到数组下标 \u0026ndash; 为何 HashMap 的数组长度一定是2的次幂？\r#\r1. 计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模 2. 扩容时重新计算索引效率更高： hash \u0026amp; oldCap == 0 的元素留在原来位置 ，否则新位置 = 旧位置 + oldCap \u0026ndash; HashMap 在JDK1.7情况下的多线程死循环问题?\r#\r在jdk1.7的HashMap中，数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环 比如说，现在有两个线程 线程一：读取到当前的hashmap数据，数据中一个链表，在准备扩容时，线程二介入 线程二：也读取hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。 比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。 线程一：继续执行的时候就会出现死循环的问题。 线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，所以B-\u0026gt;A-\u0026gt;B,形成循环。 当然，JDK 8 将扩容算法换成了尾插法，不再将元素加入链表头（而是保持与扩容前一样的顺序），就避免了死循环的问题。 \u0026ndash; HashSet 与 HashMap 的区别?\r#\r1. HashSet实现了Set接口, 仅存储对象; HashMap实现了Map接口, 存储的是键值对. 2. HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法。 依靠HashMap的key键进行存储, 而value值默认为Object对象。 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同。 \u0026ndash; HashTable 与 HashMap 的区别？\r#\r区别 HashTable HashMap 数据结构 数组+链表 数组+链表+红黑树 是否可以为null Key和value都不能为null 可以为null hash算法 key的hashCode() 二次hash 扩容方式 当前容量翻倍 +1 当前容量翻倍 线程安全 同步(synchronized)的，线程安全 非线程安全 "},{"id":229,"href":"/program-design/design-pattern/structural/07-bridge/","title":"桥接模式","section":"结构型","content":"\r桥接模式\r#\r概述\r#\r英文：Bridge Pattern 简述：将两个能够独立变化的部分分离开来 归纳：约定优于配置 目的：不允许用继承 案例：桥 示例\r#\r// 品牌 public interface Brand { void sale(); } // 类似品牌：Shenzhou、Huawei public class Dell implements Brand { @Override public void sale() { System.out.println(\u0026#34;出售戴尔\u0026#34;); } } // 电脑 public class Computer { protected Brand brand; public Computer(Brand brand) { this.brand = brand; } public void sale(){ brand.sale(); } } // 类似电脑：Laptop public class Desktop extends Computer { public Desktop(Brand b) { super(b); } @Override public void sale() { super.sale(); System.out.println(\u0026#34;出售台式电脑\u0026#34;); } } public class Test { public static void main(String[] args) { Computer c = new Desktop(new Dell()); c.sale(); } } 应用\r#\r核心要点： 处理多维度变化的场景，将各个维度设计成独立的继承结构，桥接各个维度为一体 主要解决： 在多维度变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活 注意事项： 对于两个独立变化的维度，适合使用桥接模式 "},{"id":230,"href":"/database/oracle/plsql/trigger/","title":"触发器","section":"PL/SQL","content":"\r触发器\r#\r触发器\r#\r是一种特殊类型的存储过程，通过触发数据库特定事件而自动运行。 创建触发器\r#\r-- 语法 CREATE [OR REPLACE ] TRIGGER trigger_name {BEFORE | AFTER | INSTEAD OF } -- 指定何时执行触发器。INSTEAD OF 子句用于视图 {INSERT [OR] | UPDATE [OR] | DELETE} -- 指定 DML 操作类型 [OF col_name] -- 指定将要更新的列 ON tbl_name -- 指定与触发器关联的表 [REFERENCING OLD AS o NEW AS n] -- 允许各种 DML 语句引用新值和旧值 [FOR EACH ROW] -- 行触发器：作用于每一行（否则仅执行一次，即表触发器） WHEN (condition) -- 为触发器触发的行提供一个条件。仅对行级触发器有效 DECLARE Declaration-statements BEGIN Executable-statements EXCEPTION Exception-handling-statements END; -- 示例 CREATE OR REPLACE TRIGGER display_salary_changes BEFORE DELETE OR INSERT OR UPDATE ON customers FOR EACH ROW WHEN (NEW.ID \u0026gt; 0) DECLARE sal_diff number; BEGIN sal_diff := :NEW.salary - :OLD.salary; DBMS_OUTPUT.put_line(\u0026#39;Old salary: \u0026#39; || :OLD.salary); DBMS_OUTPUT.put_line(\u0026#39;New salary: \u0026#39; || :NEW.salary); DBMS_OUTPUT.put_line(\u0026#39;Salary difference: \u0026#39; || sal_diff); END; 删除触发器\r#\r-- 删除触发器 DROP TRIGGER trigger_name; -- 禁用/启用触发器 ALTER TRIGGER trigger_name {DISABLE|ENABLEND}; "},{"id":231,"href":"/program-design/data-algorithm/sort/counting/","title":"计数排序","section":"排序","content":"\r计数排序\r#\r计数排序\r#\r要求输入的数据必须是有确定范围的整数 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 算法步骤\r#\r找出待排序的数组中最大和最小的元素 统计数组中每个值为i的元素出现的次数，存入数组C的第i项 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加） 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1 动图演示\r#\r代码实现\r#\rpublic class CountingSort implements IArraySort { @Override public int[] sort(int[] arr) throws Exception { int maxValue = getMaxValue(arr); return countingSort(arr, maxValue); } private int[] countingSort(int[] arr, int maxValue) { int bucketLen = maxValue + 1; int[] bucket = new int[bucketLen]; for (int value : arr) { bucket[value]++; } int sortedIndex = 0; for (int j = 0; j \u0026lt; bucketLen; j++) { while (bucket[j] \u0026gt; 0) { arr[sortedIndex++] = j; bucket[j]--; } } return arr; } private int getMaxValue(int[] arr) { int maxValue = arr[0]; for (int value : arr) { if (maxValue \u0026lt; value) { maxValue = value; } } return maxValue; } } "},{"id":232,"href":"/database/oracle/plsql/function/","title":"函数","section":"PL/SQL","content":"\r函数\r#\r自定义函数\r#\r创建函数\r#\r-- 语法 CREATE [OR REPLACE] FUNCTION function_name [(parameter_name [IN | OUT | IN OUT] type [, ...])] RETURN return_datatype {IS | AS} BEGIN \u0026lt; function_body \u0026gt; END [function_name]; -- 示例 CREATE OR REPLACE FUNCTION fun_max( p_num1 IN NUMBER, p_num2 IN NUMBER DEFAULT 99 ) RETURN NUMBER IS BEGIN IF p_num1\u0026gt;p_num2 THEN RETURN p_num1; ELSE RETURN p_num2; END IF; END; 调用函数\r#\r-- 方式1 SELECT fun_max(20) FROM DUAL; -- 方式2 BEGIN DBMS_OUTPUT.put_line(fun_max(12,20)); END; -- 方式3 DECLARE v_num NUMBER; BEGIN v_num := fun_max(12,20); DBMS_OUTPUT.put_line(v_num); END; 删除函数\r#\rDROP FUNCTION fun_max; "},{"id":233,"href":"/program-design/data-structure/graph/","title":"图","section":"数据结构","content":"\r图\r#\r图\r#\rGraph 是一系列结点的集合，这些顶点通过边进行连接 这些结点称为顶点，边是顶点的有序偶对 分类\r#\r有向图：边不仅连接两个顶点，并且具有方向 无向图：边仅仅连接两个顶点，没有其他含义 "},{"id":234,"href":"/program-design/data-algorithm/sort/radix/","title":"基数排序","section":"排序","content":"\r基数排序\r#\r基数排序\r#\r是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。 基数排序 vs 计数排序 vs 桶排序\r#\r都利用了桶的概念\n基数排序：根据键值的每位数字来分配桶；\n计数排序：每个桶只存储单一键值；\n桶排序：每个桶存储一定范围的数值；\n​\n算法步骤\r#\r将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。 然后，从最低位开始，依次进行一次排序。 这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。 动图演示\r#\r代码实现\r#\r/** * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9 */ public class RadixSort implements IArraySort { @Override public int[] sort(int[] arr) throws Exception { int maxDigit = getMaxDigit(arr); return radixSort(arr, maxDigit); } // 获取最高位数 private int getMaxDigit(int[] arr) { int maxValue = getMaxValue(arr); return getNumLenght(maxValue); } private int getMaxValue(int[] arr) { int maxValue = arr[0]; for (int value : arr) { if (maxValue \u0026lt; value) { maxValue = value; } } return maxValue; } protected int getNumLenght(long num) { if (num == 0) { return 1; } int lenght = 0; for (long temp = num; temp != 0; temp /= 10) { lenght++; } return lenght; } private int[] radixSort(int[] arr, int maxDigit) { int mod = 10; int dev = 1; for (int i = 0; i \u0026lt; maxDigit; i++, dev *= 10, mod *= 10) { // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10) int[][] counter = new int[mod * 2][0]; for (int j = 0; j \u0026lt; arr.length; j++) { int bucket = ((arr[j] % mod) / dev) + mod; counter[bucket] = arrayAppend(counter[bucket], arr[j]); } int pos = 0; for (int[] bucket : counter) { for (int value : bucket) { arr[pos++] = value; } } } return arr; } // 自动扩容，并保存数据 private int[] arrayAppend(int[] arr, int value) { arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; } } "},{"id":235,"href":"/program-design/design-pattern/structural/08-facade/","title":"外观模式","section":"结构型","content":"\r外观模式\r#\r概述\r#\r英文：Facade Pattern 简述：对外提供一个统一的接口用来访问子系统 归纳：打开一扇门，通向全世界 目的：统一访问入口 案例：前台 示例\r#\r// 子系统 public interface Shape { void draw(); } // 类似子系统：Rectangle、Square public class Circle implements Shape { @Override public void draw() { System.out.println(\u0026#34;Circle::draw()\u0026#34;); } } // 外观类 public class ShapeMaker { private Shape circle; private Shape rectangle; private Shape square; public ShapeMaker() { circle = new Circle(); rectangle = new Rectangle(); square = new Square(); } public void drawCircle() { circle.draw(); } public void drawRectangle() { rectangle.draw(); } public void drawSquare() { square.draw(); } } public class Test { public static void main(String[] args) { ShapeMaker shapeMaker = new ShapeMaker(); shapeMaker.drawCircle(); shapeMaker.drawRectangle(); shapeMaker.drawSquare(); } } 应用\r#\r主要解决： 降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口 应用场景： JAVA 的三层开发模式 为复杂的模块或子系统提供外界访问的模块 子系统相对独立 预防低水平人员带来的风险 注意事项： 在层次化结构中，可以使用外观模式定义系统中每一层的入口 "},{"id":236,"href":"/interview/core/09-business-scene/","title":"企业业务场景","section":"重点面试题","content":"\r\u0026ndash; 工厂模式\r#\r简单工厂： 所有的产品都共有一个工厂，如果新增产品，则需要修改代码，违反开闭原则 是一种编程习惯，可以借鉴这种编程思路 工厂方法模式： 给每个产品都提供了一个工厂，让工厂专门负责对应的产品的生产，遵循开闭原则 项目中用的最多 抽象工厂模式： 如果有多个纬度的产品需要配合生产时，优先建议采用抽象工厂（工厂的工厂） 一般的企业开发中的较少 \u0026ndash; 策略模式\r#\r1. 该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。 2. 它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。 业务场景： 1. 用户登录（账号密码登录、短信登录、微信登录） 2. 订单的支付策略（支付宝、微信、银行卡…） 3. 解析不同类型excel（xls格式、xlsx格式） 4. 打折促销（满300元9折、满500元8折、满1000元7折…） 5. 物流运费阶梯计算（5kg以下、5-10kg、10-20kg、20kg以上） \u0026ndash; 责任链模式\r#\r为了避免请求发送者与多个请求处理者耦合在一起， 将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链； 当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。 业务场景： 1. 内容审核（视频、文章、课程….） 文本审核 --\u0026gt; 图片审核 --\u0026gt; 视频审核 2. 订单创建 检验参数 --\u0026gt; 填充订单 --\u0026gt; 算价 --\u0026gt; 落库 3. 简易流程审批 组长审批 --\u0026gt; 主管审批 --\u0026gt; 副总裁审批 --\u0026gt; 总裁审批 \u0026ndash; 单点登录是如何实现的？\r#\rSingle Sign On，简称SSO 只需要登录一次，就可以访问所有信任的应用系统 实现方案有：JWT、Oauth2、CAS... JWT解决单点登录： 1. 用户访问其他系统，会在网关判断token是否有效 2. 如果token无效则会返回401（认证失败），前端跳转到登录页面 3. 用户发送登录请求，返回浏览器一个token，浏览器把token保存到cookie 4. 再去访问其他服务的时候，都需要携带token，由网关统一验证后路由到目标服务 \u0026ndash; 权限认证是如何实现的？\r#\r使用RBAC模型来指导实现 RBAC模型： Role-Based Access Control， 基于角色的访问控制，3个基础部分组成：用户、角色、权限 一般有5张表：用户表、角色表、权限表、用户角色中间表、角色权限中间表 权限框架：Spring security \u0026ndash; 上传数据的安全性是如何控制的？\r#\r使用非对称加密（或对称加密），给前端一个公钥让他把数据加密后传到后台，后台负责解密后处理数据 1. 文件很大建议使用对称加密，不过不能保存敏感信息 2. 文件较小，要求安全性高，建议采用非对称加密 \u0026ndash; 你在项目中遇到了哪些比较棘手的问题？怎么解决的？\r#\r1. 什么背景（技术问题） 2. 过程（解决问题的过程） 3. 最终落地方案 \u0026ndash; 你们项目中日志是怎么采集的？\r#\r搭建了ELK日志采集系统 Elasticsearch\t是全文搜索分析引擎，可以对数据存储、搜索、分析 Logstash\t是一个数据收集引擎，可以动态收集数据，可以对数据进行过滤、分析，将数据存储到指定的位置 Kibana\t是一个数据分析和可视化平台，配合Elasticsearch对数据进行搜索，分析，图表化展示 \u0026ndash; Linux 查看日志的命令？\r#\rtail -f xxx.log\t# 实时监控日志的变化 tail –n 100 xxx.log\t# 查询尾部最后100行的日志 head –n 100 xxx.log\t# 查询头部开始100行的日志 cat -n xxx.log | grep \u0026#34;debug\u0026#34;\t# 按照关键字查询 cat -n xxx.log | grep \u0026#34;debug\u0026#34; | more\t# 分页查询日志信息 cat -n xxx.log | grep \u0026#34;debug\u0026#34; \u0026gt; debug.txt\t# 筛选过滤以后，输出到一个文件 cat -n xxx.log | tail -n +100 | head -n 100\t# 查询查询100行至200行的日志 sed -n \u0026#39;/2023-05-18/,/2023-05-18/p\u0026#39; xxx.log\t# 按照日期查询 \u0026ndash; 生产问题怎么排查?\r#\r1. 先分析日志，通常在业务中都会有日志的记录，或者查看系统日志，或者查看日志文件，然后定位问题 2. 远程debug（正常情况下是不允许远程debug的） 3. 尽量在本地进行复现模拟问题 \u0026ndash; 怎么快速定位系统的瓶颈？\r#\r1. 压测（性能测试）：LoadRunner、Apache Jmeter 2. 监控工具、链路追踪工具：skywalking、Zipkin 3. 线上诊断工具：Arthas(阿尔萨斯) "},{"id":237,"href":"/program-design/data-algorithm/sort/bucket/","title":"桶排序","section":"排序","content":"\r桶排序\r#\r桶排序\r#\r是计数排序的升级版。它利用了函数的映射关系 影响效率的因素\r#\r桶的数量 映射函数将输入的 N 个数据分配到 K 个桶中的均匀程度 桶内的排序算法 示意图\r#\r代码实现\r#\rpublic class BucketSort implements IArraySort { private static final InsertSort insertSort = new InsertSort(); @Override public int[] sort(int[] arr) throws Exception { return bucketSort(arr, 5); } private int[] bucketSort(int[] arr, int bucketSize) throws Exception { if (arr.length == 0) { return arr; } int minValue = arr[0]; int maxValue = arr[0]; for (int value : arr) { if (value \u0026lt; minValue) { minValue = value; } else if (value \u0026gt; maxValue) { maxValue = value; } } int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1; int[][] buckets = new int[bucketCount][0]; // 利用映射函数将数据分配到各个桶中 for (int i = 0; i \u0026lt; arr.length; i++) { int index = (int) Math.floor((arr[i] - minValue) / bucketSize); buckets[index] = arrAppend(buckets[index], arr[i]); } int arrIndex = 0; for (int[] bucket : buckets) { if (bucket.length \u0026lt;= 0) { continue; } // 对每个桶进行排序，这里使用了插入排序 bucket = insertSort.sort(bucket); for (int value : bucket) { arr[arrIndex++] = value; } } return arr; } // 自动扩容，并保存数据 private int[] arrAppend(int[] arr, int value) { arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; } } "},{"id":238,"href":"/program-design/design-pattern/structural/09-composite/","title":"组合模式","section":"结构型","content":"\r组合模式\r#\r概述\r#\r英文：Composite Pattern 简述：将整体与局部（树形结构）进行递归组合，让客户端能够以一致的方式对其进行处理 归纳：人在一起叫团伙，心在一起叫团队 目的：统一整体和个体 案例：组织架构树 示例\r#\r// 节点 public class Employee { // 节点属性 private String name; private String dept; public Employee(String name, String dept) { this.name = name; this.dept = dept; subEmployees = new ArrayList\u0026lt;\u0026gt;(); } // setter、getter // ...... // 子节点集合 private List\u0026lt;Employee\u0026gt; subEmployees; public List\u0026lt;Employee\u0026gt; getSubEmployees() { return subEmployees; } public void add(Employee employee) { subEmployees.add(employee); } public void remove(Employee employee) { subEmployees.remove(employee); } } public class Test { public static void main(String[] args) { Employee CEO = new Employee(\u0026#34;John\u0026#34;,\u0026#34;CEO\u0026#34;); Employee headSales = new Employee(\u0026#34;Robert\u0026#34;,\u0026#34;Head Sales\u0026#34;); Employee headMarketing = new Employee(\u0026#34;Michel\u0026#34;,\u0026#34;Head Marketing\u0026#34;); Employee clerk = new Employee(\u0026#34;Laura\u0026#34;,\u0026#34;Marketing\u0026#34;); Employee salesExecutive = new Employee(\u0026#34;Richard\u0026#34;,\u0026#34;Sales\u0026#34;); CEO.add(headSales); CEO.add(headMarketing); headSales.add(salesExecutive); headMarketing.add(clerk); //打印所有雇员 printEmployee(CEO); } private static void printEmployee(Employee employee){ System.out.println(employee); for (Employee subEmployee : employee.getSubEmployees()) { printEmployee(subEmployee); } } } 应用\r#\r主要解决： 树型结构问题 应用场景： 部分、整体场景，如树形菜单，文件、文件夹的管理 注意事项： 只要是树形结构，就要考虑使用组合模式 "},{"id":239,"href":"/database/oracle/plsql/procedure/","title":"过程","section":"PL/SQL","content":"\r过程\r#\r过程 vs 函数\r#\r声明：函数必须包含一条 RETURN 子句，而存储过程没有 RETURN 子句 调用：函数可以在查询语句中直接调用，而存储过程必须单独调用 创建\r#\r-- 语法 CREATE [OR REPLACE] PROCEDURE procedure_name [(parameter_name [IN | OUT | IN OUT] type [, ...])] {IS | AS} BEGIN \u0026lt; procedure_body \u0026gt; END procedure_name; -- 示例 CREATE OR REPLACE PROCEDURE greetings AS BEGIN dbms_output.put_line(\u0026#39;Hello World!\u0026#39;); END; 执行\r#\r-- 方式1 EXEC greetings; EXECUTE greetings; -- 方式2 CALL greetings; -- 方式2 BEGIN greetings; END; 删除\r#\rDROP PROCEDURE greetings; 示例\r#\rDECLARE a NUMBER; b NUMBER; c NUMBER; PROCEDURE findMin(x IN NUMBER, y IN NUMBER, z OUT NUMBER) IS BEGIN IF x \u0026lt; y THEN z:= x; ELSE z:= y; END IF; END; BEGIN a:= 12; b:= 35; findMin(a, b, c); DBMS_OUTPUT.put_line(\u0026#39;12、35中的较小值是 : \u0026#39; || c); END; DECLARE a NUMBER; PROCEDURE squareNum(x IN OUT NUMBER) IS BEGIN x := x * x; END; BEGIN a:= 11; squareNum(a); dbms_output.put_line(\u0026#39; Square of (11): \u0026#39; || a); END; "},{"id":240,"href":"/program-design/design-pattern/structural/10-flyweight/","title":"享元模式","section":"结构型","content":"\r享元模式\r#\r概述\r#\r英文：Flyweight Pattern 简述：使用对象池来减少重复对象的创建 归纳：优化资源配置，减少重复浪费 目的：共享资源池 案例：全国社保联网 示例\r#\r// 享元类 public interface IChess { public void draw(); } public class Chess implements IChess { // 内部状态：不可改变，可以共享 private String color; public Chess(String color) { this.color = color; } // 外部状态：可以改变，不可共享 private String position; public void setPosition(String position) { this.position = position; } @Override public void draw() { System.out.println(\u0026#34;围棋：color=\u0026#34; + color + \u0026#34;, position=\u0026#34; + position); } } // 享元工厂 public class ChessFactory { // 池容器 private static final HashMap\u0026lt;String, IChess\u0026gt; chessMap = new HashMap\u0026lt;\u0026gt;(); // 获取享元对象 public static Chess getChess(String color) { if (!chessMap.containsKey(color)) { chessMap.put(color, new Chess(color)); } return (Chess) chessMap.get(color); } } public class Test { public static void main(String[] args) { Chess chess; for (int i = 0; i \u0026lt; 3; i++) { for (int j = 0; j \u0026lt; 3; j++) { if (new Random().nextBoolean()) { chess = ChessFactory.getChess(\u0026#34;黑色\u0026#34;); } else { chess = ChessFactory.getChess(\u0026#34;白色\u0026#34;); } chess.setPosition(\u0026#34;x\u0026#34; + i + \u0026#34;y\u0026#34; + j); chess.draw(); } } } } 应用\r#\r主要解决： 在有大量对象时，有可能会造成内存溢出。 把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建 应用场景： 系统有大量相似对象 需要缓冲池的场景 注意事项： 注意划分外部状态和内部状态，否则可能会引起线程安全问题。 这些类必须有一个工厂对象加以控制 "},{"id":241,"href":"/program-design/data-algorithm/sort/heap/","title":"堆排序","section":"排序","content":"\r堆排序\r#\r堆排序\r#\r堆是一个二叉树，其子结点的键值或索引总是小于（或者大于）它的父节点 堆排序就是利用堆这种特性进行排序 算法步骤\r#\r创建一个堆 H[0……n-1]； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤 2，直到堆的尺寸为 1。 动图演示\r#\r代码实现\r#\rpublic class HeapSort implements IArraySort { @Override public int[] sort(int[] arr) throws Exception { int len = arr.length; buildMaxHeap(arr, len); for (int i = len - 1; i \u0026gt; 0; i--) { swap(arr, 0, i); len--; heapify(arr, 0, len); } return arr; } private void buildMaxHeap(int[] arr, int len) { for (int i = (int) Math.floor(len / 2); i \u0026gt;= 0; i--) { heapify(arr, i, len); } } private void heapify(int[] arr, int i, int len) { int left = 2 * i + 1; int right = 2 * i + 2; int largest = i; if (left \u0026lt; len \u0026amp;\u0026amp; arr[left] \u0026gt; arr[largest]) { largest = left; } if (right \u0026lt; len \u0026amp;\u0026amp; arr[right] \u0026gt; arr[largest]) { largest = right; } if (largest != i) { swap(arr, i, largest); heapify(arr, largest, len); } } private void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } "},{"id":242,"href":"/database/oracle/plsql/cursor/","title":"游标","section":"PL/SQL","content":"\r游标\r#\r简介\r#\r游标是一种处理数据的机制，提供了在结果集中查看和处理数据的能力 游标可以指定结果集中的任何位置，并允许用户对数据进行处理，类似集合中的迭代器 优缺点：消耗内存，提高 sql 执行效率 语法\r#\r不带参数 DECLARE CURSOR cur_stu_info -- 定义游标 IS SELECT * FROM stu_info; v_stu_info cur_stu_info%ROWTYPE; -- 定义变量，用于保存游标检索结果行 BEGIN OPEN cur_stu_info; -- 打开游标 LOOP -- 循环遍历 FETCH cur_stu_info INTO v_stu_info; -- 提取数据 DBMS_OUTPUT.put_line( -- 处理数据 v_stu_info.id || \u0026#39;:\u0026#39; || v_stu_info.name ); EXIT WHEN cur_stu_info%NOTFOUND; -- 游标检索完后退出循环 END LOOP; CLOSE cur_stu_info; -- 关闭游标 END; 带参数 DECLARE CURSOR cur_stu_info(v_id stu_info.id%type) IS SELECT * FROM stu_info t WHERE t.id = v_id; v_stu_info stu_info%ROWTYPE; BEGIN OPEN cur_stu_info(123); FETCH cur_stu_info INTO v_stu_info; DBMS_OUTPUT.put_line(v_stu_info.id || \u0026#39; : \u0026#39; || v_stu_info.name); CLOSE cur_stu_info; END; 属性\r#\r属性 返回值类型 作用 sql%ISOPEN 布尔型 判断游标是否 ”开启“ sql%FOUND 布尔型 判断游标是否 ”获取” 到值 sql%NOTFOUND 布尔型 判断游标是否 ”没有获取” 到值 sql%ROWCOUNT 整型 ”当前” 成功执行的数据行数（非 ”总记录数”） 结构\r#\r当游标打开后，才会执行查询语句，查询到的数据会被接收到一块内存区域中存储，直到游标关闭。 游标实际上指向的是一块内存区域，此块内存位于进程全局区域内部，称为上下文区域。 分类\r#\r静态游标：隐式游标、隐式游标 动态游标：自定义类型、系统类型 显式游标\r#\r显式游标是必须通过编写必要的PL/SQL例程来进行管理的游标。 游标的整个生命期都在用户的控制之下 见 语法 隐式游标\r#\r自动创建：DML语句、select into语句 自动管理：自动声明、打开、关闭，默认游标名为 \u0026lsquo;SQL\u0026rsquo; declare v_count number; begin insert into stu_info (id, name, sex) values (3, \u0026#39;瑶瑶\u0026#39;, \u0026#39;女\u0026#39;); if sql%found then dbms_output.put_line(\u0026#39;插入成功!\u0026#39;); end if; update stu_info t set t.name = \u0026#39;悠悠\u0026#39; where t.id = 3; if sql%found then dbms_output.put_line(\u0026#39;更新成功!\u0026#39;); end if; delete from stu_info t where t.id = 3; if sql%found then dbms_output.put_line(\u0026#39;删除成功!\u0026#39;); end if; select count(1) into v_count from stu_info t; if sql%found then dbms_output.put_line(\u0026#39;总记录为： \u0026#39; || v_count); end if; if sql%isopen then dbms_output.put_line(\u0026#39;不可能的，永远不可能走这一步\u0026#39;); else dbms_output.put_line(\u0026#39;系统已自动关闭游标\u0026#39;); end if; end; "},{"id":243,"href":"/dev-tool/git/","title":"Git","section":"开发工具","content":"\rGit\r#\r是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目 Git官网 配置\r#\r系统级：/etc/gitconfig\n用户级：[用户目录]/.gitconfig\n项目级：[项目目录]/.git/config\n# 配置个人的用户名称和电子邮件地址 $ git config --global user.name \u0026#34;xxx\u0026#34; $ git config --global user.email xxx@163.com # 配置Git默认使用的文本编辑器 $ git config --global core.editor emacs # 配置差异分析工具 $ git config --global merge.tool vimdiff # 查看配置信息 $ git config --list "},{"id":244,"href":"/program-lang/web/markdown/","title":"Markdown","section":"Web","content":"\rMarkdown\r#\r概述\r#\r是一种可以使用普通文本编辑器编写的 标记语言 通过简单的标记语法，它可以使普通文本内容具有一定的格式 标题\r#\r语法 # h1 ## h2 ### h3 #### h4 ##### h5 ###### h6 文字\r#\r语法\n*斜体* **粗体** ***斜体粗体*** ~~删除线~~ 效果\n斜体 粗体 斜体粗体 删除线\n图片\r#\r语法\n![百度](https://www.baidu.com/img/baidu_jgylogo3.gif \u0026#34;百度一下\u0026#34;) 效果\n链接\r#\r语法\n//超链接 [百度](http://baidu.com \u0026#34;百度一下\u0026#34;) //自动链接 \u0026lt;address@example.com\u0026gt; //页内超链接 设锚点：\u0026lt;a id=\u0026#34;link\u0026#34;\u0026gt;目标位置\u0026lt;/a\u0026gt; 跳转到：[锚点](#link) 效果\n百度 address@example.com 设锚点：目标位置 跳转到：锚点\n列表\r#\r语法\n//无序列表 - item //有序列表 1. item 效果\nitem item 表格\r#\r语法\n左对齐|居中|右对齐 -|:-:|-: 1|2|3 a|b|c 效果\n左对齐 居中 右对齐 1 2 3 a b c 代码\r#\r语法\n`单行代码` ​```javascript // 多行代码 function fun(){ echo \u0026#34;Hello World!\u0026#34;; } ​``` 效果\n单行代码\n// 多行代码 function fun(){ echo \u0026#34;Hello World!\u0026#34;; } 分割线\r#\r语法\n--- 效果\n引用\r#\r语法\n\u0026gt; 一级引用内容 \u0026gt;\u0026gt; 二级引用内容 \u0026gt;\u0026gt;\u0026gt; 三级引用内容 ...... 效果\n一级引用内容\n二级引用内容\n三级引用内容\n"},{"id":245,"href":"/framework/quartz/","title":"Quartz","section":"开源框架","content":"\rQuartz\r#\r是一个完全由 java 编写的开源任务调度框架 核心类\r#\rJob：任务接口，承载着要被执行的具体业务逻辑 JobDetail：任务实例，记录着自定义任务的详细信息 Trigger：触发器，记录着任务的调度规则 Scheduler：调度器，负责基于 Trigger 触发器，来执行 Job 任务 "},{"id":246,"href":"/database/redis/","title":"Redis","section":"数据存储","content":"\rRedis\r#\rRemote Dictionary Server，是完全开源免费的，遵守 BSD 协议，是一个高性能的 key-value 数据库 Redis 参考手册 特点\r#\r支持数据的持久化 支持多种数据结构的存储 支持数据的备份 优势\r#\r性能极高 丰富的数据类型 所有操作都是原子性的 丰富的特性 "},{"id":247,"href":"/program-design/data-algorithm/%E5%89%8D%E7%BC%80%E5%92%8C/","title":"前缀和","section":"数据算法","content":"\r前缀和\r#\r简述\r#\r是一种数据预处理方法，可用于快速求数组的区间和 核心思想：是通过移动这两个指针来实现特定的目标 滑动窗口算法是双指针算法中的一种特定形式 示例\r#\r区域和检索 - 数组不可变\n给定一个整数数组 nums，实现 NumArray 类： 1. NumArray(int[] nums) 使用数组 nums 初始化对象 2. int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的总和 包含 left 和 right，其中 left ≤ right 输入： [\u0026#34;NumArray\u0026#34;, \u0026#34;sumRange\u0026#34;, \u0026#34;sumRange\u0026#34;, \u0026#34;sumRange\u0026#34;] [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]] 输出： [null, 1, -1, -3] 解释： NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]); numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3) numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1)) 思路\n在初始化的时候，就计算出数组 nums 在每个下标处的前缀和 题解\npublic class NumArray { int[] sums; public NumArray(int[] nums) { int n = nums.length; sums = new int[n + 1]; for (int i = 0; i \u0026lt; n; i++) { sums[i + 1] = sums[i] + nums[i]; } } public int sumRange(int i, int j) { return sums[j + 1] - sums[i]; } } "},{"id":248,"href":"/database/oracle/plsql/package/","title":"包","section":"PL/SQL","content":"\r包\r#\rPL/SQL 包\r#\r包是一种数据对象，是对相关类型、子程序、游标、异常、变量、常量的封装。 用于将逻辑相关的 PL/SQL 块或元素组织在一起，作为一个完整的单元存储在数据库中。 创建包规范\r#\r包规范：定义了可以从包外部引用的类型、变量、常量、异常、游标和子程序 ，即被公开的部分 CREATE PACKAGE cust_sal AS PROCEDURE find_sal(c_id customers.id%type); END cust_sal; 创建包体\r#\r包体：具有包规范中声明的各种方法代码和其他私有声明，这些声明对包之外的代码是隐藏的 CREATE OR REPLACE PACKAGE BODY cust_sal AS PROCEDURE find_sal(c_id customers.id%TYPE) IS c_sal customers.salary%TYPE; BEGIN SELECT salary INTO c_sal FROM customers WHERE id = c_id; DBMS_OUTPUT.put_line(\u0026#39;Salary: \u0026#39;|| c_sal); END find_sal; END cust_sal; 调用包\r#\r-- 语法 package_name.element_name; -- 示例：调用cust_sal包中的find_sal方法 DECLARE code customers.id%type := \u0026amp;cc_id; BEGIN cust_sal.find_sal(code); END; 示例\r#\r-- 数据表 Select * from customers; /* +----+----------+-----+-----------+----------+ | ID | NAME | AGE | ADDRESS | SALARY | +----+----------+-----+-----------+----------+ | 1 | Ramesh | 32 | Ahmedabad | 3000.00 | | 2 | Khilan | 25 | Delhi | 3000.00 | | 3 | kaushik | 23 | Kota | 3000.00 | | 4 | Chaitali | 25 | Mumbai | 7500.00 | | 5 | Hardik | 27 | Bhopal | 9500.00 | | 6 | Komal | 22 | MP | 5500.00 | +----+----------+-----+-----------+----------+ */ -- 包规范 CREATE OR REPLACE PACKAGE c_package AS -- Adds a customer PROCEDURE addCustomer( c_id customers.id%TYPE, c_name customers.name%TYPE, c_age customers.age%TYPE, c_addr customers.address%TYPE, c_sal customers.salary%TYPE ); -- Removes a customer PROCEDURE delCustomer(c_id customers.id%TYPE); --Lists all customers PROCEDURE listCustomer; END c_package; -- 包体 CREATE OR REPLACE PACKAGE BODY c_package AS PROCEDURE addCustomer( c_id customers.id%type, c_name customers.name%type, c_age customers.age%type, c_addr customers.address%type, c_sal customers.salary%type) IS BEGIN INSERT INTO customers (id,name,age,address,salary) VALUES(c_id, c_name, c_age, c_addr, c_sal); END addCustomer; PROCEDURE delCustomer(c_id customers.id%type) IS BEGIN DELETE FROM customers WHERE id = c_id; END delCustomer; PROCEDURE listCustomer IS CURSOR c_customers IS SELECT name FROM customers; TYPE c_list IS TABLE OF customers.name%type; name_list c_list := c_list(); counter integer :=0; BEGIN FOR n IN c_customers LOOP counter := counter +1; name_list.extend; name_list(counter) := n.name; dbms_output.put_line(\u0026#39;Customer(\u0026#39; ||counter|| \u0026#39;)\u0026#39;||name_list(counter)); END LOOP; END listCustomer; END c_package; -- 使用程序包 DECLARE code customers.id%type:= 8; BEGIN c_package.addcustomer(7, \u0026#39;Andy Liu\u0026#39;, 25, \u0026#39;Chennai\u0026#39;, 3500); c_package.addcustomer(8, \u0026#39;Kobe Bryant\u0026#39;, 32, \u0026#39;Delhi\u0026#39;, 7500); c_package.listcustomer; c_package.delcustomer(code); c_package.listcustomer; END; -- 结果 /* Old salary: New salary: 3500 Salary difference: Old salary: New salary: 7500 Salary difference: Customer(1)Ramesh Customer(2)Khilan Customer(3)kaushik Customer(4)Chaitali Customer(5)Hardik Customer(6)Komal Customer(7)Andy Liu Customer(8)Kobe Bryant Customer(1)Ramesh Customer(2)Khilan Customer(3)kaushik Customer(4)Chaitali Customer(5)Hardik Customer(6)Komal Customer(7)Andy Liu */ "},{"id":249,"href":"/program-lang/java/thread/","title":"多线程","section":"Java","content":"\r优点\r#\r充分利用多核CPU的计算能力 方便进行业务拆分，提升系统并发能力和性能 缺点\r#\r频繁的上下文切换（任务从保存到再加载的过程） 引起线程安全问题 上下文切换\r#\r当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态 以便下次再切换回这个任务时，可以再加载这个任务的状态。 任务从保存到再加载的过程就是一次上下文切换。 "},{"id":250,"href":"/program-design/design-pattern/structural/11-adapter/","title":"适配器模式","section":"结构型","content":"\r适配器模式\r#\r概述\r#\r英文：Adapter Pattern 简述：将原来不兼容的两个类匹配在一起 归纳：万能充电器 目的：兼容转换 案例：电源适配 示例\r#\r// 源 public class Adaptee { public void adapteeMethod() { System.out.println(\u0026#34;Adaptee method!\u0026#34;); } } // 目标 public interface Target { void adapteeMethod(); void adapterMethod(); } // 适配器 public class Adapter implements Target { private Adaptee adaptee; public Adapter(Adaptee adaptee) { this.adaptee = adaptee; } @Override public void adapteeMethod() { adaptee.adapteeMethod(); } @Override public void adapterMethod() { System.out.println(\u0026#34;Adapter method!\u0026#34;); } } public class Test { public static void main(String[] args) { Target target = new Adapter(new Adaptee()); target.adapteeMethod(); target.adapterMethod(); } } 应用\r#\r主要解决： 现存系统中，将一些“存在的对象”放到新环境中。而这些现存对象，不能满足新环境接口的要求 应用场景： JAVA 中的 jdbc 有动机地修改一个正常运行的系统的接口 注意事项： 适配器不是在详细设计时添加的，而是解决正在服役的项目的问题 "},{"id":251,"href":"/framework/kafka/","title":"Kafka","section":"开源框架","content":"\rKafka\r#\r是一种高吞吐量的分布式发布订阅消息系统 使用场景：日志收集、消息系统、用户活动跟踪、运营指标 Kafka 特性\r#\r高吞吐量、低延迟 kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒 可扩展性 kafka集群支持热扩展 持久性、可靠性 消息被持久化到本地磁盘，并且支持数据备份防止数据丢失 容错性 允许集群中节点失败（若副本数量为n,则允许n-1个节点失败） 高并发 支持数千个客户端同时读写 "},{"id":252,"href":"/program-design/data-algorithm/%E5%8F%8C%E6%8C%87%E9%92%88/","title":"双指针","section":"数据算法","content":"\r双指针\r#\r简述\r#\r定义两个指针：左指针、右指针，以便协同进行遍历或搜索 核心思想：是通过移动这两个指针来实现特定的目标 滑动窗口算法是双指针算法中的一种特定形式 示例\r#\r无重复字符的最长子串\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0] 思路\n左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。 右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。 题解\npublic class Main { public void moveZeroes(int[] nums) { int n = nums.length, left = 0, right = 0; while (right \u0026lt; n) { if (nums[right] != 0) { swap(nums, left, right); left++; } right++; } } public void swap(int[] nums, int left, int right) { int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; } } "},{"id":253,"href":"/program-lang/java/jvm/","title":"虚拟机","section":"Java","content":"\rJava 运行\r#\rJVM 结构\r#\r类加载器，Class Loader 执行引擎，Execution Engine 运行时数据区，Runtime Data Area 本地方法接口，Native Interface "},{"id":254,"href":"/program-design/design-pattern/structural/12-decorator/","title":"装饰器模式","section":"结构型","content":"\r装饰器模式\r#\r概述\r#\r英文：Decorator Pattern 简述：不改变原类结构、不使用继承的情况下，动态地给一个对象添加一些额外的职责。 归纳：他大舅他二舅都是他舅 目的：灵活扩展、同宗同源 案例：煎饼 示例\r#\r// 被装饰类 public interface Shape { void draw(); } // 类似形状：Circle public class Rectangle implements Shape { @Override public void draw() { System.out.println(\u0026#34;Shape: 正方形\u0026#34;); } } // 装饰类 public abstract class ShapeDecorator implements Shape { protected Shape shape; public ShapeDecorator(Shape shape) { this.shape = shape; } @Override public void draw() { shape.draw(); } } // 类似装饰类:GreenShapeDecorator public class RedShapeDecorator extends ShapeDecorator { public RedShapeDecorator(Shape shape) { super(shape); } @Override public void draw() { super.draw(); setRedBorder(shape); } private void setRedBorder(Shape shape) { System.out.println(\u0026#34;Border Color: Red\u0026#34;); } } public class Test { public static void main(String[] args) { Shape circle = new Circle(); ShapeDecorator redCircle = new RedShapeDecorator(new Circle()); ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle()); System.out.println(\u0026#34;Circle with normal border\u0026#34;); circle.draw(); System.out.println(\u0026#34;Circle of red border\u0026#34;); redCircle.draw(); System.out.println(\u0026#34;Rectangle of red border\u0026#34;); redRectangle.draw(); } } 应用\r#\r主要解决： 使用继承方式扩展类的功能，随着扩展功能的增多，导致子类膨胀问题 应用场景： 扩展一个类的功能、动态增加/撤销功能 注意事项： 可代替继承 "},{"id":255,"href":"/program-design/data-algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%86/","title":"并查集","section":"数据算法","content":"\r并查集\r#\r简述\r#\rUnion-Find Sets，是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题 基本思想：是将元素分组，每组的元素之间具有某种关系（如连通性），并且这种关系具有传递性 实现\r#\r通过维护一个父节点数组，来实现元素的分组。初始时每个元素的父节点都是自己。 通过修改父节点数组，将其中一个集合的根节点的父节点指向另一个集合的根节点，来实现两个集合的合并 通过查找元素的根节点是否相同，来判断是否属于同一个集合 示例\r#\rWe Are A Team\n总共有 n 个人在机房，每个人有一个标号（1≤标号≤n）， 他们分成了多个团队，需要你根据收到的 m 条消息判定指定的两个人是否在一个团队中，具体的： 1. 消息构成为 a b c，整数 a、b 分别代表两个人的标号，整数 c 代表指令 2. c == 0 代表 a 和 b 在一个团队内 3. c == 1 代表需要判定，如果 a 和 b 是一个团队，输出一行’we are a team’,否则输出一行’we are not a team’ 4. c 为其他值，或当前行 a 或 b 超出 1~n 的范围，输出‘da pian zi’ 输入描述： 第一行包含两个整数 n，m(1≤n,m＜100000),分别表示有 n 个人和 m 条消息 随后的 m 行，每行一条消息，消息格式为：a b c(1≤a,b≤n,0≤c≤1) 输出描述： c ==1,判断 a 和 b关系，在一个团队中输出‘we are a team‘,不在一个团队中输出’we are not a team’ c 为其他值，或当前行 a 或 b 的标号小于 1 或者大于 n 时，输出字符串‘da pian zi‘ 如果第一行 n 和 m 的值超出约定的范围时，输出字符串”NULL“。 输入：5 6 1 2 0 1 2 1 1 5 0 2 3 1 2 5 1 1 3 2 输出：we are a team we are not a team we are a team da pian zi 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int[][] msgs = new int[m][3]; for (int i = 0; i \u0026lt; m; i++) { msgs[i][0] = sc.nextInt(); msgs[i][1] = sc.nextInt(); msgs[i][2] = sc.nextInt(); } getResult(msgs, n, m); } public static void getResult(int[][] msgs, int n, int m) { // 如果第一行 n 和 m 的值超出约定的范围时，输出字符串”Null“。 if (n \u0026lt; 1 || n \u0026gt;= 100000 || m \u0026lt; 1 || m \u0026gt;= 100000) { System.out.println(\u0026#34;NULL\u0026#34;); return; } UnionFindSet ufs = new UnionFindSet(n + 1); for (int[] msg : msgs) { int a = msg[0], b = msg[1], c = msg[2]; if (a \u0026lt; 1 || a \u0026gt; n || b \u0026lt; 1 || b \u0026gt; n) { // 当前行 a 或 b 的标号小于 1 或者大于 n 时，输出字符串‘da pian zi‘ System.out.println(\u0026#34;da pian zi\u0026#34;); continue; } if (c == 0) { // c == 0 代表 a 和 b 在一个团队内 ufs.union(a, b); } else if (c == 1) { // c == 1 代表需要判定 a 和 b 的关系 String str = ufs.findRoot(a) == ufs.findRoot(b) ? \u0026#34;we are a team\u0026#34; : \u0026#34;we are not a team\u0026#34;; System.out.println(str); } else { // c 为其他值，输出字符串‘da pian zi‘ System.out.println(\u0026#34;da pian zi\u0026#34;); } } } // 并查集 static class UnionFindSet { int[] fa; // 初始化，设置i的父节点fa[i]为自身 public UnionFindSet(int n) { this.fa = new int[n]; for (int i = 0; i \u0026lt; n; i++) { fa[i] = i; } } // 查找x的根节点 public int findRoot(int x) { // 递归中断条件：根节点为自身 if (fa[x] == x) { return x; } // 递归：查询x的根节点 int root = findRoot(fa[x]); // 递归路径压缩：直接设置x的父节点为根 fa[x] = root; return root; } // 合并节点x、y public void union(int x, int y) { // 查找xy两者的根节点 int xFa = this.findRoot(x); int yFa = this.findRoot(y); // 合并：将xy两者的根节点设为相同 fa[xFa] = yFa; } } "},{"id":256,"href":"/program-design/design-pattern/behavioural/13-state/","title":"状态模式","section":"行为型","content":"\r状态模式\r#\r概述\r#\r英文：State Pattern 简述：根据不同的状态做出不同的行为 归纳：状态驱动行为，行为决定状态 目的：状态驱动行为，行为决定状态 案例：订单状态跟踪 示例\r#\r// 状态类 public abstract class LiftState { // 定义一个环境角色 protected Context context; public void setContext(Context context) { this.context = context; } public abstract void open(); public abstract void close(); public abstract void run(); public abstract void stop(); } // 类似状态：ClosingState、RunningState、StoppingState public class OpeningState extends LiftState { @Override public void close() { super.context.setLiftState(Context.closingState); super.context.getLiftState().close(); } @Override public void open() { System.out.println(\u0026#34;电梯门开启...\u0026#34;); } @Override public void run() { //do nothing; } @Override public void stop() { //do nothing; } } // 环境类 public class Context { // 定义出所有的电梯状态 public final static OpeningState openingState = new OpeningState(); public final static ClosingState closingState = new ClosingState(); public final static RunningState runningState = new RunningState(); public final static StoppingState stoppingState = new StoppingState(); // 定一个当前电梯状态 private LiftState liftState; public LiftState getLiftState() { return liftState; } public void setLiftState(LiftState liftState) { this.liftState = liftState; // 把当前的环境通知到各个实现类中 this.liftState.setContext(this); } public void open() { this.liftState.open(); } public void close() { this.liftState.close(); } public void run() { this.liftState.run(); } public void stop() { this.liftState.stop(); } } public class Test { public static void main(String[] args) { Context context = new Context(); context.setLiftState(new OpeningState()); context.open(); context.close(); context.run(); context.stop(); } } 应用\r#\r主要解决： 对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。 应用场景： 行为随状态改变而改变的场景、条件/分支语句的代替者 注意事项： 在行为受状态约束的时候使用状态模式，而且状态不超过 5 个 "},{"id":257,"href":"/program-design/design-pattern/behavioural/14-strategy/","title":"策略模式","section":"行为型","content":"\r策略模式\r#\r概述\r#\r英文：Strategy Pattern 简述：封装不同的算法，算法之间能互相替换 归纳：条条大道通罗马，具体哪条你来定 目的：把选择权交给用户 案例：选择支付方式 示例\r#\r业务场景：获取多种数据库的元数据\n// 策略类 public interface DatabaseMeta { void getColumns(); } // 类似策略类：PgsqlDatabaseMeta、OracleDatabaseMeta public class MysqlDatabaseMeta implements DatabaseMeta { @Override public void getColumns() { System.out.println(\u0026#34;Mysql column...\u0026#34;); } } // 环境类 public class Context { private DatabaseMeta meta; public Context(DatabaseMeta meta) { this.meta = meta; } public void getColumns() { meta.getColumns(); } } public class Test { public static void main(String[] args) { Context context; context = new Context(new MysqlDatabaseMeta()); context.getColumns(); context = new Context(new PgsqlDatabaseMeta()); context.getColumns(); context = new Context(new OracleDatabaseMeta()); context.getColumns(); } } 应用\r#\r主要解决： 在有多种相似算法的情况下，使用if/else所带来的复杂和难以维护的问题 应用场景： 许多相关的类仅仅是行为有异 需要使用一个算法的不同变体 一个类定义了多种行为，并且这些行为以多个条件语句的形式出现 注意事项： 如果策略类多于四个，就需要考虑使用混合模式，防止策略类膨胀 "},{"id":258,"href":"/program-design/design-pattern/behavioural/15-template/","title":"模板模式","section":"行为型","content":"\r模板模式\r#\r概述\r#\r英文：Template Pattern 简述：定义一套流程模板，根据需要实现模板中的操作 归纳：流程全部标准化，需要微调请覆盖 目的：逻辑复用 案例：把大象装进冰箱 示例\r#\r// 模板类 public abstract class Game { abstract void initialize(); abstract void startPlay(); abstract void endPlay(); // 模板方法 public final void play() { init(); startPlay(); endPlay(); } } // 类似实例：Volleyball public class Football extends Game { @Override void init() { System.out.println(\u0026#34;Football：Initialized! Start playing.\u0026#34;); } @Override void startPlay() { System.out.println(\u0026#34;Football：Started. Enjoy the game!\u0026#34;); } @Override void endPlay() { System.out.println(\u0026#34;Football：Finished!\u0026#34;); } } public class Test { public static void main(String[] args) { new Football().play(); new Volleyball().play(); } } 应用\r#\r主要解决： 一些方法通用，却在每一个子类都重新写了这一方法 应用场景： 有多个子类共有的方法，且逻辑相同； 重要的、复杂的方法，可以考虑作为模板方法 注意事项： 为防止恶意操作，一般模板方法都加上 final 关键词 "},{"id":259,"href":"/program-design/design-pattern/behavioural/16-command/","title":"命令模式","section":"行为型","content":"\r命令模式\r#\r概述\r#\r英文：Command Pattern 简述：将请求封装成命令，并记录下来，能够撤销与重做 归纳：运筹帷幄之中，决胜千里之外 目的：解耦请求和处理 案例：遥控器 示例\r#\r// 命令 public interface Command { void execute(); } // 开机命令ConcreteCommand public class CommandOn implements Command { private Tv myTv; public CommandOn(Tv tv) { myTv = tv; } public void execute() { myTv.turnOn(); } } // 关机命令ConcreteCommand public class CommandOff implements Command { private Tv myTv; public CommandOff(Tv tv) { myTv = tv; } public void execute() { myTv.turnOff(); } } // 频道切换命令ConcreteCommand public class CommandChange implements Command { private Tv myTv; private int channel; public CommandChange(Tv tv, int channel) { myTv = tv; this.channel = channel; } public void execute() { myTv.changeChannel(channel); } } // 可以看作是遥控器Invoker public class Control { private List\u0026lt;Command\u0026gt; commandList = new ArrayList\u0026lt;\u0026gt;(); public void addAction(Command command) { commandList.add(command); } public void action() { for (Command command : commandList) { command.execute(); } } } // 命令接收者Receiver public class Tv { public int currentChannel = 0; public void turnOn() { System.out.println(\u0026#34;The televisino is on.\u0026#34;); } public void turnOff() { System.out.println(\u0026#34;The television is off.\u0026#34;); } public void changeChannel(int channel) { this.currentChannel = channel; System.out.println(\u0026#34;Now TV channel is \u0026#34; + channel); } } public class Test { public static void main(String[] args) { Tv myTv = new Tv(); CommandOn on = new CommandOn(myTv); CommandOff off = new CommandOff(myTv); CommandChange channel = new CommandChange(myTv, 2); // 开机 Control control = new Control(); control.addAction(on); control.addAction(channel); control.addAction(off); // 执行 control.action(); } } 应用\r#\r主要解决： 在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系， 但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种紧耦合的设计就不太合适。 应用场景： 认为是命令的地方都可以使用命令模式 注意事项： 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式 "},{"id":260,"href":"/program-design/design-pattern/behavioural/17-iterator/","title":"迭代器模式","section":"行为型","content":"\r迭代器模式\r#\r概述\r#\r英文：Iterator Pattern 简述：提供一种方法顺序访问一个聚合对象中的各个元素，而又无须暴露该对象的内部细节 归纳：流水线上坐一天，每个包裹扫一遍 目的：统一对集合的访问方式 案例：逐个检票进站 示例\r#\r// 抽象迭代器 public interface Iterator { public boolean hasNext(); public Object next(); } // 抽象聚合 public interface Container { public Iterator getIterator(); } // 具体聚合 public class NameRepository implements Container { public String[] names = {\u0026#34;Robert\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Julie\u0026#34;, \u0026#34;Lora\u0026#34;}; @Override public Iterator getIterator() { return new NameIterator(); } // 具体迭代器 private class NameIterator implements Iterator { int index = 0; @Override public boolean hasNext() { return index \u0026lt; names.length; } @Override public Object next() { if (this.hasNext()) { return names[index++]; } return null; } } } public class Test { public static void main(String[] args) { NameRepository names = new NameRepository(); Iterator iter = names.getIterator(); while (iter.hasNext()) { String name = (String) iter.next(); System.out.println(\u0026#34;Name : \u0026#34; + name); } } } 应用\r#\r主要解决： 不同的方式来遍历整个整合对象 应用场景： 遍历一个聚合对象 注意事项： Java 已经把迭代器模式融入到集合框架 API 中，直接使用 java.util.Iterator 即可 "},{"id":261,"href":"/program-design/design-pattern/behavioural/18-interpreter/","title":"解释器模式","section":"行为型","content":"\r解释器模式\r#\r概述\r#\r英文：Interpreter Pattern 简述：给定一个语言，定义它的语法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子 归纳：我想说”方言“，一切解释权都归我 目的：实现特定语法解析 案例：摩斯密码 示例\r#\r// 解释器 public interface Expression { public boolean interpret(String context); } // 解释器TerminalExpression public class TerminalExpression implements Expression { private String data; public TerminalExpression(String data) { this.data = data; } @Override public boolean interpret(String context) { return context.contains(data); } } // 解释器OrExpression public class OrExpression implements Expression { private Expression expr1; private Expression expr2; public OrExpression(Expression expr1, Expression expr2) { this.expr1 = expr1; this.expr2 = expr2; } @Override public boolean interpret(String context) { return expr1.interpret(context) || expr2.interpret(context); } } // 解释器AndExpression public class AndExpression implements Expression { private Expression expr1; private Expression expr2; public AndExpression(Expression expr1, Expression expr2) { this.expr1 = expr1; this.expr2 = expr2; } @Override public boolean interpret(String context) { return expr1.interpret(context) \u0026amp;\u0026amp; expr2.interpret(context); } } public class Test { //规则：Robert 和 John 是男性 public static Expression getMaleExpression() { Expression robert = new TerminalExpression(\u0026#34;Robert\u0026#34;); Expression john = new TerminalExpression(\u0026#34;John\u0026#34;); return new OrExpression(robert, john); } //规则：Julie 是一个已婚的女性 public static Expression getMarriedWomanExpression() { Expression julie = new TerminalExpression(\u0026#34;Julie\u0026#34;); Expression married = new TerminalExpression(\u0026#34;Married\u0026#34;); return new AndExpression(julie, married); } public static void main(String[] args) { Expression isMale = getMaleExpression(); Expression isMarriedWoman = getMarriedWomanExpression(); System.out.println(\u0026#34;John is male? \u0026#34; + isMale.interpret(\u0026#34;John\u0026#34;)); System.out.println(\u0026#34;Julie is a married women? \u0026#34; + isMarriedWoman.interpret(\u0026#34;Married Julie\u0026#34;)); } } 应用\r#\r主要解决： 对于一些固定文法构建一个解释句子的解释器 注意事项： 可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替 "},{"id":262,"href":"/program-design/design-pattern/behavioural/19-observer/","title":"观察者模式","section":"行为型","content":"\r观察者模式\r#\r概述\r#\r英文：Observer Pattern 简述：状态发生改变时通知观察者，一对多的关系 归纳：到点就通知我 目的：解耦观察者与被观察者 案例：闹钟 示例\r#\r// 目标 public class Subject { private int state; private List\u0026lt;Observer\u0026gt; observers = new ArrayList\u0026lt;\u0026gt;(); public int getState() { return state; } public void setState(int state) { this.state = state; notifyAllObservers(); } public void attach(Observer observer) { observers.add(observer); } public void notifyAllObservers() { for (Observer observer : observers) { observer.update(); } } } // 抽象观察者 public abstract class Observer { protected Subject subject; public abstract void update(); } // 观察者BinaryObserver public class BinaryObserver extends Observer{ public BinaryObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( \u0026#34;Binary String: \u0026#34; + Integer.toBinaryString( subject.getState() ) ); } } // 观察者OctalObserver public class OctalObserver extends Observer{ public OctalObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( \u0026#34;Octal String: \u0026#34; + Integer.toOctalString( subject.getState() ) ); } } // 观察者HexaObserver public class HexaObserver extends Observer{ public HexaObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( \u0026#34;Hex String: \u0026#34; + Integer.toHexString( subject.getState() ).toUpperCase() ); } } public class Test { public static void main(String[] args) { Subject subject = new Subject(); new HexaObserver(subject); new OctalObserver(subject); new BinaryObserver(subject); System.out.println(\u0026#34;First state change: 15\u0026#34;); subject.setState(15); System.out.println(\u0026#34;Second state change: 10\u0026#34;); subject.setState(10); } } 应用\r#\r主要解决： 一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作 注意事项： 避免循环引用 JAVA 中已经有了对观察者模式的支持类 如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。 "},{"id":263,"href":"/program-design/design-pattern/behavioural/20-visitor/","title":"访问者模式","section":"行为型","content":"\r访问者模式\r#\r概述\r#\r英文：Visitor Pattern 简述：稳定数据结构，定义新的操作行为 归纳：横看成岭侧成峰，远近高低各不同 目的：解耦数据结构和数据操作 案例：KPI考核 示例\r#\r// 被访问者：员工 public abstract class Staff { public String name; public int kpi; public Staff(String name) { this.name = name; kpi = new Random().nextInt(10); } // 核心方法，接受Visitor的访问 public abstract void accept(Visitor visitor); } // 工程师 public class Engineer extends Staff { public Engineer(String name) { super(name); } @Override public void accept(Visitor visitor) { visitor.visit(this); } // 工程师一年的代码数量 public int getCodeLines() { return new Random().nextInt(10 * 10000); } } // 经理 public class Manager extends Staff { public Manager(String name) { super(name); } @Override public void accept(Visitor visitor) { visitor.visit(this); } // 一年做的产品数量 public int getProducts() { return new Random().nextInt(10); } } // 访问者 public interface Visitor { // 访问工程师类型 void visit(Engineer engineer); // 访问经理类型 void visit(Manager manager); } // CEO访问者 public class CEOVisitor implements Visitor { @Override public void visit(Engineer engineer) { System.out.println(\u0026#34;工程师: \u0026#34; + engineer.name + \u0026#34;, KPI: \u0026#34; + engineer.kpi); } @Override public void visit(Manager manager) { System.out.println(\u0026#34;经理: \u0026#34; + manager.name + \u0026#34;, KPI: \u0026#34; + manager.kpi + \u0026#34;, 新产品数量: \u0026#34; + manager.getProducts()); } } // CTO访问者 public class CTOVisitor implements Visitor { @Override public void visit(Engineer engineer) { System.out.println(\u0026#34;工程师: \u0026#34; + engineer.name + \u0026#34;, 代码行数: \u0026#34; + engineer.getCodeLines()); } @Override public void visit(Manager manager) { System.out.println(\u0026#34;经理: \u0026#34; + manager.name + \u0026#34;, 产品数量: \u0026#34; + manager.getProducts()); } } // 员工业务报表类 public class BusinessReport { private List\u0026lt;Staff\u0026gt; mStaffs = new LinkedList\u0026lt;\u0026gt;(); public BusinessReport() { mStaffs.add(new Manager(\u0026#34;经理-A\u0026#34;)); mStaffs.add(new Engineer(\u0026#34;工程师-A\u0026#34;)); mStaffs.add(new Engineer(\u0026#34;工程师-B\u0026#34;)); mStaffs.add(new Engineer(\u0026#34;工程师-C\u0026#34;)); mStaffs.add(new Manager(\u0026#34;经理-B\u0026#34;)); mStaffs.add(new Engineer(\u0026#34;工程师-D\u0026#34;)); } /** * 为访问者展示报表 * @param visitor 公司高层，如CEO、CTO */ public void showReport(Visitor visitor) { for (Staff staff : mStaffs) { staff.accept(visitor); } } } public class Test { public static void main(String[] args) { // 构建报表 BusinessReport report = new BusinessReport(); System.out.println(\u0026#34;=========== CEO看报表 ===========\u0026#34;); report.showReport(new CEOVisitor()); System.out.println(\u0026#34;=========== CTO看报表 ===========\u0026#34;); report.showReport(new CTOVisitor()); } } 应用\r#\r主要解决： 稳定的数据结构和易变的操作耦合问题 注意事项： 访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器 "},{"id":264,"href":"/program-design/design-pattern/behavioural/21-mediator/","title":"中介者模式","section":"行为型","content":"\r中介者模式\r#\r概述\r#\r英文：Mediator Pattern 简述：将对象之间的通信关联关系封装到一个中介类中单独处理，从而使其耦合松散 归纳：联系方式我给你，怎么搞定我不管 目的：统一管理网状资源 案例：朋友圈 示例\r#\r// 中介者 public class ChatRoom { public static void showMessage(User user, String message) { System.out.println(new Date().toString() + \u0026#34; [\u0026#34; + user.getName() + \u0026#34;] : \u0026#34; + message); } } // 用户 public class User { @Setter @Getter private String name; public User(String name) { this.name = name; } public void sendMessage(String message) { ChatRoom.showMessage(this, message); } } public class Test { public static void main(String[] args) { User robert = new User(\u0026#34;Robert\u0026#34;); User john = new User(\u0026#34;John\u0026#34;); robert.sendMessage(\u0026#34;Hi! John!\u0026#34;); john.sendMessage(\u0026#34;Hello! Robert!\u0026#34;); } } 应用\r#\r主要解决： 对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂， 同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。 使用场景： 系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。 注意事项： 不应当在职责混乱的时候使用。 "},{"id":265,"href":"/program-design/data-algorithm/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","title":"二分查找","section":"数据算法","content":"\r二分查找\r#\r简述\r#\r前提条件：要求待查找的数据集合有序 每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到知道要查找的元素，或者区间被缩小为0 步骤\r#\r每次取中间位置的值与待查值比较， 如果中间位置的值比待查值大，则在前半部分循环这个查找的过程， 如果中间位置的值比待查值小，则在后半部分循环这个查找的过程。 直到查找到了为止，否则序列中没有待查的关键字。 示例\r#\r搜索插入位置\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。 如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 输入: nums = [1,3,5,6], target = 5 输出: 2 题解\npublic int searchInsert(int[] nums, int target) { int n = nums.length; int left = 0, right = n - 1, ans = n; while (left \u0026lt;= right) { int mid = ((right - left) \u0026gt;\u0026gt; 1) + left; if (target \u0026lt;= nums[mid]) { ans = mid; right = mid - 1; } else { left = mid + 1; } } return ans; } "},{"id":266,"href":"/program-design/design-pattern/behavioural/22-memento/","title":"备忘录模式","section":"行为型","content":"\r备忘录模式\r#\r概述\r#\r英文：Memento Pattern 简述：保存对象的状态，在需要时进行恢复 归纳：失足不成千古恨，想重来时就重来 目的：备份、后悔机制 案例：草稿箱 示例\r#\r// 备忘录 public class Memento { private String state; public Memento(String state) { this.state = state; } public String getState() { return state; } } // 备忘录管理员 public class CareTaker { private List\u0026lt;Memento\u0026gt; mementoList = new ArrayList\u0026lt;Memento\u0026gt;(); public void add(Memento state) { mementoList.add(state); } public Memento get(int index) { return mementoList.get(index); } } // 发起人 public class Originator { private String state; public void setState(String state) { this.state = state; } public String getState() { return state; } public Memento saveStateToMemento() { return new Memento(state); } public void getStateFromMemento(Memento Memento) { state = Memento.getState(); } } public class Test { public static void main(String[] args) { Originator originator = new Originator(); CareTaker careTaker = new CareTaker(); originator.setState(\u0026#34;State #1\u0026#34;); originator.setState(\u0026#34;State #2\u0026#34;); careTaker.add(originator.saveStateToMemento()); originator.setState(\u0026#34;State #3\u0026#34;); careTaker.add(originator.saveStateToMemento()); originator.setState(\u0026#34;State #4\u0026#34;); System.out.println(\u0026#34;Current State: \u0026#34; + originator.getState()); originator.getStateFromMemento(careTaker.get(0)); System.out.println(\u0026#34;First saved State: \u0026#34; + originator.getState()); originator.getStateFromMemento(careTaker.get(1)); System.out.println(\u0026#34;Second saved State: \u0026#34; + originator.getState()); } } 应用\r#\r主要解决： 所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态， 并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。 使用场景： 需要保存/恢复数据的相关状态场景。 提供一个可回滚的操作。 注意事项： 为了符合迪米特原则，还要增加一个管理备忘录的类。 为了节约内存，可使用原型模式+备忘录模式 "},{"id":267,"href":"/program-design/data-algorithm/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","title":"贪心算法","section":"数据算法","content":"\r贪心算法\r#\r简述\r#\r指在求解最优化问题时，每一步都选择在当前状态下最好或最优的策略，从而逐步推导出最优解的算法。 应用：有最优子结构的问题 步骤\r#\r建立数学模型来描述问题。 把求解的问题分成若干个子问题。 对每一子问题求解，得到子问题的局部最优解。 把子问题的解局部最优解合成原来解问题的一个解。 示例\r#\r分发饼干\n假设你是一位家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。 如果 s[j] \u0026gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。 你的目标是满足尽可能多的孩子，并输出这个最大数值。 输入: g = [1,2,3], s = [1,1] 输出: 1 解释: 由于饼干的尺寸都是 1，你只能让胃口值是 1 的孩子满足。所以输出 1。 输入: g = [1,2], s = [1,2,3] 输出: 2 解释: 拥有的饼干数量和尺寸都足以让所有孩子满足，所以输出 2。 思路\n为了尽可能满足最多数量的孩子，从贪心的角度考虑，应该按照孩子的胃口从小到大的顺序依次满足每个孩子， 且对于每个孩子，应该选择可以满足这个孩子的胃口且尺寸最小的饼干 题解\npublic int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int m = g.length, n = s.length; int count = 0; for (int i = 0, j = 0; i \u0026lt; m \u0026amp;\u0026amp; j \u0026lt; n; i++, j++) { while (j \u0026lt; n \u0026amp;\u0026amp; g[i] \u0026gt; s[j]) { j++; } if (j \u0026lt; n) { count++; } } return count; } "},{"id":268,"href":"/program-design/data-algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","title":"动态规划","section":"数据算法","content":"\r动态规划\r#\r简述\r#\rDynamic Programming，简称DP 通过把复杂问题拆分为一系列单阶段子问题，利用各阶段之间的关系，递推出最终解 核心思想：是利用空间换时间，通过存储已经计算过的子问题的解，从而减少计算量 经典应用：背包问题、最短路径问题、最长公共子序列、股票买卖问题 特征\r#\r重叠子问题：原问题的求解过程中，相同的子问题会多次出现 最优子结构：原问题的最优解可以由其子问题的最优解递归地构建而成 无后效性：某阶段状态一旦确定，就不会受到后续决策的影响 步骤\r#\r定义状态：确定问题的状态，将大问题分解为子问题，并确定子问题所对应的状态 状态转移：根据问题的性质，建立状态之间的转移关系，即状态转移方程 确定边界：确定初始状态和边界条件 求最优解：从初始状态开始求解问题，并保存中间结果，递推得到最终问题的最优解 示例\r#\r爬楼梯\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 输入：n = 3 输出：3 解释：有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 思路\n使用 f(n) 表示爬到第 n 级台阶的方案数， 因为每次只能爬 1 级或 2 级，所以 f(n) 只能从 f(n−1) 和 f(n−2) 转移过来 所以统计方案总数：f(n)=f(n−1)+f(n−2) 题解\n// 状态定义：设 dp 为一维数组，其中 dp[n] 的值代表爬到第 n 级台阶的方案数 // 转移方程：dp[n]=dp[n-1]+dp[n−2] // 初始状态：dp[0]=1, dp[1]=1 ，即初始化前两个数字。 // 返回值：dp[n] public static int climbStairs(int n) { int a = 1, b = 1, sum; for(int i = 2; i \u0026lt;= n; i++){ sum = a + b; a = b; b = sum; } return b; } "},{"id":269,"href":"/program-design/design-pattern/behavioural/23-chainOfResponsibility/","title":"职责链模式","section":"行为型","content":"\r职责链模式\r#\r概述\r#\r英文：Chain of Responsibility Pattern 简述： 拦截的类都实现统一接口，每个接收者都包含对下一个接收者的引用。 将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 归纳：各人自扫门前雪，莫管他们瓦上霜 目的：解耦处理逻辑 案例：踢皮球 示例\r#\r// 处理者 public abstract class Logger { public static int INFO = 1; public static int DEBUG = 2; public static int ERROR = 3; protected int level; //责任链中的下一个元素 protected Logger nextLogger; public void setNextLogger(Logger nextLogger) { this.nextLogger = nextLogger; } public void logMessage(int level, String message) { if (this.level \u0026lt;= level) { write(message); } if (nextLogger != null) { nextLogger.logMessage(level, message); } } abstract protected void write(String message); } // 处理者ConsoleLogger public class ConsoleLogger extends Logger { public ConsoleLogger(int level) { this.level = level; } @Override protected void write(String message) { System.out.println(\u0026#34;StandardConsole: \u0026#34; + message); } } // 处理者ErrorLogger public class ErrorLogger extends Logger { public ErrorLogger(int level) { this.level = level; } @Override protected void write(String message) { System.out.println(\u0026#34;ErrorConsole: \u0026#34; + message); } } // 处理者FileLogger public class FileLogger extends Logger { public FileLogger(int level) { this.level = level; } @Override protected void write(String message) { System.out.println(\u0026#34;FileConsole: \u0026#34; + message); } } public class Test { private static Logger getChainOfLoggers() { Logger errorLogger = new ErrorLogger(Logger.ERROR); Logger fileLogger = new FileLogger(Logger.DEBUG); Logger consoleLogger = new ConsoleLogger(Logger.INFO); errorLogger.setNextLogger(fileLogger); fileLogger.setNextLogger(consoleLogger); return errorLogger; } public static void main(String[] args) { Logger loggerChain = getChainOfLoggers(); loggerChain.logMessage(Logger.INFO, \u0026#34;info-message\u0026#34;); loggerChain.logMessage(Logger.DEBUG, \u0026#34;debug-message\u0026#34;); loggerChain.logMessage(Logger.ERROR, \u0026#34;error-message\u0026#34;); } } 应用\r#\r主要解决： 将请求的发送者和请求的处理者解耦 使用场景： 有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求 可动态指定一组对象处理请求 注意事项： 责任链模式其实就是一个灵活版的if…else…语句 "},{"id":270,"href":"/program-design/data-algorithm/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","title":"回溯算法","section":"数据算法","content":"\r回溯算法\r#\r简述\r#\r实际上一个类似枚举的搜索尝试过程 主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就”回溯”返回，尝试别的路径 基本思想：从一条路往前走，能进则进，不能进则退回来，换一条路再试 示例\r#\r括号生成\n数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。 输入：n = 3 输出：[\u0026#34;((()))\u0026#34;,\u0026#34;(()())\u0026#34;,\u0026#34;(())()\u0026#34;,\u0026#34;()(())\u0026#34;,\u0026#34;()()()\u0026#34;] 范围：1 ≤ n ≤ 8 思路\n当序列仍然保持有效时，才添加 ( 或 ) 每次添加完后删除最后一个括号，实现回溯。 题解\npublic List\u0026lt;String\u0026gt; generateParenthesis(int n) { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); backtrack(list, new StringBuilder(), 0, 0, n); return list; } public void backtrack(List\u0026lt;String\u0026gt; list, StringBuilder sb, int open, int close, int maxLen) { if (sb.length() == maxLen * 2) { list.add(sb.toString()); return; } // 如果左括号数量不大于 n，则可以追加一个左括号。 if (open \u0026lt; maxLen) { sb.append(\u0026#39;(\u0026#39;); backtrack(list, sb, open + 1, close, maxLen); sb.deleteCharAt(sb.length() - 1); } // 如果右括号数量小于左括号的数量，则可以追加一个右括号。 if (close \u0026lt; open) { sb.append(\u0026#39;)\u0026#39;); backtrack(list, sb, open, close + 1, maxLen); sb.deleteCharAt(sb.length() - 1); } } "},{"id":271,"href":"/program-design/data-algorithm/DFS-BFS%E6%90%9C%E7%B4%A2/","title":"DFS/BFS搜索","section":"数据算法","content":"\rDFS/BFS搜索\r#\rDFS搜索\r#\r深度优先搜索，Depth-First-Search DFS：从起始节点开始，沿着一条路径一直深入直到无法继续为止，然后回溯到上一个节点继续探索 DFS：使用栈来记录遍历的路径，它优先访问最近添加到栈的节点 BFS搜索\r#\r广度优先搜索，Breadth-First-Search BFS：从起点开始，先访问当前节点的所有邻居节点，然后再访问邻居节点的邻居节点，逐层地向外扩展 BFS：使用队列来记录遍历的路径，它优先访问最早添加到队列的节点 示例\r#\r岛屿数量\n给你一个由 \u0026#39;1\u0026#39;（陆地）和 \u0026#39;0\u0026#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 输入：grid = [ [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;] ] 输出：3 题解\npublic int numIslands(char[][] grid) { int count = 0; for (int i = 0; i \u0026lt; grid.length; i++) { for (int j = 0; j \u0026lt; grid[0].length; j++) { if (grid[i][j] == \u0026#39;1\u0026#39;) { dfs(grid, i, j); // bfs(grid, i, j); count++; } } } return count; } // DFS搜索 private void dfs(char[][] grid, int i, int j) { if (i \u0026lt; 0 || j \u0026lt; 0 || i \u0026gt;= grid.length || j \u0026gt;= grid[0].length || grid[i][j] == \u0026#39;0\u0026#39;) { return; } grid[i][j] = \u0026#39;0\u0026#39;; dfs(grid, i + 1, j); dfs(grid, i, j + 1); dfs(grid, i - 1, j); dfs(grid, i, j - 1); } // BFS搜索 private void bfs(char[][] grid, int i, int j) { Queue\u0026lt;int[]\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); list.add(new int[]{i, j}); while (!list.isEmpty()) { int[] cur = list.remove(); i = cur[0]; j = cur[1]; if (0 \u0026lt;= i \u0026amp;\u0026amp; i \u0026lt; grid.length \u0026amp;\u0026amp; 0 \u0026lt;= j \u0026amp;\u0026amp; j \u0026lt; grid[0].length \u0026amp;\u0026amp; grid[i][j] == \u0026#39;1\u0026#39;) { grid[i][j] = \u0026#39;0\u0026#39;; list.add(new int[]{i + 1, j}); list.add(new int[]{i - 1, j}); list.add(new int[]{i, j + 1}); list.add(new int[]{i, j - 1}); } } } "},{"id":272,"href":"/algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%931/","title":"机试题库 - 1","section":"华为OD","content":"\r01. 车路协同场景\r#\r描述\n数轴×有两个点的序列 A={A1， A2, …, Am}和 B={B1, B2, ..., Bn}， Ai 和 Bj 均为正整数， A、 B 已经从小到大排好序， A、 B 均肯定不为空， 给定一个距离 R（正整数），列出同时满足如下条件的所有（Ai， Bj）数对 条件： 1、Ai ≤ Bj 2、Ai,Bj 距离小于等于 R，但如果 Ai 找不到 R 范围内的 Bj，则列出距它最近的 1 个 Bj，当然此种情况仍然要满足 1， 但如果仍然找不到，就丢弃 Ai。 输入描述：按照人易读的格式输入一行数据，参见输入样例 输出描述：(Ai,Bj)数对序列 输入：A={1,3,5},B={2,4,6},R=1 输出：(1,2)(3,4)(5,6) 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String line = sc.nextLine(); String[] strArr = line.split(\u0026#34;\\\\{|\\\\}\u0026#34;); int[] arrA = Arrays.stream(strArr[1].split(\u0026#34;,\u0026#34;)).mapToInt(Integer::parseInt).toArray(); int[] arrB = Arrays.stream(strArr[3].split(\u0026#34;,\u0026#34;)).mapToInt(Integer::parseInt).toArray(); int r = Integer.parseInt(line.substring(line.lastIndexOf(\u0026#34;=\u0026#34;) + 1)); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int a : arrA) { int sum = 0; for (int b : arrB) { if (b \u0026lt; a) { continue; } if (b - a \u0026lt;= r || sum == 0) { list.add(\u0026#34;(\u0026#34; + a + \u0026#34;,\u0026#34; + b + \u0026#34;)\u0026#34;); sum++; } else { break; } } } System.out.println(String.join(\u0026#34;,\u0026#34;, list)); } 02. API集群负载统计\r#\r描述\n某个产品的RESTful API集合部署在服务器集群的多个节点上，近期需要统计各个API的访问频次，根据热点信息在服务器节点之间做负载均衡，现在需要实现热点信息统计查询功能。RESTful API是由多个层级构成。 层级之间使用/连接，如/A/B/C/D这个地址，A属于第一级，B属于第二级，C属于第三级，D属于第四级。 现在负载均衡模块需要知道给定层级上某个名字出现的频次，未出现过用0表示，实现这个功能。 输入描述： 第一行为N，表示访问历史日志的条数，0 ＜ N ≤ 100。 接下来N行，每一行为一个URL地址，约束地址中仅包含英文字母和连接符 / ，最大层级为10，每层级字符串最大长度为10。 最后一行为层级L和要查询的关键字。 输出描述：输出给定层级上，关键字出现的频次，使用完全匹配方式（大小写敏感）。 输入：5 /huawei/computing/no/one /huawei/computing /huawei /huawei/cloud/no/one /huawei/wireless/no/one 2 computing 输出：2 说明：在第二层级上，computing出现了2次，因此输出2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); String[] arr = new String[num]; for (int i = 0; i \u0026lt; num; i++) { arr[i] = sc.nextLine(); } String[] strings = sc.nextLine().split(\u0026#34; \u0026#34;); int l = Integer.parseInt(strings[0]); String key = strings[1]; int sum = 0; for (int i = 0; i \u0026lt; num; i++) { String[] tempArr = arr[i].split(\u0026#34;/\u0026#34;); if (l \u0026lt; tempArr.length \u0026amp;\u0026amp; key.equals(tempArr[l])) { sum++; } } System.out.println(sum); } 03. CPU算力分配\r#\r描述\n现有两组服务器A和B，每组有多个算力不同的CPU，其中A[i]是A组第i个CPU的运算能力，B[i]是B组第i个CPU的运算能力。 一组服务器的总算力是各CPU的算力之和。为了让两组服务器的算力相等，允许从每组各选出一个CPU进行一次交换， 求两组服务器中，用于交换的CPU的算力，并且要求从A组服务器中选出的CPU，算力尽可能小。 输入描述： 第一行输入为L1和L2，以空格分隔，L1表示A组服务器中的CPU数量，L2表示B组服务器中的CPU数量。 第二行输入为A组服务器中各个CPU的算力值，以空格分隔。 第三行输入为B组服务器中各个CPU的算力值，以空格分隔。 1 ≤ L1 ≤ 10000 1 ≤ L2 ≤ 10000 1 ≤ A[i] ≤ 100000 1 ≤ B[i] ≤ 100000 输出描述： 对于每组测试数据，输出两个整数，以空格分隔，依次表示A组选出的CPU算力，B组选出的CPU算力。 要求从A组选出的CPU的算力尽可能小。 输入：3 2 1 2 5 2 4 输出：5 4 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int l1 = sc.nextInt(); int l2 = sc.nextInt(); int sumA = 0; int[] arrA = new int[l1]; for (int i = 0; i \u0026lt; l1; i++) { arrA[i] = sc.nextInt(); sumA += arrA[i]; } int sumB = 0; Set\u0026lt;Integer\u0026gt; tempSet = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; l2; i++) { int b = sc.nextInt(); sumB += b; tempSet.add(b); } String ans = \u0026#34;\u0026#34;; int minA = Integer.MAX_VALUE; int half = (sumA - sumB) / 2; for (int a : arrA) { // sumA - a + b = sumB - b + a // b = a - (sumA - sumB)/2 int b = a - half; if (tempSet.contains(b)) { minA = Math.min(a, minA); ans = minA + \u0026#34; \u0026#34; + b; } } for (int i = 0; i \u0026lt; l1; i++) { // sumA - a + b = sumB - b + a // b = a - (sumA - sumB)/2 int b = arrA[i] - half; if (tempSet.contains(b)) { minA = Math.min(arrA[i], minA); ans = minA + \u0026#34; \u0026#34; + b; } } System.out.println(ans); } } 04. We Are A Team\r#\r描述\n总共有 n 个人在机房，每个人有一个标号（1≤标号≤n）， 他们分成了多个团队，需要你根据收到的 m 条消息判定指定的两个人是否在一个团队中，具体的： 1. 消息构成为 a b c，整数 a、b 分别代表两个人的标号，整数 c 代表指令 2. c == 0 代表 a 和 b 在一个团队内 3. c == 1 代表需要判定，如果 a 和 b 是一个团队，输出一行’we are a team’,否则输出一行’we are not a team’ 4. c 为其他值，或当前行 a 或 b 超出 1~n 的范围，输出‘da pian zi’ 输入描述： 第一行包含两个整数 n，m(1≤n,m＜100000),分别表示有 n 个人和 m 条消息 随后的 m 行，每行一条消息，消息格式为：a b c(1≤a,b≤n,0≤c≤1) 输出描述： c ==1,判断 a 和 b关系，在一个团队中输出‘we are a team‘,不在一个团队中输出’we are not a team’ c 为其他值，或当前行 a 或 b 的标号小于 1 或者大于 n 时，输出字符串‘da pian zi‘ 如果第一行 n 和 m 的值超出约定的范围时，输出字符串”NULL“。 输入：5 6 1 2 0 1 2 1 1 5 0 2 3 1 2 5 1 1 3 2 输出：we are a team we are not a team we are a team da pian zi 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int[][] msgs = new int[m][3]; for (int i = 0; i \u0026lt; m; i++) { msgs[i][0] = sc.nextInt(); msgs[i][1] = sc.nextInt(); msgs[i][2] = sc.nextInt(); } getResult(msgs, n, m); } public static void getResult(int[][] msgs, int n, int m) { // 如果第一行 n 和 m 的值超出约定的范围时，输出字符串”Null“。 if (n \u0026lt; 1 || n \u0026gt;= 100000 || m \u0026lt; 1 || m \u0026gt;= 100000) { System.out.println(\u0026#34;NULL\u0026#34;); return; } UnionFindSet ufs = new UnionFindSet(n + 1); for (int[] msg : msgs) { int a = msg[0], b = msg[1], c = msg[2]; if (a \u0026lt; 1 || a \u0026gt; n || b \u0026lt; 1 || b \u0026gt; n) { // 当前行 a 或 b 的标号小于 1 或者大于 n 时，输出字符串‘da pian zi‘ System.out.println(\u0026#34;da pian zi\u0026#34;); continue; } if (c == 0) { // c == 0 代表 a 和 b 在一个团队内 ufs.union(a, b); } else if (c == 1) { // c == 1 代表需要判定 a 和 b 的关系 String str = ufs.findRoot(a) == ufs.findRoot(b) ? \u0026#34;we are a team\u0026#34; : \u0026#34;we are not a team\u0026#34;; System.out.println(str); } else { // c 为其他值，输出字符串‘da pian zi‘ System.out.println(\u0026#34;da pian zi\u0026#34;); } } } // 并查集 static class UnionFindSet { int[] fa; // 初始化，设置i的父节点fa[i]为自身 public UnionFindSet(int n) { this.fa = new int[n]; for (int i = 0; i \u0026lt; n; i++) { fa[i] = i; } } // 查找x的根节点 public int findRoot(int x) { // 递归中断条件：根节点为自身 if (fa[x] == x) { return x; } // 递归：查询x的根节点 int root = findRoot(fa[x]); // 递归路径压缩：直接设置x的父节点为根 fa[x] = root; return root; } // 合并节点x、y public void union(int x, int y) { // 查找xy两者的根节点 int xFa = this.findRoot(x); int yFa = this.findRoot(y); // 合并：将xy两者的根节点设为一样 fa[xFa] = yFa; } } 05. 爱吃蟠桃的孙悟空\r#\r描述\n孙悟空爱吃蟠桃，有一天趁着蟠桃园守卫不在来偷吃。已知蟠桃园有 N 棵桃树，每颗树上都有桃子，守卫将在 H 小时后回来。 孙悟空可以决定他吃蟠桃的速度K（个/小时），每个小时选一颗桃树，并从树上吃掉 K 个，如果树上的桃子少于 K 个，则全部吃掉，并且这一小时剩余的时间里不再吃桃。 孙悟空喜欢慢慢吃，但又想在守卫回来前吃完桃子。 请返回孙悟空可以在 H 小时内吃掉所有桃子的最小速度 K（K为整数）。如果以任何速度都吃不完所有桃子，则返回0。 输入描述： 第一行输入为 N 个数字，N 表示桃树的数量，这 N 个数字表示每颗桃树上蟠桃的数量。 第二行输入为一个数字，表示守卫离开的时间 H。 其中数字通过空格分割，N、H为正整数，每颗树上都有蟠桃，且 0 ＜ N ＜ 10000，0 ＜ H ＜ 10000。 输出描述： 吃掉所有蟠桃的最小速度 K，无解或输入异常时输出 0。 输入：30 11 23 4 20 6 输出：23 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] arr = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int h = Integer.parseInt(sc.nextLine()); System.out.println(getResult(arr, h)); } public static int getResult(int[] arr, int h) { // 每个小时只能选一颗桃树，如果桃树数量大于h，那么肯定吃不完 if (arr.length \u0026gt; h) { return 0; } // 拥有最多桃子的那颗桃树上的桃子数量 int max = Arrays.stream(arr).max().orElse(0); // 如果桃树数量就是h棵，那么必须一小时吃完一颗树，此时，吃桃速度至少是max if (arr.length == h) { return max; } // 如果只有1棵桃树，且这颗树上只有1个桃，那么吃桃速度可以是1 int min = 1; // 当桃树数量少于h棵时，以max速度吃桃肯定可以吃完，但是不一定是最优解 int ans = max; // 二分法 while (min \u0026lt;= max) { // 取中间值作为吃桃速度进行尝试 int mid = (min + max) \u0026gt;\u0026gt; 1; if (check(mid, h, arr)) { ans = mid; // 尝试更小的速度 max = mid - 1; } else { // 尝试更大的速度 min = mid + 1; } } return ans; } public static boolean check(int speed, int limit, int[] arr) { int cost = 0; for (int cnt : arr) { cost += cnt / speed + (cnt % speed \u0026gt; 0 ? 1 : 0); if (cost \u0026gt; limit) { return false; } } return true; } 06. 按身高和体重排队\r#\r描述\n某学校举行运动会，学生们按编号(1、2、3…n)进行标识，现需要按照身高由低到高排列，对身高相同的人，按体重由轻到重排列；对于身高体重都相同的人，维持原有的编号顺序关系。请输出排列后的学生编号。 输入描述： 两个序列，每个序列由n个正整数组成（0 ＜ n ≤ 100）。第一个序列中的数值代表身高，第二个序列中的数值代表体重。 输出描述： 排列结果，每个数值都是原始序列中的学生编号，编号从1开始 输入：4 100 100 120 130 40 30 60 50 输出：2 1 3 4 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); int[][] students = new int[n][3]; for (int i = 0; i \u0026lt; n; i++) { students[i][0] = sc.nextInt(); } for (int i = 0; i \u0026lt; n; i++) { students[i][1] = sc.nextInt(); students[i][2] = i + 1; } sc.close(); Arrays.sort(students, (a, b) -\u0026gt; a[0] != b[0] ? a[0] - b[0] : a[1] != b[1] ? a[1] - b[1] : a[2] - b[2]); String ans = Arrays.stream(students) .map(arr -\u0026gt; String.valueOf(arr[2])).collect(Collectors.joining(\u0026#34; \u0026#34;)); System.out.println(ans); } 07. 报数游戏\r#\r描述\n100个人围成一圈，每个人有一个编码，编号从1开始到100。 他们从1开始依次报数，报到为M的人自动退出圈圈，然后下一个人接着从1开始报数，直到剩余的人数小于M。 请问最后剩余的人在原先的编号为多少？ 输入描述：输入一个整数参数 M 输出描述：如果输入参数M小于等于1或者大于等于100，输出“ERROR!”； 否则按照原先的编号从小到大的顺序，以英文逗号分割输出编号字符串 输入：3 输出：58,91 说明：输入M为3，最后剩下两个人。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); if (m \u0026lt;= 1 || m \u0026gt;= 100) { System.out.println(\u0026#34;ERROR!\u0026#34;); return; } CycleLinkedList list = new CycleLinkedList(); for (int i = 1; i \u0026lt;= 100; i++) { list.append(i); } int idx = 1; Node cur = list.head; while (list.size \u0026gt;= m) { if (idx == m) { idx = 1; cur = list.remove(cur); } else { idx++; cur = cur.next; } } System.out.println(list); } static class Node { int val; Node prev; Node next; public Node(int val, Node prev, Node next) { this.val = val; this.prev = prev; this.next = next; } } static class CycleLinkedList { Node head; Node tail; int size = 0; public void append(int val) { Node node = new Node(val, null, null); if (this.size \u0026gt; 0) { this.tail.next = node; node.prev = this.tail; this.tail = node; } else { this.head = node; this.tail = node; } this.head.prev = this.tail; this.tail.next = this.head; this.size++; } public Node remove(Node cur) { Node pre = cur.prev; Node nxt = cur.next; pre.next = nxt; nxt.prev = pre; cur.next = cur.prev = null; if (this.head == cur) { this.head = nxt; } if (this.tail == cur) { this.tail = pre; } this.size--; return nxt; } @Override public String toString() { StringJoiner sj = new StringJoiner(\u0026#34;,\u0026#34;); Node cur = this.head; for (int i = 0; i \u0026lt; this.size; i++) { sj.add(cur.val + \u0026#34;\u0026#34;); cur = cur.next; } return sj.toString(); } } 08. 表达式括号匹配\r#\r描述\n(1+(2+3)*(3+(8+0))+1-2)这是一个简单的数学表达式,今天不是计算它的值,而是比较它的括号匹配是否正确。 前面这个式子可以简化为(()(()))这样的括号我们认为它是匹配正确的, 而((())这样的我们就说他是错误的。注意括号里面的表达式可能是错的,也可能有多个空格，对于这些我们是不用去管的， 我们只关心括号是否使用正确。 输入描述：给出一行表达式(长度不超过 100)。 输出描述：如果匹配正确输出括号的对数，否则输出-1。 输入：(1+(2+3)*(3+(8+0))+1-2) 输出：4 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chs = sc.nextLine().toCharArray(); Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); int sum = 0; for (char ch : chs) { if (ch == \u0026#39;(\u0026#39;) { stack.push(ch); continue; } if (ch != \u0026#39;)\u0026#39;) { continue; } if (stack.isEmpty()) { System.out.println(\u0026#34;-1\u0026#34;); break; } char c = stack.pop(); if (c != \u0026#39;(\u0026#39;) { System.out.println(\u0026#34;-1\u0026#34;); break; } sum++; } System.out.println(sum); } 09. 部门人力分配\r#\r描述\n部门在进行需求开发时需要进行人力安排。 当前部门需要完成 N 个需求，需求用 requirements 表述，requirements[i] 表示第 i 个需求的工作量大小，单位：人月。 这部分需求需要在 M 个月内完成开发，进行人力安排后每个月人力时固定的。 目前要求每个月最多有2个需求开发，并且每个月需要完成的需求不能超过部门人力。 请帮助部门评估在满足需求开发进度的情况下，每个月需要的最小人力是多少？ 输入描述： 输入为 M 和 requirements，M 表示需求开发时间要求，requirements 表示每个需求工作量大小，N 为 requirements长度， 1 ≤ N/2 ≤ M ≤ N ≤ 10000 1 ≤ requirements[i] ≤ 10^9 输出描述： 对于每一组测试数据，输出部门需要人力需求，行末无多余的空格 输入：3 3 5 3 4 输出：6 换个说法： 目前有 N 个人（N个需求），每个人的体重为requirements[i]，（每个需求开发需要的人力为requirements[i]） 以及 M 辆自行车（M个月开发），每辆自行车至多坐两人（每个月至多开发两个需求）， 现在想要用 M 辆自行车带走 N 个人，问每辆自行车的限重至少是多少？（M个月开发完N个需求，每个月至少需要多少人力） 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = Integer.parseInt(sc.nextLine()); int[] arr = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(m, arr)); } public static long getResult(int m, int[] requirements) { Arrays.sort(requirements); int n = requirements.length; // 每辆自行车的限重 至少是 最重的那个人的体重 long min = requirements[n - 1]; // 每辆自行车的限重 至多是 最重的和次重的那两个的体重 long max = requirements[n - 2] + requirements[n - 1]; long ans = max; // 二分取中间值 while (min \u0026lt;= max) { // min，max单独看都不超过int，但是二者相加会超过int，因此需要用long类型 long mid = (min + max) \u0026gt;\u0026gt; 1; if (check(mid, m, requirements)) { // 如果mid限重，可以满足m辆车带走n个人，则mid就是一个可能解，但不一定是最优解 ans = mid; // 继续尝试更小的限重，即缩小右边界 max = mid - 1; } else { // 如果mid限重，不能满足m辆车带走n个人，则mid限重小了 // 我们应该尝试更大的限重，即扩大左边界 min = mid + 1; } } return ans; } /** * @param limit 每辆自行车的限重 * @param m m辆自行车 * @param requirements n个人的体重数组 * @return m辆自行车，每辆限重limit的情况下，能否带走n个人 */ public static boolean check(long limit, int m, int[] requirements) { int l = 0; // 指向体重最轻的人 int r = requirements.length - 1; // 指向体重最重的人 // 需要的自行车数量 int need = 0; while (l \u0026lt;= r) { // 如果最轻的人和最重的人可以共享一辆车，则l++,r--， // 否则最重的人只能单独坐一辆车，即仅r-- if (requirements[l] + requirements[r] \u0026lt;= limit) { l++; } r--; // 用掉一辆车 need++; } // 如果m \u0026gt;= need，当前有的自行车数量足够 return m \u0026gt;= need; } 10. 求幸存数之和\r#\r描述\n给一个正整数数列 nums，一个跳数 jump，及幸存数量 left。 运算过程为：从索引0的位置开始向后跳，中间跳过 J 个数字，命中索引为 J+1 的数字，该数被敲出，并从该点起跳，以此类推，直到幸存 left 个数为止，然后返回幸存数之和。 约束： 1. 0是第一个起跳点 2. 起跳点和命中点之间间隔 jump 个数字，已被敲出的数字不计入在内。 3. 跳到末尾时无缝从头开始（循环查找），并可以多次循环。 4. 若起始时 left \u0026gt; len(nums) 则无需跳数处理过程。 输入描述： 第一行输入正整数数列 第二行输入跳数 第三行输入幸存数量 输出描述： 输出幸存数之和 输入：1,2,3,4,5,6,7,8,9 4 3 输出：13 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] nums = Arrays.stream(sc.nextLine().split(\u0026#34;,\u0026#34;)).mapToInt(Integer::parseInt).toArray(); int jump = Integer.parseInt(sc.nextLine()); int left = Integer.parseInt(sc.nextLine()); System.out.println(sumOfLeft(nums, jump, left)); } public static int sumOfLeft(int[] nums, int jump, int left) { ArrayList\u0026lt;Integer\u0026gt; list = (ArrayList\u0026lt;Integer\u0026gt;) Arrays.stream(nums).boxed().collect(Collectors.toList()); // 从起跳点的下一个节点开始 int start = 1; // 如果剩余节点数 \u0026gt; 幸存数量，则还需要继续删除节点 while (list.size() \u0026gt; left) { // 跳 jump 次 start += jump; // 为了避免越界，新起跳点索引位置对剩余节点数取余 start %= list.size(); list.remove(start); } return list.stream().reduce(Integer::sum).orElse(0); } 11. 测试用例执行计划\r#\r描述\n某个产品当前迭代周期内有 N 个特性（F1,F2,......FN）需要进行覆盖测试， 每个特性都被评估了对应的优先级，特性使用其 ID 作为下标进行标识。 设计了 M 个测试用例（T1,T2,......,TM），每个测试用例对应一个覆盖特性的集合， 测试用例使用其 ID 作为下标进行标识，测试用例的优先级定义为其覆盖的特性的优先级之和。 在开展测试之前，需要制定测试用例的执行顺序， 规则为：优先级大的用例先执行，如果存在优先级相同的用例，用例 ID 小的先执行。 输入描述 第一行输入为 N 和 M， N 表示特性的数量，0 ＜ N ≤ 100 M 表示测试用例的数量，0 ＜ M ≤ 100 之后 N 行表示特性 ID=1 到特性 ID=N 的优先级， 再接下来 M 行表示测试用例 ID=1 到测试用例 ID=M 关联的特性的 ID 的列表。 输出描述： 按照执行顺序（优先级从大到小）输出测试用例的 ID，每行一个ID。 测试用例覆盖的 ID 不重复。 输入：5 4 1 1 2 3 5 1 2 3 1 4 3 4 5 2 3 4 输出：3 4 1 2 说明：\t测试用例的优先级计算如下： T1 = Pf1 + Pf2 + Pf3 = 1 + 1 + 2 = 4 T2 = Pf1 + Pf4 = 1 + 3 = 4 T3 = Pf3 + Pf4 + Pf5 = 2 + 3 + 5 = 10 T4 = Pf2 + Pf3 + Pf4 = 1 + 2 + 3 = 6 按照优先级从小到大，以及相同优先级，ID小的先执行的规则，执行顺序为T3,T4,T1,T2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] strings = sc.nextLine().split(\u0026#34; \u0026#34;); int n = Integer.parseInt(strings[0]); int m = Integer.parseInt(strings[1]); int[] arrF = new int[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { arrF[i] = Integer.parseInt(sc.nextLine()); } int[][] arrT = new int[m][2]; for (int i = 0; i \u0026lt; m; i++) { arrT[i][1] = i + 1; int sum = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)) .map(Integer::parseInt).map(id -\u0026gt; arrF[id]).reduce(Integer::sum).orElse(0); arrT[i][0] = sum; } Arrays.sort(arrT, (a, b) -\u0026gt; a[0] != b[0] ? b[0] - a[0] : a[1] - b[1]); Arrays.stream(arrT).map(arr -\u0026gt; String.valueOf(arr[1])).forEach(System.out::println); } 12. 查找接口成功率最优时间段\r#\r描述\n服务之间交换的接口成功率作为服务调用关键质量特性，某个时间段内的接口失败率使用一个数组表示， 数组中每个元素都是单位时间内失败率数值，数组中的数值为0~100的整数， 给定一个数值(minAverageLost)表示某个时间段内平均失败率容忍值，即平均失败率小于等于minAverageLost， 找出数组中最长时间段，如果未找到则直接返回NULL。 输入描述： 输入有两行内容，第一行为{minAverageLost}，第二行为{数组}，数组元素通过空格(” “)分隔， minAverageLost及数组中元素取值范围为0~100的整数，数组元素的个数不会超过100个。 输出描述： 找出平均值小于等于minAverageLost的最长时间段，输出数组下标对，格式{beginIndex}-{endIndx}(下标从0开始)， 如果同时存在多个最长时间段，则输出多个下标对且下标对之间使用空格(” “)拼接，多个下标对按下标从小到大排序。 输入：2 0 0 100 2 2 99 0 2 输出：0-1 3-4 6-7 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int minAverageLost = Integer.parseInt(sc.nextLine()); int[] nums = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(nums, minAverageLost)); } public static String getResult(int[] nums, int minAverageLost) { int n = nums.length; int[] preSum = new int[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { preSum[i] = preSum[i - 1] + nums[i - 1]; } int maxLen = 0; ArrayList\u0026lt;int[]\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt;= n; j++) { // sum 是 区间 [i, j-1] 的和 int sum = preSum[j] - preSum[i]; int len = j - i; int minLost = len * minAverageLost; if (sum \u0026gt; minLost) { continue; } if (len \u0026gt; maxLen) { list = new ArrayList\u0026lt;\u0026gt;(); } if (len \u0026gt;= maxLen) { list.add(new int[]{i, j - 1}); maxLen = len; } } } if (list.isEmpty()) { return \u0026#34;NULL\u0026#34;; } list.sort(Comparator.comparingInt(a -\u0026gt; a[0])); return list.stream().map(arr -\u0026gt; arr[0] + \u0026#34;-\u0026#34; + arr[1]).collect(Collectors.joining(\u0026#34; \u0026#34;)); } 13. 查找众数及中位数\r#\r描述\n众数是指一组数据中出现次数量多的那个数，众数可以是多个。 中位数是指把一组数据从小到大排列，最中间的那个数，如果这组数据的个数是奇数，那最中间那个就是中位数， 如果这组数据的个数为偶数，那就把中间的两个数之和除以2，所得的结果就是中位数。 查找整型数组中元素的众数并组成一个新的数组，求新数组的中位数。 输入描述：输入一个一维整型数组，数组大小取值范围 0＜N＜1000，数组中每个元素取值范围 0＜E＜1000 输出描述：输出众数组成的新数组的中位数 输入：5 1 5 3 5 2 5 5 7 6 7 3 7 11 7 55 7 9 98 9 17 9 15 9 9 1 39 输出：7 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] nums = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(nums)); } public static int getResult(int[] nums) { HashMap\u0026lt;Integer, Integer\u0026gt; count = new HashMap\u0026lt;\u0026gt;(); for (int num : nums) { count.put(num, count.getOrDefault(num, 0) + 1); } // 获取最大出现次数 int max = count.values().stream().max(Comparator.comparingInt(a -\u0026gt; a)).orElse(0); // 将众数挑选出来 ArrayList\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (Integer k : count.keySet()) { if (count.get(k) == max) ans.add(k); } // 众数升序 ans.sort(Comparator.comparingInt(a -\u0026gt; a)); // 中位数取值 int mid = ans.size() / 2; if (ans.size() % 2 == 0) { return (ans.get(mid) + ans.get(mid - 1)) / 2; } else { return ans.get(mid); } } 14. 单词加密\r#\r描述\n1、输入一个英文句子，句子中包含若干个单词，每个单词间有一个空格； 2、需要将句子中的每个单词按照要求加密输出。 要求： 1）单词中包括元音字符（‘aeuio’、‘AEUIO’，大小写都算），则将元音字符替换成‘*’ 2）单词中不包括元音字符，将单词首尾字符进行对换 输入描述：输入只有一行，包含一个长度都不超过100的字符串，表示英文句子。 输出描述：输出只有一行，即按要求输出加密处理后的英文句子 输入：Hello world 输出：H*ll* w*rld 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.nextLine(); System.out.println(getResult(s)); } public static String getResult(String s) { String[] words = s.split(\u0026#34; \u0026#34;); for (int i = 0; i \u0026lt; words.length; i++) { Matcher matcher = Pattern.compile(\u0026#34;[aeiouAEIOU]\u0026#34;).matcher(words[i]); if (matcher.find()) { words[i] = matcher.replaceAll(\u0026#34;*\u0026#34;); } else { char[] cArr = words[i].toCharArray(); char tmp = cArr[0]; cArr[0] = cArr[cArr.length - 1]; cArr[cArr.length - 1] = tmp; words[i] = new String(cArr); } } return String.join(\u0026#34; \u0026#34;, words); } 15. 单词接龙\r#\r描述\n单词接龙的规则是： 可用于接龙的单词首字母必须要前一个单词的尾字母相同； 当存在多个首字母相同的单词时，取长度最长的单词，如果长度也相等，则取字典序最小的单词；已经参与接龙的单词不能重复使用。 现给定一组全部由小写字母组成单词数组，并指定其中的一个单词作为起始单词，进行单词接龙， 请输出最长的单词串，单词串是单词拼接而成，中间没有空格。 备注： 单词个数N的取值范围为[1, 20]； 单个单词的长度的取值范围为[1, 30]； 输入描述： 输入的第一行为一个非负整数，表示起始单词在数组中的索引K，0 ≤ K ＜ N ； 输入的第二行为一个非负整数，表示单词的个数N； 接下来的N行，分别表示单词数组中的单词。 输出描述： 输出一个字符串，表示最终拼接的单词串。 输入：4 6 word dd da dc dword d 输出：dwordda 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int k = Integer.parseInt(sc.nextLine()); int n = Integer.parseInt(sc.nextLine()); String[] arr = new String[n]; for (int i = 0; i \u0026lt; n; i++) { arr[i] = sc.nextLine(); } Map\u0026lt;String, LinkedList\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { if (i == k) { continue; } String str = arr[i]; String key = String.valueOf(str.charAt(0)); map.putIfAbsent(key, new LinkedList\u0026lt;\u0026gt;()); map.get(key).add(str); } for (LinkedList\u0026lt;String\u0026gt; list : map.values()) { list.sort((s1, s2) -\u0026gt; s1.length() != s2.length() ? s2.length() - s1.length() : s1.compareTo(s2)); } String tempStr = arr[k]; StringBuilder sb = new StringBuilder(tempStr); while (true) { String key = String.valueOf(tempStr.charAt(tempStr.length() - 1)); if (!map.containsKey(key) || map.get(key).isEmpty()) { break; } tempStr = map.get(key).removeFirst(); sb.append(tempStr); } System.out.println(sb); } 16. 单词重量\r#\r描述\n每个句子由多个单词组成，句子中的每个单词的长度都可能不一样，我们假设每个单词的长度Ni为该单词的重量，你需要做的就是给出整个句子的平均重量V。 输入：Who Love Solo 输出：3.67 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] arr = sc.nextLine().split(\u0026#34; \u0026#34;); int len = Arrays.stream(arr).mapToInt(String::length).reduce(Integer::sum).orElse(0); double d = (double) len / arr.length; /* %f : 输出浮点数 %.nf : 控制小数点后的位数，n为数字 %c : 输出字符 %d : 输出十进制整数 %o : 输出八进制整数 %x : 输出十六进制整数 %X : 输出大写十六进制整数 */ System.out.printf(\u0026#34;%.2f%n\u0026#34;, d); } 17. 德州扑克\r#\r描述\n五张牌，每张牌由牌大小和花色组成，牌大小2~10、J、Q、K、A，牌花色为红桃、黑桃、梅花、方块四种花色之一。 判断牌型: 牌型1，同花顺：同一花色的顺子，如红桃2红桃3红桃4红桃5红桃6。 牌型2，四条：四张相同数字 + 单张，如红桃A黑桃A梅花A方块A + 黑桃K。 牌型3，葫芦：三张相同数字 + 一对，如红桃5黑桃5梅花5 + 方块9梅花9。 牌型4，同花：同一花色，如方块3方块7方块10方块J方块Q。 牌型5，顺子：花色不一样的顺子，如红桃2黑桃3红桃4红桃5方块6。 牌型6，三条：三张相同+两张单。 说明： （1）五张牌里不会出现牌大小和花色完全相同的牌。 （2）编号小的牌型较大，如同花顺比四条大，依次类推。 （3）包含A的合法的顺子只有10 J Q K A和A 2 3 4 5;类似K A 2 3 4的序列不认为是顺子。 输入描述： 输入由5行组成，每行为一张牌大小和花色，牌大小为2~10、J、Q、K、A，花色分别用字符H、S、C、D表示红桃、黑桃、梅花、方块。 输出描述： 输出牌型序号，5张牌符合多种牌型时，取最大的牌型序号输出。 输入：9 S 5 S 6 S 7 S 8 S 输出：1 说明：既是顺子又是同花，输出1，同花顺 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] nums = new int[5]; String[] colors = new String[5]; for (int i = 0; i \u0026lt; 5; i++) { String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); nums[i] = cards(split[0]); colors[i] = split[1]; } System.out.println(getResult(nums, colors)); } public static int getResult(int[] nums, String[] colors) { // 同花 boolean isTongHua = new HashSet\u0026lt;\u0026gt;(Arrays.asList(colors)).size() == 1; // 顺子 boolean isShunZi = isShunZi(nums); int[] arr = new int[15]; for (int num : nums) { arr[num]++; } // 对子 boolean isDuiZi = false; for (int j : arr) { if (j == 2) { isDuiZi = true; break; } } // 相同数字的最大张数 int maxLen = Arrays.stream(arr).max().orElse(0); // 同花顺 if (isShunZi \u0026amp;\u0026amp; isTongHua) { return 1; } // 四条 if (maxLen == 4) { return 2; } // 葫芦 if (maxLen == 3 \u0026amp;\u0026amp; isDuiZi) { return 3; } // 同花 if (isTongHua) { return 4; } // 顺子 if (isShunZi) { return 5; } // 三条 if (maxLen == 3) { return 6; } return 0; } public static int getMaxLen(int[] nums) { int[] arr = new int[15]; for (int num : nums) { arr[num]++; } return Arrays.stream(arr).max().orElse(0); } public static boolean isShunZi(int[] nums) { Arrays.sort(nums); if (\u0026#34;234514\u0026#34;.equals(\u0026#34;\u0026#34; + nums[0] + nums[1] + nums[2] + nums[3] + nums[4])) { return true; } for (int i = 0; i \u0026lt; nums.length; i++) { if (nums[0] + i != nums[i]) { return false; } } return true; } private static int cards(String str) { return switch (str) { case \u0026#34;J\u0026#34; -\u0026gt; 11; case \u0026#34;Q\u0026#34; -\u0026gt; 12; case \u0026#34;K\u0026#34; -\u0026gt; 13; case \u0026#34;A\u0026#34; -\u0026gt; 14; default -\u0026gt; Integer.parseInt(str); }; } 18. 第k个排列\r#\r描述\n给定参数n，从1到n会有n个整数：1,2,3,…,n,这n个数字共有n!种排列。按大小顺序升序列出所有排列的情况，并一一标记， 当n=3时,所有排列如下:“123” “132” “213” “231” “312” “321” 给定n和k，返回第k个排列。 输入描述：输入两行，第一行为n，第二行为k，给定n的范围是[1,9],给定k的范围是[1,n!]。 输出描述：输出排在第k位置的数字。 输入：3 3 输出：213 输入：4 9 输出：2314 题解 #\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextInt()) { int n = sc.nextInt(); int k = sc.nextInt(); String res = getResult(n, k); System.out.println(res); } } // 康托展开公式：X = a[n]*(n-1)! + a[n-1]*(n-2)! + ... + a[i]*(i-1)! + ... + a[1]*0! public static String getResult(int n, int k) { // int fac[] = { 1, 1, 2, 6, 24, 120, 720, 5040, 40320 }; int[] fac = new int[n]; fac[0] = 1; for (int i = 1; i \u0026lt; n; i++) { fac[i] = fac[i - 1] * i; } StringBuilder sb = new StringBuilder(); int[] visit = new int[10]; k = k - 1; for (int i = n - 1; i \u0026gt;= 0; i--) { int t = k / fac[i]; for (int j = 1; j \u0026lt;= n; j++) { if (visit[j] == 0) { if (t == 0) { sb.append(j); visit[j] = 1; break; } t--; } } k = k % fac[i]; } return sb.toString(); } 19. 堆内存申请\r#\r描述\n有一个总空间为100字节的堆，现要从中新申请一块内存，内存分配原则为：优先紧接着前一块已使用内存，分配空间足够且最接近申请大小的空闲内存。 输入描述： 第1行是1个整数，表示期望申请的内存字节数 第2到第N行是用空格分割的两个整数，表示当前已分配的内存的情况， 每一行表示一块已分配的连续内存空间，每行的第1和第2个整数分别表示偏移地址和内存块大小 输出描述： 若申请成功，输出申请到内存的偏移； 若申请失败，输出 -1。 备注： 若输入信息不合法或无效，则申请失败 若没有足够的空间供分配，则申请失败 堆内存信息有区域重叠或有非法值等都是无效输入 输入：1 0 1 3 2 输出：1 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int len = Integer.parseInt(sc.nextLine()); boolean[] arr = new boolean[100]; while (sc.hasNextLine()) { String line = sc.nextLine(); if (line.isEmpty()) break; String[] split = line.split(\u0026#34; \u0026#34;); int index; int offset; try { index = Integer.parseInt(split[0]); offset = Integer.parseInt(split[1]); } catch (Exception e) { System.out.println(-1); return; } if (index \u0026lt; 0 || offset \u0026lt; 1) { System.out.println(-1); return; } int end = index + offset; for (int i = index; i \u0026lt; end; i++) { if (i \u0026gt; 99 || arr[i]) { System.out.println(-1); return; } arr[i] = true; } } System.out.println(getResult(arr, len)); } public static int getResult(boolean[] arr, int len) { List\u0026lt;int[]\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; arr.length; i++) { if (arr[i]) { continue; } int[] tempArr = new int[2]; tempArr[0] = i; for (int j = i; j \u0026lt; arr.length; j++) { if (arr[j]) { break; } else { tempArr[1] = j; } } i = tempArr[1]; list.add(tempArr); } for (int[] tempArr : list) { if (tempArr[1] - tempArr[0] \u0026gt;= len - 1) { return tempArr[0]; } } return -1; } 20. 堆栈中的剩余数字\r#\r描述\n向一个空栈中依次存入正整数，假设入栈元素 n(1≤n≤2^31-1)按顺序依次为 nx…n4、 n3、n2、 n1, 每当元素入栈时，如果 n1=n2+…+ny(y 的范围[2,x]， 1≤x≤1000)，则 n1~ny 全部元素出栈，重新入栈新元素 m(m=2*n1)。 如：依次向栈存入 6、 1、 2、 3, 当存入 6、 1、 2 时，栈底至栈顶依次为[6、 1、 2]；当存入 3时， 3=2+1， 3、 2、 1 全部出栈，重新入栈元素 6(6=2*3)，此时栈中有元素 6； 因为 6=6，所以两个 6 全部出栈，存入 12，最终栈中只剩一个元素 12。 输入描述： 使用单个空格隔开的正整数的字符串，如”5 6 7 8″， 左边的数字先入栈，输入的正整数个数为 x， 1\u0026lt;=x\u0026lt;=1000。 输出描述： 最终栈中存留的元素值，元素值使用空格隔开，如”8 7 6 5″， 栈顶数字在左边。 6 1 2 3 输入：1 2 5 7 9 1 2 2 输出：4 1 9 14 1 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); for (int num : nums) { addNum(list, num); } Collections.reverse(list); String ans = list.stream().map(String::valueOf).collect(Collectors.joining(\u0026#34; \u0026#34;)); System.out.println(ans); } public static void addNum(LinkedList\u0026lt;Integer\u0026gt; list, int num) { int sum = 0; boolean isClear = false; for (int i = list.size() - 1; i \u0026gt;= 0; i--) { sum += list.get(i); if (sum == num) { list.subList(i, list.size()).clear(); isClear = true; break; } } if (isClear) { addNum(list, 2 * num); return; } list.add(num); } 21. 多段线数据压缩\r#\r描述\n下图中，每个方块代表一个像素，每个像素用其行号和列号表示。 为简化处理，多线段的走向只能是水平、竖直、斜向45度。 上图中的多线段可以用下面的坐标串表示：(2,8),(3,7),(3,6),(3,5),(4,4),(5,3),(6,2),(7,3),(8,4),(7,5)。 但可以发现，这种表示不是最简的，其实只需要存储6个蓝色的关键点即可，它们是线段的起点、拐点、终点，而剩下4个点是冗余的。 现在，请根据输入的包含有冗余数据的多线段坐标列表，输出其最简化的结果。 输入描述： 所有数字以空格分隔，每两个数字一组，第一个数字是行号，第二个数字是列号； 行号和列号范围 为 [0, 64)，用例输入保证不会越界，考生不必检查； 输入数据至少包含两个坐标点 输出描述： 压缩后的最简化坐标列表，和输入数据的格式相同。 输入：2 8 3 7 3 6 3 5 4 4 5 3 6 2 7 3 8 4 7 5 输出：2 8 3 7 3 5 6 2 8 4 7 5 题解\nprivate static final List\u0026lt;String\u0026gt; TEMP_LIST = Arrays.asList(\u0026#34;0-1\u0026#34;, \u0026#34;01\u0026#34;, \u0026#34;-10\u0026#34;, \u0026#34;10\u0026#34;, \u0026#34;-1-1\u0026#34;, \u0026#34;11\u0026#34;, \u0026#34;-11\u0026#34;, \u0026#34;1-1\u0026#34;); public static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); int[][] arr = new int[nums.length / 2][2]; int k = 0; for (int i = 0; i \u0026lt; nums.length / 2; i++) { for (int j = 0; j \u0026lt; 2; j++) { arr[i][j] = nums[k]; k++; } } List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(arr[0][0]); list.add(arr[0][1]); int direct = getDirect(arr[0], arr[1]); for (int i = 2; i \u0026lt; arr.length; i++) { int currDirect = getDirect(arr[i - 1], arr[i]); if (direct == currDirect) { continue; } direct = currDirect; list.add(arr[i - 1][0]); list.add(arr[i - 1][1]); } list.add(arr[arr.length - 1][0]); list.add(arr[arr.length - 1][1]); String str = list.stream().map(String::valueOf).collect(Collectors.joining(\u0026#34; \u0026#34;)); System.out.println(str); } public static int getDirect(int[] pre, int[] next) { int x = next[0] - pre[0]; int y = next[1] - pre[1]; String key = \u0026#34;\u0026#34; + x + y; return TEMP_LIST.indexOf(key); } 22. 翻牌求最大分\r#\r描述\n给出n个牌数，在-100到100之间，求最大得分。 规则如下：连续翻牌，如果选当前牌，则总得分等于上一次翻牌总得分加上当前牌的数字， 如果当前总得分小于它前三次的总得分的话，那此次不翻牌，并且总得分就等于它前三次的得分。 1到3次翻牌数如果小于0的话就取0。 例子：1，-5，-6，4，7，2，-2 （1）1大于零 翻牌 （2）-5 加上1 小于0 不翻 结果为0 （3）-6 加上0 小于0 不翻 结果为0 （4）4 加上0 大于0（1）翻牌 结果为4 （5）7 加上4 大于0（2） 翻牌 结果为11 （6）2 加上11 大于0（3） 翻牌 结果为13 （7）-2 加上14 大于4（4）翻牌 结果为11 输入：1,-5,-6,4,7,2,-2 输出：11 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34;,\u0026#34;); int[] arr = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(arr)); } public static int getResult(int[] arr) { int n = arr.length; int[] dp = new int[n]; for (int i = 0; i \u0026lt; n; i++) { if (i == 0) { dp[0] = Math.max(0, arr[0]); } else if (i \u0026lt; 3) { dp[i] = Math.max(0, dp[i - 1] + arr[i]); } else { dp[i] = Math.max(dp[i - 3], dp[i - 1] + arr[i]); } } return dp[n - 1]; } 23. 分割均衡字符串\r#\r描述\n均衡串定义：字符串中只包含两种字符，且这两种字符的个数相同。 给定一个均衡字符串，请给出可分割成新的均衡子串的最大个数。 约定：字符串中只包含大写的 X 和 Y 两种字符。 输入描述： 输入一个均衡串。 字符串的长度：[2， 10000]。给定的字符串均为均衡字符串 输出描述： 输出可分割成新的均衡子串的最大个数。 备注： 分割后的子串，是原字符串的连续子串 输入：XXYYXY 输出：2 说明：XXYYXY可分割为2个均衡子串，分别为：XXYY、XY 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chs = sc.nextLine().toCharArray(); int countX = 0; int countY = 0; int sum = 0; for (char ch : chs) { if (ch == \u0026#39;X\u0026#39;) { countX++; } else { countY++; } if (countX == countY) { sum++; } } System.out.println(sum); } 24. 分配土地\r#\r描述\n从前有个村庄，村民们喜欢在各种田地上插上小旗子，旗子上标识了各种不同的数字。 某天集体村民决定将覆盖相同数字的最小矩阵形的土地分配给村里做出巨大贡献的村民， 请问此次分配土地，做出贡献的村民种最大会分配多大面积? 输入描述： 第一行输入 m 和 n。m代表村子的土地的长，n代表土地的宽 第二行开始输入地图上的具体标识 输出描述： 此次分配土地，做出贡献的村民种最大会分配多大面积 备注： 旗子上的数字为1~500，土地边长不超过500 未插旗子的土地用0标识 输入：3 3 1 0 1 0 0 0 0 1 0 输出：9 题解\nstatic class Rect { int minRow = Integer.MAX_VALUE; int maxRow = Integer.MIN_VALUE; int minCol = Integer.MAX_VALUE; int maxCol = Integer.MIN_VALUE; private void setRow(int row) { this.minRow = Math.min(this.minRow, row); this.maxRow = Math.max(this.maxRow, row); } private void setCol(int col) { this.minCol = Math.min(this.minCol, col); this.maxCol = Math.max(this.maxCol, col); } private int getArea() { return (maxRow - minRow + 1) * (maxCol - minCol + 1); } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); // 长（行数） int n = sc.nextInt(); // 宽（列数） HashMap\u0026lt;Integer, Rect\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { int num = sc.nextInt(); if (num \u0026gt; 0) { map.putIfAbsent(num, new Rect()); map.get(num).setRow(i); map.get(num).setCol(j); } } } int maxArea = 0; for (int num : map.keySet()) { Rect rect = map.get(num); maxArea = Math.max(maxArea, rect.getArea()); } System.out.println(maxArea); } 25. 分披萨\r#\r描述\n\u0026#34;吃货\u0026#34;和\u0026#34;馋嘴\u0026#34;两人到披萨店点了一份铁盘（圆形）披萨，并嘱咐店员将披萨按放射状切成大小相同的偶数个小块。但是粗心的服务员将披萨切成了每块大小都完全不同奇数块，且肉眼能分辨出大小。 由于两人都想吃到最多的披萨，他们商量了一个他们认为公平的分法：从\u0026#34;吃货\u0026#34;开始，轮流取披萨。除了第一块披萨可以任意选取外，其他都必须从缺口开始选。 他俩选披萨的思路不同。\u0026#34;馋嘴\u0026#34;每次都会选最大块的披萨，而且\u0026#34;吃货\u0026#34;知道\u0026#34;馋嘴\u0026#34;的想法。 已知披萨小块的数量以及每块的大小，求\u0026#34;吃货\u0026#34;能分得的最大的披萨大小的总和。 输入描述： 第 1 行为一个正整数奇数 N，表示披萨小块数量。3 ≤ N ＜ 500 接下来的第 2 行到第 N + 1 行（共 N 行），每行为一个正整数，表示第 i 块披萨的大小，1 ≤ i ≤ N 披萨小块从某一块开始，按照一个方向次序顺序编号为 1 ~ N，每块披萨的大小范围为 [1, 2147483647] 输出描述： \u0026#34;吃货\u0026#34;能分得到的最大的披萨大小的总和。 输入：5 8 2 10 5 7 输出：19 题解\nstatic int[] pizza; static long[][] cache; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); pizza = new int[n]; for (int i = 0; i \u0026lt; n; i++) { pizza[i] = sc.nextInt(); } // 缓存 cache = new long[n][n]; int l, r; long len; long maxLen = 0; // i 指向首轮被\u0026#34;吃货\u0026#34;选取的披萨位置，可以理解为缺口位置，相当于给环切了一个口 for (int i = 0; i \u0026lt; n; i++) { // i - 1 是缺口的左边披萨，i + 1 是缺口的右边披萨， // getIndex防止越界, 以便进行绕环运动 l = getIndex(i - 1); r = getIndex(i + 1); // 而第 i 块是首轮就被\u0026#34;吃货\u0026#34;拿走的，因此是recursive + pizza[i] // recursive的作用求解是\u0026#34;吃货\u0026#34;从缺失了 第 i 块的披萨铁盘 开始选，最终可得的最大披萨大小， len = recursive(l, r) + pizza[i]; maxLen = Math.max(maxLen, len); } System.out.println(maxLen); } public static long recursive(int l, int r) { if (pizza[l] \u0026gt; pizza[r]) { l = getIndex(l - 1); } else { r = getIndex(r + 1); } // 缓存优化，如果已经算过了，则无需再次重复递归 if (cache[l][r] \u0026gt; 0) { return cache[l][r]; } // 缓存对应缺口状态下，吃货可得的最大披萨大小 if (l == r) { cache[l][r] = pizza[l]; } else { long lenL = recursive(getIndex(l - 1), r) + pizza[l]; long lenR = recursive(l, getIndex(r + 1)) + pizza[r]; cache[l][r] = Math.max(lenL, lenR); } return cache[l][r]; } public static int getIndex(int idx) { if (idx \u0026lt; 0) { idx = pizza.length - 1; } else if (idx \u0026gt;= pizza.length) { idx = 0; } return idx; } "},{"id":273,"href":"/algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%932/","title":"机试题库 - 2","section":"华为OD","content":"\r01. 工号不够用了怎么办\r#\r描述\n3020年，空间通信集团的员工人数突破20亿人，即将遇到现有工号不够用的窘境。 现在，请你负责调研新工号系统。继承历史传统，新的工号系统由小写英文字母（a-z）和数字（0-9）两部分构成。 新工号由一段英文字母开头，之后跟随一段数字，比如”aaahw0001″,”a12345″,”abcd1″,”a00″。 注意新工号不能全为字母或者数字,允许数字部分有前导0或者全为0。 但是过长的工号会增加同事们的记忆成本，现在给出新工号至少需要分配的人数X和新工号中字母的长度Y，求新工号中数字的最短长度Z。 输入描述： 一行两个非负整数 X Y，用数字用单个空格分隔。 0＜ X ≤2^50 – 1 0＜ Y ≤5 输出描述： 输出新工号中数字的最短长度Z 输入：2600 1 输出：2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); long x = sc.nextLong(); int y = sc.nextInt(); // 工号总个数x，字母个数y，数字个数z，z最小取1 // x = 26^y * 10^z // z = log(x / 26^y) long min = (long) Math.ceil(Math.log10(x / Math.pow(26, y))); System.out.println(Math.max(1, min)); } 02. 勾股数元组\r#\r描述\n如果3个正整数(a,b,c)满足a^2 + b^2 = c^2的关系，则称(a,b,c)为勾股数（著名的勾三股四弦五）， 为了探索勾股数的规律，我们定义如果勾股数(a,b,c)之间两两互质（即a与b，a与c，b与c之间均互质，没有公约数），则其为勾股数元组（例如(3,4,5)是勾股数元组，(6,8,10)则不是勾股数元组）。 请求出给定范围[N,M]内，所有的勾股数元组。 输入描述： 起始范围N，1 ≤ N ≤ 10000 结束范围M，N ＜ M ≤ 10000 输出描述： 1. a,b,c请保证a ＜ b ＜ c,输出格式：a b c； 2. 多组勾股数元组请按照a升序，b升序，最后c升序的方式排序输出； 3. 给定范围中如果找不到勾股数元组时，输出”NA“。 输入：1 20 输出：3 4 5 5 12 13 8 15 17 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); getResult(n, m); } public static void getResult(int n, int m) { ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = n; i \u0026lt;= m; i++) { list.add(i * i); } HashSet\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(list); ArrayList\u0026lt;Integer[]\u0026gt; arrList = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; list.size(); i++) { for (int j = i + 1; j \u0026lt; list.size(); j++) { // 判断勾股数 a^2 + b^2 = c^2 int sum = list.get(i) + list.get(j); if (set.contains(sum)) { Integer[] arr = new Integer[3]; arr[0] = (int) Math.sqrt(list.get(i)); arr[1] = (int) Math.sqrt(list.get(j)); arr[2] = (int) Math.sqrt(sum); arrList.add(arr); } } } List\u0026lt;Integer[]\u0026gt; collect = arrList.stream() .filter(Main::isRelativePrime).collect(Collectors.toList()); if (collect.isEmpty()) { System.out.println(\u0026#34;NA\u0026#34;); } else { collect.forEach(arr -\u0026gt; System.out.println(arr[0] + \u0026#34; \u0026#34; + arr[1] + \u0026#34; \u0026#34; + arr[2])); } } private static boolean isRelativePrime(Integer[] arr) { return isRelativePrime(arr[0], arr[1]) \u0026amp;\u0026amp; isRelativePrime(arr[0], arr[2]) \u0026amp;\u0026amp; isRelativePrime(arr[1], arr[2]); } // 计算它们的最大公约数，如果最大公约数为1，则说明两个数互质 private static boolean isRelativePrime(int x, int y) { // 两个数辗转相除 while (y \u0026gt; 0) { int mod = x % y; x = y; y = mod; } return x == 1; } 03. 冠亚军排名，奖牌榜排名\r#\r描述\n奖牌榜的排名规则如下，我们假设国家名称不超过二十个字符，各类奖牌数不超过100，且大于0. 1. 首先gold medal数量多的排在前面 2. 其次silver medal数量多的排在前面 3. 然后bronze medal数量多的排在前面 4. 若以上三个条件仍无法区分名次，则以国家名称的字典顺序排定。 输入描述： 第一行输入一个整数N（0＜N＜21），代表国家数量， 然后接下来的N行，每行包含：一个字符串Name表示各个国家的名称和三个整数Gi,Si,Bi分别表示奖牌的数量，以空格隔开 输出描述： 输出奖牌榜的依次顺序，只输出国家名称，各占一行，具体见样例输出。 输入：5 China 32 28 34 England 12 34 22 France 23 33 2 Japan 12 34 25 Rusia 23 43 0 输出：China Rusia France Japan England 题解\nstatic class Country { String name; int gold; int silver; int bronze; public Country(String name) { this.name = name; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); Country[] arr = new Country[n]; for (int i = 0; i \u0026lt; n; i++) { String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); Country country = new Country(split[0]); country.gold = Integer.parseInt(split[1]); country.silver = Integer.parseInt(split[2]); country.bronze = Integer.parseInt(split[3]); arr[i] = country; } Arrays.sort(arr, (a, b) -\u0026gt; a.gold != b.gold ? b.gold - a.gold : a.silver != b.silver ? b.silver - a.silver : a.bronze != b.bronze ? b.bronze - a.bronze : a.name.compareTo(b.name)); Arrays.asList(arr).forEach(country -\u0026gt; System.out.println(country.name)); } 04. 猴子爬山\r#\r描述\n一天一只顽猴想去从山脚爬到山顶，途中经过一个有个N个台阶的阶梯，但是这猴子有一个习惯： 每一次只能跳1步或跳3步，试问猴子通过这个阶梯有多少种不同的跳跃方式？ 输入描述：输入只有一个整数N（0＜N≤50）此阶梯有多少个台阶。 输出描述：输出有多少种跳跃方式（解决方案数）。 输入：50 输出：122106097 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); System.out.println(getResult(n)); } public static int getResult(int n) { int[] dp = new int[n + 1]; if (n \u0026gt;= 1) dp[1] = 1; if (n \u0026gt;= 2) dp[2] = 1; if (n \u0026gt;= 3) dp[3] = 2; for (int i = 4; i \u0026lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 3]; } return dp[n]; } 05. 滑动窗口最大和\r#\r描述\n有一个N个整数的数组，和一个长度为M的窗口，窗口从数组内的第一个数开始滑动直到窗口不能滑动为止， 每次窗口滑动产生一个窗口和（窗口内所有数的和），求窗口滑动产生的所有窗口和的最大值。 输入描述： 第一行输入一个正整数N，表示整数个数。（0＜N＜100000） 第二行输入N个整数，整数的取值范围为[-100,100]。 第三行输入一个正整数M，M代表窗口的大小，M≤100000，且M≤N。 输出描述： 窗口滑动产生所有窗口和的最大值。 输入：6 10 20 30 15 23 12 3 输出：68 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] arr = new int[n]; for (int i = 0; i \u0026lt; n; i++) { arr[i] = sc.nextInt(); } int m = sc.nextInt(); sc.close(); // 初始滑窗内部和 int sum = 0; for (int i = 0; i \u0026lt; m; i++) { sum += arr[i]; } int max = sum; for (int i = 1; i \u0026lt;= n - m; i++) { // 基于初始滑窗进行差异求和 sum += arr[i + m - 1] - arr[i - 1]; max = Math.max(max, sum); } System.out.println(max); } 06. 灰度图存储\r#\r描述\n黑白图像常采用灰度图的方式存储，即图像的每个像素填充一个灰色阶段值，256阶灰图是一个灰阶值取值范围为 0~255 的灰阶矩阵，0表示全黑，255表示全白，范围内的其他值表示不同的灰度。 但在计算机中实际存储时，会使用压缩算法，其中一个种压缩格式描述如如下： 10 10 255 34 0 1 255 8 0 3 255 6 0 5 255 4 0 7 255 2 0 9 255 21 1. 所有的数值以空格分隔； 2. 前两个数分别表示矩阵的行数和列数； 3. 从第三个数开始，每两个数一组，每组第一个数是灰阶值，第二个数表示该灰阶值从左到右，从上到下（可理解为二维数组按行存储在一维矩阵中）的连续像素个数。比如题目所述的例子， “255 34” 表示有连续 34 个像素的灰阶值是 255。 如此，图像软件在打开此格式灰度图的时候，就可以根据此算法从压缩数据恢复出原始灰度图矩阵。 请从输入的压缩数恢复灰度图原始矩阵，并返回指定像素的灰阶值。 输入描述： 第一行是灰度图压缩数据 第二行表示一个像素位置的行号和列号，如 0 0 表示左上角像素 输出描述： 输出数据表示的灰阶矩阵的指定像素的灰阶值。 备注： 系保证输入的压缩数据是合法有效的，不会出现数据起界、数值不合法等无法恢复的场景 系统保证输入的像素坐标是合法的，不会出现不在矩阵中的像素 矩阵的行和列数范图为:(0,100] 灰阶值取值范图:[0,255] 输入：10 10 56 34 99 1 87 8 99 3 255 6 99 5 255 4 99 7 255 2 99 9 255 21 3 4 输出：99 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] nums = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int[] pos = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int rows = nums[0]; int cols = nums[1]; int start = 0; int[] graph = new int[rows * cols]; for (int i = 2; i \u0026lt; nums.length; i += 2) { // 灰阶值 int gray = nums[i]; // 该灰阶值从左到右，从上到下（可理解为二维数组按行存储在一维矩阵中）的连续像素个数 int len = nums[i + 1]; Arrays.fill(graph, start, start + len, gray); start += len; } // 将二维坐标转为一维坐标 int target = pos[0] * cols + pos[1]; System.out.println(graph[target]); } 07. 会议室占用时间\r#\r描述\n现有若干个会议，所有会议共享一个会议室，用数组表示各个会议的开始时间和结束时间，格式为： [[会议1开始时间, 会议1结束时间], [会议2开始时间, 会议2结束时间]] 请计算会议室占用时间段。 输入描述： 第一行输入一个整数 n，表示会议数量 之后输入n行，每行两个整数，以空格分隔，分别表示会议开始时间，会议结束时间 输出描述： 输出多行，每个两个整数，以空格分隔，分别表示会议室占用时间段开始和结束 备注： 会议室个数范围：[1, 100] 会议室时间段：[1, 24] 输入：4 1 4 2 5 7 9 14 18 输出：1 5 7 9 14 18 输入：[[1,4],[2,5],[7,9],[14,18]] 输出：[[1,5],[7,9],[14,18]] 说明：时间段[1,4]和[2,5]重叠，合并为[1,5] 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[][] roomTimes = new int[n][2]; for (int i = 0; i \u0026lt; n; i++) { roomTimes[i][0] = sc.nextInt(); roomTimes[i][1] = sc.nextInt(); } // 将各个会议按照开始时间升序 Arrays.sort(roomTimes, (a, b) -\u0026gt; a[0] - b[0]); ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); int[] pre = roomTimes[0]; for (int i = 1; i \u0026lt; roomTimes.length; i++) { // 当前会议占用时间段 int[] cur = roomTimes[i]; if (cur[0] \u0026lt;= pre[1]) { // 当前会议开始时间 \u0026lt;= 上一个会议结束时间，则两个会议时间重叠，可以合并 // 注意合并时，结束时间取两个时间段中较大的结束时间 pre[1] = Math.max(pre[1], cur[1]); } else { // 否则不可以合并 list.add(pre[0] + \u0026#34; \u0026#34; + pre[1]); pre = cur; } } list.add(pre[0] + \u0026#34; \u0026#34; + pre[1]); list.forEach(System.out::println); } 08. 绘图机器\r#\r描述\n绘图机器的绘图笔初始位置在原点(0,0)机器启动后按照以下规则来进行绘制直线。 1. 尝试沿着横线坐标正向绘制直线直到给定的终点E 2. 期间可以通过指令在纵坐标轴方向进行偏移，offsetY为正数表示正向偏移,为负数表示负向偏移 给定的横坐标终点值E 以及若干条绘制指令， 请计算绘制的直线和横坐标轴以及x=E的直线组成的图形面积。 输入描述： 首行为两个整数 N 和 E 表示有N条指令,机器运行的横坐标终点值E 接下来N行 每行两个整数表示一条绘制指令x，offsetY 用例保证横坐标x以递增排序的方式出现 且不会出现相同横坐标x 取值范围： 0＜N≤10000 0≤x≤E≤20000 -10000≤offsetY≤10000 输出描述： 一个整数表示计算得到的面积 用例保证结果范围在0到4294967295之内。 输入：4 10 1 1 2 1 3 1 4 -2 输出：12 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int endX = sc.nextInt(); long ans = 0; long lastX = 0; // 上一个点的横坐标 long lastY = 0; // 上一个点的纵坐标 for (int i = 0; i \u0026lt; n; i++) { int curX = sc.nextInt(); int offsetY = sc.nextInt(); ans += (curX - lastX) * Math.abs(lastY); lastX = curX; lastY += offsetY; } // 注意结束位置的处理 if (endX \u0026gt; lastX) { ans += (endX - lastX) * Math.abs(lastY); } System.out.println(ans); } 09. 火星文计算\r#\r描述\n已知火星人使用的运算符为#、$，其与地球人的等价公式如下： x#y = 2*x+3*y+4 x$y = 3*x+y+2 1. 其中x、y是无符号整数 2. 地球人公式按C语言规则计算 3. 火星人公式中，$的优先级高于#，相同的运算符，按从左到右的顺序计算 现有一段火星人的字符串报文，请你来翻译并计算结果。 输入描述： 火星人字符串表达式（结尾不带回车换行） 输入的字符串说明：字符串为仅由无符号整数和操作符（#、$）组成的计算表达式。 输出描述： 根据输入的火星人字符串输出计算结果（结尾不带回车换行）。 输入：7#6$5#12 输出：226 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.next(); System.out.println(getResult(str)); } public static long getResult(String str) { Pattern p = Pattern.compile(\u0026#34;(\\\\d+)\\\\$(\\\\d+)\u0026#34;); while (true) { Matcher m = p.matcher(str); if (!m.find()) break; String subStr = m.group(0); long x = Long.parseLong(m.group(1)); long y = Long.parseLong(m.group(2)); str = str.replaceFirst(subStr.replace(\u0026#34;$\u0026#34;, \u0026#34;\\\\$\u0026#34;), 3 * x + y + 2 + \u0026#34;\u0026#34;); } return Arrays.stream(str.split(\u0026#34;#\u0026#34;)) .map(Long::parseLong) .reduce((x, y) -\u0026gt; 2 * x + 3 * y + 4) .orElse(0L); } 10. 机场航班调度程序\r#\r描述\nXX市机场停放了多架飞机，每架飞机都有自己的航班号CA3385，CZ6678，SC6508等，航班号的前2个大写字母（或数字）代表航空公司的缩写，后面4个数字代表航班信息。但是XX市机场只有一条起飞跑道，调度人员需要安排目前停留在机场的航班有序起飞。 为保障航班的有序起飞，调度员首先按照航空公司的缩写（航班号前2个字母）对所有航班进行排序，同一航空公司的航班再按照航班号的后4个数字进行排序，最终获得安排好的航班的起飞顺序。 请编写一段代码根据输入的航班号信息帮助调度员输出航班的起飞顺序。 说明： 航空公司缩写排序按照从特殊符号$ \u0026amp; *，0~9，A~Z排序； 航班号为6为长度，后4位位纯数字，不考虑存在后4位重复的场景。 输入描述：第一行输入航班信息，多个航班号之间用逗号 \u0026#34;,\u0026#34; 分隔，输入的航班号不超过100个。 输出描述：输出航班起飞顺序，使用逗号分隔 输入：CA3385,CZ6678,SC6508,DU7523,HK4456,MK0987 输出：CA3385,CZ6678,DU7523,HK4456,MK0987,SC6508 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] flights = sc.nextLine().split(\u0026#34;,\u0026#34;); StringJoiner sj = new StringJoiner(\u0026#34;,\u0026#34;); Arrays.stream(flights).sorted(Main::compareTo).forEach(sj::add); System.out.println(sj); } private static int compareTo(String str1, String str2) { String abbr1 = str1.substring(0, 2); String num1 = str1.substring(2); String abbr2 = str2.substring(0, 2); String num2 = str2.substring(2); if (abbr1.equals(abbr2)) { return num1.compareTo(num2); } else { return abbr1.compareTo(abbr2); } } 11. 机器人搬砖\r#\r描述\n机器人搬砖，一共有 N 堆砖存放在 N 个不同的仓库中，第 i 堆砖中有 bricks[i] 块砖头，要求在 8 小时内搬完。 机器人每小时能搬砖的数量取决于有多少能量格，机器人一个小时中只能在一个仓库中搬砖，机器人的能量格只在这一个小时有效，为使得机器人损耗最小化，应尽量减小每次补充的能量格数。 为了保障在 8 小时内能完成搬砖任务，请计算每小时给机器人充能的最小能量格数。 无需考虑机器人补充能力格的耗时； 无需考虑机器人搬砖的耗时； 机器人每小时补充能量格只在这一个小时中有效； 输入描述：第一行为一行数字，空格分隔 输出描述：机器人每小时最少需要充的能量格，若无法完成任务，输出 -1 输入：30 12 25 8 19 输出：15 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] arr = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(arr)); } private static int getResult(int[] arr) { // 8个小时最多只能搬8个仓库 if (arr.length \u0026gt; 8) { return -1; } // 每小时最多需要的能量块 int num = Arrays.stream(arr).max().orElse(0); int minNum = num; while (num\u0026gt;0) { num--; if (check(arr, num)) { minNum = num; } else { break; } } return minNum; } private static boolean check(int[] bricks, int x) { int cost = 0; for (int brick : bricks) { cost += brick / x + (brick % x == 0 ? 0 : 1); if (cost \u0026gt; 8) { return false; } } return true; } 12. 计算礼品发放的最小分组数目\r#\r描述\n又到了一年的末尾，项目组让小明负责新年晚会的小礼品发放工作。 为使得参加晚会的同事所获得的小礼品价值相对平衡，需要把小礼品根据价格进行分组，但每组最多只能包括两件小礼品，并且每个分组的价格总和不能超过一个价格上限。 为了保证发放小礼品的效率，小明需要找到分组数目最少的方案。 你的任务是写一个程序，找出分组数最少的分组方案，并输出最少的分组数目。 输入描述： 第一行数据为分组礼品价格之和的上限 第二行数据为每个小礼品的价格，按照空格隔开，每个礼品价格不超过分组价格和的上限 输出描述： 输出最小分组数量 输入：5 1 2 5 输出：2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int max = Integer.parseInt(sc.nextLine()); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); Integer[] arr = Arrays.stream(split).map(Integer::parseInt).toArray(Integer[]::new); System.out.println(getResult(max, arr)); } public static int getResult(int max, Integer[] arr) { // 将商品按价格从小到大排序 Arrays.sort(arr); // l指针指向最小价格的商品 int l = 0; // r指针指向最大价格的商品 int r = arr.length - 1; // 如果商品价格不超过上限，则优先最小价格和最大价格组合 int count = 0; while (l \u0026lt; r) { // 如果最小价格+最大价格 不超过上限，则组合，否则最大价格独立一组 if (arr[l] + arr[r] \u0026lt;= max) { l++; } r--; count++; } if (l == r) { count++; } return count; } 13. 计算三叉搜索树的高度\r#\r描述\n定义构造三叉搜索树规则如下： 每个节点都存有一个数，当插入一个新的数时，从根节点向下寻找，直到找到一个合适的空节点插入。查找的规则是： 1. 如果数小于节点的数减去500，则将数插入节点的左子树 2. 如果数大于节点的数加上500，则将数插入节点的右子树 3. 否则，将数插入节点的中子树 给你一系列数，请按以上规则，按顺序将数插入树中，构建出一棵三叉搜索树，最后输出树的高度。 输入描述： 第一行为一个数 N，表示有 N 个数，1 ≤ N ≤ 10000 第二行为 N 个空格分隔的整数，每个数的范围为[1,10000] 输出描述： 输出树的高度（根节点的高度为1） 输入：5 5000 2000 5000 8000 1800 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] maxLen = {1}; TreeNode root = new TreeNode(sc.nextInt(), 1); for (int i = 1; i \u0026lt; n; i++) { int num = sc.nextInt(); addVal(maxLen, root, num); } sc.close(); System.out.println(maxLen[0]); } private static void addVal(int[] maxLen, TreeNode node, int val) { // 左子树 if (val \u0026lt; node.val - 500) { if (node.left == null) { node.left = new TreeNode(val, node.height + 1); maxLen[0] = Math.max(maxLen[0], node.height + 1); } else { addVal(maxLen, node.left, val); } return; } // 右子树 if (val \u0026gt; node.val + 500) { if (node.right == null) { node.right = new TreeNode(val, node.height + 1); maxLen[0] = Math.max(maxLen[0], node.height + 1); } else { addVal(maxLen, node.right, val); } return; } // 中子树 if (node.mid == null) { node.mid = new TreeNode(val, node.height + 1); maxLen[0] = Math.max(maxLen[0], node.height + 1); } else { addVal(maxLen, node.mid, val); } } static class TreeNode { int val; // 节点值 int height; // 节点所在高度 TreeNode left; // 左子树 TreeNode mid; // 中子树 TreeNode right; // 右子树 public TreeNode(int val, int height) { this.val = val; this.height = height; } } 14. 检查是否存在满足条件的数字组合\r#\r描述\n给定一个正整数数组，检查数组中是否存在满足规则的数字组合 规则：A = B + 2C 备注： 数组长度在3~100之间 数组成员为0~65535 数组成员可以重复，但每个成员只能在结果算式中使用一次， 如数组成员为 [0,0,1,5]，0出现两次允许，但结果0=0+2*0不允许 因为算式中使用了3个0 用例保证每组数字里最多只有一组符合要求的解 输入描述： 第一行输出数组的元素个数。 第二行输出所有数组元素，用空格隔开。 输出描述： 如果存在满足要求的数，在同一行里依次输出规则里A/B/C的取值，用空格隔开。 如果不存在，输出0。 输入： 4 2 7 3 0 输出： 7 3 2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); String[] strings = sc.nextLine().split(\u0026#34; \u0026#34;); Integer[] arr = new Integer[strings.length]; for (int i = 0; i \u0026lt; strings.length; i++) { arr[i] = Integer.parseInt(strings[i]); } System.out.println(getResult(n, arr)); } public static String getResult(int n, Integer[] arr) { Arrays.sort(arr, (a, b) -\u0026gt; b - a); for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { for (int k = j + 1; k \u0026lt; n; k++) { if (arr[i] == arr[j] + 2 * arr[k]) { return arr[i] + \u0026#34; \u0026#34; + arr[j] + \u0026#34; \u0026#34; + arr[k]; } if (arr[i] == arr[k] + 2 * arr[j]) { return arr[i] + \u0026#34; \u0026#34; + arr[k] + \u0026#34; \u0026#34; + arr[j]; } } } } return \u0026#34;0\u0026#34;; } 15. 解密犯罪时间\r#\r描述\n警察在侦破一个案件时，得到了线人给出的可能犯罪时间，形如 “HH:MM” 表示的时刻。根据约定，为了隐蔽，该时间是修改过的， 解密规则为：利用当前出现过的数字，构造下一个距离当前时间最近的时刻，则该时间为可能的犯罪时间。 每个出现的数字都可以被无限次使用。 输入描述：形如 HH:SS 的字符串，表示原始输入 输出描述：形如 HH:SS 的字符串，表示推理出来的犯罪时间 注意事项：1、可以保证线人给定的字符串一定是合法的。2、最近的时刻有可能在第二天。 输入：18:52 输出：18:55 说明：利用数字 1, 8, 5, 2 构造出来的最近时刻是 18:55，是 3 分钟之后。 输入：23:59 输出：22:22 说明：利用数字 2, 3, 5, 9 构造出来的最近时刻是 22:22 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String input = sc.nextLine(); String[] split = input.split(\u0026#34;:\u0026#34;); // 记录已经出现的数字 boolean[] exists = new boolean[10]; for (char c : input.toCharArray()) { if (Character.isDigit(c)) { exists[c - \u0026#39;0\u0026#39;] = true; } } // 原始时间 int times = Integer.parseInt(split[0]) * 60 + Integer.parseInt(split[1]); // 枚举所有时间，找到下一个距离当前事件最近的时刻 // -- 如果时间点中有字符未出现，则不考虑该时间点，因为该时间点已经不可能是答案了 // -- 如果时间点中有字符出现: // -- -- 如果时间相同，则不考虑该时间点，因为该时间点已经不可能是答案了 // -- -- 如果时间不同，则考虑该时间点，因为该时间点可能是答案了，但是要判断当天还是下一天 int hour = 0; int minute = 0; int d = Integer.MAX_VALUE; for (int h = 0; h \u0026lt; 24; h++) { if (!exists[h % 10] || !exists[h / 10]) continue; for (int m = 0; m \u0026lt; 60; m++) { int curTimes = h * 60 + m; // 字符未出现或时间相同 if (!exists[m % 10] || !exists[m / 10] || curTimes == times) continue; // 计算时间间隔，找到更近的时刻 int curD = (curTimes \u0026gt; times) ? curTimes - times : 24 * 60 - (times - curTimes); if (curD \u0026lt; d) { hour = h; minute = m; d = curD; } } } // %02d 表示将整数值按照至少占据两个字符的方式输出，不足两位时会在前面补零 // %n 表示一个换行符 System.out.printf(\u0026#34;%02d:%02d%n\u0026#34;, hour, minute); } 16. 精准核酸检测\r#\r描述\n为了达到新冠疫情精准防控的需要，为了避免全员核酸检测带来的浪费，需要精准圈定可能被感染的人群。 现在根据传染病流调以及大数据分析，得到了每个人之间在时间、空间上是否存在轨迹交叉。 现在给定一组确诊人员编号（X1,X2,X3,...,Xn），在所有人当中，找出哪些人需要进行核酸检测，输出需要进行核酸检测的人数。（注意：确诊病例自身不需要再做核酸检测） 需要进行核酸检测的人，是病毒传播链条上的所有人员，即有可能通过确诊病例所能传播到的所有人。 例如：A是确诊病例，A和B有接触、B和C有接触、C和D有接触、D和E有接触，那么B\\C\\D\\E都是需要进行核酸检测的人。 输入描述： 第一行为总人数 N 第二行为确认病例人员编号（确诊病例人员数量 ＜ N），用逗号分割 第三行开始，为一个 N * N 的矩阵，表示每个人员之间是否有接触，0表示没有接触，1表示有接触。 输出描述： 整数：需要做核酸检测的人数 备注： 人员编号从0开始 0 ＜ N ＜ 100 输入：5 1,2 1,1,0,1,0 1,1,0,0,0 0,0,1,0,1 1,0,0,1,0 0,0,1,0,1 输出：3 编号为1、2号的人员，为确诊病例。 1号和0号有接触，0号和3号有接触。 2号和4号有接触。 所以，需要做核酸检测的人是0号、3号、4号，总计3人需要进行核酸检测。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); String[] split = sc.nextLine().split(\u0026#34;,\u0026#34;); int[] confirmed = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); int[][] matrix = new int[n][n]; for (int i = 0; i \u0026lt; n; i++) { String[] strings = sc.nextLine().split(\u0026#34;,\u0026#34;); matrix[i] = Arrays.stream(strings).mapToInt(Integer::parseInt).toArray(); } System.out.println(getResult(n, confirmed, matrix)); } public static int getResult(int n, int[] confirmed, int[][] matrix) { UnionFindSet ufs = new UnionFindSet(n); for (int i = 0; i \u0026lt; n; i++) { for (int j = i; j \u0026lt; n; j++) { if (matrix[i][j] == 1) { // 有过接触的人进行合并 ufs.union(i, j); } } } // 统计每个接触群体（连通分量）中的人数 int[] cnts = new int[n]; for (int i = 0; i \u0026lt; n; i++) { int fa = ufs.findRoot(i); cnts[fa]++; } // 记录已统计过的感染群体 HashSet\u0026lt;Integer\u0026gt; confirmed_fa = new HashSet\u0026lt;\u0026gt;(); // 将有感染者的接触群体的人数统计出来 int ans = 0; for (int i : confirmed) { int fa = ufs.findRoot(i); // 如果该感染群体已统计过，则不再统计 if (confirmed_fa.contains(fa)) continue; confirmed_fa.add(fa); ans += cnts[fa]; } // 最终需要做核酸的人数，不包括已感染的人 return ans - confirmed.length; } // 并查集 static class UnionFindSet { int[] fa; // 初始化，设置i的父节点fa[i]为自身 public UnionFindSet(int n) { this.fa = new int[n]; for (int i = 0; i \u0026lt; n; i++) { fa[i] = i; } } // 查找x的根节点 public int findRoot(int x) { // 递归中断条件：根节点为自身 if (fa[x] == x) { return x; } // 递归：查询x的根节点 int root = findRoot(fa[x]); // 递归路径压缩：直接设置x的父节点为根 fa[x] = root; return root; } // 合并节点x、y public void union(int x, int y) { // 查找xy两者的根节点 int xFa = this.findRoot(x); int yFa = this.findRoot(y); // 合并：将xy两者的根节点设为一样 fa[xFa] = yFa; } } 17. 开源项目热度榜单\r#\r描述\n某个开源社区希望将最近热度比较高的开源项目出一个榜单，推荐给社区里面的开发者。 对于每个开源项目，开发者可以进行关注（watch）、收藏（star）、fork、提issue、提交合并请求（MR）等。 数据库里面统计了每个开源项目关注、收藏、fork、issue、MR的数量，开源项目的热度根据这5个维度的加权求和进行排序。 H = W(watch) x #watch + W(star) x #star + W(fork) x #fork + W(issue) x #issue + W(mr) x #mr 1. H 表示热度值 2. W(watch)、W(star)、W(fork)、W(issue)、W(mr) 分别表示5个统计维度的权重 3. #watch、#star、#fork、#issue、#mr 分别表示5个统计维度的统计值 榜单按照热度值降序排序，对于热度值相等的，按照项目名字转换为全小写字母后的字典序排序（\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,...,\u0026#39;x\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;z\u0026#39;）。 输入描述： 第一行输入为N，表示开源项目的个数，0 ＜ N ＜100。 第二行输入为权重值列表，一共 5 个整型值，分别对应关注、收藏、fork、issue、MR的权重，权重取值 0 ＜ W ≤ 50。 第三行开始接下来的 N 行为开源项目的统计维度，每一行的格式为： name nr_watch nr_start nr_fork nr_issue nr_mr 其中 name 为开源项目的名字，由英文字母组成，长度 ≤ 50，其余 5 个整型值分别为该开源项目关注、收藏、fork、issue、MR的数量，数量取值 0 ＜ nr ≤ 1000。 输出描述： 按照热度降序，输出开源项目的名字，对于热度值相等的，按照项目名字转换为全小写后的字典序排序（\u0026#39;a\u0026#39; \u0026gt; \u0026#39;b\u0026#39; \u0026gt; \u0026#39;c\u0026#39; \u0026gt; ... \u0026gt; \u0026#39;x\u0026#39; \u0026gt; \u0026#39;y\u0026#39; \u0026gt; \u0026#39;z\u0026#39;）。 输入：4 8 6 2 8 6 camila 66 70 46 158 80 victoria 94 76 86 189 211 anthony 29 17 83 21 48 emily 53 97 1 19 218 输出：victoria camila emily anthony 题解\nstatic class Project { String name; int hot; public Project(String name, int hot) { this.name = name; this.hot = hot; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] weights = new int[5]; for (int i = 0; i \u0026lt; 5; i++) { weights[i] = sc.nextInt(); } Project[] projects = new Project[n]; for (int i = 0; i \u0026lt; n; i++) { String name = sc.next(); int hot = 0; for (int j = 0; j \u0026lt; 5; j++) { hot += sc.nextInt() * weights[j]; } projects[i] = new Project(name, hot); } sc.close(); Arrays.sort(projects, (a, b) -\u0026gt; a.hot != b.hot ? b.hot - a.hot : a.name.toLowerCase().compareTo(b.name.toLowerCase())); Arrays.stream(projects).forEach(p -\u0026gt; System.out.println(p.name)); } 18. 考勤信息\r#\r描述\n公司用一个字符串来表示员工的出勤信息 缺勤-absent，迟到-late，早退-leaveearly，正常上班-resent 现需根据员工出勤信息，判断本次是否能获得出勤奖，能获得出勤奖的条件如下： 缺勤不超过一次； 没有连续的迟到/早退； 任意连续7次考勤，缺勤/迟到/早退不超过3次。 输入描述： 第一行输入一个整数n，表示有多少个员工 后面n行，每一行输入若干个字符串，表示第i名员工的出勤信息 输出描述： 输出n行，每一行表示这名员工能否获得出勤奖，如果可以，则输出“true\u0026#34;，否则输出”false\u0026#34; 输入：2 present present absent present present leaveearly present absent 输出：true false 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; num; i++) { list.add(getResult(sc.nextLine())); } list.forEach(System.out::println); } private static String getResult(String string) { // 缺勤不超过一次 String str = string.replaceFirst(\u0026#34;absent\u0026#34;, \u0026#34;\u0026#34;); if (str.contains(\u0026#34;absent\u0026#34;)) { return \u0026#34;false\u0026#34;; } // 没有连续的迟到/早退； if (string.contains(\u0026#34;late leaveearly\u0026#34;) || string.contains(\u0026#34;leaveearly late\u0026#34;)) { return \u0026#34;false\u0026#34;; } // 任意连续7次考勤，缺勤/迟到/早退不超过3次。 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(string.split(\u0026#34; \u0026#34;))); if (list.size() \u0026lt; 7) { // 填充到7天 for (int i = 0; i \u0026lt; 7 - list.size(); i++) { list.add(\u0026#34;\u0026#34;); } } for (int i = 0; i \u0026lt; list.size() - 6; i++) { int time = 0; List\u0026lt;String\u0026gt; subList = list.subList(i, i + 7); for (String subStr : subList) { if (!\u0026#34;resent\u0026#34;.equals(subStr)) { time++; } if (time \u0026gt; 3) { return \u0026#34;false\u0026#34;; } } } return \u0026#34;ture\u0026#34;; } 19. 靠谱的车\r#\r描述\n程序员小明打了一辆出租车去上班。出于职业敏感，他注意到这辆出租车的计费表有点问题，总是偏大。 出租车司机解释说他不喜欢数字4，所以改装了计费表，任何数字位置遇到数字4就直接跳过，其余功能都正常。 比如： 23再多一块钱就变为25； 39再多一块钱变为50； 399再多一块钱变为500； 小明识破了司机的伎俩，准备利用自己的学识打败司机的阴谋。 给出计费表的表面读数，返回实际产生的费用。 输入描述：只有一行，数字N，表示里程表的读数。(1≤N≤888888888)。 输出描述：一个数字，表示实际产生的费用。以回车结束。 输入：5 输出：4 输入：100 输出：81 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String line = sc.nextLine(); String[] split = line.split(\u0026#34;\u0026#34;); int[] arr = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(arr)); } // 相当于九进制 public static int getResult(int[] arr) { int sum = 0; for (int i = 0; i \u0026lt; arr.length; i++) { int num = arr[i]; if (num \u0026gt; 4) { num--; } for (int j = arr.length - i - 1; j \u0026gt; 0; j--) { num *= 9; } sum += num; } return sum; } 20. 快递运输\r#\r描述\n一辆运送快递的货车，运送的快递放在大小不等的长方体快递盒中， 为了能够装载更多的快递，同时不能让货车超载，需要计算最多能装多少个快递。 注：快递的体积不受限制，快递数最多1000个，货车载重最大50000 输入描述： 第一行输入每个快递的重量，用英文逗号隔开，如 5,10,2,11 第二行输入货车的载重量，如 20 不需要考虑异常输入 输出描述： 输出最多能装多少个快递，如 3 输入：5,10,2,11 20 输出：3 说明：货车的载重量为20，最多只能放三个快递5、10、2，因此输出3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34;,\u0026#34;); int[] weights = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); int limit = Integer.parseInt(sc.nextLine()); System.out.println(getResult(weights, limit)); } public static int getResult(int[] weights, int limit) { Arrays.sort(weights); int sum = 0; int count = 0; for (int w : weights) { // 每次都选择重量最小的快递加入 sum += w; if (sum \u0026gt; limit) break; count++; } return count; } 21. 括号匹配\r#\r描述\n给定一个字符串，里边可能包含“()”、“[]”、“{}”三种括号，请编写程序检查该字符串中的括号是否成对出现，且嵌套关系正确。 若括号成对出现且嵌套关系正确，或该字符串中无括号字符，输出：true； 若未正确使用括号字符，输出：false。 实现时，无需考虑非法输入。 输入：(1+2)/(0.5+1) 输出：true 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); System.out.println(getResult(str)); } public static boolean getResult(String str) { // 去除非括号字符 str = str.replaceAll(\u0026#34;[^\\\\(\\\\)\\\\[\\\\]\\\\{\\\\}]\u0026#34;, \u0026#34;\u0026#34;); HashMap\u0026lt;Character, Character\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#39;)\u0026#39;, \u0026#39;(\u0026#39;); map.put(\u0026#39;]\u0026#39;, \u0026#39;[\u0026#39;); map.put(\u0026#39;}\u0026#39;, \u0026#39;{\u0026#39;); LinkedList\u0026lt;Character\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; str.length(); i++) { char c = str.charAt(i); if (!stack.isEmpty() \u0026amp;\u0026amp; map.containsKey(c)) { if (stack.getLast() == map.get(c)) { stack.removeLast(); continue; } else { return false; } } stack.add(c); } return stack.isEmpty(); } 22. 来自异国的客人\r#\r描述\n有位客人来自异国，在该国使用 m 进制计数。 该客人有个幸运数字n（n ＜ m），每次购物时，其总是喜欢计算本次支付的花费（折算为异国的价格后）中存在多少幸运数字。 问：当其购买一个在我国价值 k 的产品时，其中包含多少幸运数字? 输入描述： 第一行输入为 k，n，m。 k 表示该客人购买的物品价值（以十进制计算的价格） n 表示该客人的幸运数字 m 表示该客人所在国度采用的进制 输出描述： 输出幸运数字的个数，行末无空格 备注： 当输入非法内容时，输出0 输入：10 2 4 输出：2 说明：10用4进制表示时为22，同时，异国客人的幸运数字是2，故而此处输出为2，表示有2个幸运数字。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); try { String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); long[] longs = Arrays.stream(split).mapToLong(Long::parseLong).toArray(); System.out.println(getResult(longs)); } catch (Exception e) { System.out.println(0); } } public static long getResult(long[] longs) { long k = longs[0]; long n = longs[1]; long m = longs[2]; if (n \u0026gt;= m || m \u0026lt; 1) { return 0; } long sum = 0; while (k \u0026gt; 0) { // 余数就是m进制的每一位上“位值” if (k % m == n) { sum++; } k = k / m; } return sum; } 23. 连续字母长度\r#\r描述\n给定一个字符串，只包含大写字母，求在包含同一字母的子串中，长度第 k 长的子串的长度，相同字母只取最长的那个子串。 输入描述： 第一行有一个子串(1＜长度≤100)，只包含大写字母。 第二行为 k的值 输出描述：输出连续出现次数第k多的字母的次数。 输入：AABAAA 2 输出：1 说明：同一字母连续出现的最多的是A，3次；第二多的还是A，两次，但是A已经出现过了，故为B，一次； 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chars = sc.nextLine().toCharArray(); int k = Integer.parseInt(sc.nextLine()); System.out.println(getResult(chars, k)); } public static int getResult(char[] chars, int k) { if (k \u0026lt;= 0) { return -1; } Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int tempLen = 1; char tempCh = \u0026#39;-\u0026#39;; for (char curCh : chars) { if (curCh == tempCh) { tempLen++; map.put(curCh, Math.max(tempLen, map.get(curCh))); } else { map.putIfAbsent(curCh, 1); tempCh = curCh; tempLen = 1; } } Integer[] arr = map.values().stream().sorted((a, b) -\u0026gt; b - a).toArray(Integer[]::new); if (k \u0026lt;= arr.length) { return arr[k - 1]; } return -1; } 24. 两数之和绝对值最小\r#\r描述\n给定一个从小到大的有序整数序列（存在正整数和负整数）数组 nums ，请你在该数组中找出两个数，其和的绝对值(|nums[x]+nums[y]|)为最小值，并返回这个绝对值。 每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 输入描述：一个通过空格分割的有序整数序列字符串，最多1000个整数，且整数数值范围是 -65535~65535。 输出描述：两数之和绝对值最小值 输入：-3 -1 5 7 11 15 输出：2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(nums)); } public static int getResult(int[] nums) { int min = Integer.MAX_VALUE; for (int i = 0; i \u0026lt; nums.length; i++) { for (int j = i + 1; j \u0026lt; nums.length; j++) { int sum = Math.abs(nums[i] + nums[j]); min = Math.min(min, sum); } } return min; } 25. 螺旋数字矩阵\r#\r描述\n给出数字个数 n （0 ＜ n ≤ 999）和行数 m（0 ＜ m ≤ 999），从左上角的 1 开始，按照顺时针螺旋向内写方式，依次写出2,3,....,n，最终形成一个 m 行矩阵。 这个矩阵要求： 1、每行数字的个数一样多 2、列的数量尽可能少 3、填充数字时优先填充外部 4、数字不够时，使用单个 * 号占位 输入描述：两个整数，空格隔开，依次表示 n、m 输出描述：符合要求的唯一矩阵 输入：9 4 输出：1 2 3 * * 4 9 * 5 8 7 6 说明：9个数字写出4行，最少需要3列 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); // 需要在螺旋矩阵中填入 1 ~ n 数字 int n = sc.nextInt(); // 螺旋矩阵行数 int m = sc.nextInt(); // 螺旋矩阵列数 int k = (int) Math.ceil(n * 1.0 / m); // 螺旋矩阵 int[][] arr = new int[m][k]; int top = 0; int bottom = m - 1; int left = 0; int right = k - 1; int step = 1; while (left \u0026lt;= right \u0026amp;\u0026amp; top \u0026lt;= bottom) { // 从左到右 for (int i = left; i \u0026lt;= right \u0026amp;\u0026amp; step \u0026lt;= n; i++, step++) { arr[top][i] = step; } top++; // 从上到下 for (int i = top; i \u0026lt;= bottom \u0026amp;\u0026amp; step \u0026lt;= n; i++, step++) { arr[i][right] = step; } right--; // 从右到左 for (int i = right; i \u0026gt;= left \u0026amp;\u0026amp; step \u0026lt;= n; i--, step++) { arr[bottom][i] = step; } bottom--; // 从下到上 for (int i = bottom; i \u0026gt;= top \u0026amp;\u0026amp; step \u0026lt;= n; i--, step++) { arr[i][left] = step; } left++; } // 打印 for (int i = 0; i \u0026lt; m; i++) { StringJoiner row = new StringJoiner(\u0026#34; \u0026#34;); for (int j = 0; j \u0026lt; k; j++) { if (arr[i][j] == 0) { row.add(\u0026#34;*\u0026#34;); } else { row.add(arr[i][j] + \u0026#34;\u0026#34;); } } System.out.println(row); } } "},{"id":274,"href":"/algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%933/","title":"机试题库 - 3","section":"华为OD","content":"\r01. 密码解密\r#\r描述\n给定一段“密文”字符串 s，其中字符都是经过“密码本”映射的，现需要将“密文”解密并输出。 映射的规则（\u0026#39;a\u0026#39; ~ \u0026#39;i\u0026#39;）分别用（\u0026#39;1\u0026#39; ~ \u0026#39;9\u0026#39;）表示；（\u0026#39;j\u0026#39; ~ \u0026#39;z\u0026#39;）分别用（\u0026#34;10*\u0026#34; ~ \u0026#34;26*\u0026#34;）表示。 约束：映射始终唯一。 输入描述：“密文”字符串 输出描述：明文字符串 备注：翻译后的文本长度在100以内 输入：12320*19*20* 输出：abctst 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); for (int i = 26; i \u0026gt;= 1; i--) { String key = i + (i \u0026gt; 9 ? \u0026#34;\\\\*\u0026#34; : \u0026#34;\u0026#34;); String val = String.valueOf((char) (\u0026#39;a\u0026#39; + i - 1)); str = str.replaceAll(key, val); } System.out.println(str); } 02. 密码输入检测\r#\r描述\n给定用户密码输入流 input，输入流中字符 \u0026#39;\u0026lt;\u0026#39; 表示退格，可以清除前一个输入的字符，请你编写程序，输出最终得到的密码字符，并判断密码是否满足如下的密码安全要求。 密码安全要求如下： 1. 密码长度 ≥ 8； 2. 密码至少需要包含 1 个大写字母； 3. 密码至少需要包含 1 个小写字母； 4. 密码至少需要包含 1 个数字； 5. 密码至少需要包含 1 个字母和数字以外的非空白特殊字符； 注意空串退格后仍然为空串，且用户输入的字符串不包含 \u0026#39;\u0026lt;\u0026#39; 字符和空白字符。 输入描述： 用一行字符串表示输入的用户数据，输入的字符串中 \u0026#39;\u0026lt;\u0026#39; 字符标识退格，用户输入的字符串不包含空白字符 输出描述： 输出经过程序处理后，输出的实际密码字符串，并输出改密码字符串是否满足密码安全要求。两者间由 \u0026#39;,\u0026#39; 分隔， 例如： 输入：ABC\u0026lt;c89%000\u0026lt; 输出：ABc89%00,true 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chars = sc.nextLine().toCharArray(); LinkedList\u0026lt;Character\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); for (char c : chars) { if (c == \u0026#39;\u0026lt;\u0026#39;) { if (stack.isEmpty()) { continue; } stack.removeLast(); } else { stack.addLast(c); } } int upper = 0; int lower = 0; int number = 0; int other = 0; StringBuilder password = new StringBuilder(); for (Character c : stack) { password.append(c); if (c \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39;) { lower++; } else if (c \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;Z\u0026#39;) { upper++; } else if (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) { number++; } else { other++; } } if (password.length() \u0026gt;= 8 \u0026amp;\u0026amp; lower \u0026gt;= 1 \u0026amp;\u0026amp; upper \u0026gt;= 1 \u0026amp;\u0026amp; number \u0026gt;= 1 \u0026amp;\u0026amp; other \u0026gt;= 1) { password.append(\u0026#34;,true\u0026#34;); } else { password.append(\u0026#34;,false\u0026#34;); } System.out.println(password); } 03. 密钥格式化\r#\r描述\n给定一个非空字符串 S，其被 N 个’-‘分隔成 N+1 的子串，给定正整数 K， 要求除第一个子串外，其余的串每 K 个字符用’-‘分隔，并将小写字母转换为大写。 作者：晓风长路 链接：https://www.nowcoder.com/discuss/353149752197980160?sourceSSR=search 来源：牛客网 输入描述：正整数 K 和‘-’分割的字符串 输出描述：转换后的字符串 输入：4 5F3Z-2e-9-w 输出：5F3Z-2E9W 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int k = sc.nextInt(); String str = sc.next(); System.out.println(getResult(k, str)); } public static String getResult(int k, String str) { String[] arr = str.split(\u0026#34;-\u0026#34;); String first = arr[0]; if (arr.length == 1) { return first; } StringBuilder sb = new StringBuilder(); for (int i = 1; i \u0026lt; arr.length; i++) { sb.append(arr[i]); } String[] tmp = sb.toString().toUpperCase().split(\u0026#34;\u0026#34;); for (int i = 0; i \u0026lt; tmp.length; i++) { if (i % k == 0) { tmp[i] = \u0026#34;-\u0026#34; + tmp[i]; } } return first + String.join(\u0026#34;\u0026#34;, tmp); } 04. 免单统计\r#\r描述\n华为商城举办了一个促销活动，如果某顾客是某一秒内最早时刻下单的顾客（可能是多个人），则可以获取免单。 请你编程计算有多少顾客可以获取免单。 输入描述： 输入为 n 行数据，每一行表示一位顾客的下单时间 以（年-月-日时-分-秒.毫秒） yyyy-MM-ddHH:mm:ss.fff 形式给出。所有输入保证合法。 0＜n＜50000，2000＜yyyy＜2020，0＜MM≤12，0＜dd≤28，0≤HH≤23，0≤mm≤59，0≤ss≤59，0≤fff≤999 输出描述： 输出一个整数，表示有多少顾客可以获取免单。 输入：5 2019-01-01 00:00:00.004 2019-01-01 00:00:00.004 2019-01-01 00:00:01.006 2019-01-01 00:00:01.006 2019-01-01 00:00:01.005 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); String[] arr = new String[n]; for (int i = 0; i \u0026lt; n; i++) { arr[i] = sc.nextLine(); } System.out.println(getResult(arr)); } public static Long getResult(String[] arr) { Map\u0026lt;String, List\u0026lt;Integer\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (String str : arr) { String key = str.substring(0, str.length() - 3); int num = Integer.parseInt(str.substring(str.length() - 3)); map.putIfAbsent(key, new ArrayList\u0026lt;\u0026gt;()); map.get(key).add(num); } return map.values().stream().map(Main::getMinSum).reduce(0L, Long::sum); } public static long getMinSum(List\u0026lt;Integer\u0026gt; list) { int min = list.stream().reduce(Integer::min).orElse(0); return list.stream().filter(i -\u0026gt; i == min).count(); } 05. 内存冷热标记\r#\r描述\n现代计算机系统中通常存在多级的存储设备，针对海量 workload 的优化的一种思路是将热点内存页优先放到快速存储层级，这就需要对内存页进行冷热标记。 一种典型的方案是基于内存页的访问频次进行标记，如果统计窗口内访问次数大于等于设定阈值，则认为是热内存页，否则是冷内存页。 对于统计窗口内跟踪到的访存序列和阈值，现在需要实现基于频次的冷热标记。内存页使用页框号作为标识。 输入描述： 第一行输入为 N，表示访存序列的记录条数，0 ＜ N ≤ 10000。 第二行为访存序列，空格分隔的 N 个内存页框号，页面号范围0 ~ 65535，同一个页框号可能重复出现，出现的次数即为对应框号的频次 第三行为热内存的频次阈值 T，正整数范围 1 ≤ T ≤ 10000。 输出描述： 第一行输出标记为热内存的内存页个数，如果没有被标记的热内存页，则输出 0 。 如果第一行 \u0026gt; 0，则接下来按照访问频次降序输出内存页框号，一行一个，频次一样的页框号，页框号小的排前面。 输入：10 1 2 1 2 1 2 1 2 1 2 5 输出：2 1 2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); String[] arr = sc.nextLine().split(\u0026#34; \u0026#34;); int t = Integer.parseInt(sc.nextLine()); HashMap\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (String key : arr) { if (!map.containsKey(key)) { map.put(key, 1); } else { map.put(key, map.get(key) + 1); } } List\u0026lt;String\u0026gt; list = map.entrySet().stream() .filter(entry -\u0026gt; entry.getValue() \u0026gt;= t) .map(Map.Entry::getKey).collect(Collectors.toList()); if (list.isEmpty()) { System.out.println(0); return; } System.out.println(list.size()); list.stream().sorted().forEach(System.out::println); } 06. 攀登者\r#\r描述\n攀登者喜欢寻找各种地图，并且尝试攀登到最高的山峰。 地图表示为一维数组，数组的索引代表水平位置，数组的元素代表相对海拔高度。其中数组元素0代表地面。 例如：[0,1,2,4,3,1,0,0,1,2,3,1,2,1,0]，代表如下图所示的地图，地图中有两个山脉位置分别为 1,2,3,4,5 和 8,9,10,11,12,13，最高峰高度分别为 4,3。最高峰位置分别为3,10。 一个山脉可能有多座山峰(高度大于相邻位置的高度，或在地图边界且高度大于相邻的高度)。 登山者想要知道一张地图中有多少座山峰。 输入描述：输入为一个整型数组，数组长度大于1。 输出描述：输出地图中山峰的数量。 输入：0,1,4,3,1,0,0,1,2,3,1,2,1,0 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34;,\u0026#34;); int[] heights = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(heights)); } public static int getResult(int[] heights) { int count = 0; for (int i = 0; i \u0026lt; heights.length; i++) { int leftHeight = i - 1 \u0026gt;= 0 ? heights[i - 1] : 0; int rightHeight = i + 1 \u0026lt; heights.length ? heights[i + 1] : 0; if (heights[i] \u0026gt; leftHeight \u0026amp;\u0026amp; heights[i] \u0026gt; rightHeight) { count++; } } return count; } 07. 判断字符串子序列\r#\r描述\n给定字符串 target和 source，判断 target是否为 source 的子序列。认为target和 source 中仅包含英文小写字母。 字符串 source 可能会很长（长度~=500,000），而 target是个短字符串（长度≤100)。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。 请找出最后一个子序列的起始位置。 输入描述： 第一行为target，短字符串（长度 ≤100） 第二行为source，长字符串（长度 ~= 500,000） 输出描述： 最后一个子序列的起始位置，即最后一个子序列首字母的下标 备注： 若在source中找不到target，则输出-1。 输入：abc abcaybec 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(getResult(sc.nextLine(), sc.nextLine())); } public static int getResult(String target, String source) { int cursor = target.length() - 1; for (int i = source.length() - 1; i \u0026gt;= 0; i--) { if (source.charAt(i) == target.charAt(cursor)) { cursor--; if (cursor \u0026lt; 0) return i; } } return -1; } 08. 拼接URL\r#\r描述\n给定一个url前缀和url后缀,通过,分割 需要将其连接为一个完整的url 1. 如果前缀结尾和后缀开头都没有/，需要自动补上/连接符 2. 如果前缀结尾和后缀开头都为/，需要自动去重 输入描述：url前缀(一个长度小于100的字符串)，url后缀(一个长度小于100的字符串) 输出描述：拼接后的url 约束：不用考虑前后缀URL不合法情况 输入：/acm,/bb 输出：/acm/bb 输入：/acd,bef 输出：/acd/bef 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.nextLine(); String[] arr = s.split(\u0026#34;,\u0026#34;); String prefix = arr.length \u0026gt; 0 \u0026amp;\u0026amp; !arr[0].isEmpty() ? arr[0] : \u0026#34;/\u0026#34;; String suffix = arr.length \u0026gt; 1 \u0026amp;\u0026amp; !arr[1].isEmpty() ? arr[1] : \u0026#34;/\u0026#34;; System.out.println(getResult(prefix, suffix)); } public static String getResult(String prefix, String suffix) { prefix = prefix.replaceAll(\u0026#34;/+$\u0026#34;, \u0026#34;\u0026#34;); suffix = suffix.replaceAll(\u0026#34;^/+\u0026#34;, \u0026#34;\u0026#34;); return prefix + \u0026#34;/\u0026#34; + suffix; } 09. 悄悄话\r#\r描述\n给定一个二叉树，每个节点上站一个人，节点数字表示父节点到该节点传递悄悄话需要花费的时间。 初始时，根节点所在位置的人有一个悄悄话想要传递给其他人，求二叉树所有节点上的人都接收到悄悄话花费的时间。 输入：0 9 20 -1 -1 15 7 -1 -1 -1 -1 3 2 输出：38 题解\nprivate static int ans = 0; public static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] times = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); sumTime(times, times[0], 0); System.out.println(ans); } private static void sumTime(int[] times, int pTime, int pIndex) { // 如果父节点在序列中的索引是k，则其两个子节点在序列中的索引分别为 2k+1, 2k+2 int left = 2 * pIndex + 1; // 左子节点索引 int right = 2 * pIndex + 2; // 右子节点索引 // 如果存在左子节点 if (left \u0026lt; times.length \u0026amp;\u0026amp; times[left] != -1) { int curTime = pTime + times[left]; ans = Math.max(ans, curTime); sumTime(times, curTime, left); } // 如果存在右子节点 if (right \u0026lt; times.length \u0026amp;\u0026amp; times[right] != -1) { int curTime = pTime + times[right]; ans = Math.max(ans, curTime); sumTime(times, curTime, right); } } 10. 求符合要求的结对方式\r#\r描述\n用一个数组A代表程序员的工作能力，公司想通过结对编程的方式提高员工的能力， 假设结对后的能力为两个员工的能力之和，求一共有多少种结对方式使结对后能力为N。 输入描述： 第一行为员工的总人数，取值范围[1,1000] 第二行为数组A的元素，每个元素的取值范围[1,1000] 第三行为N的值，取值范围[1,1000] 输出描述： 满足结对后能力为N的结对方式总数。 输入：5 1 2 2 2 3 4 输出：4 说明：A[0]和A[4]，A[1]和A[2]，A[1]和A[3]，A[2]和A[3]。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int total = sc.nextInt(); int[] arr = new int[total]; for (int i = 0; i \u0026lt; total; i++) { arr[i] = sc.nextInt(); } int n = sc.nextInt(); sc.close(); System.out.println(getResult(arr, n)); } public static int getResult(int[] arr, int n) { Arrays.sort(arr); int ans = 0; for (int i = 0; i \u0026lt; arr.length; i++) { for (int j = arr.length - 1; j \u0026gt;= i + 1; j--) { int sum = arr[i] + arr[j]; if (sum \u0026lt; n) { break; } if (sum == n) { ans++; } } } return ans; } 11. 求解连续数列\r#\r描述\n已知连续正整数数列{K}=K1,K2,K3…Ki的各个数相加之和为S，i=N (0＜S＜100000, 0＜N＜100000), 求此数列K。 输入描述：输入包含两个参数，1）连续正整数数列和S，2）数列里数的个数N。 输出描述：如果有解输出数列K，如果无解输出-1。 输入：525 6 输出：85 86 87 88 89 90 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int sum = sc.nextInt(); int n = sc.nextInt(); sc.close(); // 等差求和公式，算出起始数 int a1 = sum / n - (n - 1) / 2; if (a1 \u0026lt; 1) { System.out.println(-1); return; } StringJoiner joiner = new StringJoiner(\u0026#34; \u0026#34;); for (int i = 0; i \u0026lt; n; i++) { joiner.add(\u0026#34;\u0026#34; + a1); a1++; } System.out.println(joiner); } 12. 求满足条件的最长子串的长度\r#\r描述\n给定一个字符串，只包含字母和数字，按要求找出字符串中的最长（连续）子串的长度，字符串本身是其最长的子串，子串要求： 1、 只包含1个字母(a~z, A~Z)，其余必须是数字； 2、 字母可以在子串中的任意位置； 如果找不到满足要求的子串，如全是字母或全是数字，则返回-1。 输入描述：字符串(只包含字母和数字) 输出描述：子串的长度 输入：abC124ACb 输出：4 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String line = sc.nextLine(); String[] split = line.split(\u0026#34;[a-zA-Z]\u0026#34;); int maxLen = -1; for (int i = 0; i \u0026lt; split.length - 1; i++) { int len = split[i].length() + split[i + 1].length() + 1; if (len \u0026gt; 1) { maxLen = Math.max(maxLen, len); } } System.out.println(maxLen); } 13. 求字符串中所有整数的最小和\r#\r描述\n输入字符串s，输出s中包含所有整数的最小和。 说明： 字符串s，只包含 a-z A-Z ± ； 合法的整数包括 正整数：一个或者多个0-9组成，如0，2，3，002，102 负整数：负号 – 开头，数字部分由一个或者多个0-9组成，如-0，-012，-23，-00023 输入描述：包含数字的字符串。 输出描述：所有整数的最小和。 输入：b12-34aa 输出：-31 说明：1+2+(-34)=-31 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chars = sc.nextLine().toCharArray(); List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); String temp = \u0026#34;\u0026#34;; for (char ch : chars) { if (ch == \u0026#39;-\u0026#39;) { temp = \u0026#34;-\u0026#34;; continue; } if (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (temp.length() \u0026gt; 1) { list.add(Integer.parseInt(temp)); temp = \u0026#34;\u0026#34;; } continue; } if (!temp.isEmpty()) { temp += ch; continue; } list.add(Integer.parseInt(\u0026#34;\u0026#34; + ch)); } if (temp.length() \u0026gt; 1) { list.add(Integer.parseInt(temp)); } System.out.println(list.stream().reduce(Integer::sum).orElse(0)); } 14. 求最多可以派出多少支团队\r#\r描述\n用数组代表每个人的能力，一个比赛活动要求参赛团队的最低能力值为N， 每个团队可以由1人或者2人组成，且1个人只能参加1个团队，计算出最多可以派出多少只符合要求的团队。 输入描述： 第一行代表总人数，范围1-500000 第二行数组代表每个人的能力，数组大小，范围1-500000，元素取值，范围1-500000 第三行数值为团队要求的最低能力值，范围1-500000 输出描述： 最多可以派出的团队数量 输入：7 3 1 5 7 9 2 6 8 输出：4 说明：3、5组成一队，1、7一队，9自己一队，2、6一队，输出4 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] capacities = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); int minCap = Integer.parseInt(sc.nextLine()); System.out.println(getResult(n, capacities, minCap)); } public static int getResult(int n, int[] capacities, int minCap) { // 升序 Arrays.sort(capacities); int l = 0; int r = n - 1; // 记录题解 int ans = 0; // 单人组队 while (r \u0026gt;= l \u0026amp;\u0026amp; capacities[r] \u0026gt;= minCap) { r--; ans++; } // 双人组队 while (l \u0026lt; r) { int sum = capacities[l] + capacities[r]; // 如果两个人的能力值之和\u0026gt;=minCap，则组队 if (sum \u0026gt;= minCap) { ans++; l++; r--; } else { // 否则将能力低的人剔除，换下一个能力更高的人 l++; } } return ans; } 15. 全排列\r#\r描述\n给定一个只包含大写英文字母的字符串S，要求你给出对S重新排列的所有不相同的排列数。 如：S为ABA，则不同的排列有ABA、AAB、BAA三种。 输入描述：输入一个长度不超过10的字符串S，我们确保都是大写的。 输出描述：输出S重新排列的所有不相同的排列数（包含自己本身）。 输入：ABCDEFGHHA 输出：907200 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.next(); System.out.println(getResult(s)); } public static int getResult(String s) { int total = getFact(s.length()); HashMap\u0026lt;Character, Integer\u0026gt; count = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; s.length(); i++) { char k = s.charAt(i); count.put(k, count.getOrDefault(k, 0) + 1); } // 如果：一共n个元素，其中某元素A重复x次，某元素B重复了y次， // 那么：最终不重复全排列个数 = n! / x! / y! for (Character k : count.keySet()) { int n = count.get(k); if (n \u0026gt; 1) { total /= getFact(n); } } return total; } public static int getFact(int n) { int fact = 1; for (int i = 1; i \u0026lt;= n; i++) fact *= i; return fact; } 16. 生成哈夫曼树\r#\r描述\n给定长度为 n 的无序的数字数组，每个数字代表二叉树的叶子节点的权值，数字数组的值均大于等于1。 请完成一个函数，根据输入的数字数组，生成哈夫曼树，并将哈夫曼树按照中序遍历输出。 为了保证输出的二叉树中序遍历结果统一，增加以下限制： 二叉树节点中，左节点权值小于右节点权值，根节点权值为左右节点权值之和。当左右节点权值相同时，左子树高度小于等于右子树高度。 哈夫曼树： 又称为最优二叉树，是一种带权路径长度最短的二叉树。 所谓树的带权路径长度，就是树中所有的叶节点的权值乘上其到根节点的路径长度（若根节点为 0 层，叶节点到根节点的路径长度为叶节点的层数） 输入描述：长度为 n 的无序的数字数组 输出描述：输出一个哈夫曼树的中序遍历数组，数值间以空格分隔 输入：5 5 15 40 30 10 输出：40 100 30 60 15 30 5 15 10 题解\nstatic class Node { Node left; // 左孩子节点 Node right; // 右孩子节点 int weight; // 当前节点的权重 int height; // 当前节点代表子树的高度 public Node(Node lc, Node rc, int weight, int height) { this.left = lc; this.right = rc; this.weight = weight; this.height = height; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] ints = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); // 将哈夫曼树节点进行排序，方便后面筛选出权值最小的两个节点 PriorityQueue\u0026lt;Node\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(Main::compareTo); for (int i = 0; i \u0026lt; n; i++) { // 创建n个哈夫曼树节点 Node node = new Node(null, null, ints[i], 0); // 加入优先队列 pq.offer(node); } // 当优先队列中只剩一个节点时即可停止合并，此时该节点就是哈夫曼树的根节点 while (pq.size() \u0026gt; 1) { // 生成哈夫曼树的固定思路： // 取出优先队列中前两个权值最小的节点，作为新节点的左右子树 Node lc = pq.poll(); Node rc = pq.poll(); // 将lc和rc合并，合并后新节点fa的权重，是两个子节点权重之和 int fa_weight = lc.weight + rc.weight; int fa_height = rc.height + 1; // 将合并后的新节点加入优先队列 Node fa = new Node(lc, rc, fa_weight, fa_height); pq.offer(fa); } // 最后优先队列中必然只剩一个节点，即哈夫曼树的根节点 // 此时对此根节点（哈夫曼树）进行中序遍历 Node root = pq.poll(); StringJoiner sj = new StringJoiner(\u0026#34; \u0026#34;); midOrder(root, sj); System.out.println(sj); } private static int compareTo(Node a, Node b) { return a.weight != b.weight ? a.weight - b.weight : a.height - b.height; } public static void midOrder(Node root, StringJoiner sj) { // 中序遍历，即先遍历二叉树的左子树，再遍历二叉树的根，最后遍历二叉树的右子树 if (root.left != null) { midOrder(root.left, sj); } sj.add(root.weight + \u0026#34;\u0026#34;); if (root.right != null) { midOrder(root.right, sj); } } 17. 剩余银饰的重量\r#\r描述\n有 N 块二手市场收集的银饰，每块银饰的重量都是正整数，收集到的银饰会被熔化用于打造新的饰品。 每一回合，从中选出三块最重的银饰，然后一起熔掉。 假设银饰的重量分别为 x 、y和z，且 x ≤ y ≤ z。那么熔掉的可能结果如下： 如果 x == y == z，那么三块银饰都会被完全熔掉； 如果 x == y 且 y != z，会剩余重量为 z - y 的银块无法被熔掉； 如果 x != y 且 y == z，会剩余重量为 y - x 的银块无法被熔掉； 如果 x != y 且 y != z，会剩余重量为 z - y 与 y - x 差值 的银块无法被熔掉。 输入描述： 第一行为银饰数组长度 n，1 ≤ n ≤ 40， 第二行为n块银饰的重量，重量的取值范围为[1，2000]，重量之间使用空格隔开 输出描述： 如果剩余两块，返回较大的重量（若两块重量相同，返回任意一块皆可）； 如果只剩下一块，返回该块的重量； 如果没有剩下，就返回 0。 输入：3 3 7 10 输出：1 说明：(7-3)-(10-7)=1，所以数组转换为 [1]，剩余一块，返回该块重量，返回 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); LinkedList\u0026lt;Integer\u0026gt; weights = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { weights.add(sc.nextInt()); } // 升序 weights.sort((a, b) -\u0026gt; a - b); while (weights.size() \u0026gt;= 3) { // 尾删三个最大值 int z = weights.removeLast(); int y = weights.removeLast(); int x = weights.removeLast(); int remain = Math.abs((z - y) - (y - x)); // 如果还有剩余银块 if (remain != 0) { // 那么就二分查找其在剩余升序weights中的有序插入位置 int idx = Collections.binarySearch(weights, remain); if (idx \u0026lt; 0) { idx = -idx - 1; } weights.add(idx, remain); } } if (weights.size() == 2) { System.out.println(Math.max(weights.get(0), weights.get(1))); } else if (weights.size() == 1) { System.out.println(weights.get(0)); } else { System.out.println(0); } } 18. 石头剪刀布游戏\r#\r描述\n石头剪刀布游戏有 3 种出拳形状：石头、剪刀、布。分别用字母A、B、C表示。 出拳形状之间的胜负规则如下：A \u0026gt; B、B \u0026gt; C、C \u0026gt; A； 当本场次中有且仅有一种出拳形状优于其他出拳形状，则该形状的玩家是胜利者。否则认为是平局。 当发生平局，没有赢家。有多个胜利者时，同为赢家。 输入描述： 在一场游戏中，每个玩家的信息为一行。玩家数量不超过1000。每个玩家信息有2个字段，用空格隔开； 玩家ID：一个仅由英文字母和数字组成的字符串 出拳形状：以英文大写字母表示，A、B、C形状。 输出描述： 输出为赢家的玩家ID列表（一个或多个），每个ID一行，按字符串升序排列。如果没有赢家，输出为”NULL“字符串。 输入：abc1 A def A alic A xyz B 输出：abc1 alic def 输入：abc1 A xyz A 输出：NULL 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); HashMap\u0026lt;Character, ArrayList\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); while (sc.hasNextLine()) { String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); String player = split[0]; char gesture = split[1].charAt(0); if (gesture != \u0026#39;A\u0026#39; \u0026amp;\u0026amp; gesture != \u0026#39;B\u0026#39; \u0026amp;\u0026amp; gesture != \u0026#39;C\u0026#39;) { System.out.println(\u0026#34;NULL\u0026#34;); return; } map.putIfAbsent(gesture, new ArrayList\u0026lt;\u0026gt;()); map.get(gesture).add(player); } switch (map.size()) { case 1: case 3: // 只有一种手势，或者三种手势都有，则平局 System.out.println(\u0026#34;NULL\u0026#34;); break; case 2: ArrayList\u0026lt;String\u0026gt; list; if (!map.containsKey(\u0026#39;A\u0026#39;)) { // 没有A手势，只有B、C手势，则B赢 list = map.get(\u0026#39;B\u0026#39;); } else if (!map.containsKey(\u0026#39;B\u0026#39;)) { // 没有B手势，只有A、C手势，则C赢 list = map.get(\u0026#39;C\u0026#39;); } else { // 没有C手势，只有A、B手势，则A赢 list = map.get(\u0026#39;A\u0026#39;); } list.sort(String::compareTo); list.forEach(System.out::println); break; } } 19. 手机App防沉迷系统\r#\r描述\n手机App防沉迷系统原理： 1. 在一天24小时内，可以注册每个App的允许使用时段 2. 一个时间段只能使用一个App 3. App有优先级，数值越高，优先级越高。注册使用时段时， 如果高优先级的App时间和低优先级的时段有冲突，则系统会自动注销低优先级的时段， 如果App的优先级相同，则后添加的App不能注册。 请编程实现，根据输入数据注册App，并根据输入的时间点，返回时间点使用的App名称， 如果该时间点没有注册任何App，请返回字符串“NA”。 输入描述： 第一行表示注册的App数量 N（N ≤ 100） 第二部分包括 N 行，每行表示一条App注册数据 最后一行输入一个时间点，程序即返回该时间点使用的App App注册数据说明： N行注册数据以空格分隔，四项数依次表示：App名称、优先级、起始时间、结束时间 优先级1~5，数字越大，优先级越高 时间格式 HH:MM，小时和分钟都是两位，不足两位前面补0 起始时间需小于结束时间，否则注册不上 注册信息中的时间段包含起始时间点，不包含结束时间点 输出描述： 输出一个字符串，表示App名称，或NA表示空闲时间 输入：2 App1 1 09:00 10:00 App2 2 09:10 09:30 09:20 输出：App2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); App[] arr = new App[n]; for (int i = 0; i \u0026lt; n; i++) { arr[i] = newApp(sc.nextLine(), i); } int queryTime = toMinutes(sc.nextLine()); System.out.println(getResult(arr, queryTime)); } public static String getResult(App[] arr, int queryTime) { // 优先级降序+索引升序 Arrays.sort(arr, (a, b) -\u0026gt; a.priority != b.priority ? b.priority - a.priority : a.index - b.index); // 高优先级的app一定会被注册 List\u0026lt;App\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; arr.length; i++) { if (arr[i].isRemove) { continue; } list.add(arr[i]); for (int j = i + 1; j \u0026lt; arr.length; j++) { if (arr[j].isRemove) { continue; } if (arr[i].isOverlap(arr[j])) { // arr[j] 一定比 arr[i] 优先级低且在后添加 arr[j].isRemove = true; } } } // 注册成功的App时段之间互不冲突，因此queryTime只会对应一个App String ans = \u0026#34;NA\u0026#34;; for (App app : list) { if (queryTime \u0026gt;= app.startTime \u0026amp;\u0026amp; queryTime \u0026lt; app.endTime) { ans = app.name; break; } } return ans; } public static App newApp(String line, int index) { String[] arr = line.split(\u0026#34; \u0026#34;); String name = arr[0]; int priority = Integer.parseInt(arr[1]); int startTime = toMinutes(arr[2]); int endTime = toMinutes(arr[3]); return new App(name, priority, startTime, endTime, index); } public static int toMinutes(String time) { String[] arr = time.split(\u0026#34;:\u0026#34;); int hour = Integer.parseInt(arr[0]); int minute = Integer.parseInt(arr[1]); return hour * 60 + minute; } public static class App { String name; int priority; int startTime; int endTime; int index; // 注册先后排序 boolean isRemove; // 是否被移除 public App(String name, int priority, int startTime, int endTime, int index) { this.name = name; this.priority = priority; this.startTime = startTime; this.endTime = endTime; this.index = index; } // 判断当前应用程序与另一个应用程序是否有时间重叠 public boolean isOverlap(App other) { return this.startTime \u0026lt; other.endTime \u0026amp;\u0026amp; other.startTime \u0026lt; this.endTime; } } 20. 输出指定字母在字符串的中的索引\r#\r描述\n给定一个字符串，把字符串按照大写在前小写在后排序，输出排好后的第 K 个字母在原来字符串的索引。 相同字母输出第一个出现的位置。 输入：hAkDAjByBq 4 输出：6 说明：排好序后 AABBDhjkqy，第 4 个是 B，第一个出现的在原字符串 6 这个位置。（注：索引是从 0 开始） 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); String str = split[0]; int idx = Integer.parseInt(split[1]); char[] arr = str.toCharArray(); Arrays.sort(arr); char target = arr[idx - 1]; System.out.println(str.indexOf(target)); } 21. 数的分解\r#\r描述\n给定一个正整数 n，如果能够分解为 m（m \u0026gt; 1）个连续正整数之和，请输出所有分解中，m最小的分解。 如果给定整数无法分解为连续正整数，则输出字符串\u0026#34;N\u0026#34;。 输入数据为一整数，范围为 (1, 2^30] 输入：21 输出：21=10+11 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); long n = Long.parseLong(sc.nextLine()); System.out.println(getResult(n)); } public static String getResult(long n) { long a1 = 0; long m = 0; for (long i = 2; i \u0026lt; n; i++) { double temp = (double) (2 * n - i * i + i) / (2 * i); if (temp \u0026lt; 1) { break; } if (temp % 1 == 0) { a1 = (long) temp; m = i; break; } } if (m == 0) { return \u0026#34;N\u0026#34;; } StringBuilder sb = new StringBuilder(n + \u0026#34;=\u0026#34;); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (long i = 0; i \u0026lt; m; i++) { list.add((a1 + i) + \u0026#34;\u0026#34;); } return sb.append(String.join(\u0026#34;+\u0026#34;, list)).toString(); } 22. 数据单元的变化替换\r#\r描述\n将一个 csv 格式的数据文件中包含有单元格引用的内容替换为对应单元格内容的实际值。 csv 格式的数据文件使用逗号 \u0026#34;,\u0026#34; 作为分隔符将各单元的内容进行分隔。 输入描述： 1. 输入只有一行数据，用逗号分隔每个单元格，行尾没有逗号。最多26个单元格，对应编号A~Z。 2. 每个单元格的内容包含字母和数字，以及使用 \u0026#39;\u0026lt;\u0026gt;\u0026#39; 分隔的单元格引用，例如：\u0026lt;A\u0026gt;表示引用第一个单元的值。 3. 每个单元格的内容，在替换前和替换后均不超过100个字符。 4. 引用单元格的位置不受限制，允许排在后面的单元格被排在前面的单元格引用。 5. 不存在循环引用的情况 6. 不存在多重 \u0026#39;\u0026lt;\u0026gt;\u0026#39; 的情况，一个单元只能引用一个其他单元格。 输出描述： 输出替换后的结果 输入：1,2\u0026lt;A\u0026gt;00 输出：1,2100 说明：第二个单元中有对A单元的引用，A单元格的值为1，替换时，将A单元的内容替代\u0026lt;A\u0026gt;的位置，并和其他内容合并。 题解\nstatic String[] cells; static Pattern p = Pattern.compile(\u0026#34;(\u0026lt;.*?\u0026gt;)\u0026#34;); public static void main(String[] args) { Scanner sc = new Scanner(System.in); cells = sc.nextLine().split(\u0026#34;,\u0026#34;); System.out.println(getResult()); } public static String getResult() { StringJoiner sj = new StringJoiner(\u0026#34;,\u0026#34;); for (int i = 0; i \u0026lt; cells.length; i++) { // 替换单元格中的引用，替换失败，则返回-1 if (!changeCell(i)) return \u0026#34;-1\u0026#34;; // 替换成功，则记录单元格内容 sj.add(cells[i]); } return sj.toString(); } public static boolean changeCell(int index) { // 通过正则匹配出单元格内容中\u0026#34;引用字符串\u0026#34; Matcher m = p.matcher(cells[index]); while (m.find()) { // reference记录引用字符串 String refStr = m.group(0); // 引用单元格编号只能是A~Z的字母，即引用引用字符串长度只能是3 if (refStr.length() != 3) { return false; } // 引用单元格的编号 int refIndex = refStr.charAt(1) - \u0026#39;A\u0026#39;; // 引用单元格编号不能超出边界，且不能自引用 if (refIndex \u0026lt; 0 || refIndex \u0026gt;= cells.length || refIndex == index) { return false; } if (!changeCell(refIndex)) return false; // 将单元格内容中的引用部分，替换为被引用的单元格的内容 cells[index] = cells[index].replaceAll(refStr, cells[refIndex]); // 重新正则匹配 m = p.matcher(cells[index]); } return true; } 23. 数字涂色\r#\r描述\n疫情过后，希望小学终于又重新开学了，三年二班开学第一天的任务是将后面的黑板报重新制作。 黑板上已经写上了N个正整数，同学们需要给这每个数分别上一种颜色。 为了让黑板报既美观又有学习意义，老师要求同种颜色的所有数都可以被这种颜色中最小的那个数整除。 现在请你帮帮小朋友们，算算最少需要多少种颜色才能给这N个数进行上色。 输入描述： 第一行有一个正整数N，其中。 第二行有N个int型数(保证输入数据在[1,100]范围中)，表示黑板上各个正整数的值。 输出描述： 输出只有一个整数，为最少需要的颜色种数。 输入：4 2 3 4 9 输出：2 说明：2与4涂一种颜色，4能被2整除；3与9涂另一种颜色，9能被3整除。 不能4个数涂同一个颜色，因为3与9不能被2整除。所以最少的颜色是两种。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] arr = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(n, arr)); } public static int getResult(int n, int[] arr) { Arrays.sort(arr); if (arr[0] == 1) { return 1; } int count = 0; boolean[] color = new boolean[n]; for (int i = 0; i \u0026lt; n; i++) { if (color[i]) { continue; } color[i] = true; for (int j = i + 1; j \u0026lt; n; j++) { if (!color[j] \u0026amp;\u0026amp; arr[j] % arr[i] == 0) { color[j] = true; } } count++; } return count; } 24. 数字字符串组合倒序\r#\r描述\n对数字，字符，数字串，字符串，以及数字与字符串组合进行倒序排列。 1. 字符范围：由 a 到 z， A 到 Z， 2. 数字范围：由 0 到 9 符号的定义： 1. “-”作为连接符使用时作为字符串的一部分，例如“20-years”作为一个整体字符串呈现； 2. 连续出现 2 个 “-” 及以上时视为字符串间隔符，如“out--standing”中的”–“视为间隔符，是 2 个独立整体字符串 3. 除了 1，2 里面定义的字符以外其他的所有字符，都是非法字符，作为字符串的间隔符处理，倒序后间隔符作为空格处理； 4. 要求倒排后的单词间隔符以一个空格表示；如果有多个间隔符时，倒排转换后也只允许出现一个字格间隔符； 输入：I am an 20-years out--standing @ * -stu- dent 输出：dent stu standing out 20-years an am I 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); System.out.println(getResult(str)); } public static String getResult(String line) { String str = line.replaceAll(\u0026#34;-{2,}\u0026#34;, \u0026#34;@\u0026#34;) .replaceAll(\u0026#34;[^0-9a-zA-Z\\\\-]\u0026#34;, \u0026#34;@\u0026#34;) .replaceAll(\u0026#34;@-\u0026#34;, \u0026#34;@\u0026#34;) .replaceAll(\u0026#34;-@\u0026#34;, \u0026#34;@\u0026#34;) .replaceAll(\u0026#34;@{2,}\u0026#34;, \u0026#34;@\u0026#34;); String[] arr = str.split(\u0026#34;@\u0026#34;); StringJoiner joiner = new StringJoiner(\u0026#34; \u0026#34;); for (int i = arr.length - 1; i \u0026gt;= 0; i--) { joiner.add(arr[i]); } return joiner.toString(); } 25. 数组连续和\r#\r描述\n给定一个含有N个正整数的数组, 求出有多少个连续区间（包括单个正整数）, 它们的和大于等于x。 输入描述： 第一行两个整数N，x（0＜N≤100000, 0≤x≤10000000) 第二行有N个正整数（每个正整数小于等于100)。 输出描述： 输出一个整数，表示所求的个数。 注意：此题对效率有要求，暴力解法通过率不高，请考虑高效的实现方式。 输入：3 7 3 4 7 输出：4 说明：组合为 3 + 4; 3 + 4 + 7; 4 + 7; 7; 都大于等于指定的7；所以共四组。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int n = Integer.parseInt(split[0]); int x = Integer.parseInt(split[1]); String[] split2 = sc.nextLine().split(\u0026#34; \u0026#34;); int[] arr = Arrays.stream(split2).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(n, x, arr)); } public static long getResult(int n, int x, int[] arr) { int[] preSum = new int[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { preSum[i] = preSum[i - 1] + arr[i - 1]; } int l = 0; int r = 1; long ans = 0; while (r \u0026lt;= n) { if (preSum[r] - preSum[l] \u0026gt;= x) { ans += n - r + 1; l++; r = l + 1; } else { r++; } } return ans; } "},{"id":275,"href":"/algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%934/","title":"机试题库 - 4","section":"华为OD","content":"\r01. 数组组成的最小数字\r#\r描述\n给定一个整型数组，请从该数组中选择3个元素组成最小数字并输出（如果数组长度小于3，则选择数组中所有元素来组成最小数字）。 输入描述：一行用半角逗号分割的字符串记录的整型数组，0＜数组长度≤100，0＜整数的取值范围≤10000。 输出描述：由3个元素组成的最小数字，如果数组长度小于3，则选择数组中所有元素来组成最小数字。 输入：21,30,62,5,31 输出：21305 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34;,\u0026#34;); System.out.println(getResult(split)); } public static String getResult(String[] strs) { Arrays.sort(strs, Comparator.comparingInt(Integer::parseInt)); String[] tmp = Arrays.copyOfRange(strs, 0, Math.min(3, strs.length)); Arrays.sort(tmp, (a, b) -\u0026gt; (a + b).compareTo(b + a)); StringBuilder sb = new StringBuilder(); for (String s : tmp) { sb.append(s); } return sb.toString(); } 02. 水仙花数\r#\r描述\n所谓水仙花数，是指一个n位的正整数，其各位数字的n次方和等于该数本身。 例如153是水仙花数，153是一个3位数，并且153 = 1^3 + 5^3 + 3^3。 输入描述： 第一行输入一个整数n，表示一个n位的正整数。n在3到7之间，包含3和7。 第二行输入一个整数m，表示需要返回第m个水仙花数。 输出描述： 返回长度是n的第m个水仙花数。个数从0开始编号。 若m大于水仙花数的个数，返回最后一个水仙花数和m的乘积。 若输入不合法，返回-1。 题解\n// 或者预先计算水仙花数表 // 3 位：153, 370, 371, 407 // 4 位：1634, 8208, 9474 // 5 位：54748, 92727, 93084 // 6 位：548834 // 7 位：1741725, 4210818, 9800817, 9926315 public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); System.out.println(getResult(n, m)); } public static long getResult(int n, int m) { // 若输入不合法，返回-1 if (n \u0026lt; 3 || n \u0026gt; 7 || m \u0026lt; 0) return -1; // 提前计算好0~9的N次方, 避免后续进行重复计算 HashMap\u0026lt;Character, Integer\u0026gt; powN = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt;= 9; i++) { // 将整型0~9转化字符\u0026#39;0\u0026#39;~\u0026#39;9\u0026#39;，即让i+\u0026#39;0\u0026#39;即可 powN.put((char) (i + \u0026#39;0\u0026#39;), (int) Math.pow(i, n)); } // 最小的N位数 int min = (int) Math.pow(10, n - 1); // 最大的N位数 int max = (int) Math.pow(10, n); // 记录当前水仙花数 long ans = 0; // 记录当前水仙花数是第几个 int idx = 0; for (int num = min; num \u0026lt; max; num++) { // 记录num各位数字的N次方之和 int sum = 0; // 遍历num的每一位数字 String str = num + \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; n; i++) { sum += powN.get(str.charAt(i)); } // 判断num是否为水仙花数 if (sum == num) { ans = num; // 如果num刚好是N位数的第m个水仙花数，则直接返回，否则继续查找 if (idx++ == m) return ans; } } // 若m大于水仙花数的个数，返回最后一个水仙花数和m的乘积 return ans * m; } 03. 素数之积\r#\r描述\nRSA加密算法在网络安全世界中无处不在，它利用了极大整数因数分解的困难度，数据越大，安全系数越高。 给定一个32位正整数，请对其进行因数分解，找出是哪两个素数的乘积。 输入描述：一个正整数num，0＜num≤2147483647 输出描述：如果成功找到，以单个空格分割，从小到大输出两个素数，分解失败，请输出-1 -1 输入：15 输出：3 5 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); int r1 = -1; int r2 = -1; for (int i = 2; i \u0026lt; Math.sqrt(num) + 1; i++) { if (num % i != 0) { continue; } if (isPrime(i) \u0026amp;\u0026amp; isPrime(num / i)) { r1 = i; r2 = num / i; break; } } System.out.println(r1 + \u0026#34; \u0026#34; + r2); } // 素数只能被1和自身整除 private static boolean isPrime(int n) { if (n \u0026lt; 2) { return false; } for (int i = 2; i \u0026lt;= Math.sqrt(n); i++) { if (n % i == 0) { return false; } } return true; } 04. 提取字符串中的最长合法简单数学表达式\r#\r描述\n提取字符串中的最长合法简单数学表达式，字符串长度最长的，并计算表达式的值。如果没有，则返回 0 。 简单数学表达式只能包含以下内容：0-9数字，符号+-* 说明： 1. 所有数字，计算结果都不超过long 2. 如果有多个长度一样的，请返回第一个表达式的结果 3. 数学表达式，必须是最长的，合法的 4. 操作符不能连续出现，如 +--+1 是不合法的 输入：1-2abcd 输出：-1 题解\npublic static void main(String[] args) throws ScriptException { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); Matcher matcher = Pattern.compile(\u0026#34;((\\\\d+[+*-])*\\\\d+)\u0026#34;).matcher(str); String maxLenExp = \u0026#34;\u0026#34;; while (matcher.find()) { String exp = matcher.group(0); if (exp.length() \u0026gt; maxLenExp.length()) { maxLenExp = exp; } } ScriptEngine engine = new ScriptEngineManager().getEngineByName(\u0026#34;js\u0026#34;); System.out.println(engine.eval(maxLenExp)); } 05. 停车场车辆统计\r#\r描述\n特定大小的停车场，数组cars[]表示，其中1表示有车，0表示没车。 车辆大小不一，小车占一个车位（长度1），货车占两个车位（长度2），卡车占三个车位（长度3）。 统计停车场最少可以停多少辆车，返回具体的数目。 输入描述：整型字符串数组cars[]，其中1表示有车，0表示没车，数组长度小于1000。 输出描述：整型数字字符串，表示最少停车数目。 输入：1,1,0,0,1,1,1,0,1 输出：3 说明：1个货车占第1、2个车位；第3、4个车位空；1个卡车占第5、6、7个车位；第8个车位空；1个小车占第9个车位 最少3辆车 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String line = sc.nextLine(); String str = line.replaceAll(\u0026#34;,\u0026#34;, \u0026#34;\u0026#34;) .replaceAll(\u0026#34;111\u0026#34;, \u0026#34;x\u0026#34;) .replaceAll(\u0026#34;11\u0026#34;, \u0026#34;x\u0026#34;) .replaceAll(\u0026#34;1\u0026#34;, \u0026#34;x\u0026#34;); int ans = 0; for (int i = 0; i \u0026lt; str.length(); i++) { if (str.charAt(i) == \u0026#39;x\u0026#39;) { ans++; } } System.out.println(ans); } 06. 围棋的气\r#\r描述\n围棋棋盘由纵横各19条线垂直相交组成，棋盘上一共19 x 19 = 361 个交点， 对弈双方一方执白棋，一方执黑棋，落子时只能将棋子置于交点上。 “气”是围棋中很重要的一个概念，某个棋子有几口气，是指其上下左右方向四个相邻的交叉点中，有几个交叉点没有棋子 现在，请根据输入的黑棋和白棋得到坐标位置，计算黑棋和白棋一共各有多少气？ 输入描述： 输入包含两行数据，如： 每行数据以空格分隔，数据个数是2的整数倍，每两个数是一组，代表棋子在棋盘上的坐标； 坐标的原点在棋盘左上角点，第一个值是行号，范围从0到18；第二个值是列号，范围从0到18。 举例说明：第一行数据表示三个坐标（0, 5）、(8, 9)、(9, 10) 第一行表示黑棋的坐标，第二行表示白棋的坐标。 题目保证输入两行数据，无空行且每行按前文要求是偶数个，每个坐标不会超出棋盘范围。 输出描述： 两个数字以空格分隔，第一个数代表黑棋的气数，第二个数代表白棋的气数。 输入：0 5 8 9 9 10 5 0 9 9 9 8 输出：8 7 题解\nstatic int[] xArr = {0, 0, 1, -1}; static int[] yArr = {1, -1, 0, 0}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split1 = sc.nextLine().split(\u0026#34; \u0026#34;); int[] ints1 = Arrays.stream(split1).mapToInt(Integer::parseInt).toArray(); String[] split2 = sc.nextLine().split(\u0026#34; \u0026#34;); int[] ints2 = Arrays.stream(split2).mapToInt(Integer::parseInt).toArray(); int[][] board = new int[19][19]; List\u0026lt;Integer[]\u0026gt; list1 = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; ints1.length; ) { int x = ints1[i]; int y = ints1[i + 1]; board[x][y] = 1; list1.add(new Integer[]{x, y}); i += 2; } List\u0026lt;Integer[]\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; ints2.length; ) { int x = ints2[i]; int y = ints2[i + 1]; board[x][y] = 2; list2.add(new Integer[]{x, y}); i += 2; } int sum1 = 0; for (Integer[] arr : list1) { for (int i = 0; i \u0026lt; 4; i++) { int newX = arr[0] + xArr[i]; int newY = arr[1] + yArr[i]; if (newX \u0026lt; 0 || newX \u0026gt; 18 || newY \u0026lt; 0 || newY \u0026gt; 18) { continue; } int value = board[newX][newY]; if (value == 0) { board[newX][newY] = -1; sum1++; } } } int sum2 = 0; for (Integer[] arr : list2) { for (int i = 0; i \u0026lt; 4; i++) { int newX = arr[0] + xArr[i]; int newY = arr[1] + yArr[i]; if (newX \u0026lt; 0 || newX \u0026gt; 18 || newY \u0026lt; 0 || newY \u0026gt; 18) { continue; } int value = board[newX][newY]; if (value == 0 || value == -1) { board[newX][newY] = -2; sum2++; } } } System.out.println(sum1 + \u0026#34; \u0026#34; + sum2); } 07. 消消乐游戏\r#\r描述\n游戏规则：输入一个只包含英文字母的字符串，字符串中的两个字母如果相邻且相同，就可以消除。 在字符串上反复执行消除的动作，直到无法继续消除为止，此时游戏结束。 输出最终得到的字符串长度。 输入描述：输入原始字符串 str ，只能包含大小写英文字母，字母的大小写敏感， str 长度不超过100。 输出描述：输出游戏结束后，最终得到的字符串长度。 备注：输入中包含 非大小写英文字母 时，均为异常输入，直接返回 0。 输入：mMbccbc 输出：3 说明：mMbccbc 中，可以先消除 cc ； 此时字符串变成 mMbbc ，可以再消除 bb ； 此时字符串变成 mMc ，此时没有相邻且相同的字符，无法继续消除。最终得到的字符串为 mMc ，长度为3。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chs = sc.nextLine().toCharArray(); System.out.println(getResult(chs)); } public static int getResult(char[] chs) { LinkedList\u0026lt;Character\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); for (char ch : chs) { if (ch \u0026lt; \u0026#39;A\u0026#39; || ch \u0026gt; \u0026#39;z\u0026#39; || (ch \u0026gt; \u0026#39;Z\u0026#39; \u0026amp;\u0026amp; ch \u0026lt; \u0026#39;a\u0026#39;)) { return 0; } if (!stack.isEmpty() \u0026amp;\u0026amp; ch == stack.getLast()) { stack.removeLast(); } else { stack.addLast(ch); } } return stack.size(); } 08. 小华地图寻宝\r#\r描述\n小华按照地图去寻宝，地图上被划分成 m 行和 n 列的方格，横纵坐标范围分别是 [0, n-1] 和 [0, m-1]。 在横坐标和纵坐标的数位之和不大于 k 的方格中存在黄金（每个方格中仅存在一克黄金），但横坐标和纵坐标之和大于 k 的方格存在危险不可进入。小华从入口 (0,0) 进入，任何时候只能向左，右，上，下四个方向移动一格。 请问小华最多能获得多少克黄金？ 输入描述： 坐标取值范围如下：0 ≤ m ≤ 50，0 ≤ n ≤ 50 k 的取值范围如下：0 ≤ k ≤ 100 输入中包含3个字数，分别是m, n, k 输出描述： 输出小华最多能获得多少克黄金 输入：40 40 18 输出：1484 题解\nstatic int m; static int n; static int k; static int ans = 0; // 记录已访问过的位置 static HashSet\u0026lt;String\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); // 上下左右偏移量 static int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 数位和数组 static int[] digitSums; public static void main(String[] args) { Scanner sc = new Scanner(System.in); m = sc.nextInt(); n = sc.nextInt(); k = sc.nextInt(); digitSum(Math.max(m, n)); dfs(0, 0); System.out.println(ans); } // 深度优先搜索遍历矩阵 public static void dfs(int x, int y) { // 如果对应位置越界，或者已访问过，或者横坐标、纵坐标的数位和之和超过了k，则不能进入 if (x \u0026lt; 0 || x \u0026gt;= m || y \u0026lt; 0 || y \u0026gt;= n || visited.contains(x + \u0026#34;-\u0026#34; + y) || digitSums[x] + digitSums[y] \u0026gt; k) return; // 否则可以进入，且获得黄金 visited.add(x + \u0026#34;-\u0026#34; + y); ans++; // 继续遍历上、下、左、右方向上的新位置继续深搜 for (int[] offset : offsets) { int newX = x + offset[0]; int newY = y + offset[1]; dfs(newX, newY); } } // 提前计算好，避免后期重复计算某个数的数位和 public static void digitSum(int maxSize) { // digitSums数组的索引是原始数，值是原始数对应的数位和 digitSums = new int[maxSize]; for (int i = 0; i \u0026lt; maxSize; i++) { int num = i; while (num \u0026gt; 0) { digitSums[i] += num % 10; num /= 10; } } } 09. 小明的幸运数\r#\r描述\n小明在玩一个游戏，游戏规则如下： 在游戏开始前，小明站在坐标轴原点处（坐标值为0）。给定一组指令和一个幸运数， 每个指令都是一个整数，小明按照指令前进指定步数或者后退指定步数。前进代表朝坐标轴的正方向走，后退代表朝坐标轴的负方向走。 幸运数为一个整数，如果某个指令正好和幸运数相等，则小明行进步数+1。 例如： 幸运数为3，指令为[2,3,0,-5] 指令为2，表示前进2步；指令为3，正好和幸运数相等，前进3+1=4步； 指令为0，表示原地不动，既不前进，也不后退。指令为-5，表示后退5步。 输入描述： 第一行输入1个数字，代表指令的总个数 n（1 ≤ n ≤ 100） 第二行输入1个数字，代表幸运数m（-100 ≤ m ≤ 100） 第三行输入n个指令，每个指令的取值范围为：-100 ≤ 指令值 ≤ 100 输出描述： 输出在整个游戏过程中，小明所处的最大坐标值。异常情况下输出：12345 输入：2 1 -5 1 输出：0 输入：5 -5 -5 1 6 0 -7 输出：1 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); if (n \u0026lt; 1 || n \u0026gt; 100) { System.out.println(\u0026#34;12345\u0026#34;); return; } int m = sc.nextInt(); if (m \u0026lt; -100 || m \u0026gt; 100) { System.out.println(\u0026#34;12345\u0026#34;); return; } int pos = 0; int maxPos = 0; for (int i = 0; i \u0026lt; n; i++) { int num = sc.nextInt(); if (num \u0026lt; -100 || num \u0026gt; 100) { System.out.println(\u0026#34;12345\u0026#34;); return; } pos += num; if (num == m) { if (num \u0026gt; 0) { pos += 1; } else if (num \u0026lt; 0) { pos -= 1; } } maxPos = Math.max(maxPos, pos); } System.out.println(maxPos); } 10. 小明找位置\r#\r描述\n小朋友出操，按学号从小到大排成一列； 小明来迟了，请你给小明出个主意，让他尽快找到他应该排的位置。 算法复杂度要求不高于nLog(n)；学号为整数类型，队列规模 ≤ 10000； 输入描述： 第一行：输入已排成队列的小朋友的学号（正整数），以\u0026#34;,\u0026#34;隔开 第二行：小明学号 输出描述： 输出一个数字，代表队列位置（从1开始） 输入：93,95,97,100,102,123,155 110 输出：6 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34;,\u0026#34;); int[] nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); int target = Integer.parseInt(sc.nextLine()); int idx = Arrays.binarySearch(nums, target); if (idx \u0026lt; 0) { idx = -idx - 1; } // 队列位置（从1开始），因此索引+1 System.out.println(idx + 1); } 11. 小朋友来自多少小区\r#\r描述\n幼儿园组织活动，老师布置了一个任务：每个小朋友去了解与自己同一个小区的小朋友还有几个。 我们将这些数量汇总到数组 garden 中。 请根据这些小朋友给出的信息，计算最少的小朋友数量？ 备注： garden 数组长度最大为 999 每个小区的小朋友数量最多 1000 人，也就是 garden[i] 的范围为 [0, 999] 输入：2 2 3 输出：7 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(nums)); } public static int getResult(int[] nums) { HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int num : nums) { map.put(num, map.getOrDefault(num, 0) + 1); } int ans = 0; for (int key : map.keySet()) { // key是反馈，假设某小朋友反馈有key个人和自己一个小区，那么该小区总人数为total = key+1 int total = key + 1; ans += (int) (Math.ceil(map.get(key) * 1.0 / total) * total); } return ans; } 12. 虚拟理财游戏\r#\r描述\n在一款虚拟游戏中生活，你必须进行投资以增强在虚拟游戏中的资产以免被淘汰出局。 现有一家Bank，它提供有若干理财产品 m 个，风险及投资回报不同，你有 N（元）进行投资，能接收的总风险值为X。 你要在可接受范围内选择最优的投资方式获得最大回报。 备注： 1. 在虚拟游戏中，每项投资风险值相加为总风险值； 2. 在虚拟游戏中，最多只能投资2个理财产品； 3. 在虚拟游戏中，最小单位为整数，不能拆分为小数； 4. 投资额*回报率=投资回报 输入描述： 第一行：产品数（取值范围[1,20]），总投资额（整数，取值范围[1, 10000]），可接受的总风险（整数，取值范围[1,200]） 第二行：产品投资回报率序列，输入为整数，取值范围[1,60] 第三行：产品风险值序列，输入为整数，取值范围[1, 100] 第四行：最大投资额度序列，输入为整数，取值范围[1, 10000] 输出描述： 每个产品的投资额序列 输入：5 100 10 10 20 30 40 50 3 4 5 6 10 20 30 20 40 30 输出：0 30 0 40 0 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] tmp = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int m = tmp[0]; // 产品数 int n = tmp[1]; // 总投资 int x = tmp[2]; // 总风险 // 产品回报率序列 int[] back = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); // 产品风险值序列 int[] risk = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); // 产品投资额序列 int[] invest = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int maxBack = 0; HashMap\u0026lt;Integer, Integer\u0026gt; select = new HashMap\u0026lt;\u0026gt;(); // 情况1：只投资1个产品 for (int i = 0; i \u0026lt; m; i++) { if (risk[i] \u0026gt; x) { continue; } // 产品I的投资额不能超过该产品的最大投资额，以及总投资 int investI = Math.min(invest[i], n); // 产品投资回报 int curBack = investI * back[i]; // 如果投资回报高于其他产品组合，那么选择该产品 if (curBack \u0026gt; maxBack) { maxBack = curBack; select.clear(); select.put(i, investI); } } // 情况2：投资了2个产品 for (int i = 0; i \u0026lt; m; i++) { for (int j = i + 1; j \u0026lt; m; j++) { if (risk[i] + risk[j] \u0026gt; x) { continue; } int investI; int investJ; // 其中优先投资回报率大的 if (back[i] \u0026gt; back[j]) { // 产品I回报率高，则能投多少投多少，最多不能超过min(总投资, 产品I的最多投资额) investI = Math.min(n, invest[i]); // 留给产品J的剩余钱未 n - investI, 而产品J最多投资invest[j]，因此取二者较小值 investJ = Math.min(n - investI, invest[j]); } else { investJ = Math.min(n, invest[j]); investI = Math.min(n - investJ, invest[i]); } // 总投资回报 int curBack = investI * back[i] + investJ * back[j]; // 如果当前产品组合的总回报更大，则选当前组合产品 if (curBack \u0026gt; maxBack) { maxBack = curBack; select.clear(); // select的key记录产品的ID，val记录产品的投资额 if (investI \u0026gt; 0) select.put(i, investI); if (investJ \u0026gt; 0) select.put(j, investJ); } } } StringJoiner sj = new StringJoiner(\u0026#34; \u0026#34;); for (int i = 0; i \u0026lt; m; i++) { if (select.containsKey(i)) { sj.add(select.get(i) + \u0026#34;\u0026#34;); } else { sj.add(\u0026#34;0\u0026#34;); } } System.out.println(sj); } 13. 寻找身高相近的小朋友\r#\r描述\n小明今年升学到了小学1年级来到新班级后，发现其他小朋友身高参差不齐， 然后就想基于各小朋友和自己的身高差，对他们进行排序，请帮他实现排序。 输入描述： 第一行为正整数 h和n，0＜h＜200 为小明的身高，0＜n＜50 为新班级其他小朋友个数。 第二行为n个正整数，h1 ~ hn分别是其他小朋友的身高，取值范围0＜hi＜200，且n个正整数各不相同。 输出描述： 输出排序结果，各正整数以空格分割， 和小明身高差绝对值最小的小朋友排在前面，和小明身高差绝对值最大的小朋友排在后面， 如果两个小朋友和小明身高差一样，则个子较小的小朋友排在前面。 输入：100 10 95 96 97 98 99 101 102 103 104 105 输出：99 101 98 102 97 103 96 104 95 105 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int h = sc.nextInt(); int n = sc.nextInt(); Integer[] heights = new Integer[n]; for (int i = 0; i \u0026lt; n; i++) { heights[i] = sc.nextInt(); } System.out.println(getResult(h, heights)); } public static String getResult(int h, Integer[] heights) { Arrays.sort(heights, (a, b) -\u0026gt; { int absA = Math.abs(a - h); int abaB = Math.abs(b - h); return absA != abaB ? absA - abaB : a - b; }); StringJoiner sj = new StringJoiner(\u0026#34; \u0026#34;); for (Integer height : heights) { sj.add(height + \u0026#34;\u0026#34;); } return sj.toString(); } 14. 寻找相同子串\r#\r描述\n给你两个字符串t和p，要求从t中找到一个和p相同的连续子串，并输出该子串第一个字符的下标。 输入描述： 1. 输入文件包括两行，分别表示字符串t和p 2. 保证t的长度不小于p 3. t的长度不超过1000000 4. p的长度不超过10000 输出描述： 1. 如果能从t中找到一个和p相等的连续子串，则输出该子串第一个字符在t中的下标，下标从左到右依次为1,2,3,…； 2. 如果不能，则输出 “No” 3. 如果含有多个这样的子串，则输出第一个字符下标最小的 输入：AVERDXIVYERDIAN RDXI 输出：4 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); String subStr = sc.nextLine(); if (str.length() \u0026lt; subStr.length()) { System.out.println(\u0026#34;No\u0026#34;); return; } int idx = str.indexOf(subStr); String ans = idx == -1 ? \u0026#34;No\u0026#34; : idx + 1 + \u0026#34;\u0026#34;; System.out.println(ans); } 15. 一种字符串压缩表示的解压\r#\r描述\n有一种简易压缩算法：针对全部由小写英文字母组成的字符串， 将其中连续超过两个相同字母的部分压缩为连续个数加该字母，其他部分保持原样不变。 例如：字符串“aaabbccccd”经过压缩成为字符串“3abb4cd”。 请您编写解压函数，根据输入的字符串，判断其是否为合法压缩过的字符串， 若输入合法则输出解压缩后的字符串，否则输出字符串“!error”来报告错误。 输入描述：输入一行，为一个ASCII字符串，长度不会超过100字符，用例保证输出的字符串长度也不会超过100字符。 输出描述：若判断输入为合法的经过压缩后的字符串，则输出压缩前的字符串；若输入不合法，则输出字符串“!error”。 输入：4dff 输出：ddddff 说明：4d扩展为dddd，故解压后的字符串为ddddff。 输入：2dff 输出：!error 说明：两个d不需要压缩，故输入不合法。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(getResult(sc.nextLine())); } public static String getResult(String str) { if (!str.matches(\u0026#34;[a-z0-9]+\u0026#34;)) { return \u0026#34;!error\u0026#34;; } char[] chars = str.toCharArray(); StringBuilder sb = new StringBuilder(); LinkedList\u0026lt;Character\u0026gt; numList = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; chars.length; i++) { char ch = chars[i]; // 数字 if (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { numList.addLast(ch); continue; } // 字母 if (numList.isEmpty()) { sb.append(ch); continue; } String numStr = \u0026#34;\u0026#34;; while (!numList.isEmpty()) { numStr += numList.removeFirst(); } int num = Integer.parseInt(numStr); if (numStr.charAt(0) == \u0026#39;0\u0026#39; || num \u0026lt; 3) { return \u0026#34;!error\u0026#34;; } if (i + 1 \u0026lt; chars.length \u0026amp;\u0026amp; ch == chars[i + 1]) { return \u0026#34;!error\u0026#34;; } for (int j = 0; j \u0026lt; num; j++) { sb.append(ch); } } if (!numList.isEmpty()) { return \u0026#34;!error\u0026#34;; } if (!zip(sb.toString()).equals(str)) { return \u0026#34;!error\u0026#34;; } return sb.toString(); } public static String zip(String str) { char[] chars = str.toCharArray(); char ch; int num; StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; chars.length; i++) { ch = chars[i]; num = 1; for (int j = i + 1; j \u0026lt; chars.length; j++) { if (chars[j] == ch) { num++; continue; } break; } if (num == 1) { sb.append(ch); continue; } if (num == 2) { sb.append(ch).append(ch); i++; continue; } sb.append(num).append(ch); i += num - 1; } return sb.toString(); } 16. 英文输入法\r#\r描述\n主管期望你来实现英文输入法单词联想功能。 需求如下： 依据用户输入的单词前缀，从已输入的英文语句中联想出用户想输入的单词，按字典序输出联想到的单词序列， 如果联想不到，请输出用户输入的单词前缀。 注意： 英文单词联想时，区分大小写 缩略形式如”don’t”，判定为两个单词，”don”和”t” 输出的单词序列，不能有重复单词，且只能是英文单词，不能有标点符号 输入描述：输入为两行 首行输入一段由英文单词word和标点符号组成的语句str； 接下来一行为一个英文单词前缀pre。 0 ＜ word.length() ≤ 20 0 ＜ str.length ≤ 10000 0 ＜ pre ≤ 20 输出描述： 输出符合要求的单词序列或单词前缀，存在多个时，单词之间以单个空格分割 输入：The furthest distance in the world, Is not between life and death, But when I stand in front of you f 输出：front furthest 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); String pre = sc.nextLine(); System.out.println(getResult(str, pre)); } public static String getResult(String str, String pre) { String[] tmp = str.split(\u0026#34;[^a-zA-Z]\u0026#34;); List\u0026lt;String\u0026gt; list = Arrays.asList(tmp); String ans = list.stream().filter(s -\u0026gt; !s.isBlank()) .filter(s -\u0026gt; s.startsWith(pre)).sorted().collect(Collectors.joining(\u0026#34; \u0026#34;)); return ans.isEmpty() ? pre : ans; } 17. 用户调度问题\r#\r描述\n在通信系统中，一个常见的问题是对用户进行不同策略的调度，会得到不同的系统消耗和性能。 假设当前有n个待串行调度用户，每个用户可以使用A/B/C三种不同的调度策略，不同的策略会消耗不同的系统资源。 请你根据如下规则进行用户调度，并返回总的消耗资源数。 1. 相邻的用户不能使用相同的调度策略，例如，第1个用户使用了A策略，则第2个用户只能使用B或者C策略。 2. 对单个用户而言，不同的调度策略对系统资源的消耗可以归一化后抽象为数值。 3. 每个用户依次选择当前所能选择的对系统资源消耗最少的策略（局部最优），如果有多个满足要求的策略，选最后一个。 输入描述： 第一行表示用户个数n 接下来每一行表示一个用户分别使用三个策略的系统消耗resA resB resC 输出描述： 最优策略组合下的总的系统资源消耗数 输入：3 15 8 17 12 20 9 11 7 5 输出：24 说明：1号用户使用B策略，2号用户使用C策略，3号用户使用B策略。系统资源消耗: 8 + 9 + 7 = 24。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[][] res = new int[n][3]; for (int i = 0; i \u0026lt; n; i++) { res[i][0] = sc.nextInt(); res[i][1] = sc.nextInt(); res[i][2] = sc.nextInt(); } System.out.println(getResult(n, res)); } public static int getResult(int n, int[][] res) { int last = -1; int sum = 0; for (int i = 0; i \u0026lt; n; i++) { last = getMinEleIdx(res[i], last); sum += res[i][last]; } return sum; } public static int getMinEleIdx(int[] arr, int excludeIdx) { int minEleVal = Integer.MAX_VALUE; int minEleIdx = -1; for (int i = 0; i \u0026lt; arr.length; i++) { if (i == excludeIdx) continue; if (arr[i] \u0026lt;= minEleVal) { minEleVal = arr[i]; minEleIdx = i; } } return minEleIdx; } 18. 用连续自然数之和来表达整数\r#\r描述\n一个整数可以由连续的自然数之和来表示。 给定一个整数，计算该整数有几种连续自然数之和的表达式，且打印出每种表达式 输入描述： 一个目标整数T (1 ≤T≤ 1000) 输出描述： 该整数的所有表达式和表达式的个数。 如果有多种表达式，输出要求为：自然数个数最少的表达式优先输出，每个表达式中按自然数递增的顺序输出，具体的格式参见样例。 在每个测试数据结束时，输出一行”Result:X”，其中X是最终的表达式个数。 输入：9 输出：9=9 9=4+5 9=2+3+4 Result:3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); int i = 0; List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); while (true) { i++; int l = 2 * n - i * i + i; if (l % (2 * i) != 0) { continue; } int a1 = l / (2 * i); if (a1 \u0026lt; 1) { break; } list.add(getResult(n, a1, i)); } list.forEach(System.out::println); System.out.println(\u0026#34;Result:\u0026#34; + list.size()); } public static String getResult(int sum, int a1, int n) { StringJoiner joiner = new StringJoiner(\u0026#34;+\u0026#34;); for (int i = a1; i \u0026lt; n + a1; i++) { joiner.add(i + \u0026#34;\u0026#34;); } return sum + \u0026#34;=\u0026#34; + joiner; } 19. 游戏分组\r#\r描述\n部门准备举办一场王者荣耀表演赛，有 10 名游戏爱好者参与，分为两队，每队 5 人。 每位参与者都有一个评分，代表着他的游戏水平。为了表演赛尽可能精彩，我们需要把 10 名参赛者分为实力尽量相近的两队。 一队的实力可以表示为这一队 5 名队员的评分总和。 现在给你 10 名参与者的游戏水平评分，请你根据上述要求分队，最后输出这两组的实力差绝对值。 输入描述：10个整数，表示10名参与者的游戏水平评分。范围在 [1, 10000] 之间。 输出描述：1个整数，表示分组后两组实力差绝对值的最小值。 输入：1 2 3 4 5 6 7 8 9 10 输出：1 题解\nstatic int[] nums; public static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); dfs(list, 0, 0, 0, 0, 0); int ans = list.stream().reduce(Integer::min).orElse(0); System.out.println(ans); } public static void dfs(List\u0026lt;Integer\u0026gt; list, int index, int size1, int sum1, int size2, int sum2) { if (index \u0026gt; 9) { list.add(Math.abs(sum1 - sum2)); return; } int num = nums[index]; if (size1 \u0026lt; 5) { dfs(list, index + 1, size1 + 1, sum1 + num, size2, sum2); } if (size2 \u0026lt; 5) { dfs(list, index + 1, size1, sum1, size2 + 1, sum2 + num); } } 20. 约瑟夫问题\r#\r描述\n输入一个由随机数组成的数列（数列中每个数均是大于 0 的整数，长度已知），和初始计数值 m。 从数列首位置开始计数，计数到 m 后，将数列该位置数值替换计数值 m， 并将数列该位置数值出列，然后从下一位置从新开始计数，直到数列所有数值出列为止。 如果计数到达数列尾段，则返回数列首位置继续计数。 请编程实现上述计数过程，同时输出数值出列的顺序。 输入描述： 第一行是初始数列 第二行是初始数列的长度 第三行是初始计数值m 输出描述 输出的数值出列顺序 输入：3,1,2,4 4 7 输出：2,3,1,4 比如：输入的随机数列为：3,1,2,4，初始计数值 m=7，从数列首位置开始计数（数值 3 所在位置） 第一轮计数出列数字为 2，计数值更新 m=2，出列后数列为 3,1,4，从数值 4 所在位置从新开始计数 第二轮计数出列数字为 3，计数值更新 m=3，出列后数列为 1,4，从数值 1 所在位置开始计数 第三轮计数出列数字为 1，计数值更新 m=1，出列后数列为 4，从数值 4 所在位置开始计数 最后一轮计数出列数字为 4，计数过程完成。输出数值出列顺序为：2,3,1,4。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34;,\u0026#34;); Integer[] nums = Arrays.stream(split).map(Integer::parseInt).toArray(Integer[]::new); int len = Integer.parseInt(sc.nextLine()); int m = Integer.parseInt(sc.nextLine()); System.out.println(getResult(nums, len, m)); } public static String getResult(Integer[] nums, int len, int m) { LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(Arrays.asList(nums)); ArrayList\u0026lt;String\u0026gt; ansList = new ArrayList\u0026lt;\u0026gt;(); int i = 1; while (len \u0026gt; 0) { Integer out = list.removeFirst(); if (i == m) { ansList.add(out + \u0026#34;\u0026#34;); m = out; i = 1; len--; } else { list.add(out); i++; } } return String.join(\u0026#34;,\u0026#34;, ansList); } 21. 在字符串中找出连续最长的数字串\r#\r描述\n请在一个字符串中找出连续最长的数字串，并返回这个数字串。 如果存在长度相同的连续数字串，返回最后一个。 如果没有符合条件的字符串，返回空字符串””。 注意： 数字串可以由数字”0-9″、小数点”.”、正负号”±”组成，长度包括组成数字串的所有符号。 “.”、“±”仅能出现一次，”.”的两边必须是数字，”±”仅能出现在开头且其后必须要有数字。 长度不定，可能含有空格。 输入：1234567890abcd9.+12345.678.9ed 输出：+12345.678 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34;[^0-9.+-]\u0026#34;); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (String str : split) { if (str.isBlank()) { continue; } String[] strings = str.replaceAll(\u0026#34;\\\\+\u0026#34;, \u0026#34;@+\u0026#34;) .replaceAll(\u0026#34;-\u0026#34;, \u0026#34;@-\u0026#34;) .split(\u0026#34;@\u0026#34;); for (String string : strings) { if (string.isBlank() || string.equals(\u0026#34;+\u0026#34;) || string.equals(\u0026#34;-\u0026#34;)) { continue; } splitNumString(list, string); } } String ans = \u0026#34;\u0026#34;; for (String string : list) { if (string.length() \u0026gt;= ans.length()) { ans = string; } } System.out.println(ans); } public static void splitNumString(List\u0026lt;String\u0026gt; list, String line) { String[] arr = line.split(\u0026#34;\\\\.\u0026#34;); if (arr.length == 1) { list.add(arr[0]); return; } for (int i = 0; i \u0026lt; arr.length - 1; i++) { if (arr[i].isEmpty()) { continue; } if (arr[i + 1].isEmpty()) { list.add(arr[i]); } else { list.add(arr[i] + \u0026#34;.\u0026#34; + arr[i + 1]); } } } 22. 掌握的单词个数\r#\r描述\n有一个字符串数组 words 和一个字符串 chars。 假如可以用 chars 中的字母拼写出 words 中的某个“单词”（字符串），那么我们就认为你掌握了这个单词。 words 的字符仅由 a-z 英文小写字母组成，例如 \u0026#34;abc\u0026#34;； chars 由 a-z 英文小写字母和 \u0026#34;?\u0026#34; 组成。其中英文 \u0026#34;?\u0026#34; 表示万能字符，能够在拼写时当作任意一个英文字母。例如：\u0026#34;?\u0026#34; 可以当作 \u0026#34;a\u0026#34; 等字母。 注意： 每次拼写时，chars 中的每个字母和万能字符都只能使用一次。 输出词汇表 words 中你掌握的所有单词的个数。没有掌握任何单词，则输出0。 输入描述： 第一行：输入数组 words 的个数，记作N。 第二行 ~ 第N+1行：依次输入数组words的每个字符串元素 第N+2行：输入字符串chars 输出描述： 输出一个整数，表示词汇表 words 中你掌握的单词个数 备注： 1 ≤ words.length ≤ 100 1 ≤ words[i].length, chars.length ≤ 100 所有字符串中都仅包含小写英文字母、英文问号 输入：4 cat bt hat tree atach?? 输出：3 说明：可以拼写字符串\u0026#34;cat\u0026#34;、\u0026#34;bt\u0026#34;和\u0026#34;hat\u0026#34; 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); String[] words = new String[n]; for (int i = 0; i \u0026lt; n; i++) { words[i] = sc.nextLine(); } String chars = sc.nextLine(); System.out.println(getResult(words, n, chars)); } public static int getResult(String[] words, int n, String chars) { int sum = 0; int[] chsArr = getChs(chars); for (int i = 0; i \u0026lt; n; i++) { int diff = 0; int[] wordArr = getChs(words[i]); for (int j = 0; j \u0026lt; 128; j++) { diff += Math.max(wordArr[j] - chsArr[j], 0); } if (diff \u0026lt;= chsArr[\u0026#39;?\u0026#39;]) { sum++; } } return sum; } public static int[] getChs(String s) { int[] ints = new int[128]; char[] chs = s.toCharArray(); for (char ch : chs) { ints[ch]++; } return ints; } 23. 找出符合要求的字符串子串\r#\r描述\n给定两个字符串，从字符串2中找出字符串1中的所有字符，去重并按照ASCII值从小到大排序。 输入字符串1：长度不超过1024 输入字符串2：长度不超过1000000 字符范围满足ASCII编码要求，按照ASCII的值由小到大排序 输入：fach bbaaccedfg 输出：acf 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chs1 = sc.nextLine().toCharArray(); char[] chs2 = sc.nextLine().toCharArray(); System.out.println(getResult(chs1, chs2)); } public static String getResult(char[] chs1, char[] chs2) { HashSet\u0026lt;Character\u0026gt; set1 = new HashSet\u0026lt;\u0026gt;(); for (char ch : chs1) { set1.add(ch); } HashSet\u0026lt;Character\u0026gt; set2 = new HashSet\u0026lt;\u0026gt;(); for (char ch : chs2) { set2.add(ch); } return set1.stream().filter(set2::contains) .sorted().map(String::valueOf).collect(Collectors.joining()); } 24. 找出经过特定点的路径长度\r#\r描述\n输入描述： 输入一个字符串，都是以大写字母组成，每个相邻的距离是 1， 第二行输入一个字符串，表示必过的点。 说明每个点可过多次。 输出描述： 经过这些必过点的最小距离是多少 输入：ANTSEDXQOKPUVGIFWHJLYMCRZB ABC 输出：28 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String all = sc.nextLine(); String must = sc.nextLine(); System.out.println(getResult(all, must)); } public static int getResult(String all, String must) { HashMap\u0026lt;Character, ArrayList\u0026lt;Integer\u0026gt;\u0026gt; mustCharIdx = new HashMap\u0026lt;\u0026gt;(); HashSet\u0026lt;Character\u0026gt; mustChar = new HashSet\u0026lt;\u0026gt;(); for (char c : must.toCharArray()) { mustChar.add(c); } for (int i = 0; i \u0026lt; all.length(); i++) { char c = all.charAt(i); if (mustChar.contains(c)) { mustCharIdx.putIfAbsent(c, new ArrayList\u0026lt;\u0026gt;()); mustCharIdx.get(c).add(i); } } int[] ans = {Integer.MAX_VALUE}; dfs(0, must, mustCharIdx, new LinkedList\u0026lt;\u0026gt;(), ans); return ans[0]; } public static void dfs( int index, String must, HashMap\u0026lt;Character, ArrayList\u0026lt;Integer\u0026gt;\u0026gt; mustCharIdx, LinkedList\u0026lt;Integer\u0026gt; path, int[] ans) { if (path.size() == must.length()) { int dis = path.get(0); // 运动起点必须从第一行输入all的第一个字母开始 for (int i = 1; i \u0026lt; path.size(); i++) { dis += Math.abs(path.get(i) - path.get(i - 1)); } ans[0] = Math.min(ans[0], dis); return; } for (Integer idx : mustCharIdx.get(must.charAt(index))) { path.add(idx); dfs(index + 1, must, mustCharIdx, path, ans); path.removeLast(); } } 25. 找朋友\r#\r描述\n在学校中，N个小朋友站成一队， 第i个小朋友的身高为height[i]， 第i个小朋友可以看到的第一个比自己身高更高的小朋友j，那么j是i的好朋友(要求j \u0026gt; i)。 请重新生成一个列表，对应位置的输出是每个小朋友的好朋友位置，如果没有看到好朋友，请在该位置用0代替。 小朋友人数范围是 [0, 40000]。 输入描述： 第一行输入N，N表示有N个小朋友 第二行输入N个小朋友的身高height[i]，都是整数 输出描述： 输出N个小朋友的好朋友的位置 输入：8 123 124 125 121 119 122 126 123 输出：1 2 6 5 5 6 0 0 说明：123的好朋友是1位置上的124 124的好朋友是2位置上的125 125的好朋友是6位置上的126 以此类推 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] arr = new int[n]; for (int i = 0; i \u0026lt; n; i++) { arr[i] = sc.nextInt(); } sc.close(); System.out.println(getResult(arr)); } public static String getResult(int[] arr) { int[] ints = new int[arr.length]; for (int i = 0; i \u0026lt; arr.length; i++) { for (int j = i + 1; j \u0026lt; arr.length; j++) { if (arr[j] \u0026gt; arr[i]) { ints[i] = j; break; } } } StringJoiner joiner = new StringJoiner(\u0026#34; \u0026#34;); for (int i : ints) { joiner.add(i + \u0026#34;\u0026#34;); } return joiner.toString(); } "},{"id":276,"href":"/algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%935/","title":"机试题库 - 5","section":"华为OD","content":"\r01. 找座位\r#\r描述\n在一个大型体育场内举办了一场大型活动，由于疫情防控的需要，要求每位观众的必须间隔至少一个空位才允许落座。 现在给出一排观众座位分布图，座位中存在已落座的观众，请计算出，在不移动现有观众座位的情况下，最多还能坐下多少名观众。 输入描述： 一个数组，用来标识某一排座位中，每个座位是否已经坐人。0表示该座位没有坐人，1表示该座位已经坐人。 1 ≤ 数组长度 ≤ 10000 输出描述： 整数，在不移动现有观众座位的情况下，最多还能坐下多少名观众。 输入：10001 输出：1 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(getResult(sc.nextLine().toCharArray())); } public static int getResult(char[] desk) { int ans = 0; for (int i = 0; i \u0026lt; desk.length; i++) { if (desk[i] == \u0026#39;0\u0026#39;) { boolean isLeftEmpty = i == 0 || desk[i - 1] == \u0026#39;0\u0026#39;; boolean isRightEmpty = i == desk.length - 1 || desk[i + 1] == \u0026#39;0\u0026#39;; if (isLeftEmpty \u0026amp;\u0026amp; isRightEmpty) { ans++; desk[i] = \u0026#39;1\u0026#39;; i++; } } } return ans; } 02. 整数对最小和\r#\r描述\n给定两个整数数组array1、array2，数组元素按升序排列。 假设从array1、array2中分别取出一个元素可构成一对元素，现在需要取出k对元素， 并对取出的所有元素求和，计算和的最小值。 注意： 两对元素如果对应于array1、array2中的两个下标均相同，则视为同一对元素。 输入描述： 输入两行数组array1、array2，每行首个数字为数组大小size(0 ＜ size ≤ 100); 0 ＜ array1[i],array2[i] ≤ 1000 接下来一行为正整数k 0 ＜ k ≤ array1.size() * array2.size() 输出描述： 满足要求的最小和 输入：3 1 1 2 3 1 2 3 2 输出：4 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n1 = sc.nextInt(); int[] arr1 = new int[n1]; for (int i = 0; i \u0026lt; n1; i++) { arr1[i] = sc.nextInt(); } int n2 = sc.nextInt(); int[] arr2 = new int[n2]; for (int i = 0; i \u0026lt; n2; i++) { arr2[i] = sc.nextInt(); } int k = sc.nextInt(); System.out.println(getResult(arr1, arr2, k)); } public static int getResult(int[] arr1, int[] arr2, int k) { ArrayList\u0026lt;Integer\u0026gt; pairs = new ArrayList\u0026lt;\u0026gt;(); for (int v1 : arr1) { for (int v2 : arr2) { pairs.add(v1 + v2); } } pairs.sort((a, b) -\u0026gt; a - b); int sum = 0; for (int i = 0; i \u0026lt; k; i++) { sum += pairs.get(i); } return sum; } 03. 整型数组按个位值排序\r#\r描述\n给定一个非空数组（列表），其元素数据类型为整型， 请按照数组元素十进制最低位从小到大进行排序，十进制最低位相同的元素，相对位置保持不变。 当数组元素为负值时，十进制最低位等同于去除符号位后对应十进制值最低位。 输入描述：给定一个非空数组，其元素数据类型为32位有符号整数，数组长度[1, 1000] 输出描述：输出排序后的数组 输入：1,2,5,-21,22,11,55,-101,42,8,7,32 输出：1,-21,11,-101,2,22,42,32,5,55,7,8 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] arr = sc.nextLine().split(\u0026#34;,\u0026#34;); System.out.println(getResult(arr)); } public static String getResult(String[] arr) { Arrays.sort(arr, (a, b) -\u0026gt; a.charAt(a.length() - 1) - b.charAt(b.length() - 1)); StringJoiner sj = new StringJoiner(\u0026#34;,\u0026#34;); for (String s : arr) sj.add(s); return sj.toString(); } 04. 执行任务赚积分\r#\r描述\n现有N个任务需要处理，同一时间只能处理一个任务，处理每个任务所需要的时间固定为1。 每个任务都有最晚处理时间限制和积分值，在最晚处理时间点之前处理完成任务才可获得对应的积分奖励。 可用于处理任务的时间有限，请问在有限的时间内，可获得的最多积分。 输入描述： 第一行为一个数 N，表示有 N 个任务，1 ≤ N ≤ 100 第二行为一个数 T，表示可用于处理任务的时间，1 ≤ T ≤ 100 接下来 N 行，每行两个空格分隔的整数（SLA 和 V），SLA 表示任务的最晚处理时间，V 表示任务对应的积分。 1 ≤ SLA ≤ 100，0 ≤ V ≤ 100000 输出描述： 可获得的最多积分 输入：4 3 1 2 1 3 1 4 1 5 输出：5 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int t = sc.nextInt(); int[][] wos = new int[n][2]; for (int i = 0; i \u0026lt; n; i++) { wos[i][0] = sc.nextInt(); wos[i][1] = sc.nextInt(); } System.out.println(getResult(wos, t)); } public static int getResult(int[][] wos, int t) { // 按照任务截止时间升序 Arrays.sort(wos, (a, b) -\u0026gt; a[0] - b[0]); // pq用于按照积分对任务进行优先级排序，积分越小，优先级越高，目的是为了每次替换掉最少积分的工单 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a - b); // 当前时间 int curTime = 0; // 已获得的积分 int ans = 0; // 遍历任务 for (int[] wo : wos) { int endTime = wo[0]; // 任务截止时间 int score = wo[1]; // 任务积分 if (curTime \u0026lt; endTime) { // 如果 curTime \u0026lt; 当前任务的截止时间，则curTime时刻可以指向当前任务 pq.offer(score); ans += score; curTime++; } else { // 如果 curTime \u0026gt;= 当前任务的截止时间，则当前任务只能在curTime时刻之前找一个时间点执行 // pq中记录的就是curTime之前时刻执行的任务 if (pq.isEmpty()) { continue; } // 此时取出pq记录的可执行的任务中最小积分的那个 int min_score = pq.peek(); // 如果当前任务的积分 \u0026gt; 前面时间内可执行的任务中最小积分 if (score \u0026gt; min_score) { // 则我们应该将执行pq中最小积分任务的时间，用于执行当前任务，因为这样可以获得更大积分 pq.poll(); pq.offer(score); ans += score - min_score; } } } // 由于时间限制为t单位，而每个任务花费1单位时间，因此最多完成t个任务，对于多出任务应该去除，且优先去除积分少的 while (pq.size() \u0026gt; t \u0026amp;\u0026amp; t \u0026gt; 0) { ans -= pq.poll(); } return ans; } 05. 执行时长\r#\r描述\n为了充分发挥GPU算力，需要尽可能多的将任务交给GPU执行， 现在有一个任务数组，数组元素表示在这1秒内新增的任务个数且每秒都有新增任务。 假设GPU最多一次执行n个任务，一次执行耗时1秒，在保证GPU不空闲情况下，最少需要多长时间执行完成。 输入描述： 第一个参数为GPU一次最多执行的任务个数，取值范围[1, 10000] 第二个参数为任务数组长度，取值范围[1, 10000] 第三个参数为任务数组，数字范围[1, 10000] 输出描述： 执行完所有任务最少需要多少秒。 输入：4 5 5 4 1 1 1 输出：5 说明：一次最多执行4个任务，最少耗时5s 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int maxCount = sc.nextInt(); int n = sc.nextInt(); int[] tasks = new int[n]; for (int i = 0; i \u0026lt; n; i++) { tasks[i] = sc.nextInt(); } System.out.println(getResult(maxCount, tasks)); } public static int getResult(int maxCount, int[] tasks) { int time = 0; int remain = 0; for (int task : tasks) { if (task + remain \u0026gt; maxCount) { remain = task + remain - maxCount; } else { remain = 0; } time++; } while (remain \u0026gt; 0) { remain -= maxCount; time++; } return time; } 06. 智能成绩表\r#\r描述\n小明来到某学校当老师，需要将学生按考试总分或单科分数进行排名，你能帮帮他吗？ 输入描述： 第 1 行输入两个整数，学生人数 n 和科目数量 m。0 ＜ n ＜ 100，0 ＜ m ＜ 10 第 2 行输入 m 个科目名称，彼此之间用空格隔开。 科目名称只由英文字母构成，单个长度不超过10个字符。 科目的出现顺序和后续输入的学生成绩一一对应。 不会出现重复的科目名称。 第 3 行开始的 n 行，每行包含一个学生的姓名和该生 m 个科目的成绩（空格隔开） 学生不会重名。 学生姓名只由英文字母构成，长度不超过10个字符。 成绩是0~100的整数，依次对应第2行种输入的科目。 第n+2行，输入用作排名的科目名称。若科目不存在，则按总分进行排序。 输出描述： 输出一行，按成绩排序后的学生名字，空格隔开。成绩相同的按照学生姓名字典顺序排序。 输入：3 2 yuwen shuxue fangfang 95 90 xiaohua 88 95 minmin 100 82 shuxue 输出：xiaohua fangfang minmin 题解\nstatic class Student { public String name; public int[] score; int total; public Student(String name) { this.name = name; } public void setScore(int[] score) { this.score = score; this.total = Arrays.stream(score).reduce(Integer::sum).orElse(0); } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); // 学生人数 int n = sc.nextInt(); // 科目数量 int m = sc.nextInt(); Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; m; i++) { map.put(sc.next(), i); } Student[] students = new Student[n]; for (int i = 0; i \u0026lt; n; i++) { Student stu = new Student(sc.next()); int[] score = new int[m]; for (int j = 0; j \u0026lt; m; j++) { score[j] = sc.nextInt(); } stu.setScore(score); students[i] = stu; } String rankKeMu = sc.next(); if (map.containsKey(rankKeMu)) { int index = map.get(rankKeMu); Arrays.sort(students, (a, b) -\u0026gt; a.score[index] != b.score[index] ? b.score[index] - a.score[index] : a.name.compareTo(b.name)); } else { Arrays.sort(students, (a, b) -\u0026gt; b.total != a.total ? b.total - a.total : a.name.compareTo(b.name)); } StringJoiner sj = new StringJoiner(\u0026#34; \u0026#34;); for (Student student : students) { sj.add(student.name); } System.out.println(sj); } 07. 转盘寿司\r#\r描述\n寿司店周年庆，正在举办优惠活动回馈新老客户。寿司转盘上总共有 n 盘寿司，prices[i] 是第 i 盘寿司的价格， 如果客户选择了第 i 盘寿司，寿司店免费赠送客户距离第 i 盘寿司最近的下一盘寿司 j， 前提是 prices[j] ＜ prices[i]，如果没有满足条件的 j，则不赠送寿司。 每个价格的寿司都可无限供应。 输入描述： 输入的每一个数字代表每盘寿司的价格，每盘寿司的价格之间使用空格分隔， 寿司的盘数 n 范围为：1 ≤ n ≤ 500 每盘寿司的价格 price 范围为：1 ≤ price ≤ 1000 输出描述： 输出享受优惠后的一组数据，每个值表示客户选择第 i 盘寿司时实际得到的寿司的总价格。使用空格进行分隔 输入：3 15 6 14 输出：3 21 9 17 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] ints = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int len = ints.length; int[] arr = new int[len]; for (int i = 0; i \u0026lt; len; i++) { for (int j = i + 1; j \u0026lt; len + i; j++) { int idx = getIndex(j, len); if (ints[idx] \u0026lt; ints[i]) { arr[i] = ints[i] + ints[idx]; break; } } if (arr[i] == 0) { arr[i] = ints[i]; } } StringJoiner joiner = new StringJoiner(\u0026#34; \u0026#34;); for (int i : arr) { joiner.add(i + \u0026#34;\u0026#34;); } System.out.println(joiner); } public static int getIndex(int i, int len) { if (i \u0026lt; len) { return i; } else { return i % len; } } 08. 字符串变换最小字符串\r#\r描述\n给定一个字符串s，最多只能进行一次变换，返回变换后能得到的最小字符串（按照字典序进行比较）。 变换规则：交换字符串中任意两个不同位置的字符。 输入描述：一串小写字母组成的字符串s 输出描述：按照要求进行变换得到的最小字符串。 备注：s是都是小写字符组成，1 ≤ s.length ≤ 1000 输入：bcdefa 输出：acdefb 说明：a和b进行位置交换，可以得到最小字符串 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(getResult(sc.nextLine())); } public static String getResult(String s) { char[] misChs = s.toCharArray(); Arrays.sort(misChs); String minS = new String(misChs); if (minS.equals(s)) { return s; } char[] chs = s.toCharArray(); for (int i = 0; i \u0026lt; s.length(); i++) { if (chs[i] != misChs[i]) { char tmp = chs[i]; chs[i] = misChs[i]; int swapIndex = s.lastIndexOf(misChs[i]); chs[swapIndex] = tmp; break; } } return new String(chs); } 09. 字符串分割\r#\r描述\n给定一个非空字符串S，其被N个‘-’分隔成N+1的子串，给定正整数K，要求除第一个子串外， 其余的子串每K个字符组成新的子串，并用‘-’分隔。 对于新组成的每一个子串， 如果它含有的小写字母比大写字母多，则将这个子串的所有大写字母转换为小写字母； 如果它含有的大写字母比小写字母多，则将这个子串的所有小写字母转换为大写字母； 大小写字母的数量相等时，不做转换。 输入描述：输入为两行，第一行为参数K，第二行为字符串S。 输出描述：输出转换后的字符串 输入：3 12abc-abcABC-4aB@ 输出：12abc-abc-ABC-4aB-@ 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int k = Integer.parseInt(sc.nextLine()); String input = sc.nextLine(); String[] strings = input.split(\u0026#34;-\u0026#34;); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(strings[0]); StringBuilder str = new StringBuilder(); for (int i = 1; i \u0026lt; strings.length; i++) { str.append(strings[i]); } for (int i = 0; i \u0026lt; str.length(); i += k) { if (i + k \u0026lt;= str.length()) { list.add(caseConversion(str.substring(i, i + k))); } else { list.add(caseConversion(str.substring(i))); } } System.out.println(String.join(\u0026#34;-\u0026#34;, list)); } private static String caseConversion(String s) { int upperCaseLength = s.length() - s.replaceAll(\u0026#34;[A-Z]\u0026#34;, \u0026#34;\u0026#34;).length(); int lowerCaseLength = s.length() - s.replaceAll(\u0026#34;[a-z]\u0026#34;, \u0026#34;\u0026#34;).length(); if (upperCaseLength \u0026gt; lowerCaseLength) { return s.toUpperCase(Locale.ROOT); } if (lowerCaseLength \u0026gt; upperCaseLength) { return s.toLowerCase(Locale.ROOT); } return s; } 10. 字符串排序\r#\r描述\n排序规则： 1. 单词中字母比较不区分大小写，两个单词先以第一个字母作为排序的基准，如果第一个字母相同，就用第二个字母为基准， 如果第二个字母相同就以第三个字母为基准。依此类推，如果到某个字母不相同，字母顺序在前的那个单词顺序在前。 2. 当一个短单词和一个长单词的开头部分都相同（即短单词是长单词从首字母开始的一部分），短单词顺序在前。 3. 字母大小写不同的相同单词，只输出一次。 输入：i LOVE Cc I love CC Hello Hel Hellow 输出：Cc Hel Hello Hellow i LOVE 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] arr = sc.nextLine().split(\u0026#34; \u0026#34;); System.out.println(getResult(arr)); } public static String getResult(String[] arr) { Arrays.sort(arr, (a, b) -\u0026gt; a.toLowerCase().compareTo(b.toLowerCase())); LinkedList\u0026lt;String\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); stack.add(arr[0]); for (int i = 1; i \u0026lt; arr.length; i++) { String top = stack.getLast(); if (top.equalsIgnoreCase(arr[i])) { continue; } stack.add(arr[i]); } return String.join(\u0026#34; \u0026#34;, stack); } 11. 字符串筛选排序\r#\r描述\n输入一个由N个大小写字母组成的字符串，按照ASCII码值从小到大进行排序 查找字符串中第K个最小ASCII码值的字母(k\u0026gt;=1)，输出该字母所在字符串中的位置索引(字符串的第一个位置索引为0) k如果大于字符串长度则输出最大ASCII码值的字母所在字符串的位置索引 如果有重复字母则输出字母的最小位置索引 输入描述： 第一行输入一个由大小写字母组成的字符串 第二行输入k ，k必须大于0 ，k可以大于输入字符串的长度 输出描述： 输出字符串中第k个最小ASCII码值的字母所在字符串的位置索引 k如果大于字符串长度则输出最大ASCII码值的字母所在字符串的位置索引 如果第k个最小ASCII码值的字母存在重复 则输出该字母的最小位置索引 输入：AbCdeFG 3 输出：5 输入：fAdDAkBbBq 4 输出：6 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.next(); int k = sc.nextInt(); sc.close(); System.out.println(getResult(str, k)); } public static int getResult(String str, int k) { char[] chars = str.toCharArray(); Arrays.sort(chars); if (k \u0026gt; str.length()) { k = str.length(); } char tar = chars[k - 1]; return str.indexOf(tar); } 12. 字符串序列判定\r#\r描述\n输入两个字符串 S 和 L ，都只包含英文小写字母。S长度 ≤ 100，L长度 ≤ 500,000。判定S是否是L的有效子串。 判定规则：S 中的每个字符在 L 中都能找到（可以不连续），且 S 在Ｌ中字符的前后顺序与 S 中顺序要保持一致。（例如，S = ”ace” 是 L= ”abcde” 的一个子序列且有效字符是a、c、e，而”aec”不是有效子序列，且有效字符只有a、e） 输入描述： 输入两个字符串 S 和 L，都只包含英文小写字母。S长度 ≤ 100，L长度 ≤ 500,000。 先输入S，再输入L，每个字符串占一行。 输出描述： S 串最后一个有效字符在 L 中的位置。（首位从0开始计算，无有效字符返回-1） 输入：ace abcde 输出：4 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.nextLine(); String l = sc.nextLine(); System.out.println(getResult(s, l)); } public static int getResult(String s, String l) { int i = 0; int j = 0; while (i \u0026lt; s.length() \u0026amp;\u0026amp; j \u0026lt; l.length()) { if (s.charAt(i) == l.charAt(j)) { i++; } j++; } return i == s.length() ? j - 1 : -1; } 13. 字符统计及重排\r#\r描述\n给出一个仅包含字母的字符串，不包含空格，统计字符串中各个字母（区分大小写）出现的次数， 并按照字母出现次数从大到小的顺序。输出各个字母及其出现次数。 如果次数相同，按照自然顺序进行排序，且小写字母在大写字母之前。 输入描述：输入一行，为一个仅包含字母的字符串。 输出描述： 按照字母出现次数从大到小的顺序输出各个字母和字母次数，用英文分号分隔，注意末尾的分号； 字母和次数间用英文冒号分隔。 输入：abababb 输出：b:4;a:3; 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chs = sc.nextLine().toCharArray(); int[][] arr = new int[128][3]; for (char ch : chs) { arr[ch][0] = ch; arr[ch][1]++; int idx = ch; if (idx \u0026gt;= \u0026#39;a\u0026#39;) { idx = idx - \u0026#39;a\u0026#39;; } arr[ch][2] = idx; } Arrays.sort(arr, (a, b) -\u0026gt; a[1] != b[1] ? b[1] - a[1] : a[2] - b[2]); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int[] ints : arr) { if (ints[1] == 0) { continue; } list.add((char) ints[0] + \u0026#34;:\u0026#34; + ints[1] + \u0026#34;;\u0026#34;); } System.out.println(String.join(\u0026#34;\u0026#34;, list)); } 14. 最大N个数与最小N个数的和\r#\r描述\n给定一个数组，编写一个函数来计算它的最大N个数与最小N个数的和。你需要对数组进行去重。 说明： 数组中数字范围[0, 1000] 最大N个数与最小N个数不能有重叠，如有重叠，输入非法返回-1 输入非法返回-1 输入描述： 第一行输入M， M标识数组大小 第二行输入M个数，标识数组内容 第三行输入N，N表达需要计算的最大、最小N个数 输出描述： 输出最大N个数与最小N个数的和 输入：5 95 88 83 64 100 2 输出：342 说明：最大2个数[100,95],最小2个数[83,64], 输出为342。 输入：5 3 2 3 4 2 2 输出：-1 说明：最大2个数[4,3],最小2个数[3,2], 有重叠输出为-1。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); int[] arr = new int[m]; for (int i = 0; i \u0026lt; m; i++) { arr[i] = sc.nextInt(); } int n = sc.nextInt(); sc.close(); System.out.println(getResult(m, arr, n)); } public static int getResult(int m, int[] arr, int n) { HashSet\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int val : arr) { if (val \u0026lt; 0 || val \u0026gt; 1000) { return -1; } set.add(val); } if (set.size() \u0026lt; n * 2) { return -1; } Integer[] ints = set.toArray(new Integer[0]); Arrays.sort(ints, (a, b) -\u0026gt; a - b); int l = 0; int r = ints.length - 1; int ans = 0; while (n \u0026gt; 0) { ans += ints[l] + ints[r]; l++; r--; n--; } return ans; } 15. 最大股票收益\r#\r描述\n假设知道某段连续时间内股票价格，计算通过买入卖出可获得的最大收益。 输入一个大小为 n 的数 price(p1,p2,p3,p4…….pn),pi 是第i天的股票价格。 pi 的格式为股票价格(非负整型)加上货币单位 Y 或者 S,其中 Y 代表人民币,S 代表美元,这里规定 1 美元可以兑换 7 人民币。 假设你可以在任何一天买入或者卖出股票,也可以选择放弃交易,请计其在交易周期 n 天内你能获得的最大收(以人民币计算)。 输入描述：输入一个包含交易周期内各天股票价格的字符串，以空格分隔。不考虑输入异常情况。 输出描述：输出一个整型数代表在交易周期 n 天内你能获得的最大收益，n 不能超过 10000 备注：股票价格只会用 Y 人民币或 S 美元进行输入，不考虑其他情况。 输入：2Y 3S 4S 6Y 8S 输出：76 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); Integer[] arr = Arrays.stream(split).map(Main::getRmb).toArray(Integer[]::new); System.out.println(getResult(arr)); } public static int getRmb(String str) { int num = Integer.parseInt(str.substring(0, str.length() - 1)); String unit = str.substring(str.length() - 1); return \u0026#34;Y\u0026#34;.equals(unit) ? num : num * 7; } public static int getResult(Integer[] arr) { int ans = 0; for (int i = 1; i \u0026lt; arr.length; i++) { ans += Math.max(0, arr[i] - arr[i - 1]); } return ans; } 16. 最大矩阵和\r#\r描述\n给定一个二维整数矩阵，要在这个矩阵中选出一个子矩阵，使得这个子矩阵内所有的数字和尽量大， 我们把这个子矩阵称为和最大子矩阵，子矩阵的选取原则是原矩阵中一块相互连续的矩形区域。 输入描述： 输入的第一行包含2个整数n, m(1 ≤ n, m ≤ 10)，表示一个n行m列的矩阵，下面有n行，每行有m个整数， 同一行中，每2个数字之间有1个空格，最后一个数字后面没有空格，所有的数字的在[-1000, 1000]之间。 输出描述： 输出一行一个数字，表示选出的和最大子矩阵内所有的数字和。 输入：3 4 -3 5 -1 5 2 4 -2 4 -1 3 -1 3 输出：20 说明：一个3*4的矩阵中，后面3列的子矩阵求和加起来等于20，和最大。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int[][] matrix = new int[n][m]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { matrix[i][j] = sc.nextInt(); } } System.out.println(getResult(n, m, matrix)); } public static int getResult(int n, int m, int[][] matrix) { ArrayList\u0026lt;Integer\u0026gt; dp = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { dp.add(maxSubArraySum(matrix[i])); // 一行子矩阵最大和 for (int j = i + 1; j \u0026lt; n; j++) { // 多行子矩阵最大和 int[] nums = matrixZip(Arrays.copyOfRange(matrix, i, j + 1)); dp.add(maxSubArraySum(nums)); } } return dp.stream().max((a, b) -\u0026gt; a - b).orElse(0); } // 最大子数组和求解 public static int maxSubArraySum(int[] nums) { int[] dp = new int[nums.length]; int res = dp[0] = nums[0]; for (int i = 1; i \u0026lt; nums.length; i++) { dp[i] = Math.max(dp[i - 1], 0) + nums[i]; res = Math.max(res, dp[i]); } return res; } // 多行子矩阵，压缩为一行子数组 public static int[] matrixZip(int[][] matrix) { int cols = matrix[0].length; int rows = matrix.length; int[] zip = new int[cols]; for (int c = 0; c \u0026lt; cols; c++) { for (int r = 0; r \u0026lt; rows; r++) { zip[c] += matrix[r][c]; } } return zip; } 17. 最大括号深度\r#\r描述\n现有一字符串仅由 ‘(‘，’)’，\u0026#39;{‘，’}’，\u0026#39;[‘，’]’六种括号组成。0≤字符串长度≤100000 若字符串满足以下条件之一，则为无效字符串： 1. 任一类型的左右括号数量不相等； 2. 存在未按正确顺序（先左后右）闭合的括号。 3. 输出括号的最大嵌套深度，若字符串无效则输出0。 输入描述：一个只包括 ‘(‘，’)’，\u0026#39;{‘，’}’，\u0026#39;[‘，’]’的字符串 输出描述：一个整数，最大的括号深度 输入：([]{()}) 输出：3 输入：([)] 输出：0 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.nextLine(); System.out.println(getResult(s)); } public static int getResult(String s) { HashMap\u0026lt;Character, Character\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#39;)\u0026#39;, \u0026#39;(\u0026#39;); map.put(\u0026#39;]\u0026#39;, \u0026#39;[\u0026#39;); map.put(\u0026#39;}\u0026#39;, \u0026#39;{\u0026#39;); LinkedList\u0026lt;Character\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); int maxDepth = 0; for (int i = 0; i \u0026lt; s.length(); i++) { char c = s.charAt(i); if (!stack.isEmpty() \u0026amp;\u0026amp; map.get(c) == stack.getLast()) { stack.removeLast(); } else { stack.add(c); maxDepth = Math.max(maxDepth, stack.size()); } } if (!stack.isEmpty()) { return 0; } return maxDepth; } 18. 最大时间\r#\r描述\n给定一个数组，里面有 6 个整数，求这个数组能够表示的最大 24 进制的时间是多少，输出这个时间，无法表示输出 invalid。 输入描述： 输入为一个整数数组，数组内有六个整数。 输入整数数组长度为 6，不需要考虑其它长度，元素值为 0 或者正整数，6 个数字每个数字只能使用一次。 输出描述： 输出为一个 24 进制格式的时间，或者字符串”invalid“。 输入：[0,2,3,0,5,6] 输出：23:56:00 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.nextLine(); String[] split = s.substring(1, s.length() - 1).split(\u0026#34;,\u0026#34;); Integer[] arr = Arrays.stream(split).map(Integer::parseInt).toArray(Integer[]::new); System.out.println(getResult(arr)); } public static String getResult(Integer[] arr) { ArrayList\u0026lt;Integer\u0026gt; numList = new ArrayList\u0026lt;\u0026gt;(List.of(arr)); // 小时1 int hour1 = getMaxNum(numList, 2); if (hour1 == -1) { return \u0026#34;invalid\u0026#34;; } removeFirst(numList, hour1); // 小时2 int hour2; if (hour1 == 2) { hour2 = getMaxNum(numList, 3); } else { hour2 = getMaxNum(numList, 9); } if (hour2 == -1) { return \u0026#34;invalid\u0026#34;; } removeFirst(numList, hour2); // 分钟 int min1 = getMaxNum(numList, 5); if (min1 == -1) { return \u0026#34;invalid\u0026#34;; } removeFirst(numList, min1); int min2 = getMaxNum(numList, 9); if (min2 == -1) { return \u0026#34;invalid\u0026#34;; } removeFirst(numList, min2); // 秒 Integer s1 = getMaxNum(numList, 5); if (s1 == -1) { return \u0026#34;invalid\u0026#34;; } numList.remove(s1); int s2 = getMaxNum(numList, 9); if (s2 == -1) { return \u0026#34;invalid\u0026#34;; } removeFirst(numList, s2); return \u0026#34;\u0026#34; + hour1 + hour2 + \u0026#34;:\u0026#34; + min1 + min2 + \u0026#34;:\u0026#34; + s1 + s2; } public static int getMaxNum(ArrayList\u0026lt;Integer\u0026gt; numList, int limit) { return numList.stream().filter(i -\u0026gt; i \u0026lt;= limit).reduce(Integer::max).orElse(-1); } public static void removeFirst(ArrayList\u0026lt;Integer\u0026gt; numList, int num) { for (int i = 0; i \u0026lt; numList.size(); i++) { if (numList.get(i) == num) { numList.remove(i); return; } } } 19. 最多购买宝石数目\r#\r描述\n橱窗里有一排宝石，不同的宝石对应不同的价格，宝石的价格标记为 gems[i]，0 ≤ i ＜ n，n = gems.length 宝石可同时出售0个或多个，如果同时出售多个，则要求出售的宝石编号连续； 例如客户最大购买宝石个数为m，购买的宝石编号必须为：gems[i]，gems[i+1]，...，gems[i+m-1] 假设你当前拥有总面值为 value 的钱，请问最多能购买到多少个宝石，如无法购买宝石，则返回0。 输入描述： 第一行输入n，参数类型为int，取值范围：[0,10^6]，表示橱窗中宝石的总数量。 之后 n 行分别表示从第0个到第n-1个宝石的价格，即 gems[0] 到 gems[n-1] 的价格，类型为int，取值范围：(0,1000]。 之后一行输入v，类型为int，取值范围：[0,10^9]，表示你拥有的钱。 输出描述： 输出int类型的返回值，表示最大可购买的宝石数量。 输入：7 8 4 6 3 1 6 7 10 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] arr = new int[n]; for (int i = 0; i \u0026lt; n; i++) { arr[i] = sc.nextInt(); } int v = sc.nextInt(); System.out.println(getResult(arr, v)); } public static int getResult(int[] arr, int v) { int maxLen = 0; for (int i = 0; i \u0026lt; arr.length; i++) { int sum = 0; for (int j = i; j \u0026lt; arr.length; j++) { sum = sum + arr[j]; if (sum \u0026lt;= v) { maxLen = Math.max(maxLen, j - i + 1); continue; } break; } } return maxLen; } 20. 最富裕的小家庭\r#\r描述\n在一颗树中，每个节点代表一个家庭成员，节点的数字表示其个人的财富值，一个节点及其直接相连的子节点被定义为一个小家庭。 现给你一颗树，请计算出最富裕的小家庭的财富和。 输入描述： 第一行为一个数 N，表示成员总数，成员编号 1~N。1 ≤ N ≤ 1000 第二行为 N 个空格分隔的数，表示编号 1~N 的成员的财富值。0 ≤ 财富值 ≤ 1000000 接下来 N -1 行，每行两个空格分隔的整数（N1, N2），表示 N1 是 N2 的父节点。 输出描述： 最富裕的小家庭的财富和 输入：4 100 200 300 500 1 2 1 3 2 4 输出：700 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); long[] wealth = new long[n + 1]; long[] family = new long[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { wealth[i] = sc.nextInt(); family[i] = wealth[i]; } for (int i = 0; i \u0026lt; n - 1; i++) { int fa = sc.nextInt(); int ch = sc.nextInt(); family[fa] += wealth[ch]; } System.out.println(Arrays.stream(family).max().orElse(0)); } 21. 最长的指定瑕疵度的元音子串\r#\r描述\n如果一个字符串的开头和结尾都是元音字母（a、e、i、o、u、A、E、I、O、U），那么它就被称为元音字符串。 元音字符串中非元音字母的数量定义为该字符串的瑕疵度 现在，给定一个字符串和一个目标瑕疵度，请你找出具有指定瑕疵度的最长元音子串，并输出其长度。如果不存在则输出0 注意：字符串中任意连续的字符组成的子序列称为该字符串的子串。 a 和 aa 都是元音字符串，它们的瑕疵度为 0。 aiur 不是元音字符串，因为它的结尾不是元音字母。 abira 是一个元音字符串，它的瑕疵度为2 输入描述： 第一行包含一个整数flaw，表示目标瑕疵度，满足0≤flaw≤65535。 第二行包含一个字符串str，仅由小写字母和大写字母组成，满足1≤str≤65535。 输出描述： 输出一个整数，表示满足条件的最长元音子串的长度。如果不存在满足条件的元音子串，则输出0 输入：0 asdbuiodevauufgh 输出：3 题解\nprivate static final char[] YAUN = {\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;U\u0026#39;}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); char[] chars = sc.nextLine().toCharArray(); boolean[] arr = new boolean[chars.length]; for (int i = 0; i \u0026lt; chars.length; i++) { arr[i] = isYuan(chars[i]); } int maxLen = 0; for (int i = 0; i \u0026lt; arr.length; i++) { if (!arr[i]) { continue; } int sum = 0; for (int j = i + 1; j \u0026lt; arr.length; j++) { if (arr[j]) { if (sum == num) { maxLen = Math.max(maxLen, j - i + 1); } } else { sum++; } } } System.out.println(maxLen); } private static boolean isYuan(char ch) { for (char c : YAUN) { if (ch == c) { return true; } } return false; } 22. 最长子字符串的长度\r#\r描述\n给你一个字符串 s，首尾相连成一个环形，请你在环中找出 \u0026#39;o\u0026#39; 字符出现了偶数次最长子字符串的长度。 输入描述：输入是一个小写字母组成的字符串 输出描述：输出是一个整数 备注： 1 ≤ s.length ≤ 500000 s 只包含小写英文字母 输入：looxdolx 输出：7 说明：最长子字符串\u0026#34;oxdolxl\u0026#34;，由于是首尾连接一起的，所以最后一个\u0026#39;x\u0026#39;和开头的\u0026#39;l\u0026#39;是连接在一起的，此字符串包含2个\u0026#39;o\u0026#39; 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(getResult(sc.nextLine())); } public static int getResult(String s) { int n = s.length(); // s中\u0026#39;o\u0026#39;的个数 int zeroCount = 0; for (int i = 0; i \u0026lt; n; i++) { if (s.charAt(i) == \u0026#39;o\u0026#39;) { zeroCount++; } } if (zeroCount % 2 == 0) { // 如果 \u0026#39;o\u0026#39; 为偶数个，则s本身就是一个含有偶数个\u0026#39;o\u0026#39;的子字符串，结果输出s.length return n; } else { // 如果 \u0026#39;o\u0026#39; 为奇数个，由于s是环形的，因此只要任选环中任意一个\u0026#39;o\u0026#39;解开（删除）， // 剩下的就是含有偶数个 \u0026#39;o\u0026#39; 的子串，该子串长度为 s.length - 1 return n - 1; } } 23. 堆内存申请\r#\r描述\n题解\n24.\r#\r描述\n题解\n25.\r#\r描述\n题解\n"},{"id":277,"href":"/algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%9311/","title":"机试题库 - 11","section":"华为OD","content":"\r01. 5G网络建设\r#\r描述\n现需要在某城市进行5G网络建设，已经选取N个地点设置5G基站，编号固定为1到N，接下来需要各个基站之间使用光纤进行连接以确保基站能互联互通，不同基站之间假设光纤的成本各不相同，且有些节点之间已经存在光纤相连。 请你设计算法，计算出能联通这些基站的最小成本是多少。 注意：基站的联通具有传递性，比如基站A与基站B架设了光纤，基站B与基站C也架设了光纤，则基站A与基站C视为可以互相联通。 输入描述： 第一行输入表示基站的个数N，其中：0 ＜ N ≤ 20 第二行输入表示具备光纤直连条件的基站对的数目M，其中：0 ＜ M ＜ N * (N - 1) / 2 从第三行开始连续输入M行数据，格式为X Y Z P，其中： X，Y 表示基站的编号，0 ＜ X ≤ N，0 ＜ Y ≤ N，X ≠ Y， Z 表示在 X、Y之间架设光纤的成本，0 ＜ Z ＜ 100 P 表示是否已存在光纤连接，0 表示未连接，1表示已连接 输出描述： 如果给定条件，可以建设成功互联互通的5G网络，则输出最小的建设成本 如果给定条件，无法建设成功互联互通的5G网络，则输出 -1 输入：3 3 1 2 3 0 1 3 1 0 2 3 5 0 输出：4 说明：只需要在1，2以及1，3基站之间铺设光纤，其成本为3+1=4 题解\n// 边 static class Edge { int from; // 边起点 int to; // 边终点 int weight; // 边权重 public Edge(int from, int to, int weight) { this.from = from; this.to = to; this.weight = weight; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); // 基站数量（节点数） int m = sc.nextInt(); // 基站对数量（边数） Edge[] edges = new Edge[m]; for (int i = 0; i \u0026lt; m; i++) { int x = sc.nextInt(); int y = sc.nextInt(); int z = sc.nextInt(); int p = sc.nextInt(); // 如果p==1，则可以认为x-y边权为0 edges[i] = new Edge(x, y, p == 0 ? z : 0); } System.out.println(kruskal(edges, n)); } public static int kruskal(Edge[] edges, int n) { int minWeight = 0; // 按照边权升序 Arrays.sort(edges, (a, b) -\u0026gt; a.weight - b.weight); UnionFindSet ufs = new UnionFindSet(n + 1); // 最先遍历出来是边权最小的边 for (Edge edge : edges) { // 如果edge.from节点 和 edge.to节点 是同一个连通分量（即都在最小生成树中），则此时会产生环 // 因此只有当edge.from节点 和 edge.to节点不在同一个连通分量时，才能合并（纳入最小生成树） if (ufs.find(edge.from) != ufs.find(edge.to)) { minWeight += edge.weight; ufs.union(edge.from, edge.to); // 需要注意的是，上面初始化并查集的节点数为n+1个，因此并查集底层fa数组的长度就是n+1， // 即索引范围是[0, n]，左闭右闭，其中0索引是无用的，1~n索引对应最小生成树中各个节点， // 如果者n个节点可以变为最小生成树，那么1~n节点会被合并为一个连通分量，而0索引虽然无用， // 但是也会自己形成一个连通分量，因此最终如果能形成最小生成树，则并查集中会有两个连通分量 if (ufs.count == 2) { return minWeight; } } } return -1; } // 并查集 static class UnionFindSet { int[] fa; int count; public UnionFindSet(int n) { this.fa = new int[n]; this.count = n; for (int i = 0; i \u0026lt; n; i++) this.fa[i] = i; } public int find(int x) { if (x != this.fa[x]) { return (this.fa[x] = this.find(this.fa[x])); } return x; } public void union(int x, int y) { int x_fa = this.find(x); int y_fa = this.find(y); if (x_fa != y_fa) { this.fa[y_fa] = x_fa; this.count--; } } } 02. N进制减法\r#\r描述\n主管期望你实现一个基于字符串的N进制的减法。 需要对输入的两个字符串按照给定的N进制进行减法操作，输出正负符号和表示结果的字符串。 输入描述： 第一个参数是整数形式的进制N值，N值范围为大于等于2、小于等于35。 第二个参数为被减数字符串； 第三个参数为减数字符串。 有效的字符包括0-9以及小写字母a-z，字符串有效字符个数最大为100个字符，另外还有结尾的\\0。 限制： 输入的被减数和减数，除了单独的0以外，不能是以0开头的字符串。 如果输入有异常或计算过程中有异常，此时应当输出-1表示错误。 输出描述：输出有2个。 其一为减法计算的结果，-1表示出错，0表示结果为整数，1表示结果为负数。 其二为表示结果的字符串。 输入：8 07 1 输出：-1 说明：按8进制，检查到减数不符合非0前导的要求，返回结果为-1，没有其他结果内容。 输入：2 11 1 输出：0 10 说明：按二进制计算 11 -1 ，计算正常，0表示符号为正数，结果为10 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int n = Integer.parseInt(split[0]); String num = split[1]; String numSub = split[2]; System.out.println(getResult(n, num, numSub)); } public static String getResult(int n, String num, String numSub) { if (n \u0026lt; 2 || n \u0026gt; 35 || !isValid(num, n) || !isValid(numSub, n)) { return \u0026#34;-1\u0026#34;; } long numVal = Long.parseLong(num, n); long numSubVal = Long.parseLong(numSub, n); String diff = Long.toString(Math.abs(numVal - numSubVal), n); String sign = numVal \u0026gt;= numSubVal ? \u0026#34;0\u0026#34; : \u0026#34;1\u0026#34;; return sign + \u0026#34; \u0026#34; + diff; } public static boolean isValid(String str, int n) { // 含前导的0只有0值本身合法 if (str.startsWith(\u0026#34;0\u0026#34;)) { return \u0026#34;0\u0026#34;.equals(str); } // 被减数，减数只能包含字符0-9，a-z Pattern reg = Pattern.compile(\u0026#34;[^a-z0-9]\u0026#34;); if (reg.matcher(str).find()) { return false; } // 被减数，减数长度最多100 if (str.length() \u0026gt; 100) { return false; } // 被减数，减数的每位不能超过n for (int i = 0; i \u0026lt; str.length(); i++) { char c = str.charAt(i); if (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39; \u0026amp;\u0026amp; Integer.parseInt(c + \u0026#34;\u0026#34;) \u0026gt;= n) { return false; // 比如2进制数的每一位不能超过2 } if (c \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39; \u0026amp;\u0026amp; c - \u0026#39;a\u0026#39; + 10 \u0026gt;= n) { return false; // 比如16进制数每一位不能超过f } } return true; } 03. TLV解析\r#\r描述\n两端通过TLV格式的报文来通信，现在收到对端的一个TLV格式的消息包，要求生成匹配后的(tag, length, valueOffset)列表。 具体要求如下： (1)消息包中多组tag、length、value紧密排列，其中tag,length各占1字节(uint8_t) , value所占字节数等于length的值 (2)结果数组中tag值已知，需要填充每个tag对应数据的length和valueOffset值 (valueOffset为value在原消息包中的起始偏移量（从0开始，以字节为单位))，即将消息包中的tag与结果数组中的tag进行匹配 （可能存在匹配失败的情况，若结果数组中的tag在消息包中找不到，则length和valueOffset都为0) (3)消息包和结果数组中的tag值都按升序排列，且不重复 (4)此消息包未被篡改，但尾部可能不完整，不完整的一组TLV请丢弃掉 输入描述： 第一行：一个字符串，代表收到的消息包。字符串长度在10000以内。 说明1：字符串使用十六进制文本格式（字母为大写）来展示消息包的数据，如0F04ABABABAB代表一组TLV： 前两个字符(0F）代表tag值为15，接下来两个字符（04）代表length值为4字节，接下来8个字符即为4字节的value。 说明2：输入字符串中，每一组TLV紧密排列，中间无空格等分隔符 第二行：需要匹配的tag数量n (0 ＜ n ＜1000) 。 后面n行：需要匹配的n个tag值（十进制表示)，递增排列。 输出描述： 和需要匹配的n个tag对应的n行匹配结果，每一行由长度和偏移量组成 输入：0F04ABABABAB 1 15 输出：4 2 说明：tag15(十六进制0F)对应数据的长度为4，其value从第三个字节开始，因此偏移量为2 输入：0F04ABABABAB1001FF 2 15 17 输出：4 2 0 0 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String msg = sc.next(); int n = sc.nextInt(); int[] tags = new int[n]; for (int i = 0; i \u0026lt; n; i++) { tags[i] = sc.nextInt(); } sc.close(); getResult(msg, tags); } public static void getResult(String msg, int[] tags) { HashMap\u0026lt;Integer, Integer[]\u0026gt; tagMap = new HashMap\u0026lt;\u0026gt;(); // 这里i+3的目的是确保tag，len的截取不会越界 for (int i = 0; i + 3 \u0026lt; msg.length(); i++) { int tag = Integer.parseInt(msg.substring(i, i + 2), 16); int len = Integer.parseInt(msg.substring(i + 2, i + 4), 16); // valueOffset以字节为单位，故要除以2 int valueOffset = (i + 5) / 2; // 本TLV格式报文段结束位置i i += 3 + len * 2; // 如果结束位置i越界，则当前TLV报文段是一个不完整的，需要丢弃 if (i \u0026gt;= msg.length()) break; // 题目已经保证tag不会重复 tagMap.put(tag, new Integer[]{len, valueOffset}); } for (int tag : tags) { if (tagMap.containsKey(tag)) { Integer[] tmp = tagMap.get(tag); int len = tmp[0]; int valueOffset = tmp[1]; System.out.println(len + \u0026#34; \u0026#34; + valueOffset); } else { System.out.println(\u0026#34;0 0\u0026#34;); } } } 04. Wonderland\r#\r描述\nWonderland是小王居住地一家很受欢迎的游乐园。 Wonderland目前有4种售票方式，分别为一日票（1天）、三日票（3天）、周票（7天）和月票（30天）。 每种售票方式的价格由一个数组给出，每种票据在票面时限内可以无限制地进行游玩。 小王计划在接下来一年多次游玩该游乐园。小王计划地游玩日期将由一个数组给出。 现在，请您根据给出地售票价格数组和小王计划游玩日期数组，返回游玩计划所需要地最低消费。 输入描述： 数组1：售票价格数组为costs，costs.length = 4，默认顺序为一日票、三日票、周票和月票。 数组2：小王计划游玩日期数组为days，1 ≤ days.length ≤ 365，1 ≤ days[i] ≤ 365，默认顺序为升序。 输出描述： 完成游玩计划的最低消费。 输入：5 14 30 100 1 3 5 20 21 200 202 230 输出：40 说明：根据售票价格数组和游玩日期数组给出的信息，发现每次去玩的时候买一张一日票是最省钱的， 所以小王会卖8张一日票，每张5元，最低花费是40元。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] costs = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int[] days = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); List\u0026lt;Integer\u0026gt; dayList = getDays(days); Cost[] costArr = getCosts(costs); System.out.println(getResult(costArr, dayList)); } private static int getResult(Cost[] costs, List\u0026lt;Integer\u0026gt; days) { for (int day : days) { minCost(costs, 0, day); } int sum = 0; for (Cost cost : costs) { sum += cost.totalCost; } return sum; } // 连续天数(len)内，先使用较便宜的票 public static void minCost(Cost[] costs, int index, int len) { if (index \u0026gt;= costs.length || len \u0026lt; 1) { return; } Cost cost = costs[index]; int size = len / cost.day; if (size \u0026gt; 0) { cost.totalCost += cost.cost * size; } if (len % cost.day != 0) { minCost(costs, index + 1, len % cost.day); } } // 处理成连续天的分段 public static List\u0026lt;Integer\u0026gt; getDays(int[] arr) { int[] tempArr = new int[366]; for (int i : arr) { tempArr[i] = 1; } String line = Arrays.stream(tempArr).mapToObj(String::valueOf).collect(Collectors.joining()); String[] dayStrArr = line.split(\u0026#34;0\u0026#34;); List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (String dayStr : dayStrArr) { if (dayStr.isBlank()) { continue; } list.add(dayStr.length()); } return list; } public static Cost[] getCosts(int[] arr) { Cost[] costs = new Cost[4]; costs[0] = new Cost(1, arr[0]); costs[1] = new Cost(3, arr[1]); costs[2] = new Cost(7, arr[2]); costs[3] = new Cost(30, arr[3]); Arrays.sort(costs, Comparator.comparingInt(a -\u0026gt; a.sort)); return costs; } public static class Cost { public int day; // 天数 public int cost; // 花费 public int sort; // 排序 public int totalCost; // 在递归中用于存储总花费 public Cost(int day, int cost) { this.day = day; this.cost = cost; this.sort = cost * 210 / day; } } 05. 比较两个版本号的大小\r#\r描述\n输入两个版本号 version1 和 version2，每个版本号由多个子版本号组成。 子版本号之间由 “.” 隔开，由大小写字母、数字组成，并且至少有一个字符。 按从左到右的顺序比较子版本号，比较规则如下： 1. 子版本号前面的0不参与比较，比如 001 和 1 是相等的。 2. 小写字母 \u0026gt; 大写字母 \u0026gt; 数字 3. 空字符和0相等，比如 1 和 1.0 相等 比较结果： 如果 version1 \u0026gt; version2 ，返回 1 如果 version1 ＜ version2 ，返回 -1 其他情况返回0 输入描述：第一行输入version1，第二行输入version2 输出描述：输出version1和version2的比较结果 输入：5.2 5.1a 输出：1 输入：5.6.1 5.6.2a 输出：-1 输入：5.6.8.a 5.6.8.0a 输出：0 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String v1 = sc.nextLine(); String v2 = sc.nextLine(); System.out.println(getResult(v1, v2)); } public static int getResult(String v1, String v2) { String[] arr1 = convert(v1); String[] arr2 = convert(v2); int n = Math.max(arr1.length, arr2.length); for (int i = 0; i \u0026lt; n; i++) { String tmp1 = arr1.length \u0026gt; i ? arr1[i] : \u0026#34;0\u0026#34;; String tmp2 = arr2.length \u0026gt; i ? arr2[i] : \u0026#34;0\u0026#34;; try { int i1 = Integer.parseInt(tmp1); int i2 = Integer.parseInt(tmp2); if (i1 != i2) return i1 \u0026gt; i2 ? 1 : -1; } catch (Exception e) { int res = tmp1.compareTo(tmp2); if (res != 0) return res \u0026gt; 0 ? 1 : -1; } } return 0; } public static String[] convert(String version) { return Arrays.stream(version.split(\u0026#34;\\\\.\u0026#34;)) .map(Main::replaceZero).toArray(String[]::new); } public static String replaceZero(String str) { // 去除前导0 String s = str.replaceAll(\u0026#34;^0+\u0026#34;, \u0026#34;\u0026#34;); // 如果是\u0026#34;0\u0026#34;，去除前导0后就变为了\u0026#34;\u0026#34;，需要做特殊处理 return s.isEmpty() ? \u0026#34;0\u0026#34; : s; } 06. 猜密码\r#\r描述\n小杨申请了一个保密柜，但是他忘记了密码。只记得密码都是数字，而且所有数字都是不重复的。 请你根据他记住的数字范围和密码的最小数字数量，帮他算下有哪些可能的组合，规则如下： 1. 输出的组合都是从可选的数字范围中选取的，且不能重复； 2. 输出的密码数字要按照从小到大的顺序排列，密码组合需要按照字母顺序，从小到大的顺序排序。 3. 输出的每一个组合的数字的数量要大于等于密码最小数字数量； 4. 如果可能的组合为空，则返回“None” 输入描述： 输入的第一行是可能的密码数字列表，数字间以半角逗号分隔 输入的第二行是密码最小数字数量 输出描述： 可能的密码组合，每种组合显示成一行，每个组合内部的数字以半角逗号分隔，从小到大的顺序排列。 出的组合间需要按照字典序排序。比如：2,3,4放到2,4的前面 输入：2,3,4 2 输出：2,3 2,3,4 2,4 3,4 题解\nstatic int[] nums; static int level; public static void main(String[] args) { Scanner sc = new Scanner(System.in); nums = Arrays.stream(sc.nextLine().split(\u0026#34;,\u0026#34;)).mapToInt(Integer::parseInt).toArray(); level = Integer.parseInt(sc.nextLine()); System.out.println(getResult()); } public static String getResult() { // 按照数值大小升序，这样后续形成的组合的内部就是按照数值大小升序的 Arrays.sort(nums); // 求不重复组合 ArrayList\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); dfs(0, new LinkedList\u0026lt;\u0026gt;(), res); if (!res.isEmpty()) { // 组合间按照字典序排序 res.sort(String::compareTo); return String.join(\u0026#34;\\n\u0026#34;, res); } else { return \u0026#34;None\u0026#34;; } } public static void dfs(int index, LinkedList\u0026lt;String\u0026gt; path, ArrayList\u0026lt;String\u0026gt; res) { if (path.size() \u0026gt;= level) { // 如果path层数到达level层，则记录该组合 res.add(String.join(\u0026#34;,\u0026#34;, path)); } for (int i = index; i \u0026lt; nums.length; i++) { // 树层去重 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; path.add(nums[i] + \u0026#34;\u0026#34;); dfs(i + 1, path, res); path.removeLast(); } } 07. 查找一个有向网络的头节点和尾节点\r#\r描述\n给定一个有向图，图中可能包含有环，图使用二维矩阵表示， 每一行的第一列表示起始节点，第二列表示终止节点，如 [0, 1] 表示从 0 到 1 的路径。 每个节点用正整数表示。 求这个数据的首节点与尾节点， 题目给的用例会是一个首节点，但可能存在多个尾节点。同时图中可能含有环。如果图中含有环，返回 [-1]。 说明：入度为0是首节点，出度为0是尾节点。 输入描述： 第一行为后续输入的键值对数量N（N ≥ 0） 第二行为2N个数字。每两个为一个起点，一个终点 输出描述： 输出一行头节点和尾节点。如果有多个尾节点，按从小到大的顺序输出。 备注： 如果图有环，输出为 -1 所有输入均合法，不会出现不配对的数据 输入：4 0 1 0 2 1 2 2 3 输出：0 3 题解\nstatic boolean hasO = false; public static class Ve { public int val; public List\u0026lt;Ve\u0026gt; subList; public Ve(int val) { this.val = val; this.subList = new ArrayList\u0026lt;\u0026gt;(); } public void addSub(Ve subVe) { this.subList.add(subVe); } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); int[] ints = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); Map\u0026lt;Integer, Ve\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); HashSet\u0026lt;Integer\u0026gt; preSet = new HashSet\u0026lt;\u0026gt;(); HashSet\u0026lt;Integer\u0026gt; subSet = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { int pre = ints[i * 2]; int sub = ints[i * 2 + 1]; preSet.add(pre); subSet.add(sub); map.putIfAbsent(pre, new Ve(pre)); map.putIfAbsent(sub, new Ve(sub)); Ve preVe = map.get(pre); Ve subVe = map.get(sub); preVe.addSub(subVe); } hasO =false; System.out.println(getResult(map, preSet, subSet)); } public static String getResult(Map\u0026lt;Integer, Ve\u0026gt; map, HashSet\u0026lt;Integer\u0026gt; preSet, HashSet\u0026lt;Integer\u0026gt; subSet) { // 有无环 for (int pre : preSet) { if (hasO) { break; } dp(pre, map.get(pre).subList); } if (hasO) { return \u0026#34;-1\u0026#34;; } int head = -1; for (int pre : preSet) { if (subSet.contains(pre)) { continue; } head = pre; break; } List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int sub : subSet) { if (!preSet.contains(sub)) { list.add(sub); } } String str = list.stream().sorted().map(String::valueOf).collect(Collectors.joining(\u0026#34; \u0026#34;)); return head + \u0026#34; \u0026#34; + str; } public static void dp(int value, List\u0026lt;Ve\u0026gt; subList) { if (hasO || subList.isEmpty()) { return; } for (Ve sub : subList) { if (value == sub.val) { hasO = true; return; } dp(value, sub.subList); } } 08. 出错的或电路\r#\r描述\n某生产门电路的厂商发现某一批次的或门电路不稳定，具体现象为计算两个二进制数的或操作时， 第一个二进制数中某两个比特位会出现交换，交换的比特位置是随机的，但只交换这两个位，其他位不变。 很明显，这个交换可能会影响最终的或结果，也可能不会有影响。 为了评估影响和定位出错的根因，工程师需要研究在各种交换的可能下，最终的或结果发生改变的情况有多少种。 输入描述： 第一行有一个正整数N; 其中1≤N≤1000000。 第二行有一个长为N的二进制数，表示与电路的第一个输入数，即会发生比特交换的输入数。 第三行有一个长为N的二进制数，表示与电路的第二个输入数。注意第二个输入数不会发生比特交换。 输出描述： 输出只有一个整数，表示会影响或结果的交换方案个数。 输入：6 011011 110110 输出：4 说明： 原本011011和110110的或结果是111111，但是第一个输入数发生如下比特交换会影响最终计算结果： 1、交换第1个比特和第3个比特，第一个输入数变为110011，计算结果变为110111 2、交换第1个比特和第6个比特，第一个输入数变为111010，计算结果变为111110 3、交换第3个比特和第4个比特，第一个输入数变为010111，计算结果变为110111 4、交换第4个比特和第6个比特，第一个输入数变为011110，计算结果变为111100 其他交换都不会影响计算结果，故输出4. 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); String bin1 = sc.next(); String bin2 = sc.next(); System.out.println(getResult(n, bin1, bin2)); } /** * @param n 二进制长度 * @param bin1 可能产生错误交换的二进制 * @param bin2 不会发生错误的二进制 * @return 产生错误结果的情况有几种 */ public static long getResult(int n, String bin1, String bin2) { // 找出bin2值为0的位，并统计对应位上bin1的值为0的有x个 long x = 0; // 找出bin2值为0的位，并统计对应位上bin1的值为1的有y个 long y = 0; // 统计bin1总共有多少个1 long a = 0; // 统计bin1总共有多少个0 long b = 0; for (int i = 0; i \u0026lt; n; i++) { if (bin1.charAt(i) == \u0026#39;0\u0026#39;) { b++; if (bin2.charAt(i) == \u0026#39;0\u0026#39;) x++; } else { a++; if (bin2.charAt(i) == \u0026#39;0\u0026#39;) y++; } } return x * a + y * b - x * y; } 09. 打印任务排序\r#\r描述\n某个打印机根据打印队列执行打印任务。 打印任务分为九个优先级，分别用数字1-9表示，数字越大优先级越高。打印机每次从队列头部取出第一个任务A， 然后检查队列余下任务中有没有比A优先级更高的任务，如果有比A优先级高的任务，则将任务A放到队列尾部，否则就执行任务A的打印。 请编写一个程序，根据输入的打印队列，输出实际的打印顺序。 输入描述：输入一行，为每个任务的优先级，优先级之间用逗号隔开，优先级取值范围是1~9。 输出描述：输出一行，为每个任务的打印顺序，打印顺序从0开始，用逗号隔开 输入：1,2,2 输出：2,0,1 说明：队列头部任务的优先级为1，被移到队列尾部；接着顺序打印两个优先级为2的任务，故其序号分别为0和1； 最后打印剩下的优先级为1的任务，其序号为2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34;,\u0026#34;); int[] nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(nums)); } public static String getResult(int[] nums) { int n = nums.length; LinkedList\u0026lt;int[]\u0026gt; link = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { link.add(new int[]{nums[i], i}); } Arrays.sort(nums); int printIdx = 0; int maxNumIdx = n - 1; int[] arr = new int[n]; while (!link.isEmpty()) { int[] head = link.removeFirst(); if (head[0] == nums[maxNumIdx]) { arr[head[1]] = printIdx; printIdx++; maxNumIdx--; } else { link.add(head); } } return Arrays.stream(arr).mapToObj(String::valueOf).collect(Collectors.joining(\u0026#34;,\u0026#34;)); } 10. 导师请吃火锅\r#\r描述\n火锅里会在不同时间下很多菜，不同食材要煮不同时间，才能变得刚好合适，你希望吃到最多的刚好合适的菜， 但是你的手速不够快用m代替手速，每次下手捞菜后至少要过m秒，才能再捞（每次只能捞一个） 那么用最合理的策略，最多能吃到多少，刚好合适的菜 输入描述： 第一行两个整数n、m，其中n代表往锅里下菜的个数，m代表手速 接下来有n行，每行有两个数x、y，代表第x秒下的菜过y秒才能变得刚好合适（1 ＜ mn ＜ 1000），（1 ＜ xy ＜ 1000） 输出描述： 输出一个整数代表用最合理的策略，最多能吃到刚好合适的菜的数量 输入：3 2 1 2 2 1 3 2 输出：2 往锅里下的菜的个数3，手速2； 第1秒的时候下入菜品1，2秒后熟了； 第2秒的时候下入菜品2，1秒后熟了； 第3秒的时候下入菜品3，2秒后熟了； 第一种菜品和第二种菜品只能吃到一种，第三种菜品可以吃到； 题解\n// 遍历每一种菜，若当前与上一次捞菜的时间差\u0026gt;=m，则当前可以进行捞菜 public static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int n = Integer.parseInt(split[0]); int m = Integer.parseInt(split[1]); int[] arr = new int[n]; for (int i = 0; i \u0026lt; n; i++) { String[] tmp = sc.nextLine().split(\u0026#34; \u0026#34;); // 每种菜刚好合适的时间点 arr[i] = Integer.parseInt(tmp[0]) + Integer.parseInt(tmp[1]); } Arrays.sort(arr); // 第1个合适的菜 int count = 1; int pre = 0; for (int i = 1; i \u0026lt; arr.length; i++) { if (arr[i] \u0026gt;= arr[pre] + m) { // 当前与上次捞菜的时间差大于等于m，则可以进行捞菜 count++; // 更新本次捞菜时间点 pre = i; } } System.out.println(count); } 11. 电脑病毒感染\r#\r描述\n一个局域网内有很多台电脑，分别标注为 1 ~ N 的数字。相连接的电脑距离不一样，所以感染时间不一样，感染时间用 t 表示。 其中网络内一台电脑被病毒感染，求其感染网络内所有的电脑最少需要多长时间。如果最后有电脑不会感染，则返回-1。 给定一个数组 times 表示一台电脑把相邻电脑感染所用的时间。 如：path[i] = {i, j, t} 表示：电脑 i-\u0026gt;j，电脑 i 上的病毒感染 j，需要时间 t。 输入：4 3 2 1 1 2 3 1 3 4 1 2 输出：2 说明： 第一个参数：局域网内电脑个数N，1 ≤ N ≤ 200； 第二个参数：总共多少条网络连接 第三个 2 1 1 表示2-\u0026gt;1时间为1 第六行：表示病毒最开始所在电脑号2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); List\u0026lt;Edge\u0026gt; edges = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; m; i++) { int a = sc.nextInt(); // 出发点 int b = sc.nextInt(); // 目标点 int c = sc.nextInt(); // 出发点到达目标点的耗时 edges.add(new Edge(a, b, c)); } // 最短路 long[] dist = new long[n + 1]; // 起始先将所有的点标记为「距离为正无穷」 Arrays.fill(dist, Integer.MAX_VALUE); // 源点 int src = sc.nextInt(); // 源点到达源点的耗时为0 dist[src] = 0; // 迭代 n 次 for (int i = 1; i \u0026lt;= n; i++) { long[] prev = dist.clone(); // 每次都使用上一次迭代的结果，执行松弛操作 for (Edge edge : edges) { int a = edge.a, b = edge.b, c = edge.c; dist[b] = Math.min(dist[b], prev[a] + c); } } // 遍历答案 long ans = 0; for (int i = 1; i \u0026lt;= n; i++) { ans = Math.max(ans, dist[i]); } System.out.println(ans == Integer.MAX_VALUE ? -1 : ans); } static class Edge { int a, b, c; Edge(int a, int b, int c) { this.a = a; this.b = b; this.c = c; } } 12. 叠积木\r#\r描述\n有一堆长方体积木，它们的宽度和高度都相同，但长度不一。 小橙想把这堆积木叠成一面墙，墙的每层可以放一个积木，也可以将两个积木拼接起来，要求每层的长度相同。 若必须用完这些积木，叠成的墙最多为多少层？ 输入描述：输入为一行，为各个积木的长度，数字为正整数，并由空格分隔。积木的数量和长度都不超过5000。 输出描述：输出一个数字，为墙的最大层数，如果无法按要求叠成每层长度一致的墙，则输出-1。 输入：3 6 6 3 输出：3 输入：1 4 2 3 6 输出：-1 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); Integer[] nums = Arrays.stream(split).map(Integer::parseInt).toArray(Integer[]::new); System.out.println(getResult(nums)); } public static int getResult(Integer[] nums) { int n = nums.length; // 如果只有一个积木，那么只能是一层高度 if (n == 1) { return 1; } // 如果有两个积木 if (n == 2) { // 如果两个积木长度相同，则最大高度为2 // 如果两个积木长度不同，则最大高度为1 return nums[0] - nums[1] != 0 ? 1 : 2; } // 积木按长度降序 Arrays.sort(nums, (a, b) -\u0026gt; b - a); // 一层的最小长度，即最长的积木的长度 int minLen = nums[0]; // 一层的最大长度 int maxLen = nums[0] + nums[nums.length - 1]; // 尝试minLen和maxLen中每一个值作为一层长度 for (int len = minLen; len \u0026lt;= maxLen; len++) { // 对应一层长度限制下的最大高度 int height = 0; // 通过l,r指针去选择组成一层的一个或两个积木 int l = 0; // l指针指向最大长度的积木 int r = n - 1; // r指针指向最小长度的积木 // 如果最大长度的积木，可以独立一层，则l++，height++ while (l \u0026lt; n \u0026amp;\u0026amp; nums[l] == len) { l++; height++; } // 如果 l,r积木无法组成一层 // 假设nums[l] + nums[r] \u0026gt; len，则必然nums[l] + nums[r-1] \u0026gt; len， // 因为nums已降序，nums[r-1] \u0026gt;= nums[r]，即必然l积木无法和其他积木组成一层 // 假设nums[l] + nums[r] \u0026lt; len，则必然nums[l+1] + nums[r] \u0026lt; len， // 因为nums已降序，nums[l+1] \u0026lt;= nums[l]，即必然r积木无法和其他积木组成一层 while (l \u0026lt; r) { if (nums[l] + nums[r] != len) break; l++; r--; height++; } // 如果正常结束，则必然l \u0026gt; r，否则就是异常结束 if (l \u0026lt;= r) continue; return height; } return -1; } 13. 二叉树的广度优先遍历\r#\r描述\n有一棵二叉树，每个节点由一个大写字母标识(最多26个节点）。 现有两组字母，分别表示后序遍历（左孩子-\u0026gt;右孩子-\u0026gt;父节点）和中序遍历（左孩子-\u0026gt;父节点-\u0026gt;右孩子）的结果， 请你输出层序遍历的结果。 输入描述： 每个输入文件一行，第一个字符串表示后序遍历结果，第二个字符串表示中序遍历结果。（每串只包含大写字母） 中间用单空格分隔。 输出描述： 输出仅一行，表示前序遍历的结果，结尾换行。 输入：CBEFDA CBAEDF 输出：ABDCEF 题解\npublic static class TreeNode { char val; TreeNode left; TreeNode right; TreeNode(char val) { this.val = val; } } public static void preOrder(StringBuilder sb, TreeNode node) { if (node == null) { return; } sb.append(node.val); preOrder(sb, node.left); preOrder(sb, node.right); } private static TreeNode build(String postOrder, String midOrder) { if (postOrder.isEmpty()) { return null; } char midVal = postOrder.charAt(postOrder.length() - 1); TreeNode root = new TreeNode(midVal); if (postOrder.length() == 1) { return root; } int midIndex = midOrder.indexOf(midVal); String postLeft = postOrder.substring(0, midIndex); String postRight = postOrder.substring(midIndex, postOrder.length() - 1); String midLeft = midOrder.substring(0, midIndex); String midRight = midOrder.substring(midIndex + 1); root.left = build(postLeft, midLeft); root.right = build(postRight, midRight); return root; } public static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); String postOrder = split[0]; String midOrder = split[1]; TreeNode root = build(postOrder, midOrder); StringBuilder sb = new StringBuilder(); preOrder(sb, root); System.out.println(sb); } 14. 二叉树计算\r#\r描述\n如图，给出一个二叉树， 由该二叉树生成一个新的二叉树，它满足其树中的每个节点将包含原始树中的左子树和右子树的和。 输入描述：2行整数，第1行表示二叉树的中序遍历，第2行表示二叉树的前序遍历，以空格分割 输出描述：1行整数，表示求和树的中序遍历，以空格分割 输入：-3 12 6 8 9 -10 -7 8 12 -3 6 -10 9 -7 输出：0 3 0 7 0 2 0 题解\npublic static class TreeNode { int num; // 当前节点的值 int sum; // 当前节点的左子树+右子树的和 TreeNode left; TreeNode right; public TreeNode(int num) { this.num = num; this.sum = 0; } public int sumChild() { if (this.left == null \u0026amp;\u0026amp; this.right == null) { this.sum = 0; return 0; } int sumL = 0; if (this.left != null) { sumL = left.sumChild() + left.num; } int sumR = 0; if (this.right != null) { sumR = right.sumChild() + right.num; ; } this.sum = sumL + sumR; return sum; } } public static void midOrder(StringBuilder sb, TreeNode node) { if (node == null) { return; } midOrder(sb, node.left); sb.append(node.sum).append(\u0026#34; \u0026#34;); midOrder(sb, node.right); } private static TreeNode build(String preOrder, String midOrder) { if (preOrder.isEmpty()) { return null; } String[] preArr = preOrder.split(\u0026#34; \u0026#34;); String[] midArr = midOrder.split(\u0026#34; \u0026#34;); String midVal = preArr[0]; TreeNode root = new TreeNode(Integer.parseInt(midVal)); if (preOrder.length() == 1) { return root; } List\u0026lt;Integer\u0026gt; idxList = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; midArr.length; i++) { if (midArr[i].equals(midVal)) { idxList.add(i); } } int midIndex = -1; for (int idx : idxList) { if (isTrueRoot(preArr, midArr, idx)) { midIndex = idx; break; } } String[] preLeft = Arrays.copyOfRange(preArr, 1, midIndex + 1); String[] minLeft = Arrays.copyOfRange(midArr, 0, midIndex); String[] preRight = Arrays.copyOfRange(preArr, midIndex + 1, preArr.length); String[] minRight = Arrays.copyOfRange(midArr, midIndex + 1, midArr.length); root.left = build(String.join(\u0026#34; \u0026#34;, preLeft), String.join(\u0026#34; \u0026#34;, minLeft)); root.right = build(String.join(\u0026#34; \u0026#34;, preRight), String.join(\u0026#34; \u0026#34;, minRight)); return root; } public static boolean isTrueRoot(String[] preArr, String[] midArr, int idx) { String[] preLeft = Arrays.copyOfRange(preArr, 1, idx + 1); String[] minLeft = Arrays.copyOfRange(midArr, 0, idx); String preLeftStr = Arrays.stream(preLeft).sorted().collect(Collectors.joining(\u0026#34; \u0026#34;)); String minLeftStr = Arrays.stream(minLeft).sorted().collect(Collectors.joining(\u0026#34; \u0026#34;)); if (!preLeftStr.equals(minLeftStr)) { return false; } String[] preRight = Arrays.copyOfRange(preArr, idx + 1, preArr.length); String[] minRight = Arrays.copyOfRange(midArr, idx + 1, midArr.length); String preRightStr = Arrays.stream(preRight).sorted().collect(Collectors.joining(\u0026#34; \u0026#34;)); String minRightStr = Arrays.stream(minRight).sorted().collect(Collectors.joining(\u0026#34; \u0026#34;)); if (!preRightStr.equals(minRightStr)) { return false; } return true; } public static void main(String[] args) { Scanner sc = new Scanner(System.in); String minOrder = sc.nextLine(); String preOrder = sc.nextLine(); TreeNode root = build(preOrder, minOrder); root.sumChild(); StringBuilder sb = new StringBuilder(); midOrder(sb, root); System.out.println(sb); } 15. 发广播\r#\r描述\n某地有N个广播站，站点之间有些有连接，有些没有。有连接的站点在接受到广播后会互相发送。 给定一个N*N的二维数组matrix,数组的元素都是字符’0’或者’1’。 matrix[i][j] = ‘1’, 代表i和j站点之间有连接，matrix[i][j] = ‘0’, 代表没连接， 现在要发一条广播，问初始最少给几个广播站发送，才能保证所有的广播站都收到消息。 输入描述：从stdin输入，共一行数据，表示二维数组的各行，用逗号分隔行。保证每行字符串所含的字符数一样的。 输出描述：返回初始最少需要发送广播站个数 输入：110,110,001 输出：2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] matrix = sc.nextLine().split(\u0026#34;,\u0026#34;); System.out.println(getResult(matrix)); } public static int getResult(String[] matrix) { int n = matrix.length; UnionFindSet ufs = new UnionFindSet(n); for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { if (matrix[i].charAt(j) == \u0026#39;1\u0026#39;) { ufs.union(i, j); } } } return ufs.count; } // 并查集实现 static class UnionFindSet { int[] fa; int count; public UnionFindSet(int n) { this.fa = new int[n]; for (int i = 0; i \u0026lt; n; i++) fa[i] = i; this.count = n; } public int find(int x) { if (x != this.fa[x]) { this.fa[x] = this.find(this.fa[x]); return this.fa[x]; } return x; } public void union(int x, int y) { int x_fa = this.find(x); int y_fa = this.find(y); if (x_fa != y_fa) { this.fa[y_fa] = x_fa; this.count--; } } } 16. 伐木工\r#\r描述\n一根X米长的树木，伐木工切割成不同长度的木材后进行交易，交易价格为每根木头长度的乘积。规定切割后的每根木头长度都为正整数；也可以不切割，直接拿整根树木进行交易。 请问伐木工如何尽量少的切割，才能使收益最大化？ 输入描述：木材的长度（X ≤ 50） 输出描述：输出最优收益时的各个树木长度，以空格分隔，按升序排列 输入：10 输出：3 3 4 题解\nstatic class Wood { // 记录木材的最大收益 int profit; // 记录木材最大收益时对应的切割状态 ArrayList\u0026lt;Integer\u0026gt; slices = new ArrayList\u0026lt;\u0026gt;(); } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int x = sc.nextInt(); Wood[] dp = new Wood[x + 1]; for (int i = 0; i \u0026lt;= x; i++) { // 初始时，将木材不切割的收益作为最大收益 dp[i] = new Wood(); dp[i].profit = i; dp[i].slices.add(i); } // 从长度为2的木材开始尝试切割 for (int i = 2; i \u0026lt;= x; i++) { for (int j = 1; j \u0026lt; i; j++) { int profit = dp[j].profit * dp[i - j].profit; // 如果该切割方案的收益更大， // 或者收益和之前切割方案的收益相同，但是切割数更少，则使用当前切割方案 if (profit \u0026gt; dp[i].profit || (profit == dp[i].profit \u0026amp;\u0026amp; dp[i].slices.size() \u0026gt; dp[j].slices.size() + dp[i - j].slices.size())) { dp[i].profit = profit; dp[i].slices.clear(); dp[i].slices.addAll(dp[j].slices); dp[i].slices.addAll(dp[i - j].slices); } } } // dp[x].slices记录的是：长度x的木材对应的最大收益的切割方案 // 按题目输出描述要求进行升序 dp[x].slices.sort((a, b) -\u0026gt; a - b); // 打印切割方案 StringJoiner sj = new StringJoiner(\u0026#34; \u0026#34;); for (int slice : dp[x].slices) { sj.add(slice + \u0026#34;\u0026#34;); } System.out.println(sj); } 17. 反射计数\r#\r描述\n给定一个包含 0 和 1 的二维矩阵。 给定一个初始位置和速度，一个物体从给定的初始位置出发，在给定的速度下进行移动，遇到矩阵的边缘则发生镜面发射。 无论物体经过 0 还是 1，都不影响其速度。 请计算并给出经过 t 时间单位后，物体经过 1 点的次数。 矩阵以左上角位置为 [0, 0]（列(x)，行(y)），例如下面A点坐标为 [2, 1]（第二列，第一行） 注意： 如果初始位置的点是 1，也计算在内 时间的最小单位为 1，不考虑小于 1 个时间单位内经过的点 输入描述： 第一行为初始信息\u0026lt;w\u0026gt;\u0026lt;h\u0026gt;\u0026lt;x\u0026gt;\u0026lt;y\u0026gt;\u0026lt;sx\u0026gt;\u0026lt;sy\u0026gt;\u0026lt;t\u0026gt; 第二行开始一共 h 行，为二维矩阵信息 其中： w，h 为矩阵的宽和高，0 ＜ w ＜ 100，0 ＜ h ＜ 100 x，y 为起始位置，0 ≤ x ＜ w，0 ≤ y ＜ h sx，sy 为初始速度，-1 ≤ sx ≤ 1，-1 ≤ sy ≤ 1 t 为经过的时间，0 ≤ t ＜100 输出描述： 经过 1 的个数，注意初始位置也要计算在内 输入：12 7 2 1 1 -1 13 001000010000 001000010000 001000010000 001000010000 001000010000 001000010000 001000010000 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int w = sc.nextInt(); int h = sc.nextInt(); int x = sc.nextInt(); int y = sc.nextInt(); int sx = sc.nextInt(); int sy = sc.nextInt(); int t = sc.nextInt(); char[][] matrix = new char[h][w]; for (int i = 0; i \u0026lt; h; i++) { matrix[i] = sc.next().toCharArray(); } int ans = 0; while (t \u0026gt;= 0) { // 注意本题横纵坐标是反的，因此y其实是行号，x是列号 if (matrix[y][x] == \u0026#39;1\u0026#39;) { ans++; } y += sy; x += sx; if (x \u0026lt; 0) { x = 1; sx = -sx; } else if (x \u0026gt;= w) { // 注意本题横纵坐标是反的，因此x是列号，w是矩阵列数 x = w - 2; sx = -sx; } if (y \u0026lt; 0) { y = 1; sy = -sy; } else if (y \u0026gt;= h) { // 注意本题横纵坐标是反的，因此y是行号，h是矩阵行数 y = h - 2; sy = -sy; } t--; } System.out.println(ans); } 18. 分月饼\r#\r描述\n中秋节，公司要给员工分月饼。公司有m个员工，买了n个月饼，且m≤n。每个员工至少分到 1 个月饼，但可以分多个。 要求： 单人分到最多的月饼个数为Max1，单人分到第二多的月饼个数为Max2，需要满足Max1−Max2≤3。 单人分到倒数第二多的月饼个数为Max(n−1)，单人分到最少的月饼个数为Max(n)，需要满足Max(n−1)−Max(n)≤3。 问有多少种分月饼的方法？ 输入描述：第一行输入两个整数m和n，表示m个员工和n个月饼，m≤n。 输出描述：输出有多少种分月饼的方法。 输入：3 12 输出：6 题解\nstatic int m; static int n; static int maxDiff = 3; static int ans = 0; public static void main(String[] args) { Scanner sc = new Scanner(System.in); m = sc.nextInt(); n = sc.nextInt(); // 如果只有一个员工分月饼，那么就只有一种方案 if (m == 1) { System.out.println(1); return; } // 如果有多个员工分月饼， // 为了保证分月饼的方案不重复，我们这里保证 员工i的月饼数量 \u0026lt;= 员工i+1的月饼数量 // 因此对于第0个员工，至少分得1个月饼，至多分得n/m个月饼（均分数量） recursive(0, 1, n / m, n); System.out.println(ans); } /** * @param level 第几个员工 * @param min 当前员工至少分得几个月饼 * @param max 当前员工至多分得几个月饼 * @param remain 分月饼给当前员工前，月饼的剩余数量 */ public static void recursive(int level, int min, int max, int remain) { if (level == m - 1) { // 分到最后一个员工时，我们应该将剩余月饼都给他 // 因此最后一个员工的月饼数量就是remain， // 而倒数第二个员工的月饼数量是min（本轮递归的min参数，即上一轮员工分得的月饼数量） // 如果二者差距不超过maxDiff，则分月饼方案可行 if (remain - min \u0026lt;= maxDiff) { ans++; } return; } // i 是当前员工可以分得的月饼数量 for (int i = min; i \u0026lt;= max; i++) { // 下一个员工至少分得 i 个月饼（当前员工分得的月饼数量），至多分得 i + maxDiff // 同时下一个员工分得的月饼数量不能超过：均分月饼数量（即剩余月饼总数 / 剩余员工总数）， // 否则破坏去重策略（为了保证分月饼的方案不重复，我们这里保证后面的员工分得月饼数不小于前面员工） remain -= i; recursive(level + 1, i, Math.min(i + maxDiff, remain / (m - level - 1)), remain); remain += i; } } 19. 符号运算\r#\r描述\n给定一个表达式，求其分数计算结果。用例输入一定合法，不会出现括号匹配的情况 表达式的限制如下： 1. 所有的输入数字皆为正整数（包括0） 2. 仅支持四则运算（+-*/）和括号 3. 结果为整数或分数，分数必须化为最简格式（比如6，3/4，7/8，90/7） 4. 除数可能为0，如果遇到这种情况，直接输出\u0026#34;ERROR\u0026#34; 5. 输入和最终计算结果中的数字都不会超出整型范围 输入描述： 字符串格式的表达式，仅支持+-*/，数字可能超过两位，可能带有空格，没有负数 长度小于200个字符 输出描述： 表达式结果，以最简格式表达 1. 如果结果为整数，那么直接输出整数 2. 如果结果为负数，那么分子分母不可再约分，可以为假分数，不可表达为带分数 3. 结果可能是负数，符号放在前面 输入：1 + 5 * 7 / 8 输出：43/8 输入：1 / (0 - 5) 输出：-1/5 说明：符号需要提到最前面 输入：1 * (3*4/(8-(7+0))) 输出：12 说明：注意括号可以多重嵌套 题解\n// 分数 static class Fractions { int fa; // 分母 int ch; // 分子 public Fractions() { } public Fractions(int fa, int ch) { this.fa = fa; this.ch = ch; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(getResult(sc.nextLine())); } // 操作数栈 static LinkedList\u0026lt;Fractions\u0026gt; numStack = new LinkedList\u0026lt;\u0026gt;(); // 操作符栈 static LinkedList\u0026lt;Character\u0026gt; signStack = new LinkedList\u0026lt;\u0026gt;(); public static String getResult(String s) { // +,-,*,/ 运算符优先级 HashMap\u0026lt;Character, Integer\u0026gt; priority = new HashMap\u0026lt;\u0026gt;(); priority.put(\u0026#39;+\u0026#39;, 1); priority.put(\u0026#39;-\u0026#39;, 1); priority.put(\u0026#39;*\u0026#39;, 2); priority.put(\u0026#39;/\u0026#39;, 2); // 操作数的字符缓存容器 StringBuilder numStr = new StringBuilder(); int i = 0; while (i \u0026lt; s.length()) { char c = s.charAt(i); // 遇到数字字符 if (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) { // 则将该数字所在操作数的剩余数字字符一次性探索完 while (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) { numStr.append(c); if (i + 1 \u0026gt;= s.length()) break; i++; c = s.charAt(i); } // 探索完后，将操作数缓存容器中记录的字符，变为分数后，压入操作数栈 numStack.addLast(new Fractions(1, Integer.parseInt(numStr.toString()))); // 注意清空操作数缓存容器 numStr = new StringBuilder(); } // 遇到运算符 if (c == \u0026#39;+\u0026#39; || c == \u0026#39;-\u0026#39; || c == \u0026#39;*\u0026#39; || c == \u0026#39;/\u0026#39;) { // 只要栈顶运算符的优先级 \u0026gt;= 当前运算符，就需要不停出栈运算 while (!signStack.isEmpty() \u0026amp;\u0026amp; signStack.getLast() != \u0026#39;(\u0026#39; \u0026amp;\u0026amp; priority.get(c) \u0026lt;= priority.get(signStack.getLast())) { calc(); } signStack.addLast(c); } else if (c == \u0026#39;)\u0026#39;) { // 遇到\u0026#39;)\u0026#39;, 需要将操作符栈中靠近栈顶的\u0026#39;(\u0026#39;后面的运算都出栈做了 while (signStack.getLast() != \u0026#39;(\u0026#39;) { calc(); } // 最后将\u0026#39;)\u0026#39;对应的\u0026#39;(\u0026#39;出栈 signStack.removeLast(); } else if (c == \u0026#39;(\u0026#39;) { // 遇到\u0026#39;(\u0026#39;，则直接压到操作符栈 signStack.add(c); } i++; } // numStack栈中还有2个以上的数，则还需要进行运算 while (numStack.size() \u0026gt; 1) { calc(); } // numStack栈中只剩一个数时，该数就是表达式结果 Fractions result = numStack.removeLast(); // 如果结果的分母为0（除数为0），则不合法 if (result.fa == 0) { return \u0026#34;ERROR\u0026#34;; } // 求分子、分母的最大公约数，并进行约份，求得最简格式的分子，分母 int k = getMaxCommonDivisor(result.fa, result.ch); result.fa /= k; result.ch /= k; // 求计算结果的符号，这里用乘法是为了避免 分母小，分子大，除法结果为0的情况，这样会丢失符号信息 String sign = result.fa * result.ch \u0026lt; 0 ? \u0026#34;-\u0026#34; : \u0026#34;\u0026#34;; int fa = Math.abs(result.fa); int ch = Math.abs(result.ch); if (fa == 1) { // 如果分母为1，则直接输出分子 return sign + ch; } else { // 如果分母不为1，则输出 分子 / 分母 return sign + ch + \u0026#34;/\u0026#34; + fa; } } // 取出numStack栈顶两个操作数进行运算 public static void calc() { // 操作数顺序会对运算产生影响 Fractions b = numStack.removeLast(); // 栈顶元素是运算符右边的操作数 Fractions a = numStack.removeLast(); // 栈顶倒数第二个元素是运算符左边的操作数 // 运算符 char op = signStack.removeLast(); // 记录运算结果 Fractions result = new Fractions(); switch (op) { case \u0026#39;+\u0026#39;: result.fa = a.fa * b.fa; result.ch = a.ch * b.fa + b.ch * a.fa; break; case \u0026#39;-\u0026#39;: result.fa = a.fa * b.fa; result.ch = a.ch * b.fa - b.ch * a.fa; break; case \u0026#39;*\u0026#39;: result.fa = a.fa * b.fa; result.ch = a.ch * b.ch; break; case \u0026#39;/\u0026#39;: result.fa = a.fa * b.ch; result.ch = a.ch * b.fa; break; } numStack.add(result); } // 辗转相除法，求两个数的最大公约数 public static int getMaxCommonDivisor(int x, int y) { while (y != 0) { int tmp = y; y = x % y; x = tmp; } return x; } 20. 高效的任务规划\r#\r描述\n你有 n 台机器编号为 1~n，每台都需要完成完成一项工作，机器经过配置后都能完成独立完成一项工作。 假设第 i 台机器你需要花 B 分钟进行设置，然后开始运行，J 分钟后完成任务。 现在，你需要选择布置工作的顺序，使得用最短的时间完成所有工作。 注意，不能同时对两台进行配置，但配置完成的机器们可以同时执行他们各自的工作。 输入描述： 第一行输入代表总共有 M 组任务数据（1＜M≤10）。 每组数第一行为一个整数指定机器的数量 N（0＜N≤1000）。 随后的 N 行每行两个整数，第一个表示 B（0≤B≤10000），第二个表示 J（0≤J≤10000）。 每组数据连续输入，不会用空行分隔。各组任务单独计时。 输出描述： 对于每组任务，输出最短完成时间，且每组的结果独占一行。例如，两组任务就应该有两行输出。 输入：2 2 1 1 2 2 3 1 1 2 2 3 3 输出：4 7 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); for (int i = 0; i \u0026lt; m; i++) { int n = sc.nextInt(); int[][] tasks = new int[n][2]; for (int j = 0; j \u0026lt; n; j++) { tasks[j][0] = sc.nextInt(); tasks[j][1] = sc.nextInt(); } getResult(tasks); } } public static void getResult(int[][] tasks) { // 将每个任务中的机器工作顺序，按照运行时间降序排序 Arrays.sort(tasks, (a, b) -\u0026gt; b[1] - a[1]); int configEndTime = 0; int ans = 0; for (int[] task : tasks) { int configCost = task[0]; int runCost = task[1]; configEndTime += configCost; ans = Math.max(ans, configEndTime + runCost); } System.out.println(ans); } 21. 高效货运\r#\r描述\n老李是货运公司承运人，老李的货车额定载货重量为 wt。现有两种货物： 货物 A 单件重量为 wa，单件运费利润为 pa 货物 B 单件重量为 wb，单件运费利润为 pb 老李每次发车时载货总重量刚好为货车额定的载货重量 wt，车上必须同时有货物 A 和货物 B ，货物A、B不可切割。 老李单次满载运输可获得的最高利润是多少？ 输入描述： 第一列输入为货物 A 的单件重量 wa，0 ＜ wa ＜ 10000 第二列输入为货物 B 的单件重量 wb，0 ＜ wb ＜ 10000 第三列输入为货车的额定载重 wt， 0 ＜ wt ＜ 100000 第四列输入为货物 A 的单件运费利润 pa，0 ＜ pa ＜ 1000 第五列输入为货物 B 的单件运费利润 pb，0 ＜ pb ＜ 1000 输出描述： 单次满载运输的最高利润 输入：10 8 36 15 7 输出：44 输入：1 1 2 1 1 输出：2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int wa = sc.nextInt(); int wb = sc.nextInt(); int wt = sc.nextInt(); int pa = sc.nextInt(); int pb = sc.nextInt(); // 装入货车的A货物数量至少1件，至多(wt - wb) / wa件 int minX = 1; int maxX = (wt - wb) / wa; // 记录最大利润 int ans = 0; // 枚举A货物的可能数量 for (int x = minX; x \u0026lt;= maxX; x++) { // B货物可能的总重量 int remain = wt - wa * x; if (remain % wb == 0) { // B货物的数量 int y = remain / wb; // 计算利润，保留最大利润 ans = Math.max(ans, pa * x + pb * y); } } System.out.println(ans); } 22. 根据IP查找城市\r#\r描述\n某业务需要根据终端的IP地址获取该终端归属的城市，可以根据公开的IP地址池信息查询归属城市。 地址池格式：城市名=起始IP,结束IP 起始和结束地址用英文逗号分隔，多个地址段采用英文分号分隔。如： City1=1.1.1.1,1.1.1.2;City1=1.1.1.11,1.1.1.16;City2=3.3.3.3,4.4.4.4;City3=2.2.2.2,6.6.6.6 一个城市可以有多个IP段，比如City1有2个IP段。 城市间也可能存在包含关系，如City3的IP段包含City2的IP段范围。 现在要根据输入的IP列表，返回最佳匹配的城市列表。 注：最佳匹配即包含待查询IP且长度最小的IP段， 比如例子中3.4.4.4最佳匹配是City2=3.3.3.3,4.4.4.4，5.5.5.5的最佳匹配是City3=2.2.2.2,6.6.6.6 输入描述： 第一行为城市的IP段列表，多个IP段采用英文分号 \u0026#39;;\u0026#39; 分隔，IP段列表最大不超过500000。 城市名称只包含英文字母、数字和下划线。最多不超过100000个。IP段包含关系可能有多层，但不超过100层。 第二行为查询的IP列表，多个IP采用英文逗号 \u0026#39;,\u0026#39; 分隔，最多不超过10000条。 输出描述： 最佳匹配的城市名列表，采用英文逗号分隔，城市列表长度应该跟查询的IP列表长度一致。 备注： 1. 假定用例中的所有输入均合法，IP地址均为合法的ipv4地址，满足 (1~255).(0~255).(0~255).(0~255) 的格式 2. 无论是否查到匹配正常都要输出分隔符。 举例：假如输入IP列表为IPa,IPb，两个IP均未有匹配城市，此时输出为\u0026#34;,\u0026#34;，即只有一个逗号分隔符，两个城市均为空； 输入：City1=1.1.1.1,1.1.1.2;City1=1.1.1.11,1.1.1.16;City2=3.3.3.3,4.4.4.4;City3=2.2.2.2,6.6.6.6 1.1.1.15,3.3.3.5,2.2.2.3 输出：City1,City2,City3 题解\nstatic class Range { String city; long startIpDec; long endIpDec; long ipLen; public Range(String city, String startIpStr, String endIpStr) { this.city = city; // 将IP地址转为整型 this.startIpDec = ip2dec(startIpStr); this.endIpDec = ip2dec(endIpStr); this.ipLen = this.endIpDec - this.startIpDec + 1; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); ArrayList\u0026lt;Range\u0026gt; ranges = new ArrayList\u0026lt;\u0026gt;(); // 城市IP列表 String[] cities = sc.nextLine().split(\u0026#34;;\u0026#34;); // 待查询的IP列表 String[] queryIps = sc.nextLine().split(\u0026#34;,\u0026#34;); // 提取各个城市IP列表信息 for (String city : cities) { String[] tmp = city.split(\u0026#34;[=,]\u0026#34;); ranges.add(new Range(tmp[0], tmp[1], tmp[2])); } // 遍历待查询的IP地址 StringJoiner joiner = new StringJoiner(\u0026#34;,\u0026#34;); for (String ip : queryIps) { long ipDec = ip2dec(ip); // 记录该目标IP地址的最佳匹配城市 String city = \u0026#34;\u0026#34;; // 记录最佳匹配城市IP段的长度 long minLen = Long.MAX_VALUE; // 将带查询IP与城市IP段列表逐一匹配 for (Range range : ranges) { if (ipDec \u0026gt;= range.startIpDec \u0026amp;\u0026amp; ipDec \u0026lt;= range.endIpDec \u0026amp;\u0026amp; minLen \u0026gt; range.ipLen) { city = range.city; minLen = range.ipLen; } } joiner.add(city); } System.out.println(joiner); } // IP地址转整型 public static long ip2dec(String ip) { long res = 0; String[] blocks = ip.split(\u0026#34;\\\\.\u0026#34;); for (String block : blocks) { res = (Integer.parseInt(block)) | (res \u0026lt;\u0026lt; 8); } return res; } 23. 欢乐的周末\r#\r描述\n小华和小为是很要好的朋友，他们约定周末一起吃饭。 通过手机交流，他们在地图上选择了多个聚餐地点（由于自然地形等原因，部分聚餐地点不可达）， 求小华和小为都能到达的聚餐地点有多少个？ 输入描述： 第一行输入 m 和 n（m 代表地图的长度，n 代表地图的宽度） 第二行开始具体输入地图信息，地图信息包含： 0 为通畅的道路 1 为障碍物（且仅1为障碍物） 2 为小华或者小为，地图中必定有且仅有2个 （非障碍物） 3 为被选中的聚餐地点（非障碍物） 输出描述： 可以被两方都到达的聚餐地点数量，行末无空格。 备注： 地图的长宽为 m 和 n，其中：4 ≤ m ≤ 100，4 ≤ n ≤ 100 聚餐的地点数量为 k，1＜ k ≤ 100 输入：4 4 2 1 0 3 0 1 2 1 0 3 0 0 0 0 0 0 输出：2 输入：4 4 2 1 2 3 0 1 0 0 0 1 0 0 0 1 0 0 输出：0 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); // 长度m表示行数 int m = sc.nextInt(); // 宽度n表示列数 int n = sc.nextInt(); int[][] matrix = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { matrix[i][j] = sc.nextInt(); } } System.out.println(getResult(matrix)); } public static int getResult(int[][] matrix) { int rows = matrix.length; int cols = matrix[0].length; UnionFindSet ufs = new UnionFindSet(rows * cols); // 记录小华，小为的位置 ArrayList\u0026lt;Integer\u0026gt; huawei = new ArrayList\u0026lt;\u0026gt;(); // 记录餐厅的位置 ArrayList\u0026lt;Integer\u0026gt; restaurants = new ArrayList\u0026lt;\u0026gt;(); // 上下左右四个方向偏移量 int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; for (int i = 0; i \u0026lt; rows; i++) { for (int j = 0; j \u0026lt; cols; j++) { if (matrix[i][j] != 1) { // 二维坐标(i, j) 转为 一维坐标pos int pos = i * cols + j; if (matrix[i][j] == 2) { // 收集小华，小为的位置 huawei.add(pos); } else if (matrix[i][j] == 3) { // 收集餐厅的位置 restaurants.add(pos); } for (int[] offset : offsets) { int newI = i + offset[0]; int newJ = j + offset[1]; if (newI \u0026gt;= 0 \u0026amp;\u0026amp; newI \u0026lt; rows \u0026amp;\u0026amp; newJ \u0026gt;= 0 \u0026amp;\u0026amp; newJ \u0026lt; cols \u0026amp;\u0026amp; matrix[newI][newJ] != 1) { // 如果(i,j)和（newI,newJ）位置都是非1，则合并 ufs.union(pos, newI * cols + newJ); } } } } } // 小华所在连通分量的根 int hua_fa = ufs.find(huawei.get(0)); // 小为所在连通分量的根 int wei_fa = ufs.find(huawei.get(1)); // 如果小华和小为的不属于同一个连通分量，则二人无法去往相同餐厅 if (hua_fa != wei_fa) { return 0; } // 找出和小华、小为在同一个连通分量里面的餐厅 int ans = 0; for (Integer restaurant : restaurants) { if (ufs.find(restaurant) == hua_fa) { ans++; } } return ans; } // 并查集实现 static class UnionFindSet { int[] fa; public UnionFindSet(int n) { fa = new int[n]; for (int i = 0; i \u0026lt; n; i++) fa[i] = i; } public int find(int x) { if (x != this.fa[x]) { this.fa[x] = this.find(this.fa[x]); return this.fa[x]; } return x; } public void union(int x, int y) { int x_fa = this.find(x); int y_fa = this.find(y); if (x_fa != y_fa) { this.fa[y_fa] = x_fa; } } } 24. 机器人走迷宫\r#\r描述\n1、房间有X*Y的方格组成，例如下图为6*4的大小。每一个放个以坐标(x,y)描述。 2、机器人固定从方格(0,0)出发，只能向东或者向北前进，出口固定为房间的最东北角，用例保证机器人可以从入口走到出口。 3、房间有些方格是墙壁，如(4,1),机器人不能经过那儿。 4、有些地方是一旦到达就无法走到出口的，如标记为B的方格，称之为陷阱方格。 5、有些地方是机器人无法达到的，如标记为A的方格，称之为不可达方格，不可达方格不包括墙壁所在的位置 6、如下实例图中，陷阱方格有2个，不可达方格有3个。 请为该机器人实现路径规划功能：给定房间大小，墙壁位置，请计算出陷阱方格与不可达方格分别有多少个 输入描述： 1、第一行为房间的x和y(0 ＜ x,y ≤ 1000) 2、第二行为房间中墙壁的个数N (0 ≤ N ＜ X*Y) 3、接着下面会有N行墙壁的坐标 同一行中如果有多个数据以一个空格隔开，用例保证所有的输入数据均合法，(结尾不带回车换行) 输出描述： 陷阱方格与不可达方格数量，两个信息在一行中输出，以一个空格隔开。(结尾不带回车换行) 输入：6 4 5 0 2 1 2 2 2 4 1 5 1 输出：2 3 题解\nstatic int x; static int y; static int n; static int[][] poses; static int[][] matrix; public static void main(String[] args) { Scanner sc = new Scanner(System.in); x = sc.nextInt(); // 行数 y = sc.nextInt(); // 列数 n = sc.nextInt(); // 墙数 poses = new int[n][2]; // 墙位置 for (int i = 0; i \u0026lt; n; i++) { poses[i][0] = sc.nextInt(); poses[i][1] = sc.nextInt(); } getResult(); } public static void getResult() { matrix = new int[x][y]; for (int[] pos : poses) { int i = pos[0]; int j = pos[1]; matrix[i][j] = 1; // 墙点值为1，非墙点值为0 } matrix[x - 1][y - 1] = 2; // 可达点值为2 dfs(0, 0); int trap = 0; // 陷阱数量 int unreach = 0; // 不可达点数量 for (int i = 0; i \u0026lt; x; i++) { for (int j = 0; j \u0026lt; y; j++) { if (matrix[i][j] == 0) unreach++; else if (matrix[i][j] == -1) trap++; } } System.out.println(trap + \u0026#34; \u0026#34; + unreach); } public static boolean dfs(int cx, int cy) { if (cx \u0026gt;= x || cy \u0026gt;= y) return false; if (matrix[cx][cy] == 1) return false; if (matrix[cx][cy] == -1) return false; if (matrix[cx][cy] == 2) return true; if (matrix[cx][cy] == 0) { boolean east = dfs(cx + 1, cy); boolean north = dfs(cx, cy + 1); if (east || north) { // 如果向东可达或者向北可达，则当前点可达，将值设为2 matrix[cx][cy] = 2; } else { // 如果向东，向北都不可达，则当前前也是不可达点，将值设为-1 matrix[cx][cy] = -1; } } return matrix[cx][cy] == 2; } 25. 计算疫情扩散时间\r#\r描述\n在一个地图中(地图由n*n个区域组成），有部分区域被感染病菌。 感染区域每天都会把周围（上下左右）的4个区域感染。 请根据给定的地图计算，多少天以后，全部区域都会被感染。 如果初始地图上所有区域全部都被感染，或者没有被感染区域，返回-1 输入描述： 一行N*N个数字（只包含0,1，不会有其他数字）表示一个地图，数字间用,分割，0表示未感染区域，1表示已经感染区域 每N个数字表示地图中一行，输入数据共表示N行N列的区域地图。 例如输入1,0,1,0,0,0,1,0,1，表示地图 1,0,1 0,0,0 1,0,1 输出描述： 一个整数，表示经过多少天以后，全部区域都被感染 1≤N＜200 输入：1,0,1,0,0,0,1,0,1 输出：2 说明：1天以后，地图中仅剩余中心点未被感染；2天以后，全部被感染。 输入：0,0,0,0 输出：-1 说明：无感染区域 输入：1,1,1,1,1,1,1,1,1 输出：-1 说明：全部都感染 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34;,\u0026#34;); Integer[] arr = Arrays.stream(split).map(Integer::parseInt).toArray(Integer[]::new); System.out.println(getResult(arr)); } public static int getResult(Integer[] arr) { int n = (int) Math.sqrt(arr.length); int[][] matrix = new int[n][n]; // 将矩阵中所有感染区域位置记录到queue中 LinkedList\u0026lt;Integer[]\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { matrix[i][j] = arr[i * n + j]; if (matrix[i][j] == 1) { queue.add(new Integer[]{i, j}); } } } // 全是感染区，或全是健康区 if (queue.isEmpty() || queue.size() == arr.length) { return -1; } // 健康区个数 int healthy = arr.length - queue.size(); // 上下左右偏移量 int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // day用于统计感染全部花费的时间 int day = 0; // 如果健康区个数为0，说明感染完了 while (!queue.isEmpty() \u0026amp;\u0026amp; healthy \u0026gt; 0) { // 遍历完当前queue的所有感染区，即过去一天 LinkedList\u0026lt;Integer[]\u0026gt; newQue = new LinkedList\u0026lt;\u0026gt;(); for (Integer[] tmp : queue) { int x = tmp[0], y = tmp[1]; for (int[] offset : offsets) { int newX = x + offset[0]; int newY = y + offset[1]; if (newX \u0026gt;= 0 \u0026amp;\u0026amp; newX \u0026lt; n \u0026amp;\u0026amp; newY \u0026gt;= 0 \u0026amp;\u0026amp; newY \u0026lt; n \u0026amp;\u0026amp; matrix[newX][newY] == 0) { matrix[newX][newY] = 1; healthy--; // 新增感染区加到newQue中，不影响queue的当前遍历 newQue.add(new Integer[]{newX, newY}); } } } day++; queue = newQue; } return day; } "},{"id":278,"href":"/algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%9312/","title":"机试题库 - 12","section":"华为OD","content":"\r01. 简易内存池\r#\r描述\n请实现一个简易内存池Q，根据请求命令完成内存分配和释放。 内存池支持两种操作命令，REQUEST和RELEASE， REQUEST=请求的内存大小 表示请求分配指定大小内存，如果分配成功，返回分配到的内存首地址；如果内存不足，或指定的大小为0,则输出error. RELEASE=释放的内存首地址， 表示释放掉之前分配的内存，释放成功无需输出，如果释放不存在的首地址则输出error。 注意： 1.内存池总大小为100字节。 2.内存池地址分配必须是连续内存，并优先从低地址分配。 3.内存释放后可被再次分配，已释放的内存在空闲时不能被二次释放 4.不会释放已申请的内存块的中间地址， 5.释放操作只是针对首地址所对应的单个内存块进行操作，不会影响其它内存块。 输入描述： 首行为整数N，表示操作命令的个数，取值范围：N≤100. 接下来的N行，每行将给出一个操作命令，操作命令和参数之间用等号分割。 输出描述： 根据操作命令返回输出 输入：5 REQUEST=10 REQUEST=20 RELEASE=0 REQUEST=15 RELEASE=10 输出：0 10 10 题解\n// 0 表示未分配 1表示已经分配 public static final int[] RAM_ARR = new int[100]; // 存放分配过的内存的首地址及长度 static final HashMap\u0026lt;Integer, Integer\u0026gt; MAP = new HashMap\u0026lt;\u0026gt;(); public static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = sc.nextInt(); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; num; i++) { String[] strings = sc.nextLine().split(\u0026#34;=\u0026#34;); int answer = answer(strings[0], Integer.parseInt(strings[1])); if (answer != -2) { list.add(answer == -1 ? \u0026#34;error\u0026#34; : answer + \u0026#34;\u0026#34;); } } list.forEach(System.out::println); } public static int answer(String str, int num) { if (str.equals(\u0026#34;REQUEST\u0026#34;)) { if (num == 0) { return -1; } int len = 0; for (int i = 0; i \u0026lt; RAM_ARR.length; i++) { if (RAM_ARR[i] != 0) { continue; } for (int j = i; j \u0026lt; RAM_ARR.length; j++) { if (RAM_ARR[j] == 0) { len++; } else { i = len - 1; len = 0; break; } if (len == num) { for (int k = i; k \u0026lt; i + num; k++) { RAM_ARR[k] = 1; } MAP.put(i, num); return i; } } } return -1; } if (str.equals(\u0026#34;RELEASE\u0026#34;)) { if (MAP.containsKey(num)) { Integer len = MAP.get(num); MAP.remove(num); for (int i = num; i \u0026lt; len + num; i++) { RAM_ARR[i] = 0; } return -2; } else { return -1; } } return -1; } 02. 结队编程\r#\r描述\n某部门计划通过结队编程来进行项目开发， 已知该部门有 N 名员工，每个员工有独一无二的职级，每三个员工形成一个小组进行结队编程 请你按下述条件计算可能组合的小组数量。同一员工可以参加多个小组。 结队分组规则如下： 从部门中选出序号分别为 i、j、k 的3名员工，他们的职级分贝为 level[i]，level[j]，level[k]， 结队小组满足 level[i] ＜ level[j] ＜ level[k] 或者 level[i] \u0026gt; level[j] \u0026gt; level[k]， 其中 0 ≤ i ＜ j ＜ k ＜ n。 输入描述： 第一行输入：员工总数 n，1 ≤ n ≤ 6000 第二行输入：按序号依次排列的员工的职级 level，中间用空格隔开，1 ≤ level[i] ≤ 10^5 输出描述： 可能结队的小组数量 输入：4 1 2 3 4 输出：4 说明：可能结队成的组合(1,2,3)、(1,2,4)、(1,3,4)、(2,3,4) 输入：3 5 4 7 输出：0 说明：根据结队条件，我们无法为该部门组建小组 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] levels = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(n, levels)); } public static long getResult(int n, int[] levels) { long ans = 0; for (int i = 1; i \u0026lt; n - 1; i++) { int mid = levels[i]; // 左边比自己小的元素的个数 long leftSmallerCount = 0; // 左边比自己大的元素的个数 long leftBiggerCount = 0; for (int j = 0; j \u0026lt; i; j++) { if (levels[j] \u0026gt; mid) { leftBiggerCount++; } else { leftSmallerCount++; } } // 右边比自己小的元素是的个数 long rightSmallerCount = 0; // 右边比自己大的元素的个数 long rightBiggerCount = 0; for (int k = i + 1; k \u0026lt; n; k++) { if (levels[k] \u0026gt; mid) { rightBiggerCount++; } else { rightSmallerCount++; } } ans += leftSmallerCount * rightBiggerCount + leftBiggerCount * rightSmallerCount; } return ans; } 03. 九宫格按键输入\r#\r描述\n九宫格按键输入，输出显示内容，有英文和数字两个模式，默认是数字模式，数字模式直接输出数字，英文模式连续按同一个按键会依次出现这个按键上的字母，如果输入”/”或者其他字符，则循环中断。 字符对应关系如图 输入描述： 输入范围为数字 0~9 和字符’#’、’/’，输出屏幕显示，例如， 在数字模式下，输入 1234，显示 1234 在英文模式下，输入 1234，显示,adg 输出描述： #用于切换模式，默认是数字模式，执行#后切换为英文模式； /表示延迟，例如在英文模式下，输入 22/222，显示为 bc； 英文模式下，多次按同一键，例如输入 22222，显示为 b； 输入：123#222235/56 输出：123adjjm 题解\nstatic String[] dict = {\u0026#34; \u0026#34;, \u0026#34;,.\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34;}; static LinkedList\u0026lt;Character\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); static int topRepeat = 0; static boolean isEng = false; public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(getResult(sc.nextLine())); } public static String getResult(String s) { s += \u0026#34; \u0026#34;; for (int i = 0; i \u0026lt; s.length(); i++) { char c = s.charAt(i); switch (c) { case \u0026#39;#\u0026#39;: interrupt(); isEng = !isEng; break; case \u0026#39;/\u0026#39;: interrupt(); break; default: // 数字模式，直接输出数字 if (!isEng) { stack.add(c); break; } // 英文模式，需要检查栈顶 // 如果栈顶不是英文模式字符，则缓存对应字符c，并记录重复次数 if (topRepeat == 0) { stack.add(c); topRepeat++; break; } // 如果栈顶字符有重复次数 // 则此时需要比较当前按键c和之前重复的按键stack.getLast是否相同 if (c != stack.getLast()) { // 如果输入”/”或者其他字符，则循环中断 interrupt(); stack.add(c); } topRepeat++; } } StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; stack.size() - 1; i++) sb.append(stack.get(i)); return sb.toString(); } // 英文模式连续按同一个按键会依次出现这个按键上的字母，如果输入”/”或者其他字符，则循环中断 // interrupt用于处理循环中断后的逻辑 public static void interrupt() { if (!isEng || stack.isEmpty() || topRepeat == 0) return; stack.add(map(stack.removeLast(), topRepeat)); topRepeat = 0; } // 基于dict，获取一个数字c被重复repeat次后，对应的字符 public static char map(char c, int repeat) { int num = Integer.parseInt(c + \u0026#34;\u0026#34;); String s = dict[num]; int i = (repeat - 1) % s.length(); return s.charAt(i); } 04. 矩阵匹配\r#\r描述\n从一个 N * M（N ≤ M）的矩阵中选出 N 个数， 任意两个数字不能在同一行或同一列，求选出来的 N 个数中第 K 大的数字的最小值是多少。 注意：结果是第 K 大的数字的最小值 输入描述： N M K N*M矩阵范围：1 ≤ K ≤ N ≤ M ≤ 150 输出描述： N*M 的矩阵中可以选出 M! / N! 种组合数组，每个组合数组种第 K 大的数中的最小值。 无需考虑重复数字，直接取字典排序结果即可。 输入：3 4 2 1 5 6 6 8 3 4 3 6 8 6 3 输出：3 题解\nstatic int n; static int m; static int k; static int[][] matrix; public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); m = sc.nextInt(); k = sc.nextInt(); int min = 1; int max = Integer.MIN_VALUE; matrix = new int[n][m]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { matrix[i][j] = sc.nextInt(); max = Math.max(max, matrix[i][j]); } } // 二分枚举第K大值 while (min \u0026lt;= max) { // mid就是被枚举出来的N个数中的第K大值 int mid = (min + max) \u0026gt;\u0026gt; 1; // 检查mid作为N个数中第K大值时，是否存在N-K+1个不大于它的值 if (check(mid)) { max = mid - 1; } else { min = mid + 1; } } System.out.println(min); } public static boolean check(int kth) { // 利用二分图最大匹配来求解，小于等于kth（第K大值）的元素个数（即二分图最大匹配） int smallerCount = 0; // 记录每个行号的匹配成功的列号 int[] match = new int[m]; // 初始时每个行号都处于未配对状态，此时将行号配对的列号赋值为-1 Arrays.fill(match, -1); // 遍历列号，每个列号对互相心仪的行号发起配对请求 for (int i = 0; i \u0026lt; n; i++) { // 记录增广路访问过的行号 boolean[] vis = new boolean[m]; if (dfs(i, kth, match, vis)) smallerCount++; } return smallerCount \u0026gt;= n - k + 1; } public static boolean dfs(int i, int kth, int[] match, boolean[] vis) { // 列号 i 发起了配对请求 // 遍历每一个行号j for (int j = 0; j \u0026lt; m; j++) { // 如果当前行号j未被增广路探索过 // 当前行j列号i可以配对（如果行列号位置(i,j)对应矩阵元素值小于等于kth（第K大值），则可以配对） if (!vis[j] \u0026amp;\u0026amp; matrix[i][j] \u0026lt;= kth) { vis[j] = true; // 如果对应行号j未配对，或者，已配对但是配对的雷浩match[j]可以找到其他行号重新配对 if (match[j] == -1 || dfs(match[j], kth, match, vis)) { // 则当前列号i 和 行号j 可以配对 match[j] = i; return true; } } } return false; } 05. 考古学家\r#\r描述\n有一个考古学家发现一个石碑，但是很可惜发现时其已经断成多段。 有N个断口整齐的石碑碎片，为了破解石碑内容，考古学家希望有程序能帮忙计算复原后的石碑文字组合数 输入描述： 第一行输入N，N表示石碑碎片的个数 第二行依次输入石碑碎片上的文字内容S共有N组 输出描述： 输出石碑文字的组合(按照升序排列)，行尾无多余空格 备注： 如果存在石碑碎片内容完全相同，则由于碎片间的顺序变换不影响复原后的碑文内容，即相同碎片间的位置变换不影响组合。 输入：3 a b ab 输出：aabb abab abba baab baba 题解\nstatic int n; static String[] arr; public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = Integer.parseInt(sc.nextLine()); arr = sc.nextLine().split(\u0026#34; \u0026#34;); getResult(); } public static void getResult() { // 排序是为了让相同元素相邻，方便后面树层去重 Arrays.sort(arr); boolean[] used = new boolean[n]; LinkedList\u0026lt;String\u0026gt; path = new LinkedList\u0026lt;\u0026gt;(); HashSet\u0026lt;String\u0026gt; res = new HashSet\u0026lt;\u0026gt;(); dfs(used, path, res); // 输出石碑文字的组合（按照升序排列） res.stream().sorted(String::compareTo).forEach(System.out::println); } public static void dfs(boolean[] used, LinkedList\u0026lt;String\u0026gt; path, HashSet\u0026lt;String\u0026gt; res) { if (path.size() == n) { StringBuilder sb = new StringBuilder(); path.forEach(sb::append); res.add(sb.toString()); return; } for (int i = 0; i \u0026lt; n; i++) { if (used[i]) continue; // 树层去重 if (i \u0026gt; 0 \u0026amp;\u0026amp; arr[i].equals(arr[i - 1]) \u0026amp;\u0026amp; !used[i - 1]) continue; path.addLast(arr[i]); used[i] = true; dfs(used, path, res); used[i] = false; path.removeLast(); } } 06. 可以处理的最大任务数\r#\r描述\n在某个项目中有多个任务（用task数组表示）需要你进行处理，其中：task[i] = [si, ei] 你可以在 si ≤ day ≤ ei 中的任意一天处理该任务，请返回你可以处理的最大任务数。 输入描述： 第一行为任务数量 n，1 ≤ n ≤ 100000 后面 n 行表示各个任务的开始时间和终止时间，使用 si，ei 表示，1 ≤ si ≤ ei ≤ 100000 输出描述： 输出为一个整数，表示可以处理的最大任务数。 输入：3 1 1 1 2 1 3 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[][] ranges = new int[n][2]; for (int i = 0; i \u0026lt; n; i++) { ranges[i][0] = sc.nextInt(); ranges[i][1] = sc.nextInt(); } // 将所有任务按照结束时间降序 Arrays.sort(ranges, (a, b) -\u0026gt; b[1] - a[1]); // 优先队列中记录的是任务的开始时间，并且开始时间越大，优先级越高 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; b - a); // 优先队列中记录的是结束时间相同的任务的开始时间，pq_end就是优先队列中任务的相同结束时间 int pq_end = Integer.MAX_VALUE; // 最大任务数 int count = 0; for (int[] range : ranges) { // 当前任务的开始和结束时间 int start = range[0]; int end = range[1]; // 如果当前任务的结束时间 小于 优先队列中记录的任务的结束时间， // 则两个结束时间之间的间隔时间段，可以处理一些紧急任务 while (!pq.isEmpty() \u0026amp;\u0026amp; end \u0026lt; pq_end) { // 这里的紧急任务即指时间短的任务，即开始时间比较大的任务 if (pq.poll() \u0026lt;= pq_end) { // 如果紧急任务的开始时间未超过其结束时间，则可以执行 count++; pq_end--; // 一个时刻只执行一个任务 } } // 间隔时间消耗完后，优先队列中的任务的结束时间全部更新为当前任务的结束时间 pq.add(start); pq_end = end; } // 收尾处理 while (!pq.isEmpty()) { if (pq.poll() \u0026lt;= pq_end) { count++; pq_end--; } } System.out.println(count); } 07. 可以组成网络的服务器\r#\r描述\n在一个机房中，服务器的位置标识在 n*m 的整数矩阵网格中，1 表示单元格上有服务器，0 表示没有。 如果两台服务器位于同一行或者同一列中紧邻的位置，则认为它们之间可以组成一个局域网。 请你统计机房中最大的局域网包含的服务器个数。 输入描述： 第一行输入两个正整数，n和m，0＜n,m≤100 之后为n*m的二维数组，代表服务器信息 输出描述： 最大局域网包含的服务器个数。 输入：2 2 1 0 1 1 输出：3 题解\nstatic int n; static int m; static int[][] matrix; public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); m = sc.nextInt(); matrix = new int[n][m]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { matrix[i][j] = sc.nextInt(); } } System.out.println(getResult()); } public static int getResult() { int ans = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { if (matrix[i][j] == 1) ans = Math.max(ans, bfs(i, j)); } } return ans; } static int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; public static int bfs(int i, int j) { int count = 1; matrix[i][j] = 0; LinkedList\u0026lt;int[]\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.add(new int[]{i, j}); while (!queue.isEmpty()) { int[] pos = queue.removeFirst(); int x = pos[0]; int y = pos[1]; for (int[] offset : offsets) { int newX = x + offset[0]; int newY = y + offset[1]; if (newX \u0026gt;= 0 \u0026amp;\u0026amp; newX \u0026lt; n \u0026amp;\u0026amp; newY \u0026gt;= 0 \u0026amp;\u0026amp; newY \u0026lt; m \u0026amp;\u0026amp; matrix[newX][newY] == 1) { count++; matrix[newX][newY] = 0; queue.add(new int[]{newX, newY}); } } } return count; } 08. 快递员的烦恼\r#\r描述\n快递公司每日早晨，给每位快递员推送需要送到客户手中的快递以及路线信息， 快递员自己又查找了一些客户与客户之间的路线距离信息，请你依据这些信息，给快递员设计一条最短路径，告诉他最短路径的距离。 注意： 1. 不限制快递包裹送到客户手中的顺序，但必须保证都送到客户手中 2. 用例保证一定存在投递站到每位客户之间的路线，但不保证客户与客户之间有路线，客户位置及投递站均允许多次经过 3. 所有快递送完后，快递员需回到投递站 输入描述： 首行输入两个正整数n、m 接下来 n 行，输入快递公司发布的客户快递信息，格式为：客户id 投递站到客户之间的距离distance 再接下俩的 m 行，是快递员自行查找的客户与客户之间的距离信息，格式为：客户id1 客户id2 distance 在每行数据中，数据与数据之间均以单个空格分隔 规格： 0 ＜ n ≤ 10 0 ≤ m ≤ 10 0 ＜ 客户id ≤ 1000 0 ＜ distance ≤ 10000 输出描述： 最短路径距离，如无法找到，请输出-1 输入：2 1 1 1000 2 1200 1 2 300 输出：2500 输入：5 1 5 1000 9 1200 17 300 132 700 500 2300 5 9 400 输出：9200 题解\nstatic int n; static int[][] dist; static int[][] path; static int ans; public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); int m = sc.nextInt(); // floyd算法需要基于dist和path矩阵求解 // dist[i][j] 用于记录点 i-\u0026gt;j 的最短距离，初始时等价于邻接矩阵 dist = new int[n + 1][n + 1]; // path[i][j] 用于记录点 i-\u0026gt;j 最短距离情况下需要经过的中转点， // 初始时默认任意两点间无中转点，即默认path[i][j] = -1 path = new int[n + 1][n + 1]; for (int i = 0; i \u0026lt; n + 1; i++) { for (int j = 0; j \u0026lt; n + 1; j++) { // 初始时默认i,j不相连，即i,j之间距离无穷大 if (i != j) { dist[i][j] = Integer.MAX_VALUE; } path[i][j] = -1; } } // 由于本题的客户id不是顺序的，因此这里需要将客户id离散化处理 HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt;= n; i++) { int id = sc.nextInt(); int dis = sc.nextInt(); // 离散化处理 map.put(id, i); // 投递站到客户之间的距离distance dist[0][i] = dis; dist[i][0] = dis; } for (int i = 1; i \u0026lt;= m; i++) { int id1 = sc.nextInt(); int id2 = sc.nextInt(); int dis = sc.nextInt(); int i1 = map.get(id1); int i2 = map.get(id2); // 客户与客户之间的距离信息 dist[i1][i2] = dis; dist[i2][i1] = dis; } // floyd算法调用 floyd(); // ans记录经过所有点后回到出发点的最短距离 ans = Integer.MAX_VALUE; // 全排列模拟经过所有点的路径 dfs(0, 0, new boolean[n + 1], 0); System.out.println(ans); } // floyd算法求解图中任意两点之间的最短路径 public static void floyd() { for (int k = 0; k \u0026lt; n + 1; k++) { for (int i = 0; i \u0026lt; n + 1; i++) { for (int j = 0; j \u0026lt; n + 1; j++) { // newDist是经过k后，i-\u0026gt;j的距离 int newDist = dist[i][k] + dist[k][j]; // 如果newDist是i-\u0026gt;j的更短路径 if (newDist \u0026lt; dist[i][j]) { // 则更新i-\u0026gt;j的最短距离 dist[i][j] = newDist; // 且此更短距离需要经过k, path[i][j]即记录 i-\u0026gt;j 最短距离下需要经过点 k path[i][j] = k; } } } } } /** * 找一条经过所有点的最短路径，我们可以求解所有点形成的全排列， * 每一个全排列都对应一条经过所有点的路径，只是经过点的先后顺序不同 * 求某个全排列过程中，可以通过dist数组，累计上一个点i到下一个点j的最短路径dist[i][j] * * @param pre 上一个点, 初始为0，表示从快递站出发 * @param sum 当前全排列路径累计的路径权重 * @param used 全排列used数组，用于标记哪些点已使用过 * @param level 用于记录排列的长度 */ public static void dfs(int pre, int sum, boolean[] used, int level) { if (level == n) { // 此时pre是最后一个客户所在点，送完最后一个客户后， // 快递员需要回到快递站，因此最终累计路径权重为 sum + dist[pre][0] // 我们保留最小权重路径 ans = Math.min(ans, sum + dist[pre][0]); return; } for (int i = 1; i \u0026lt;= n; i++) { if (used[i]) continue; used[i] = true; dfs(i, sum + dist[pre][i], used, level + 1); used[i] = false; } } 09. 快速人名查找\r#\r描述\n给一个字符串，表示用’,’分开的人名。 然后给定一个字符串，进行快速人名查找，符合要求的输出。 快速人名查找要求︰人名的每个单词的连续前几位能组成给定字符串，一定要用到每个单词。 输入描述： 第一行是人名，用’,’分开的人名 第二行是 查找字符串 输出描述： 输出满足要求的人名 输入：zhang san,zhang san san zs 输出：zhang san 输入：zhang san san,zhang an sa,zhang hang,zhang seng,zhang sen a zhas 输出：zhang an sa,zhang seng 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] names = sc.nextLine().split(\u0026#34;,\u0026#34;); String abbr = sc.nextLine(); System.out.println(getResult(names, abbr)); } public static String getResult(String[] names, String abbr) { ArrayList\u0026lt;String\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (String name : names) { String[] parts = name.split(\u0026#34; \u0026#34;); if (parts.length \u0026gt; abbr.length()) continue; if (recursive(parts, 0, abbr, 0)) { ans.add(name); } } StringJoiner sj = new StringJoiner(\u0026#34;,\u0026#34;); for (String an : ans) { sj.add(an); } return sj.toString(); } /** * @param parts 人名组成 * @param parts_index 人名被匹配的组成部分的索引位置 * @param abbr 人名缩写 * @param abbr_index 缩写被匹配的字符的索引位置 * @return 当前人名name是否匹配对应缩写abbr */ public static boolean recursive(String[] parts, int parts_index, String abbr, int abbr_index) { if (abbr_index \u0026gt;= abbr.length()) { // 如果缩写被匹配完，且人名组成也匹配到最后一个，则说明当前人名可以匹配对应缩写 return parts_index \u0026gt;= parts.length; } // 如果缩写尚未匹配完，但是人名组成已经匹配完，则说明当前人名无法匹配对应缩写 if (parts_index \u0026gt;= parts.length) { return false; } String part_name = parts[parts_index]; for (int j = 0; j \u0026lt; part_name.length(); j++) { // 如果当前人名组成部分part_name的第 j 个字符 可以 匹配 缩写abbr的第 abbr_index个字符 if (abbr_index \u0026lt; abbr.length() \u0026amp;\u0026amp; part_name.charAt(j) == abbr.charAt(abbr_index)) { // 为了保证part_name匹配不回退， // 此时我们将缩写abbr的第abbr_index+1个字符的匹配权优先交给人名的parts_index + 1部分 if (recursive(parts, parts_index + 1, abbr, ++abbr_index)) { return true; } } else { return false; } } return false; } 10. 篮球游戏\r#\r描述\n幼儿园里有一个放倒的圆桶，它是一个线性结构，允许在桶的右边将篮球放入，可以在桶的左边和右边将篮球取出。 每个篮球有单独的编号，老师可以连续放入一个或多个篮球， 小朋友可以在桶左边或右边将篮球取出，当桶只有一个篮球的情况下，必须从左边取出。 如老师按顺序放入1、2、3、4、5 共有 5 个编号的篮球， 那么小朋友可以依次取出编号为1、2、3、4、5 或者 3、1、2、4、5 编号的篮球，无法取出 5、1、3、2、4 编号的篮球。 其中 3、1、2、4、5 的取出场景为： 连续放入1、2、3号 从右边取出3号 从左边取出1号 从左边取出2号 放入4号 从左边取出4号 放入5号 从左边取出5号 简答起见，我们以 L 表示左，R表示右，此时取出篮球的依次取出序列为“RLLLL”。 输入描述： 每次输入包含一个测试用例： 第一行的数字作为老师依次放入的篮球编号 第二行的数字作为要检查是否能够按照放入的顺序取出给定的篮球的编号，其中篮球的编号用逗号进行分隔。 其中篮球编号用逗号进行分隔。 输出描述： 对于每个篮球的取出序列，如果确实可以获取，请打印出其按照左右方向的操作取出顺序，如果无法获取则打印“NO”。 备注： 1 ≤ 篮球编号，篮球个数 ≤ 200 篮球上的数字不重复 输出的结果中 LR 必须为大写 输入：4,5,6,7,0,1,2 6,4,0,1,2,5,7 输出：RLRRRLL 输入：4,5,6,7,0,1,2 6,0,5,1,2,4,7 输出：NO 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] inputs = Arrays.stream(sc.nextLine().split(\u0026#34;,\u0026#34;)).mapToInt(Integer::parseInt).toArray(); int[] outputs = Arrays.stream(sc.nextLine().split(\u0026#34;,\u0026#34;)).mapToInt(Integer::parseInt).toArray(); // 利用队列结构模拟圆桶 LinkedList\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // outputs[index]是要被取出的篮球的编号 int index = 0; // 记录题解 StringBuilder sb = new StringBuilder(); for (int input : inputs) { // 按照放入顺序，从圆桶右边放入 queue.addLast(input); // 然后开始尝试取出 while (!queue.isEmpty()) { // 圆桶左边的篮球的编号 int left = queue.getFirst(); // 圆桶右边的篮球的编号 int right = queue.getLast(); if (left == outputs[index]) { // 优先比较圆桶左边的篮球是不是当前要取出的篮球， // 优先左边的原因是：当桶只有一个篮球的情况下，必须从左边取出 sb.append(\u0026#34;L\u0026#34;); queue.removeFirst(); index++; } else if (right == outputs[index]) { // 比较圆桶右边的篮球是不是当前要取出的篮球 sb.append(\u0026#34;R\u0026#34;); queue.removeLast(); index++; } else { // 如果圆桶左右两边都不是要取出的球，则本轮取出流程结束 break; } } } // 最终如果圆桶空了，则说明所有球都取出了，否则按照给定要求无法取出所有球 if (!queue.isEmpty()) { System.out.println(\u0026#34;NO\u0026#34;); } else { System.out.println(sb); } } 11. 连续出牌数量\r#\r描述\n有这么一款单人卡牌游戏，牌面由颜色和数字组成，颜色为红、黄、蓝、绿中的一种，数字为0-9中的一个。 游戏开始时玩家从手牌中选取一张卡牌打出，接下来如果玩家手中有和他上一次打出的手牌颜色或者数字相同的手牌， 他可以继续将该手牌打出，直至手牌打光或者没有符合条件可以继续打出的手牌。 现给定一副手牌，请找到最优的出牌策略，使打出的手牌最多。 输入描述：输入为两行 第一行是每张手牌的数字，数字由空格分隔， 第二行为对应的每张手牌的颜色，用r y b g这4个字母分别代表4种颜色，字母也由空格分隔。 手牌数量不超过10。 输出描述： 输出一个数字，即最多能打出的手牌的数量。 输入：1 4 3 4 5 r y b b r 输出：3 输入：1 2 3 4 r y b l 输出：1 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); String[] colors = sc.nextLine().split(\u0026#34; \u0026#34;); System.out.println(getResult(nums, colors)); } public static class Card { int num; char color; public Card(int num, String color) { this.num = num; this.color = color.charAt(0); } } public static int getResult(int[] nums, String[] colors) { int n = nums.length; Card[] cards = new Card[n]; for (int i = 0; i \u0026lt; n; i++) { cards[i] = new Card(nums[i], colors[i]); } int[] ans = {0}; boolean[] used = new boolean[n]; dfs(cards, used, null, 0, ans); return ans[0]; } public static void dfs(Card[] cards, boolean[] used, Card last, int count, int[] ans) { ans[0] = Math.max(ans[0], count); for (int i = 0; i \u0026lt; cards.length; i++) { if (used[i]) continue; Card cur = cards[i]; if (last != null \u0026amp;\u0026amp; last.num != cur.num \u0026amp;\u0026amp; last.color != cur.color) { continue; } used[i] = true; dfs(cards, used, cur, count + 1, ans); used[i] = false; } } 12. 两个字符串间的最短路径问题\r#\r描述\n给定两个字符串，分别为字符串 A 与字符串 B。 例如 A字符串为 \u0026#34;ABCABBA\u0026#34;，B字符串为 \u0026#34;CBABAC\u0026#34; 可以得到下图 m * n 的二维数组， 定义原点为(0,0)，终点为(m,n)，水平与垂直的每一条边距离为1，映射成坐标系如下图。 从原点 (0,0) 到 (0,A) 为水平边，距离为1，从 (0,A) 到 (A,C) 为垂直边，距离为1； 假设两个字符串同一位置的两个字符相同，则可以作一个斜边，如 (A,C) 到 (B,B) 最短距离为斜边，距离同样为1。 作出所有的斜边如下图，(0,0) 到 (B,B) 的距离为：1 个水平边 + 1 个垂直边 + 1 个斜边 = 3。 根据定义可知，原点到终点的最短距离路径如下图红线标记，最短距离为9： 输入描述： 空格分割的两个字符串 A 与字符串 B 字符串不为\u0026#34;空串\u0026#34; 字符格式满足正则规则：[A-Z] 字符串长度小于 10000 输出描述： 原点到终点的最短距离 输入：ABC ABC 输出：3 输入：ABCABBA CBABAC 输出：9 题解\nstatic String A; static String B; static int m; static int n; public static void main(String[] args) { Scanner sc = new Scanner(System.in); A = sc.next(); B = sc.next(); m = B.length(); n = A.length(); System.out.println(getResult()); } public static int getResult() { // 初始时preRow记录第一行上各点到(0,0)点的最短距离，即为(0,0) -\u0026gt; (0,j) 的直线路径 int[] preRow = new int[n + 1]; for (int j = 0; j \u0026lt;= n; j++) { preRow[j] = j; } // 初始时curRow记录第二行上各点到(0,0)点的最短距离 int[] curRow = new int[n + 1]; for (int i = 1; i \u0026lt;= m; i++) { // curRow[0]是指 (i, 0)点 到 (0,0)点 的最短距离，即为(0,0) -\u0026gt; (i, 0) 的直线路径 curRow[0] = i; for (int j = 1; j \u0026lt;= n; j++) { if (A.charAt(j - 1) == B.charAt(i - 1)) { // 如果可以走斜线，则选走斜线的点 curRow[j] = preRow[j - 1] + 1; } else { // 如果不能走斜线，则从当前点的上方点、左方点中选择一个较小值 curRow[j] = Math.min(preRow[j], curRow[j - 1]) + 1; } } // 压缩 System.arraycopy(curRow, 0, preRow, 0, n + 1); } return curRow[n]; } 13. 路口最短时间问题\r#\r描述\n假定街道是棋盘型的，每格距离相等，车辆通过每格街道需要时间均为 timePerRoad； 街道的街口（交叉点）有交通灯，灯的周期 T（=lights[row][col]）各不相同； 车辆可直行、左转和右转，其中直行和左转需要等相应 T 时间的交通灯才可通行，右转无需等待。 现给出 n * m 个街口的交通灯周期，以及起止街口的坐标，计算车辆经过两个街口的最短时间。 其中： 起点和终点的交通灯不计入时间，且可以在任意方向经过街口 不可超出 n * m 个街口，不可跳跃，但边线也是道路（即：lights[0][0] -\u0026gt; lights[0][1] 是有效路径） 输入描述： 第一行输入 n 和 m，以空格分隔 之后 n 行输入 lights矩阵，矩阵每行m个整数，以空格分隔 之后一行输入 timePerRoad 之后一行输入 rowStart colStart，以空格分隔 最后一行输入 rowEnd colEnd，以空格分隔 输出描述： lights[rowStart][colStart] 与 lights[rowEnd][colEnd] 两个街口之间的最短通行时间 输入：3 3 1 2 3 4 5 6 7 8 9 60 0 0 2 2 输出：245 题解\nstatic int n; static int m; static int[][] lights; static int timePreRoad; static int rowStart; static int colStart; static int rowEnd; static int colEnd; static boolean[][] visited; static int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); m = sc.nextInt(); lights = new int[n][m]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { lights[i][j] = sc.nextInt(); } } timePreRoad = sc.nextInt(); rowStart = sc.nextInt(); colStart = sc.nextInt(); rowEnd = sc.nextInt(); colEnd = sc.nextInt(); System.out.println(getResult()); } public static int getResult() { // 记录访问过的点，防止走回路 visited = new boolean[n][m]; // 初始时起点位置标记为访问过 visited[rowStart][colStart] = true; // 记录起点到终点的最小花费时间，这里minCost定义为数组， // 是为了其在dfs函数调用结束后，不会被释放内存，因为它是引用类型变量 int[] minCost = {Integer.MAX_VALUE}; // 开始暴搜所有起点到终点的路径 dfs(rowStart, colStart, -1, -1, 0, minCost); return minCost[0]; } /** * 暴力搜索 * * @param curX 当前位置横坐标 * @param curY 当前位置纵坐标 * @param preX 上一个位置横坐标 * @param preY 上一个位置纵坐标 * @param cost 到达当前位置花费的时间 * @param minCost 记录起点到终点的最小花费时间 */ public static void dfs(int curX, int curY, int preX, int preY, int cost, int[] minCost) { // 如果到达当前前花费的时间cost 达到了 已知minCost，那么后续路径就没必要探索了，因为必然要比minCost大 if (cost \u0026gt;= minCost[0]) { return; } // 如果当前点是终点，且花费的时间cost更少，则更新minCost if (curX == rowEnd \u0026amp;\u0026amp; curY == colEnd) { minCost[0] = cost; return; } // 否则，从当前位置的四个方向继续探索路径 for (int[] offset : offsets) { // 新位置 int nextX = curX + offset[0]; int nextY = curY + offset[1]; // 新位置越界或者已经访问过，则不能访问，继续其他方向探索 if (nextX \u0026lt; 0 || nextX \u0026gt;= n || nextY \u0026lt; 0 || nextY \u0026gt;= m || visited[nextX][nextY]) continue; // 标记新位置访问过 visited[nextX][nextY] = true; // 根据pre,cur,next三点，判断拐弯方向 int direction = getDirection(preX, preY, curX, curY, nextX, nextY); // cur到达next位置必须要增加timePreRoad个时间 int increment = timePreRoad; // preX=-1, preY=-1 表示pre位置不存在，此时探索下一个位置不需要花费等待周期 if (preX \u0026gt;= 0 \u0026amp;\u0026amp; preY \u0026gt;= 0 \u0026amp;\u0026amp; direction \u0026gt;= 0) { // pre位置存在，且cur-\u0026gt;next是左拐或者直行，则需要增加当前位置对应的等待周期时间 increment += lights[curX][curY]; } // 递归进入新位置 dfs(nextX, nextY, curX, curY, cost + increment, minCost); // 回溯 visited[nextX][nextY] = false; } } /** * 根据三点坐标，确定拐弯方向 * * @param preX 前一个点横坐标 * @param preY 前一个点纵坐标 * @param curX 当前点横坐标 * @param curY 当前点纵坐标 * @param nextX 下一个点横坐标 * @param nextY 下一个点纵坐标 * @return cur到next的拐弯方向， \u0026gt;0 表示向左拐， ==0 表示直行（含调头）， \u0026lt;0 表示向右拐 */ public static int getDirection(int preX, int preY, int curX, int curY, int nextX, int nextY) { // 向量 pre-\u0026gt;cur int dx1 = curX - preX; int dy1 = curY - preY; // 向量 cur-\u0026gt;next int dx2 = nextX - curX; int dy2 = nextY - curY; // 两个向量的叉积 \u0026gt;0 表示向左拐， ==0 表示直行（含调头）， \u0026lt;0 表示向右拐 return dx1 * dy2 - dx2 * dy1; } 14. 没有回文串\r#\r描述\n回文串的定义：正读和反读都一样的字符串。 现在已经存在一个不包含回文串的字符串，字符串的字符都是在英语字母的前N个,且字符串不包含任何长度大于等于2的回文串； 请找出下一个字典序的不包含回文串的、字符都是在英语字母的前N个、且长度相同的字符串。 如果不存在，请输出NO。 输入描述：输入包括两行。 第一行有一个整数:N（1≤N≤26），表示字符串的每个字符范围都是前N的英语字母。 第二行输入一个字符串S（输入长度≤10000），输入保证这个字符串是合法的并且没有包含回文串。 输出描述： 输出下一个字典序的不包含回文串的、字符都是在英语字母的前N个、且长度相同的字符串； 如果不存在,请输出”NO“。 输入：3 cba 输出：NO 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); String s = sc.next(); System.out.println(getResult(n, s)); } /** * @param n 字符串的每个字符范围都是前N的英语字母（1\u0026lt;=N\u0026lt;=26） * @param s 合法的并且没有包含回文串的字符串（长度\u0026lt;=10000） */ public static String getResult(int n, String s) { // 将输入的字符串转化为ASCII数组 char[] chars = s.toCharArray(); // 每一位上的最大ASCII值 char limit = (char) (\u0026#39;a\u0026#39; + n - 1); // 当前位是否处于回退检查状态 boolean back = false; // 从最低位开始检查 int i = chars.length - 1; while (i \u0026gt;= 0) { // 如果当前位还有新增空间 if (chars[i] \u0026lt; limit) { if (!back) { // 如果当前位不是回退检查状态,则当前位ASCII+1 chars[i] += 1; } else { // 如果当前位是回退检查状态, 则重置back back = false; } // 避免出现 *abb* 这种情况 if (i - 1 \u0026gt;= 0 \u0026amp;\u0026amp; chars[i] == chars[i - 1]) continue; // 避免出现 *aba* 这种情况 if (i - 2 \u0026gt;= 0 \u0026amp;\u0026amp; chars[i] == chars[i - 2]) continue; // 如果都没有出现上面两个情况： if (i == chars.length - 1) { // 当前检查位是最低位，则说明当前字符串不含回文串, 可以直接返回当前字符串 return new String(chars); } // 当前检查位不是最低位，则只完成了高位的回文检查，还要回退到低位检查 i++; // 由于回退到了低位，则标记当前i指向的位置为回退检查状态，即检查时不进行ASCII+1操作 back = true; } else { // 当前位没有新增空间了, 因此i位（低位）变为\u0026#39;a\u0026#39;, i-1位（高位）+ 1 chars[i] = \u0026#39;a\u0026#39;; i--; } } return \u0026#34;NO\u0026#34;; } 15. 迷宫问题\r#\r描述\n定义一个二维数组 N*M ，如 5 × 5 数组下所示： int maze[5][5] = { 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, }; 它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。 入口点为[0,0],既第一格是可以走的路。 数据范围： 2≤n,m≤10 ， 输入的内容只包含 0≤val≤1。 输入描述： 输入两个整数，分别表示二维数组的行数，列数。 再输入相应的数组，其中的1表示墙壁，0表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。 输出描述： 左上角到右下角的最短路径，格式如样例所示。 输入：5 5 0 1 0 0 0 0 1 1 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0 输出：(0,0) (1,0) (2,0) (2,1) (2,2) (2,3) (2,4) (3,4) (4,4) 题解\nstatic int n; // 矩阵行数 static int m; // 矩阵列数 static int[][] matrix; // 矩阵 public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); m = sc.nextInt(); matrix = new int[n][m]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { matrix[i][j] = sc.nextInt(); } } getResult(); } // 点类 static class Pos { int x; // 当前点的横坐标 int y; // 当前点的纵坐标 Pos pre; // 当前点的上一个点（此属性用于形成路径链） public Pos(int x, int y, Pos pre) { this.x = x; this.y = y; this.pre = pre; } } public static void getResult() { // 广搜队列 LinkedList\u0026lt;Pos\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // 将（0，0）位置标记为“走过状态”，即将元素值设为2 matrix[0][0] = 2; // 将走过的点加入队列 queue.add(new Pos(0, 0, null)); // 上下左右偏移量 int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 广搜 while (queue.size() \u0026gt; 0) { // 当前点 Pos cur = queue.removeFirst(); // 遍历当前点的上、下、左、右方向的新点 for (int[] offset : offsets) { // 新点的坐标 int newX = cur.x + offset[0]; int newY = cur.y + offset[1]; // 如果新点不越界，且未被访问过，且不是墙， 则新点可以访问 if (newX \u0026gt;= 0 \u0026amp;\u0026amp; newX \u0026lt; n \u0026amp;\u0026amp; newY \u0026gt;= 0 \u0026amp;\u0026amp; newY \u0026lt; m \u0026amp;\u0026amp; matrix[newX][newY] == 0) { // 将新点状态设为走过 matrix[newX][newY] = 2; // 将新点和上一个点关联，形成路径链 Pos next = new Pos(newX, newY, cur); queue.add(next); // 如果新点就是终点，那么则说明找到了起点到终点的路径 if (newX == n - 1 \u0026amp;\u0026amp; newY == m - 1) { // 打印路径 printPath(next); // 结束查找 return; } } } } } public static void printPath(Pos cur) { // 这里采用递归打印，保证打印顺序是起点到终点 if (cur.pre != null) { // 递归的作用是优先打印pre点，pre点打印完，回溯打印cur点 printPath(cur.pre); } System.out.println(\u0026#34;(\u0026#34; + cur.x + \u0026#34;,\u0026#34; + cur.y + \u0026#34;)\u0026#34;); } 16. 模拟目录管理功能\r#\r描述\n实现一个模拟目录管理功能的软件，输入一个命令序列，输出最后一条命令运行结果。 支持命令： 1. 创建目录命令：mkdir 目录名称， 如 mkdir abc 为在当前目录创建abc目录，如果已存在同名目录则不执行任何操作。此命令无输出。 2. 进入目录命令：cd 目录名称， 如 cd abc 为进入abc目录，如果目录不存在则不执行任何操作。此命令无输出。 特别地，cd .. 为返回上级目录 3. 查看当前所在路径命令：pwd，输出当前路径字符串。 约束： 1. 目录名称仅支持小写字母；mkdir 和 cd 命令的参数仅支持单个目录，如：mkdir abc 和 cd abc； 不支持嵌套路径和绝对路径，如 mkdir abc/efg，cd abc/efg，mkdir /abc/efg，cd /abc/efg 是不支持的。 2. 目录符号为/，根目录/作为初始目录。 3. 任何不符合上述定义的无效命令不做任何处理并且无输出。 输入描述： 输入 N 行字符串，每一行字符串是一条命令。 输出描述： 输出最后一条命令运行结果字符串。 备注： 命令行数限制100行以内，目录名称限制10个字符以内。 输入：mkdir abc cd abc pwd 输出：/abc/ 说明：在根目录创建一个abc的目录并进入abc目录中查看当前目录路径，输出当前路径/abc/。 题解\nstatic class TreeNode { String curDicName; TreeNode father; HashMap\u0026lt;String, TreeNode\u0026gt; children; public TreeNode(String curDicName, TreeNode father) { this.curDicName = curDicName; this.father = father; this.children = new HashMap\u0026lt;\u0026gt;(); } } static class Tree { TreeNode root; TreeNode cur; public Tree() { // root是根目录，根目录 / 作为初始目录 this.root = new TreeNode(\u0026#34;/\u0026#34;, null); // cur用于指向当前正在操作的目录 this.cur = root; } public void mkdir(String childDicName) { // mkdir 目录名称，如 mkdir abc 为在当前目录创建abc目录，如果已存在同名目录则不执行任何操作 TreeNode node = new TreeNode(childDicName + \u0026#34;/\u0026#34;, this.cur); this.cur.children.putIfAbsent( childDicName, node); } public void cd(String dicName) { if (dicName.equals(\u0026#34;..\u0026#34;)) { // cd .. 为返回上级目录，如果目录不存在则不执行任何操作 if (this.cur.father != null) { // cur 变更指向上级目录 this.cur = this.cur.father; } } else { // cd 目录名称，如 cd abc 为进入abc目录，如果目录不存在则不执行任何操作 if (this.cur.children.containsKey(dicName)) { // cur 变更指向下级目录 this.cur = this.cur.children.get(dicName); } } } public String pwd() { // 输出当前路径字符串 StringBuilder sb = new StringBuilder(); // 倒序路径，即不停向上找父目录 TreeNode cur = this.cur; while (cur != null) { // 头插目录名，保证路径中目录层级正确 sb.insert(0, cur.curDicName); cur = cur.father; } return sb.toString(); } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); // 初始化目录结构 Tree tree = new Tree(); // 记录最后一条命令的输出 String lastCommandOutPut = \u0026#34;\u0026#34;; outer: while (sc.hasNextLine()) { String line = sc.nextLine(); if (line.isEmpty()) break; String[] tmp = line.split(\u0026#34; \u0026#34;); String cmd_key = tmp[0]; if (cmd_key.equals(\u0026#34;pwd\u0026#34;)) { // pwd 命令不需要参数 if (tmp.length != 1) continue; lastCommandOutPut = tree.pwd(); } else if (cmd_key.equals(\u0026#34;mkdir\u0026#34;) || cmd_key.equals(\u0026#34;cd\u0026#34;)) { // 约束：mkdir 和 cd 命令的参数仅支持单个目录，如：mkdir abc 和 cd abc if (tmp.length != 2) continue; // 目录名 String cmd_val = tmp[1]; if (!(cmd_key.equals(\u0026#34;cd\u0026#34;) \u0026amp;\u0026amp; cmd_val.equals(\u0026#34;..\u0026#34;))) { // 目录名约束校验 // 约束：目录名称仅支持小写字母 // 约束：不支持嵌套路径和绝对路径， // 关于嵌套路径和绝对路径， // 我简单理解就是cmd_val含有\u0026#39;/\u0026#39;字符，可以被小写字母判断涵盖住 for (int i = 0; i \u0026lt; cmd_val.length(); i++) { char c = cmd_val.charAt(i); if (c \u0026lt; \u0026#39;a\u0026#39; || c \u0026gt; \u0026#39;z\u0026#39;) continue outer; } } if (cmd_key.equals(\u0026#34;mkdir\u0026#34;)) { tree.mkdir(cmd_val); // 题目进要求输出最后一个命令的运行结果， // 因此，对于无输出的命令，我认为需要覆盖掉前面的命令的输出结果 lastCommandOutPut = \u0026#34;\u0026#34;; } else { tree.cd(cmd_val); lastCommandOutPut = \u0026#34;\u0026#34;; } } } System.out.println(lastCommandOutPut); } 17. 模拟数据序列化传输\r#\r描述\n模拟一套简化的序列化传输方式，请实现下面的数据编码与解码过程 1. 编码前数据格式为 [位置,类型,值]，多个数据的时候用逗号分隔，位置仅支持数字，不考虑重复等场景； 类型仅支持：Integer / String / Compose（Compose的数据类型表示该存储的数据也需要编码） 2. 编码后数据参考图示，数据区的格式是：位置#类型#长度#数据， 类型存储需要编码，Integer-\u0026gt;0；String-\u0026gt;1；Compose-\u0026gt;2，长度是指数据的字符长度；数据仅允许数字、大小写字母、空格。 3. 输入的编码字符长度不能超过1000，一个数据的格式错误，则解析剩下数据，其他错误输出ENCODE_ERROR。 4. 输入的解码字符不能超过1000，数据区异常则跳过继续解析剩余数据区，其他异常输出DECODE_ERROR。 输入描述： 第一行是命令，1表示编码，2表示解码 第二行输入待编码、解码的字符 数据最多嵌套10层，[1,Compose,[1,String,Second]] 为2层嵌套。 输出描述： 如果输入要求是编码，则输出编码结果； 如果输入要求是解码，则输出解码结果； 当异常时输出对应的错误字符。 输入：1 [1,String,I am Mary],[2,Integer,23],[3,Long,1000000],[4,Compose,[1,String,I am Kitty],[2,Integer,44]] 输出：1#1#9#I am Mary2#0#2#234#2#25#1#1#10#I am Kitty2#0#2#44 输入：2 1#1#9#I am Mary2#0#2#233#0#3#8794#2#25#1#1#10#I am Kitty2#0#2#44 输出：[I,String,I am Mary],[2,Integer,23],[3,Integer,879],[4,Compose,[1,String,I am Kitty],[2,Integer,44]] 题解\n// 编码时，类型 -\u0026gt; 数值 static HashMap\u0026lt;String, String\u0026gt; type2num = new HashMap\u0026lt;\u0026gt;(); // 解码时，数值 -\u0026gt; 类型 static HashMap\u0026lt;String, String\u0026gt; num2type = new HashMap\u0026lt;\u0026gt;(); static Pattern num_RegExp = Pattern.compile(\u0026#34;^\\\\d+$\u0026#34;); static Pattern str_RegExp = Pattern.compile(\u0026#34;^[0-9a-zA-Z\\\\s]+$\u0026#34;); public static void main(String[] args) { Scanner sc = new Scanner(System.in); int command = Integer.parseInt(sc.nextLine()); String str = sc.nextLine(); // 编码时，类型 -\u0026gt; 数值 type2num.put(\u0026#34;Integer\u0026#34;, \u0026#34;0\u0026#34;); type2num.put(\u0026#34;String\u0026#34;, \u0026#34;1\u0026#34;); type2num.put(\u0026#34;Compose\u0026#34;, \u0026#34;2\u0026#34;); // 解码时，数值 -\u0026gt; 类型 num2type.put(\u0026#34;0\u0026#34;, \u0026#34;Integer\u0026#34;); num2type.put(\u0026#34;1\u0026#34;, \u0026#34;String\u0026#34;); num2type.put(\u0026#34;2\u0026#34;, \u0026#34;Compose\u0026#34;); switch (command) { case 1: System.out.println(encode(str)); break; case 2: try { System.out.println(decode(str)); } catch (Exception e) { // 待解码字符串如果解码过程中发生了异常，则说明格式或者嵌套关系存在问题，则此时报错 System.out.println(\u0026#34;DECODE_ERROR\u0026#34;); } break; } } // 校验待编码的字符串的格式 public static boolean check_encode_str(String str) { // 这里通过栈结构检查代编码字符串中[,]字符的闭合 LinkedList\u0026lt;Character\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; str.length(); i++) { char c = str.charAt(i); if (c == \u0026#39;]\u0026#39;) { while (!stack.isEmpty() \u0026amp;\u0026amp; stack.getLast() != \u0026#39;[\u0026#39;) { stack.removeLast(); } if (stack.isEmpty()) { return false; } else { stack.removeLast(); } } else { stack.addLast(c); } } return stack.isEmpty(); } public static boolean check_encoded(String pos, String type, String data) { if (!num_RegExp.matcher(pos).find()) { return false; } if (!type2num.containsKey(type)) { return false; } if (\u0026#34;Integer\u0026#34;.equals(type)) { return num_RegExp.matcher(data).find(); } else if (\u0026#34;String\u0026#34;.equals(type)) { return str_RegExp.matcher(data).find(); } return true; } // 编码 public static String encode(String s) { // 去除数据与数据之间的逗号后 s = s.replaceAll(\u0026#34;],\\\\[\u0026#34;, \u0026#34;][\u0026#34;); // 待编码字符串的格式校验 if (!check_encode_str(s)) { return \u0026#34;ENCODE_ERROR\u0026#34;; } // 由于后面我想用正则匹配取出字符串中 \u0026#34;[位置,类型,值]\u0026#34; 信息，而 \u0026#39;[\u0026#39;, \u0026#39;]\u0026#39; 字符又是正则表达式的元字符 // 因此为了简单实现正则，这里先将待编码字符串str中所有 \u0026#39;[\u0026#39; 替换为 \u0026#39;\u0026lt;\u0026#39;, 所有 \u0026#39;]\u0026#39; 替换为 \u0026#39;\u0026gt;\u0026#39; s = s.replaceAll(\u0026#34;\\\\[\u0026#34;, \u0026#34;\u0026lt;\u0026#34;).replaceAll(\u0026#34;]\u0026#34;, \u0026#34;\u0026gt;\u0026#34;); // 该正则用于匹配出待编码字符串中 \u0026#34;\u0026lt;位置,类型,值\u0026gt;\u0026#34; Pattern p = Pattern.compile(\u0026#34;\u0026lt;([^\u0026lt;\u0026gt;]+)\u0026gt;\u0026#34;); while (true) { Matcher m = p.matcher(s); if (!m.find()) break; // m.group(0) 是正则匹配到的完整子串 \u0026#34;\u0026lt;位置,类型,值\u0026gt;\u0026#34; // m.group(1)用于获取是第一个正则捕获组，所谓正则捕获组， // 即正则表达式中()中的正则能匹配到的内容， // 如上正则捕获组即为：[^\u0026lt;\u0026gt;]+, 匹配到的内容是：\u0026#34;位置,类型,值\u0026#34; String[] tmp = m.group(1).split(\u0026#34;,\u0026#34;); String pos = tmp[0]; String type = tmp[1]; String data = tmp[2]; // sj记录编码内容 String encodeStr = \u0026#34;\u0026#34;; if (check_encoded(pos, type, data)) { encodeStr = pos + \u0026#34;#\u0026#34; + type2num.get(type) + \u0026#34;#\u0026#34; + data.length() + \u0026#34;#\u0026#34; + data; } s = s.replace(m.group(0), encodeStr); // 将匹配到的内容 替换为 编码后的内容 } return s; } public static boolean check_decoded(String pos, String type, String data) { if (!num_RegExp.matcher(pos).find()) { return false; } if (!num2type.containsKey(type)) { return false; } if (\u0026#34;0\u0026#34;.equals(type)) { return num_RegExp.matcher(data).find(); } else if (\u0026#34;1\u0026#34;.equals(type)) { return str_RegExp.matcher(data).find(); } return true; } // 解码 public static String decode(String str) { // 解码有如下难点： // 1、各数据区之间没有分隔符，即无法直接分离出各个数据区 // 2、Compose类型数据区的\u0026#34;数据\u0026#34;部分也是一个或多个数据区组合 // 我这里直接将待解码字符串str按照\u0026#39;#\u0026#39;分割, 并加入到队列中, 方便头部出队 LinkedList\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); Collections.addAll(queue, str.split(\u0026#34;#\u0026#34;)); // res记录解码后的内容 StringJoiner res = new StringJoiner(\u0026#34;,\u0026#34;); // 如果队列不空，则继续循环 while (!queue.isEmpty()) { // 如果待解码字符串是合法的，则： // 第一个#分割出来的内容认定为当前数据区的pos String pos = queue.removeFirst(); // 第二个#分割出来的内容认定为当前数据区的type String type = queue.removeFirst(); // 第三个#分割出来的内容认定为当前数据区的len int len = Integer.parseInt(queue.removeFirst()); // 剩余部分重新以#拼接 String remain = String.join(\u0026#34;#\u0026#34;, queue); queue.clear(); // remain字符串的 [0,len) 部分作为当前数据区的data信息 String data = remain.substring(0, len); if (remain.length() \u0026gt; len) { // remain字符串的 [len,end) 部分是其他数据区，按照#分割后重新入队 Collections.addAll(queue, remain.substring(len).split(\u0026#34;#\u0026#34;)); } if (\u0026#34;2\u0026#34;.equals(type)) { data = decode(data); } // pos, type, data都合法则进行解法 if (check_decoded(pos, type, data)) { // 解码 res.add(\u0026#34;[\u0026#34; + pos + \u0026#34;,\u0026#34; + num2type.get(type) + \u0026#34;,\u0026#34; + data + \u0026#34;]\u0026#34;); } } return res.toString(); } 18. 攀登者2\r#\r描述\n攀登者喜欢寻找各种地图，并且尝试攀登到最高的山峰。 地图表示为一维数组，数组的索引代表水平位置，数组的元素代表相对海拔高度。其中数组元素0代表地面。 一个山脉可能有多座山峰(高度大于相邻位置的高度，或在地图边界且高度大于相邻的高度)。 例如：[0,1,2,4,3,1,0,0,1,2,3,1,2,1,0]，代表如下图所示的地图，地图中有两个山脉位置分别为 1,2,3,4,5 和 8,9,10,11,12,13，最高峰高度分别为 4,3。最高峰位置分别为3,10。 登山时会消耗登山者的体力(整数)， 1. 上山时，消耗相邻高度差两倍的体力 2. 下山时，消耗相邻高度差一倍的体力 3. 平地不消耗体力 4. 登山者体力消耗到零时会有生命危险。 例如，上图所示的山峰： 从索引0，走到索引1，高度差为1，需要消耗 2 * 1 = 2 的体力， 从索引2，走到索引3，高度差为2，需要消耗 2 * 2 = 4 的体力。 从索引3，走到索引4，高度差为1，需要消耗 1 * 1 = 1 的体力。 攀登者想要评估一张地图内有多少座山峰可以进行攀登，且可以安全返回到地面，且无生命危险。 例如上图中的数组，有3个不同的山峰，登上位置在3的山可以从位置0或者位置6开始，从位置0登到山顶需要消耗体力 1 * 2 + 1 * 2 + 2 * 2 = 8，从山顶返回到地面0需要消耗体力 2 * 1 + 1 * 1 + 1 * 1 = 4 的体力，按照登山路线 0 → 3 → 0 需要消耗体力12。攀登者至少需要12以上的体力（大于12）才能安全返回。 输入描述： 第一行输入为地图一维数组 第二行输入为攀登者的体力 输出描述： 确保可以安全返回地面，且无生命危险的情况下，地图中有多少山峰可以攀登。 输入：0,1,4,3,1,0,0,1,2,3,1,2,1,0 13 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] heights = Arrays.stream(sc.nextLine().split(\u0026#34;,\u0026#34;)).mapToInt(Integer::parseInt).toArray(); int strength = Integer.parseInt(sc.nextLine()); System.out.println(getResult(heights, strength)); } // 算法实现（本题实际考试为核心代码模式，因此考试时只需要写出此函数实现即可） public static int getResult(int[] heights, int strength) { // 记录可攀登的山峰索引 HashSet\u0026lt;Integer\u0026gt; idxs = new HashSet\u0026lt;\u0026gt;(); // 正向攀登 climb(heights, strength, idxs, true); // 逆序攀登 reverse(heights); climb(heights, strength, idxs, false); return idxs.size(); } public static void climb(int[] heights, int strength, HashSet\u0026lt;Integer\u0026gt; idxs, boolean direction) { // 找到第一个地面位置 int j = 0; while (j \u0026lt; heights.length \u0026amp;\u0026amp; heights[j] != 0) { j++; } int cost = 0; // 攀登体力总消耗（包括上山，下山） // int upCost = 0; // 上山体力消耗 // int downCost = 0; // 下山体力消耗 // 开始攀登 for (int i = j + 1; i \u0026lt; heights.length; i++) { // 如果遇到了新的地面，则从新的地面位置重新计算攀登消耗的体力 if (heights[i] == 0) { cost = 0; // upCost = 0; // downCost = 0; continue; } int diff = heights[i] - heights[i - 1]; // diff记录高度差 if (diff \u0026gt; 0) { // 如果过程是上坡 cost += diff * 3; // upCost += diff * 2; // 则上山时，体力消耗 = 高度差 * 2 // downCost += diff; // 相反的下山时，体力消耗 = 高度差 * 1 // 由于 height[i] \u0026gt; heights[i-1]，因此如果 height[i] \u0026gt; heights[i+1] 的话，位置 i 就是山顶 if (i + 1 \u0026gt;= heights.length || heights[i] \u0026gt; heights[i + 1]) { // 计算攀登此山顶的上山下山消耗的体力和 if (cost \u0026lt; strength) { // if (upCost + downCost \u0026lt;= strength) { // 如果小于自身体力，则可以攀登 if (direction) { idxs.add(i); } else { // 需要注意，逆序heights数组后，我们对于的山峰位置需要反转 idxs.add(heights.length - i - 1); } } } } else if (diff \u0026lt; 0) { // 如果过程是下坡 cost -= diff * 3; // upCost -= diff; // 则上山时，体力消耗 = 高度差 * 1 // downCost -= diff * 2; // 相反的下山时，体力消耗 = 高度差 * 2 // heights[i] \u0026lt; heights[i-1]，因此位置i不可能是山顶 } } } public static void reverse(int[] nums) { int i = 0; int j = nums.length - 1; while (i \u0026lt; j) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; i++; j--; } } 19. 启动多任务排序\r#\r描述\n一个应用启动时，会有多个初始化任务需要执行，并且任务之间有依赖关系， 例如A任务依赖B任务，那么必须在B任务执行完成之后，才能开始执行A任务。 现在给出多条任务依赖关系的规则，请输入任务的顺序执行序列，规则采用贪婪策略，即一个任务如果没有依赖的任务，则立刻开始执行，如果同时有多个任务要执行，则根据任务名称字母顺序排序。 例如：B任务依赖A任务，C任务依赖A任务，D任务依赖B任务和C任务，同时，D任务还依赖E任务。那么执行任务的顺序由先到后是： A任务，E任务，B任务，C任务，D任务 输入描述： 输入参数每个元素都表示任意两个任务之间的依赖关系，输入参数中符号\u0026#34;-\u0026gt;\u0026#34;表示依赖方向 例如：A-\u0026gt;B，表示A依赖B，多个依赖之间用单个空格分隔 输出描述： 输出排序后的启动任务列表，多个任务之间用单个空格分隔 输入：A-\u0026gt;B C-\u0026gt;B 输出：B A C 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); String[][] relations =Arrays.stream(split).map(s -\u0026gt; s.split(\u0026#34;-\u0026gt;\u0026#34;)).toArray(String[][]::new); HashMap\u0026lt;String, Integer\u0026gt; inDegree = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;String, ArrayList\u0026lt;String\u0026gt;\u0026gt; next = new HashMap\u0026lt;\u0026gt;(); for (String[] relation : relations) { // a依赖b, 即b执行完，才能执行a String a = relation[0]; String b = relation[1]; // b的入度不变 inDegree.put(b, inDegree.getOrDefault(b, 0)); // a的入度+1 inDegree.put(a, inDegree.getOrDefault(a, 0) + 1); // b的后继节点集合添加a next.putIfAbsent(b, new ArrayList\u0026lt;\u0026gt;()); next.get(b).add(a); // a的后继节点集合不变 next.putIfAbsent(a, new ArrayList\u0026lt;\u0026gt;()); } // queue收集第一层入度为0的点 ArrayList\u0026lt;String\u0026gt; queue = new ArrayList\u0026lt;\u0026gt;(); for (String task : inDegree.keySet()) { if (inDegree.get(task) == 0) { queue.add(task); } } // 记录任务执行的顺序 StringJoiner ans = new StringJoiner(\u0026#34; \u0026#34;); while (!queue.isEmpty()) { // 如果同时有多个任务要执行，则根据任务名称字母顺序排序 queue.sort(String::compareTo); // newQueue用于记录下一层入度为0的点 ArrayList\u0026lt;String\u0026gt; newQueue = new ArrayList\u0026lt;\u0026gt;(); for (String fa : queue) { // fa执行，则加入已完成的任务列表 ans.add(fa); for (String ch : next.get(fa)) { // fa是父任务，ch是子任务, 即fa执行完，才能执行ch // fa执行完，则对应ch的入度-1 inDegree.put(ch, inDegree.get(ch) - 1); // 如果ch的入度变为0，则加入新一层入度0的点集 if (inDegree.get(ch) == 0) { newQueue.add(ch); } } } queue = newQueue; } System.out.println(ans); } 20. 抢7游戏\r#\r描述\nA、B两个人玩抢7游戏，游戏规则为： A先报一个起始数字 X（10 ≤ 起始数字 ≤ 10000），B报下一个数字 Y （X - Y ＜ 3），A再报一个数字 Z（Y - Z ＜ 3）， 以此类推，直到其中一个抢到7，抢到7即为胜者； B赢得比赛的情况下，一共有多少种组合？ 输入描述： 起始数字 M，10 ≤ M ≤ 10000 输出描述： B能赢得比赛的组合次数 输入：10 输出：1 题解\nstatic BigInteger[] factor; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); initFactor(m - 7); int oneCount = m - 7; int twoCount = 0; // 记录B赢的情况数 BigInteger ans = new BigInteger(\u0026#34;0\u0026#34;); while (oneCount \u0026gt;= 0) { // 叫的次数为奇数时，才能B赢 if ((oneCount + twoCount) % 2 != 0) { ans = ans.add(getPermutationCount(oneCount, twoCount)); } // 合并两个1为一个2 oneCount -= 2; twoCount += 1; } System.out.println(ans); } // 求解不重复的全排列数 public static BigInteger getPermutationCount(int oneCount, int twoCount) { if (oneCount == 0 || twoCount == 0) { // 即 1 1 1 1 1 或 2 2 2 这种情况，此时只有一种排列 return new BigInteger(\u0026#34;1\u0026#34;); } else { // 排列数去重，比如 1 1 1 2 2 的不重复排列数为 5! / 3! / 2! = 10 return factor[oneCount + twoCount].divide(factor[oneCount].multiply(factor[twoCount])); } } // 阶乘 public static void initFactor(int n) { factor = new BigInteger[n + 1]; factor[0] = new BigInteger(\u0026#34;1\u0026#34;); for (int i = 1; i \u0026lt;= n; i++) { factor[i] = factor[i - 1].multiply(new BigInteger(i + \u0026#34;\u0026#34;)); } } 21. 亲子游戏\r#\r描述\n宝宝和妈妈参加亲子游戏，在一个二维矩阵（N*N）的格子地图上， 宝宝和妈妈抽签决定各自的位置，地图上每个格子有不同的糖果数量，部分格子有障碍物。 游戏规则是妈妈必须在最短的时间（每个单位时间只能走一步）到达宝宝的位置，路上的所有糖果都可以拿走，不能走障碍物的格子，只能上下左右走。 请问妈妈在最短到达宝宝位置的时间内最多拿到多少糖果（优先考虑最短时间到达的情况下尽可能多拿糖果）。 输入描述： 第一行输入为 N，N 表示二维矩阵的大小 之后 N 行，每行有 N 个值，表格矩阵每个位置的值，其中： -3：妈妈 -2：宝宝 -1：障碍 ≥0：糖果数（0表示没有糖果，但是可以走） 输出描述： 输出妈妈在最短到达宝宝位置的时间内最多拿到多少糖果，行末无多余空格 备注： 地图最大 50*50 输入：4 3 2 1 -3 1 -1 1 1 1 1 -1 2 -2 1 2 3 输出：9 题解\nstatic int n; static int[][] matrix; static int[][] candy; static int[][] offsets = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); matrix = new int[n][n]; candy = new int[n][n]; LinkedList\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { candy[i][j] = -1; matrix[i][j] = sc.nextInt(); // 妈妈的位置 if (matrix[i][j] == -3) { candy[i][j] = 0; queue.add(i * n + j); // 二维坐标一维化 } } } // 记录题解 int ans = -1; // bfs 按层扩散 while (!queue.isEmpty()) { // 记录当前扩散层的点 LinkedList\u0026lt;Integer\u0026gt; newQueue = new LinkedList\u0026lt;\u0026gt;(); // 当前层是否有宝宝所在的点 boolean flag = false; for (int pos : queue) { // 源点坐标 int x = pos / n; int y = pos % n; // 向四个方向扩散 for (int[] offset : offsets) { // 当前扩散点坐标 int newX = x + offset[0]; int newY = y + offset[1]; // 当前扩散点坐标越界，或者扩散点是墙，则无法扩散 if (newX \u0026lt; 0 || newX \u0026gt;= n || newY \u0026lt; 0 || newY \u0026gt;= n || matrix[newX][newY] == -1) { continue; } // 当前扩散点坐标对应的糖果数量为-1，说明对应扩散点坐标位置还没有加入到当前扩散层 if (candy[newX][newY] == -1) { newQueue.addLast(newX * n + newY); // 加入当前扩散层 } // 当前扩散点可能会被多个源点扩散到，因此比较保留扩散过程中带来的较大糖果数 // candy[newX][newY] 记录的是当前扩散点获得的糖果数 // candy[x][y] + Math.max(0, matrix[newX][newY]) // 记录的是从源点(x,y)带来的糖果数 + (newX,newY)位置原本的糖果数 candy[newX][newY] = Math.max(candy[newX][newY], candy[x][y] + Math.max(0, matrix[newX][newY])); // 如果当前扩散点是宝宝位置，则可以停止后续层级的bfs扩散， // 因为已经找到宝宝的最短路径长度（即扩散层数） if (matrix[newX][newY] == -2) { ans = candy[newX][newY]; flag = true; } } } // 已经找到去宝宝位置的最短路径和最大糖果数，则终止bfs if (flag) break; // 否则继续 queue = newQueue; } System.out.println(ans); } 22. 任务最优调度\r#\r描述\n给定一个正整数数组表示待系统执行的任务列表，数组的每一个元素代表一个任务，元素的值表示该任务的类型。 请计算执行完所有任务所需的最短时间。 任务执行规则如下: 1. 任务可以按任意顺序执行，且每个任务执行耗时间均为1个时间单位。 2. 两个同类型的任务之间必须有长度为N个单位的冷却时间， 比如N为2时，在时间K执行了类型3的任务，那么K+1和K+2两个时间不能执行类型3任务。 3. 系统在任何一个单位时间内都可以执行一个任务，或者等待状态。 说明：数组最大长度为1000，数组最大值1000。 输入描述： 第一行记录一个用半角逗号分隔的数组，数组长度不超过1000，数组元素的值不超过1000， 第二行记录任务冷却时间，N为正整数，N≤100。 输出描述： 输出为执行完所有任务所需的最短时间。 输出描述： 输出为执行完所有任务所需的最短时间。 输入：2,2,2,3 2 输出：7 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] tasks = Arrays.stream(sc.next().split(\u0026#34;,\u0026#34;)).mapToInt(Integer::parseInt).toArray(); int n = sc.nextInt(); System.out.println(getResult(tasks, n)); } public static int getResult(int[] tasks, int n) { HashMap\u0026lt;Integer, Integer\u0026gt; cnts = new HashMap\u0026lt;\u0026gt;(); for (int task : tasks) { cnts.put(task, cnts.getOrDefault(task, 0) + 1); } // k表示:最多任务的数量 // 比如2,2,2,3， 其中任务2数量最多，有3个，则k = 3 int k = cnts.values().stream().max((a, b) -\u0026gt; a - b).orElse(0); // p表示:数量为k的任务个数 // 比如2,2,2,3,3,3,4， 其中数量为3的任务有2个，分别是任务2，任务3，则p=2 int p = 0; for (Integer task : cnts.keySet()) { if (cnts.get(task) == k) p++; } return Math.max((k - 1) * (n + 1) + p, tasks.length); } 23. 数字排列\r#\r描述\n小明负责公司年会，想出一个趣味游戏： 屏幕给出 1 ~ 9 中任意 4 个不重复的数字，大家以最快时间给出这几个数字可拼成的数字从小到大排列位于第 N 位置的数字， 其中 N 为给出数字中最大的（如果不到这么多数字则给出最后一个即可）。 注意： 2 可以当作 5 来使用，5 也可以当作 2 来使用进行数字拼接，且屏幕不能同时给出 2 和 5； 6 可以当作 9 来使用，9 也可以当作 6 来使用进行数字拼接，且屏幕不能同时给出 6 和 9。 如给出：1，4，8，7，则可以拼接的数字为： 1，4，7，8，14，17，18，41，47，48，71，74，78，81，84，87，147，148，178 ... (省略后面的数字) 那么第 N （即8）个的数字为 41。 输入描述： 输入以逗号分隔的 4 个 int 类型整数的字符串。 输出描述： 输出为这几个数字可拼成的数字从小大大排列位于第 N （N为输入数字中最大的数字）位置的数字， 如果输入的数字不在范围内或者有重复，则输出-1。 输入：1,4,8,7 输出：41 输入：3,9,7,8 输出：39 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34;,\u0026#34;); int[] nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(solution(nums)); } public static int solution(int[] nums) { HashSet\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); int n = Integer.MIN_VALUE; for (int num : nums) { if (num \u0026lt; 1 || num \u0026gt; 9) { // 输入的数字不在范围内 return -1; } else { set.add(num); n = Math.max(n, num); } } // 输入的数字有重复 if (set.size() != 4) return -1; // 屏幕不能同时给出 2 和 5 if (set.contains(2) \u0026amp;\u0026amp; set.contains(5)) return -1; // 屏幕不能同时给出 6 和 9 if (set.contains(6) \u0026amp;\u0026amp; set.contains(9)) return -1; HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(2, 5); map.put(5, 2); map.put(6, 9); map.put(9, 6); boolean[] vis = new boolean[nums.length]; String path = \u0026#34;\u0026#34;; // 记录排列 ArrayList\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); // 排列求解 dfs(nums, vis, path, map, res); // 给出这几个数字可拼成的数字从小到大排列位于第 N 位置的数字 res.sort((a, b) -\u0026gt; a - b); // N为给出数字中最大的，如果不到这么多数字则给出最后一个即可 n = Math.min(n, res.size()); return res.get(n - 1); } // 排列求解 public static void dfs(int[] nums, boolean[] vis, String path, HashMap\u0026lt;Integer, Integer\u0026gt; map, ArrayList\u0026lt;Integer\u0026gt; res) { if (!path.isEmpty()) { res.add(Integer.parseInt(path)); } if (path.length() == nums.length) { return; } for (int i = 0; i \u0026lt; nums.length; i++) { if (vis[i]) continue; vis[i] = true; dfs(nums, vis, path + nums[i], map, res); // 2 可以当作 5 来使用，5 也可以当作 2 来使用进行数字拼接 // 6 可以当作 9 来使用，9 也可以当作 6 来使用进行数字拼接 if (map.containsKey(nums[i])) { dfs(nums, vis, path + map.get(nums[i]), map, res); } vis[i] = false; } } 24. 数组二叉树\r#\r描述\n二叉树也可以用数组来存储，给定一个数组，树的根节点的值存储在下标1， 对于存储在下标N的节点，它的左子节点和右子节点分别存储在下标2*N和2*N+1，并且我们用值-1代表一个节点为空。 给定一个数组存储的二叉树，试求从根节点到最小的叶子节点的路径，路径由节点的值组成。 输入描述： 输入一行为数组的内容，数组的每个元素都是正整数，元素间用空格分隔。 注意第一个元素即为根节点的值，即数组的第N个元素对应下标N，下标0在树的表示中没有使用，所以我们省略了。 输入的树最多为7层。 输出描述： 输出从根节点到最小叶子节点的路径上，各个节点的值，由空格分隔，用例保证最小叶子节点只有一个。 输入：3 5 7 -1 -1 2 4 输出：3 7 2 输入：5 9 8 -1 -1 7 -1 -1 -1 -1 -1 6 输出：5 8 7 6 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); Integer[] arr =Arrays.stream(split).map(Integer::parseInt).toArray(Integer[]::new); System.out.println(getResult(arr)); } public static String getResult(Integer[] arr) { int n = arr.length - 1; // 最小叶子节点的值 int min = Integer.MAX_VALUE; // 最小叶子节点的索引 int minIdx = -1; // 求解最小叶子节点的值和索引 for (int i = n; i \u0026gt;= 1; i--) { if (arr[i] != -1) { if (i * 2 + 1 \u0026lt;= n \u0026amp;\u0026amp; arr[i * 2 + 1] != -1) continue; if (i * 2 + 2 \u0026lt;= n \u0026amp;\u0026amp; arr[i * 2 + 2] != -1) continue; if (min \u0026gt; arr[i]) { min = arr[i]; minIdx = i; } } } // path用于缓存最小叶子节点到根的路径 LinkedList\u0026lt;Integer\u0026gt; path = new LinkedList\u0026lt;\u0026gt;(); path.addFirst(min); // 从最小叶子节点开始向上找父节点，直到树顶 while (minIdx != 0) { int f = (minIdx - 1) / 2; path.addFirst(arr[f]); minIdx = f; } StringJoiner sj = new StringJoiner(\u0026#34; \u0026#34;); for (Integer val : path) sj.add(val + \u0026#34;\u0026#34;); return sj.toString(); } 25. 贪吃的猴子\r#\r描述\n一只贪吃的猴子，来到一个果园，发现许多串香蕉排成一行，每串香蕉上有若干根香蕉。每串香蕉的根数由数组numbers给出。 猴子获取香蕉，每次都只能从行的开头或者末尾获取，并且只能获取N次，求猴子最多能获取多少根香蕉。 输入描述： 第一行为数组numbers的长度 第二行为数组numbers的值每个数字通过空格分开 第三行输入为N，表示获取的次数 输出描述： 按照题目要求能获取的最大数值 备注： 1 ≤ numbers.length ≤ 100000 1 ≤ numbers ≤ 100 1 ≤ N ≤ numbers.length 输入：7 1 2 2 7 3 6 1 3 输出：10 输入：3 1 2 3 3 输出：6 输入：4 4 2 2 3 2 输出：7 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int len = Integer.parseInt(sc.nextLine()); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); int n = Integer.parseInt(sc.nextLine()); System.out.println(getResult(len, nums, n)); } public static int getResult(int len, int[] nums, int n) { // 初始时，左边选择0个，因此左边选择的香蕉数为 0 int leftSum = 0; // 初始时，右边选择n个，因此右边选择的香蕉数为 nums[len-n] ~ nums[len - 1] 这个n个元素之和 int rightSum = 0; for (int i = len - n; i \u0026lt; len; i++) { rightSum += nums[i]; } // 如果选择数n == len，即全选，此时直接返回初始rightSum if (len == n) { return rightSum; } // 如果不是全选 // sum记录当前选择结果 int sum = leftSum + rightSum; // ans记录所有选择结果中最大的 int ans = sum; // l指向左边将要获得的，即左边获得一个 int l = 0; // r指向右边将要失去的，即右边失去一个 int r = len - n; while (l \u0026lt; n) { sum += nums[l++] - nums[r++]; ans = Math.max(ans, sum); } return ans; } "},{"id":279,"href":"/algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%9313/","title":"机试题库 - 13","section":"华为OD","content":"\r01. 贪吃蛇\r#\r描述\n贪吃蛇是一个经典游戏，蛇的身体由若干方格连接而成，身体随蛇头移动。蛇头触碰到食物时，蛇的长度会增加一格。 蛇头和身体的任一方格或者游戏版图边界碰撞时，游戏结束。 贪吃蛇游戏的模拟： 给定一个NM的数组ar，代表NM个方格组成的版图，贪吃蛇每次移动一个方格。 若ar[i][j]==\u0026#39;H\u0026#39;，表示该方可为贪吃蛇的起始位置; 若ar[i][j]==\u0026#39;F\u0026#39;，表示该方格为食物， 若ar[i][j]==\u0026#39;E\u0026#39;，表示该方格为空格。 贪吃蛇初始长度为1，初始移动方向为向左。 输入为给定一系列贪吃蛇的移动操作，返回操作后蛇的长度，如果在操作执行完之前已经游戏结束，返回游戏结束时贪吃蛇的长度。 输入描述: 第1行：为空格分隔的字母，代表贪吃蛇的移动操作。字母取值为 U、D、L、R、G， 其中UDLR分别表示贪吃蛇往上下左右转向，转向时贪吃蛇不移动，G表示贪吃蛇按 当前的方向移动一格。用例保证输入的操作正确。 第2行：为空格分隔的两个数，指定为 N和 M，为数组的行和列数。 余下 N行每行是空格分 隔的 M个字母。字母取值为 H、F和 E，H表示贪吃蛇的起始位置，F表示食物，E表示该 方格为空。 用例保证有且只有一个 H，而 F和 E会有多个。 输出描述: 输出一个数字为蛇的长度。 输入：D G G 3 3 F F F F F H E F E 输出：1 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] roadArr = sc.nextLine().split(\u0026#34; \u0026#34;); String[] numArr = sc.nextLine().split(\u0026#34; \u0026#34;); int n = Integer.parseInt(numArr[0]); int m = Integer.parseInt(numArr[1]); String[][] arr = new String[n][m]; for (int i = 0; i \u0026lt; n; i++) { String[] tempArr = sc.nextLine().split(\u0026#34; \u0026#34;); for (int j = 0; j \u0026lt; m; j++) { arr[i][j] = tempArr[j]; } } int ans = solution(roadArr, arr, n, m); System.out.println(ans); } public static int solution(String[] roadArr, String[][] arr, int n, int m) { int[] start = {0, 0}; ArrayDeque\u0026lt;String\u0026gt; body = new ArrayDeque\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { if (\u0026#34;H\u0026#34;.equals(arr[i][j])) { body.add(i + \u0026#34;-\u0026#34; + j); start[0] = i; start[1] = j; } } } String curDir = \u0026#34;L\u0026#34;; for (int i = 0; i \u0026lt; roadArr.length; i++) { String str = roadArr[i]; if (\u0026#34;U\u0026#34;.equals(str) || \u0026#34;D\u0026#34;.equals(str) || \u0026#34;L\u0026#34;.equals(str) || \u0026#34;R\u0026#34;.equals(str)) { curDir = str; } if (\u0026#34;G\u0026#34;.equals(str)) { if (\u0026#34;U\u0026#34;.equals(curDir)) start = new int[]{start[0] - 1, start[1]}; if (\u0026#34;D\u0026#34;.equals(curDir)) start = new int[]{start[0] + 1, start[1]}; if (\u0026#34;L\u0026#34;.equals(curDir)) start = new int[]{start[0], start[1] - 1}; if (\u0026#34;R\u0026#34;.equals(curDir)) start = new int[]{start[0], start[1] + 1}; if (start[0] \u0026lt; 0 || start[1] \u0026lt; 0 || start[0] \u0026gt; n - 1 || start[1] \u0026gt; m - 1 || body.contains(start[0] + \u0026#34;-\u0026#34; + start[1])) { return body.size(); } if (\u0026#34;E\u0026#34;.equals(arr[start[0]][start[1]])) { body.addFirst(start[0] + \u0026#34;-\u0026#34; + start[1]); body.removeLast(); } if (\u0026#34;F\u0026#34;.equals(arr[start[0]][start[1]])) { body.addFirst(start[0] + \u0026#34;-\u0026#34; + start[1]); } } } return body.size(); } 02. 贪心歌手\r#\r描述\n一个歌手准备从A城去B城参加演出。问贪心的歌手最多可以赚多少钱？ 1. 按照合同，他必须在 T 天内赶到 2. 歌手途经 N 座城市 3. 歌手不能往回走 4. 每两座城市之间需要的天数都可以提前获知。 5. 歌手在每座城市都可以在路边卖唱赚钱。 经过调研，歌手提前获知了每座城市卖唱的收入预期： 如果在一座城市第一天卖唱可以赚M，后续每天的收入会减少D（第二天赚的钱是 M - D，第三天是 M - 2D ...）。 如果收入减少到 0 就不会再少了。 6. 歌手到达后的第二天才能开始卖唱。如果今天卖过唱，第二天才能出发。 输入描述： 第一行两个数字 T 和 N，中间用空格隔开。T 代表总天数，0 ＜ T ＜ 1000；N 代表路上经过 N 座城市，0 ＜ N ＜ 100 第二行 N+1 个数字，中间用空格隔开。代表每两座城市之间耗费的时间。其总和 ≤ T。 接下来 N 行，每行两个数字 M 和 D，中间用空格隔开。代表每个城市的输入预期。0 ＜ M ＜ 1000，0 ＜ D ＜ 100 输出描述： 一个数字。代表歌手最多可以赚多少钱。以回车结束。 输入：10 2 1 1 2 120 20 90 10 输出：540 题解\nstatic int t; static int n; static int roadCost; static int[][] mds; public static void main(String[] args) { Scanner sc = new Scanner(System.in); t = sc.nextInt(); n = sc.nextInt(); // roadCost是A~B城市必需的路程时间 roadCost = 0; for (int i = 0; i \u0026lt; n + 1; i++) { roadCost += sc.nextInt(); } mds = new int[n][2]; for (int i = 0; i \u0026lt; n; i++) { mds[i][0] = sc.nextInt(); mds[i][1] = sc.nextInt(); } System.out.println(getResult()); } public static int getResult() { // remain是刨去必要的路程时间后，剩余可以用于赚钱的时间 int remain = t - roadCost; // 如果没有剩余时间可以用，则赚不到钱 if (remain \u0026lt;= 0) { return 0; } // 优先队列（小顶堆）记录赚到的钱, 即堆顶是某天赚的最少的钱 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a - b); for (int[] md : mds) { // 第一天卖唱可以赚m，后续每天的收入会减少d int m = md[0]; int d = md[1]; // 只要在当前城市还有钱赚，那么就继续待 while (m \u0026gt; 0) { // 只有remain天可以赚钱，超出的时间不能赚钱， // 因此需要比较超出的时间赚的钱m，和前面时间中赚的最少的钱pq.peek if (pq.size() \u0026gt;= remain) { // pq.peek只可能是某座城市停留的最后一天的赚的钱， // 因为每座城市都是停留的最后一天赚的钱最少 if (m \u0026gt; pq.peek()) { // 如果当前城市当天赚的钱m，比前面天里面赚的最少的pq.peek多， // 那么就赚pq.peek钱的那天时间节约下来，给当天用 pq.poll(); } else { // 如果当前城市当天赚的钱m，比前面天里面赚的最少的pq.peek还少， // 则当前城市继续待下去赚的钱只会更少，因此没必要呆下去了 break; } } // 如果所有城市停留时间没有超出remain天，或者当天是超出的时间， // 但是比前面赚的最少的一天的赚的更多，则赚m更优 pq.add(m); // 每天收入减少d m -= d; } } return pq.stream().reduce(Integer::sum).orElse(0); } 03. 特殊的加密算法\r#\r描述\n有一种特殊的加密算法，明文为一段数字串，经过密码本查找转换，生成另一段密文数字串。 规则如下： 1. 明文为一段数字串由 0~9 组成 2. 密码本为数字 0~9 组成的二维数组 3. 需要按明文串的数字顺序在密码本里找到同样的数字串，密码本里的数字串是由相邻的单元格数字组成， 上下和左右是相邻的，注意：对角线不相邻，同一个单元格的数字不能重复使用。 4. 每一位明文对应密文即为密码本中找到的单元格所在的行和列序号（序号从0开始）组成的两个数宇。 如明文第 i 位 Data[i] 对应密码本单元格为 Book[x][y]，则明文第 i 位对应的密文为X Y，X和Y之间用空格隔开。 如果有多条密文，返回字符序最小的密文。 如果密码本无法匹配，返回\u0026#34;error\u0026#34;。 请你设计这个加密程序。 输入描述： 第一行输入 1 个正整数 N，代表明文的长度（1 ≤ N ≤ 200） 第二行输入 N 个明文组成的序列 Data[i]（0 ≤ Data[i] ≤ 9） 第三行输入 1 个正整数 M，代表密文的长度 接下来 M 行，每行 M 个数，代表密文矩阵 输出描述： 输出字典序最小密文，如果无法匹配，输出\u0026#34;error\u0026#34; 输入：2 0 3 3 0 0 2 1 3 4 6 6 4 输出：0 1 1 1 题解\n// 明文数字个数 static int n; // 明文 static int[] datas; // 密码本矩阵大小 static int m; // 密码本 static int[][] secrets; static int[][] offsets = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); datas = new int[n]; for (int i = 0; i \u0026lt; n; i++) { datas[i] = sc.nextInt(); } // 记录密码本中元素值等于“明文第一个数字”的所有元素的位置 ArrayList\u0026lt;Integer\u0026gt; starts = new ArrayList\u0026lt;\u0026gt;(); m = sc.nextInt(); secrets = new int[m][m]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; m; j++) { secrets[i][j] = sc.nextInt(); // 如果密码本(i,j)位置元素指等于明文第一个数字值，则记录(i,j)作为一个出发位置 if (datas[0] == secrets[i][j]) { starts.add(i * m + j); } } } System.out.println(getResult(starts)); } public static String getResult(ArrayList\u0026lt;Integer\u0026gt; starts) { for (int start : starts) { // 出发位置 int x = start / m; int y = start % m; // used[i][j]用于记录密码本(i,j)元素是否已使用 boolean[][] used = new boolean[m][m]; // 出发点位置元素已使用 used[x][y] = true; // 记录结果路径各节点位置 LinkedList\u0026lt;String\u0026gt; path = new LinkedList\u0026lt;\u0026gt;(); // 出发点位置记录 path.add(x + \u0026#34; \u0026#34; + y); // 开始深搜 if (dfs(x, y, 1, path, used)) { StringJoiner sj = new StringJoiner(\u0026#34; \u0026#34;); for (String pos : path) sj.add(pos); return sj.toString(); } } return \u0026#34;error\u0026#34;; } /** * @param x 当前位置横坐标 * @param y 当前位置纵坐标 * @param index datas[index]是将要匹配的明文数字 * @param path 路径 * @param used 密码本各元素使用情况 * @return 是否找到符合要求的路径 */ public static boolean dfs(int x, int y, int index, LinkedList\u0026lt;String\u0026gt; path, boolean[][] used) { // 已找到明文最后一个数字，则找到符合要求的路径 if (index == n) { return true; } // 否则，进行上、左、右、下四个方向偏移，注意这里的顺序是有影响的， // 即下一步偏移后产生的密文的字符序必然是：上 \u0026lt; 左 \u0026lt; 右 \u0026lt; 下 for (int[] offset : offsets) { // 新位置 int newX = x + offset[0]; int newY = y + offset[1]; // 新位置越界，或者新位置已使用，或者新位置不是目标值，则跳过 if (newX \u0026lt; 0 || newX \u0026gt;= m || newY \u0026lt; 0 || newY \u0026gt;= m || used[newX][newY] || secrets[newX][newY] != datas[index]) { continue; } // 递归进入新位置 path.add(newX + \u0026#34; \u0026#34; + newY); used[newX][newY] = true; // 如果当前分支可以找到符合要求的路径，则返回 if (dfs(newX, newY, index + 1, path, used)) { return true; } // 否则，回溯 used[newX][newY] = false; path.removeLast(); } return false; } 04. 田忌赛马\r#\r描述\n给定两个只包含数字的数组a，b，调整数组 a 里面的数字的顺序，使得尽可能多的a[i] \u0026gt; b[i]。 数组a和b中的数字各不相同。 输出所有可以达到最优结果的a数组的结果。 输入描述： 输入的第一行是数组 a 中的数字，其中只包含数字，每两个数字之间相隔一个空格，a数组大小不超过10。 输入的第二行是数组 b 中的数字，其中只包含数字，每两个数字之间相隔一个空格，b数组大小不超过10。 输出描述： 输出所有可以达到最优结果的 a 数组的数量。 输入：11 8 20 10 13 7 输出：1 说明：最优结果只有一个，a = [11, 20, 8]，故输出1 输入：11 12 20 10 13 7 输出：2 说明：有两个a数组的排列可以达到最优结果，[12, 20, 11] 和 [11, 20, 12]，故输出2 输入：1 2 3 4 5 6 输出：6 说明：a无论如何都会全输，故a任意排列都行，输出所有a数组的排列，6种排法。 题解\nstatic int[] a; static int[] b; static int maxBiggerCount = 0; static int ans = 0; public static void main(String[] args) { Scanner sc = new Scanner(System.in); a = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); b = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); // 求解a的全排列 dfs(0, new boolean[a.length], 0); System.out.println(ans); } public static void dfs(int level, boolean[] used, int biggerCount) { if (level \u0026gt;= a.length) { if (biggerCount \u0026gt; maxBiggerCount) { maxBiggerCount = biggerCount; ans = 1; } else if (biggerCount == maxBiggerCount) { ans++; } return; } for (int i = 0; i \u0026lt; a.length; i++) { if (used[i]) continue; used[i] = true; // biggerCount记录当前全排列中a[level] \u0026gt; b[level]的位置的数量, 此时a[level] == a[i] dfs(level + 1, used, biggerCount + (a[i] \u0026gt; b[level] ? 1 : 0)); used[i] = false; } } 05. 跳格子3\r#\r描述\n小明和朋友们一起玩跳格子游戏，每个格子上有特定的分数 score = [1, -1, -6, 7, -17, 7]， 从起点score[0]开始，每次最大的步长为k，请你返回小明跳到终点 score[n-1] 时，能得到的最大得分。 输入描述： 第一行输入总的格子数量 n 第二行输入每个格子的分数 score[i] 第三行输入最大跳的步长 k 输出描述： 输出最大得分 输入：6 1 -1 -6 7 -17 7 2 输出：14 说明：输出最大得分数，小明从起点score[0]开始跳，第一次跳score[1],第二次跳到score[3],第三次跳到score[5]， 因此得到的最大的得分是score[0] + score[1] + score[3] + score[5] = 14 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] scores = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); int k = Integer.parseInt(sc.nextLine()); System.out.println(getResult(n, scores, k)); } public static int getResult(int n, int[] scores, int k) { // 第i个格子，可以从第i-k个格子~第i-1个格子调过来，因此本题滑窗的长度相当于k+1 k++; // dp[i]表示跳到第i个格子能得到的最大分数 int[] dp = new int[n]; dp[0] = scores[0]; // 单调队列（单调递减，队首是滑窗最大值） LinkedList\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.addLast(dp[0]); // 初始滑窗的形成过程（即只有新增尾部元素的过程） // 注意当k \u0026gt; n时, 需要取n, 此时只有滑窗形成过程，没有滑窗移动过程 for (int i = 1; i \u0026lt; Math.min(k, n); i++) { // dp[i] = max(dp[0]~dp[i-1]) + scores[i] // 即单调队列队首保存的是max(dp[0]~dp[i-1]) dp[i] = queue.getFirst() + scores[i]; // 保持单调队列的单调递减性，即如果后入队的dp[i] 大于 队尾元素，则队尾元素出队 while (!queue.isEmpty() \u0026amp;\u0026amp; dp[i] \u0026gt; queue.getLast()) { queue.removeLast(); } // 当队尾没有比dp[i]更小的元素后，dp[i]才能入队 queue.addLast(dp[i]); } // 滑窗的右移过程（即相较于老滑窗失去一个首元素，新增一个尾元素） for (int i = k; i \u0026lt; n; i++) { // 如果滑窗失去的元素dp[i - k]，和单调队列的队首元素queue[0]相同，则单调队列需要弹出头部元素 if (dp[i - k] == queue.getFirst()) { queue.removeFirst(); } // 下面逻辑同之前 dp[i] = queue.getFirst() + scores[i]; while (!queue.isEmpty() \u0026amp;\u0026amp; dp[i] \u0026gt; queue.getLast()) { queue.removeLast(); } queue.addLast(dp[i]); } return dp[n - 1]; } 06. 跳马\r#\r描述\n马是象棋（包括中国象棋和国际象棋）中的棋子，走法是每步直一格再斜一格，即先横着或者直者走一格，然后再斜着走一个对角线，可进可退，可越过河界，俗称\u0026#34;马走日\u0026#34;字。 给定 m 行 n 列的棋盘（网格图），棋盘上只有棋子象棋中的棋子“马”，并且每个棋子有等级之分，等级为 k 的马可以跳 1~k 步（走的方式与象棋中“马”的规则一样，不可以超出棋盘位置），问是否能将所有马跳到同一位置，如果存在，输出最少需要的总步数（每匹马的步数相加），不存在则输出-1。 注：允许不同的马在跳的过程中跳到同一位置，坐标为（x,y）的马跳一次可以跳到的坐标为：(x+1, y+2)，(x+1, y-2)，(x+2, y+1)，(x+2, y-1)，(x-1, y+2)，(x-1, y-2)，(x-2, y+1)，(x-2, y-1)，的格点上，但是不可以超出棋盘范围。 输入描述： 第一行输入m，n，代表 m 行 n 列的网格图棋盘（1 ≤ m, n ≤ 25） 接下来输入 m 行 n 列的网格图棋盘，如果第 i 行，第 j 列的元素为 \u0026#34;.\u0026#34; ，代表此格点没有棋子，如果为数字 k（1 ≤ k ≤ 9），代表此格点存在等级为 k 的“马” 输出描述： 输出最少需要的总步数（每匹马的步数相加），不存在则输出-1。 输入：3 5 47.48 4744. 7.... 输出：17 题解\n// 棋盘行数 static int m; // 棋盘列数 static int n; // 棋盘矩阵 static char[][] map; // 最小步数和矩阵，stepMap[i][j]记录各个马走到棋盘(i,j)位置的最小步数之和 static int[][] stepMap; // 记录所有马都可达的公共位置坐标 static HashSet\u0026lt;Integer\u0026gt; reach; // 马走日的偏移量 static int[][] offsets = {{1, 2}, {1, -2}, {2, 1}, {2, -1}, {-1, 2}, {-1, -2}, {-2, 1}, {-2, -1}}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); m = sc.nextInt(); n = sc.nextInt(); map = new char[m][n]; stepMap = new int[m][n]; reach = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; m; i++) { map[i] = sc.next().toCharArray(); // 初始时假设所有位置都是各个马可达的 for (int j = 0; j \u0026lt; n; j++) { reach.add(i * n + j); } } System.out.println(getResult()); } public static int getResult() { // 遍历棋盘 for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { // 如果棋盘(i,j)位置是马 if (map[i][j] != \u0026#39;.\u0026#39;) { // 马的等级 int k = map[i][j] - \u0026#39;0\u0026#39;; // 对该马进行BFS走日 bfs(i, j, k); } } } // 如果所有马走完，发现没有公共可达位置 if (reach.size() == 0) { return -1; } // 记录所有马都可达位置的最小步数和 int minStep = Integer.MAX_VALUE; for (int pos : reach) { int x = pos / n; int y = pos % n; // (x,y)是所有马都可达的位置，stepMap[x][y]记录所有马到达此位置的步数和 minStep = Math.min(minStep, stepMap[x][y]); } return minStep; } // 广搜 public static void bfs(int sx, int sy, int k) { // 广搜队列 LinkedList\u0026lt;int[]\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // (sx,sy)为马所在初始位置，马到达初始位置需要0步 queue.add(new int[]{sx, sy, 0}); // 记录该马可以访问(sx,sy)位置 HashSet\u0026lt;Integer\u0026gt; vis = new HashSet\u0026lt;\u0026gt;(); vis.add(sx * n + sy); // 二维坐标一维化 // k记录该马剩余可走步数 while (queue.size() \u0026gt; 0 \u0026amp;\u0026amp; k \u0026gt; 0) { // newQueue记录该马花费相同步数的可达的位置（即BFS按层遍历的层） LinkedList\u0026lt;int[]\u0026gt; newQueue = new LinkedList\u0026lt;\u0026gt;(); // 按层BFS for (int[] tmp : queue) { // 当前马所在位置(x,y)，以及马到达该位置的步数step int x = tmp[0]; int y = tmp[1]; int step = tmp[2]; for (int[] offset : offsets) { // 马走日到达的新位置 int newX = x + offset[0]; int newY = y + offset[1]; int pos = newX * n + newY; // 如果新位置越界或者已访问过，则不能访问 if (newX \u0026lt; 0 || newX \u0026gt;= m || newY \u0026lt; 0 || newY \u0026gt;= n || vis.contains(pos)) { continue; } // 将新位置加入新层 newQueue.add(new int[]{newX, newY, step + 1}); // 该马到达(newX, newY)位置最小步数为step+1, // 由于该马首次到达(newX, newY)位置，因此step+1就是最小步数 stepMap[newX][newY] += step + 1; // 记录该马访问过该位置，后续如果该马再次访问该位置，则不是最小步数 vis.add(pos); } } queue = newQueue; k--; // 剩余步数减1 } // BFS完后，将公共可达位置reach和当前马可达位置取交集，交集部分就是新的公共可达位置 reach.retainAll(vis); } 07. 图像物体的边界\r#\r描述\n给定一个二维数组M行N列，二维数组里的数字代表图片的像素， 为了简化问题，仅包含像素1和5两种像素，每种像素代表一个物体，2个物体相邻的格子为边界，求像素1代表的物体的边界个数。 像素1代表的物体的边界指与像素5相邻的像素1的格子，边界相邻的属于同一个边界， 相邻需要考虑8个方向(上，下，左，右，左上，左下，右上，右下)。 输入描述： 第一行包含两个正整数 M 和 N，表示二维数组的行数和列数。 接下来的 M 行，每行包含 N 个数字，表示二维数组的像素。 输出描述： 输出像素1代表的物体的边界数目。如果没有边界，输出0（例如只存在像素1，或者只存在像素5）。 输入： 6 6 1 1 1 1 1 1 1 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5 1 1 1 1 1 1 1 输出：1 题解\nprivate static int m; private static int n; private static int[] dx = {0, 0, -1, 1, -1, 1, -1, 1}; private static int[] dy = {-1, 1, 0, 0, -1, 1, 1, -1}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); m = sc.nextInt(); n = sc.nextInt(); int[][] grid = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { grid[i][j] = sc.nextInt(); } } sc.close(); // 标记边界 int[][] border = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == 5) { for (int k = 0; k \u0026lt; 8; k++) { int newI = i + dx[k]; int newJ = j + dy[k]; if (0 \u0026lt;= newI \u0026amp;\u0026amp; newI \u0026lt; m \u0026amp;\u0026amp; 0 \u0026lt;= newJ \u0026amp;\u0026amp; newJ \u0026lt; n \u0026amp;\u0026amp; grid[newI][newJ] == 1) { border[newI][newJ] = 1; } } } } } // 计算边界数量 int count = 0; boolean[][] visited = new boolean[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (border[i][j] == 1 \u0026amp;\u0026amp; !visited[i][j]) { count++; dfs(i, j, border, visited); } } } System.out.println(count); } public static void dfs(int x, int y, int[][] border, boolean[][] visited) { if (x \u0026lt; 0 || x \u0026gt;= n || y \u0026lt; 0 || y \u0026gt;= m || border[x][y] == 0 || visited[x][y]) { return; } visited[x][y] = true; for (int i = 0; i \u0026lt; 8; i++) { dfs(x + dx[i], y + dy[i], border, visited); } } 08. 推荐多样性\r#\r描述\n推荐多样性需要从多个列表中选择元素，一次性要返回 N 屏数据（窗口数量），每屏展示 K 个元素（窗口大小），选择策略： 1. 各个列表元素需要做穿插处理，即先从第一个列表中为每屏选择一个元素，再从第二个列表中为每屏选择一个元素，依次类推 2. 每个列表的元素尽量均分为 N 份，如果不够 N 个，也要全部分配完，参考样例图： 输入描述： 第一行输入为 N，表示需要输出的窗口数量，取值范围 [1, 10] 第二行输入为 K，表示每个窗口需要的元素数量，取值范围 [1, 100] 之后的行数不定（行数取值范围 [1, 10]），表示每个列表输出的元素列表。元素之间以空格隔开，已经过排序处理，每个列表输出的元素数量取值范围 [1, 100] 输出描述： 输出元素列表，元素数量 = 窗口数量 * 窗口大小，元素之间以空格分隔，多个窗口合并为一个列表输出，参考样例： 先输出窗口1的元素列表，再输出窗口2的元素列表，再输出窗口3的元素列表，最后输出窗口4的元素列表 备注 1. 每个列表会保证元素数量满足窗口要求，不需要考虑元素不足情况 2. 每个列表的元素已去重，不需要考虑元素重复情况 3. 每个列表的元素列表均不为空，不需要考虑列表为空的情况 4. 每个列表的元素列表已经过排序处理，输出结果要保证不改变同一个列表的元素顺序 5. 每个列表的元素数量可能是不同的 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); int k = Integer.parseInt(sc.nextLine()); ArrayList\u0026lt;LinkedList\u0026lt;Integer\u0026gt;\u0026gt; lists = new ArrayList\u0026lt;\u0026gt;(); while (sc.hasNextLine()) { String line = sc.nextLine(); // 本地测试，以空行作为输入截止条件 if (line.length() == 0) break; String[] split = line.split(\u0026#34; \u0026#34;); Integer[] nums =Arrays.stream(split).map(Integer::parseInt).toArray(Integer[]::new); lists.add(new LinkedList\u0026lt;\u0026gt;(Arrays.asList(nums))); } // 窗口矩阵，k行n列，每一列对应一个窗口，这里将二维矩阵一维化，方便后面赋值 int[] windows = new int[k * n]; // 窗口矩阵中正在赋值的索引位置 int idx = 0; // 正在从第level个列表中取值 int level = 0; // 当窗口矩阵填满后，结束循环 while (idx \u0026lt; windows.length) { // 当前轮次是否发生了\u0026#34;借\u0026#34;动作 boolean flag = false; // 从第level个列表中取前n个元素 for (int i = 0; i \u0026lt; n; i++) { windows[idx++] = lists.get(level).removeFirst(); // 如果第level个列表没有元素了，则继续切到下一个列表中\u0026#34;借\u0026#34; if (lists.get(level).size() == 0 \u0026amp;\u0026amp; lists.size() \u0026gt; 1) { lists.remove(level); // 删除空列表 level %= lists.size(); // 防止越界 flag = true; // 发生了\u0026#34;借\u0026#34;动作 } } // 如果没有发生\u0026#34;借\u0026#34;动作，则需要切到下一行 if (!flag) { level = (level + 1) % lists.size(); // 防止越界 } } StringJoiner sj = new StringJoiner(\u0026#34; \u0026#34;); // 遍历窗口矩阵的每一列 for (int j = 0; j \u0026lt; n; j++) { // 遍历列号 for (int i = 0; i \u0026lt; k; i++) { // 遍历行号 sj.add(windows[i * n + j] + \u0026#34;\u0026#34;); // 将每一列的元素进行拼接 } } System.out.println(sj); } 09. 文本统计分析\r#\r描述\n有一个文件，包含以一定规则写作的文本，请统计文件中包含的文本数量。 规则如下： 1. 文本以”;”分隔，最后一条可以没有”;”，但空文本不能算语句， 比如”COMMAND A; ;”只能算一条语句。注意，无字符/空白字符/制表符都算作”空”文本； 2. 文本可以跨行，比如下面，是一条文本，而不是三条 COMMAND A \\nAND \\n\\nCOMMAND B; 3. 文本支持字符串，字符串为成对的单引号(\u0026#39;)或者成对的双引号(\u0026#34;)， 字符串可能出现用转义字符(\\)处理的单双引号(\u0026#34;your input is\\\u0026#34;\u0026#34;)和转义字符本身，比如 COMMAND A \u0026#34;Say \\\u0026#34;hello\\\u0026#34;\u0026#34;; 4. 支持注释，可以出现在字符串之外的任意位置注释以”-“开头，到换行结束，比如： COMMAND A; -this is comment COMMAND -comment A AND COMMAND B; 注意字符串内的”-“，不是注释。 输入描述：文本文件 输出描述：包含的文本数量 输入：COMMAND TABLE IF EXISTS \u0026#34;UNITED STATE\u0026#34;; COMMAND A GREAT ( ID ADSAB, download_length INTE-GER, -- test file_name TEXT, guid TEXT, mime_type TEXT, notifica-tionid INTEGER, original_file_name TEXT, pause_reason_type INTEGER, resumable_flag INTEGER, start_time INTEGER, state INTEGER, folder TEXT, path TEXT, total_length INTE-GER, url TEXT ); 输出：2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); LinkedList\u0026lt;String\u0026gt; lines = new LinkedList\u0026lt;\u0026gt;(); while (sc.hasNextLine()) { String line = sc.nextLine(); if (\u0026#34;\u0026#34;.equals(line)) { System.out.println(getResult(lines)); sc.close(); break; } else { lines.add(line); } } } // 算法入口 public static int getResult(LinkedList\u0026lt;String\u0026gt; lines) { StringBuilder sb = new StringBuilder(); for (String line : lines) { line = line.replaceAll(\u0026#34;\\\\\\\\[\\\u0026#34;\u0026#39;]\u0026#34;, \u0026#34;\u0026#34;) // 替换\\\u0026#34;和\\\u0026#39;为空串 .replaceAll(\u0026#34;\\\u0026#34;.*?\\\u0026#34;\u0026#34;, \u0026#34;a\u0026#34;) // 将成对双引号及其中内容替换为空串 .replaceAll(\u0026#34;\u0026#39;.*?\u0026#39;\u0026#34;, \u0026#34;a\u0026#34;) // 将成对单引号及其中内容替换为空串 .replaceAll(\u0026#34;-.+\u0026#34;, \u0026#34;\u0026#34;) // 将-往后的注释替换为空串 .replaceAll(\u0026#34;\\\\s+\u0026#34;, \u0026#34;\u0026#34;) // 将空白字符替换为空串 .replaceAll(\u0026#34;;+\u0026#34;, \u0026#34;;\u0026#34;); // 将连续分号替换为单个分号 sb.append(line); } // 题目描述说：文本以”;”分隔，最后一条可以没有”;” // 为了避免复杂处理，这里无论最后一条文本有没有分号，都加一个 sb.append(\u0026#34;;\u0026#34;); // 下面处理主要是为了处理跨行文本 /*** * 比如 * aaaa; * ;aaaa * * 比如 * ;aaaa * ;aaaa */ String s = sb.toString().replaceAll(\u0026#34;;+\u0026#34;, \u0026#34;;\u0026#34;).replaceAll(\u0026#34;^;\u0026#34;, \u0026#34;\u0026#34;); // 记录文本条数 int count = 0; for (int i = 0; i \u0026lt; s.length(); i++) { if (s.charAt(i) == \u0026#39;;\u0026#39;) count++; } return count; } 10. 文件缓存系统\r#\r描述\n请设计一个文件缓存系统，该文件缓存系统可以指定缓存的最大值（单位为字节）。 文件缓存系统有两种操作：存储文件（put），读取文件（get） 操作命令为：put fileName fileSize，get fileName 存储文件是把文件放入文件缓存系统中； 读取文件是从文件缓存系统中访问已存在，如果文件不存在，则不作任何操作。 当缓存空间不足以存放新的文件时，根据规则删除文件，直到剩余空间满足新的文件大小位置，再存放新文件。 具体的删除规则为： 文件访问过后，会更新文件的最近访问时间和总的访问次数，当缓存不够时， 按照第一优先顺序为访问次数从少到多，第二顺序为时间从老到新的方式来删除文件。 输入描述： 第一行为缓存最大值 m（整数，取值范围为 0 ＜ m ≤ 52428800） 第二行为文件操作序列个数 n（0 ≤ n ≤ 300000） 从第三行起为文件操作序列，每个序列单独一行，文件操作定义为：op file_name file_size file_name 是文件名，file_size 是文件大小 输出描述： 输出当前文件缓存中的文件名列表，文件名用英文逗号分隔，按字典顺序排序，如：a,c 如果文件缓存中没有文件，则输出NONE 备注： 1. 如果新文件的文件名和文件缓存中已有的文件名相同，则不会放在缓存中 2. 新的文件第一次存入到文件缓存中时，文件的总访问次数不会变化，文件的最近访问时间会更新到最新时间 3. 每次文件访问后，总访问次数加1，最近访问时间更新到最新时间 4. 任何两个文件的最近访问时间不会重复 5. 文件名不会为空，均为小写字母，最大长度为10 6. 缓存空间不足时，不能存放新文件 7. 每个文件大小都是大于 0 的整数 输入：50 6 put a 10 put b 20 get a get a get b put c 30 输出：a,c 题解\n/** 双向链表节点 */ static class Node { /** 记录本题的文件名 */ String key; /** 记录本题的文件大小 */ int val; /** 记录该文件的访问次数 */ int freq; /** 当前节点的前一个节点 */ Node prev; /** 当前节点的后一个节点 */ Node next; public Node(String key, int val, int freq) { this.key = key; this.val = val; this.freq = freq; this.prev = null; this.next = null; } } /** 双向链表 */ static class Link { /** 链表节点数 */ int size; /** 链表头节点 */ Node head; /** 链表尾节点 */ Node tail; /** * 尾插 * * @param node 要插入的节点 */ public void addLast(Node node) { if (this.size == 0) { this.head = node; this.tail = node; } else { this.tail.next = node; node.prev = this.tail; this.tail = node; } this.size++; } /** * 删除指定节点 * * @param node 指定删除的节点 */ public void remove(Node node) { // 如果是空链表，则没法删除 if (this.size == 0) return; if (this.size == 1) { // 如果是单节点链表，则删除完，链表为空 this.head = null; this.tail = null; } else if (node == this.head) { // 被删除节点是链表头节点 this.head = this.head.next; this.head.prev = null; } else if (node == this.tail) { // 被删除节点是链表尾节点 this.tail = this.tail.prev; this.tail.next = null; } else { // 被删除节点是链表中间节点 node.prev.next = node.next; node.next.prev = node.prev; } this.size--; } } static class LFUCache { /** key是文件名，value是文件信息 * （key.value本质是freqMap.value对应的链表中节点Node的对象地址） */ HashMap\u0026lt;String, Node\u0026gt; keyMap; /** key是访问次数，value是访问次数位key的文件（Node）组成的链表（Link） */ HashMap\u0026lt;Integer, Link\u0026gt; freqMap; /** 文件系统总容量 */ int capacity; /** 最少访问次数（记录自各个文件访问次数中最少的那个） */ int minFreq; public LFUCache(int capacity) { this.capacity = capacity; this.minFreq = 0; this.keyMap = new HashMap\u0026lt;\u0026gt;(); this.freqMap = new HashMap\u0026lt;\u0026gt;(); } /** * @param key 对应本题的文件名 */ public void get(String key) { // 如果文件不存在，则不作任何操作。 if (!this.keyMap.containsKey(key)) return; Node node = this.keyMap.get(key); // 每次文件访问后，总访问次数加1，最近访问时间更新到最新时间 incNodeFreq(node); } /** * @param key 对应本题的文件名 * @param val 对应本题的文件大小 */ public void put(String key, int val) { // 如果新文件的文件名和文件缓存中已有的文件名相同，则不会放在缓存中 if (this.keyMap.containsKey(key)) return; // 当缓存空间不足以存放新的文件时，根据规则删除文件， // 直到剩余空间满足新的文件大小位置，再存放新文件。 while (this.capacity \u0026lt; val) { if (this.minFreq == 0) { // 文件系统空了，也放不下该文件，则不放入 return; } // 找出最少访问次数对应的链表 Link minFreqLink = this.freqMap.get(this.minFreq); // 链表头部节点是最少访问次数中，最远访问的文件，我们需要删除它 Node removeNode = minFreqLink.head; // 删除对应文件后，文件系统容量新增 this.capacity += removeNode.val; // 执行删除操作，freqMap和keyMap都要删除掉对应文件的记录 minFreqLink.remove(removeNode); this.keyMap.remove(removeNode.key); // 如果删除后，最少访问次数的链表空了，则需要找到下一个最少访问次数的链表 if (minFreqLink.size == 0) { // 最少访问次数没有对应文件（链表为空），则删除最少访问次数的记录（freqMap的key） this.freqMap.remove(this.minFreq); if (this.freqMap.size() \u0026gt; 0) { this.minFreq = this.freqMap.keySet().stream().min((a, b) -\u0026gt; a - b).get(); } else { // 文件系统没有缓存文件了，则最少次数为0，表示文件系统空了 this.minFreq = 0; } } } // 新增文件，则文件系统容量减少 this.capacity -= val; // 新增文件的访问次数为1，因此最少访问次数变为了1 this.minFreq = 1; Node node = new Node(key, val, this.minFreq); // 执行新增操作，freqMap和keyMap都要新增对应文件的记录 this.freqMap.putIfAbsent(this.minFreq, new Link()); this.freqMap.get(this.minFreq).addLast(node); this.keyMap.put(key, node); } public void incNodeFreq(Node node) { Link link = this.freqMap.get(node.freq); // 由于要更新文件的访问次数，因此需要将node从当前访问次数的链表中删除 link.remove(node); // 如果当前访问次数链表只有当前node，则继续看当前链表对应的访问次数是否位最少访问次数， // 若是，则说明删除当前节点后，最少访问次数对应的文件没了 if (link.size == 0) { // 当前访问次数没有对应文件（链表为空），则删除当前访问次数的记录（freqMap的key） this.freqMap.remove(node.freq); if (node.freq == this.minFreq) { // 此时我们应该更新最少访问次数 this.minFreq++; } } node.freq++; // 总访问次数加1 this.freqMap.putIfAbsent(node.freq, new Link()); // 将node插入到对应freq的链表中 // 尾插 是为了实现：最近访问时间更新到最新时间，即这里认为：链表尾部是最近的，链表头部是最远的 this.freqMap.get(node.freq).addLast(node); } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = Integer.parseInt(sc.nextLine()); LFUCache lfuCache = new LFUCache(m); int n = Integer.parseInt(sc.nextLine()); for (int i = 0; i \u0026lt; n; i++) { String[] operation = sc.nextLine().split(\u0026#34; \u0026#34;); String op = operation[0]; String fileName = operation[1]; if (\u0026#34;put\u0026#34;.equals(op)) { int fileSize = Integer.parseInt(operation[2]); lfuCache.put(fileName, fileSize); } else { lfuCache.get(fileName); } } if (lfuCache.capacity == m) { // 如果文件系统容量没有减少，则没有文件被缓存 System.out.println(\u0026#34;NONE\u0026#34;); } else { // 否则取出文件系统中的文件名，按照字典序输出 StringJoiner sj = new StringJoiner(\u0026#34;,\u0026#34;); lfuCache.keyMap.keySet().stream().sorted().forEach(sj::add); System.out.println(sj); } } 11. 污染水域\r#\r描述\n输入一行字符串，字符串可转换为N*N的数组，数组可认为是一个水域，判断多少天后，水域被全部污染。 数组中只有0和1，0表示纯净，1表示污染，每天只可污染上下左右的水域，如果开始全部被污染，或永远无法污染，则返回-1。 输入：1,0,1,0,0,0,1,0,1 输出：2 说明： 输入转化为数组为： 1 0 1 0 0 0 1 0 1 第一天后水域变为 1 1 1 1 0 1 1 1 1 第二天全部被污染 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34;,\u0026#34;); int[] nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(nums)); } public static int getResult(int[] nums) { int n = (int) Math.sqrt(nums.length); LinkedList\u0026lt;int[]\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); int[][] matrix = new int[n][n]; int total = nums.length; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { matrix[i][j] = nums[i * n + j]; if (matrix[i][j] == 1) { queue.add(new int[] {i, j}); total--; } } } if (queue.size() == 0 || queue.size() == nums.length) { return -1; } int day = 0; int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; while (queue.size() \u0026gt; 0 \u0026amp;\u0026amp; total \u0026gt; 0) { LinkedList\u0026lt;int[]\u0026gt; newQueue = new LinkedList\u0026lt;\u0026gt;(); for (int[] pos : queue) { int i = pos[0]; int j = pos[1]; for (int[] offset : offsets) { int newI = i + offset[0]; int newJ = j + offset[1]; if (newI \u0026gt;= 0 \u0026amp;\u0026amp; newI \u0026lt; n \u0026amp;\u0026amp; newJ \u0026gt;= 0 \u0026amp;\u0026amp; newJ \u0026lt; n \u0026amp;\u0026amp; matrix[newI][newJ] == 0) { matrix[newI][newJ] = 1; newQueue.add(new int[] {newI, newJ}); total--; } } } queue = newQueue; day++; } return day; } 12. 项目排期\r#\r描述\n项目组共有 N 个开发人员，项目经理接到了 M 个独立的需求， 每个需求的工作量不同，且每个需求只能由一个开发人员独立完成，不能多人合作。 假定各个需求直接无任何先后依赖关系，请设计算法帮助项目经理进行工作安排，使整个项目能用最少的时间交付。 输入描述： 第一行输入为 M 个需求的工作量，单位为天，用逗号隔开。 例如：X1 X2 X3 ... Xm 其中：0 ＜ M ＜ 30，0 ＜ Xm ＜ 200 第二行输入为项目组人员数量N， 其中：0 ＜ N ＜ 10 输出描述： 最快完成所有工作的天数 输入：6 2 7 7 9 3 2 1 3 11 4 2 输出：28 题解\nstatic Integer[] balls; static int n; public static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); balls = Arrays.stream(split).map(Integer::parseInt).toArray(Integer[]::new); n = Integer.parseInt(sc.nextLine()); System.out.println(getResult()); } public static int getResult() { // 这里对balls降序，有利于降低后面回溯操作的复杂度 Arrays.sort(balls, (a, b) -\u0026gt; b - a); // 二分范围：即每个桶的容量最小，最大值 int min = balls[0]; // 桶至少要有max(balls)的容量 // 当只有一个桶时，此时该桶容量要装下所有balls int max = Arrays.stream(balls).reduce(Integer::sum).get(); // 记录题解 int ans = max; // 二分找中间值作为桶容量 while (min \u0026lt;= max) { int mid = (min + max) \u0026gt;\u0026gt; 1; if (check(0, new int[n], mid)) { // 如果k个mid容量的桶，可以装完所有balls， // 那么mid容量就是一个可能解，但不一定是最优解，我们应该尝试更小的桶容量 ans = mid; max = mid - 1; } else { // 如果k个mid容量的桶，无法装完所有balls，那么说明桶容量取小了，我们应该尝试更大的桶容量 min = mid + 1; } } return ans; } /** * @param index 当前轮次要被装入的球的索引（balls数组索引） * @param buckets 桶数组，buckets[i]记录的是第 i 个桶已使用的容量 * @param limit 每个桶的最大可使用容量 * @return k个桶（每个桶容量limit）是否可以装下balls中所有球 */ public static boolean check(int index, int[] buckets, int limit) { // 如果balls已经取完，则说明k个limit容量的桶，可以装完所有balls if (index == balls.length) return true; // select是当前要装的球 int selected = balls[index]; // 遍历桶 for (int i = 0; i \u0026lt; buckets.length; i++) { // 剪枝优化 if (i \u0026gt; 0 \u0026amp;\u0026amp; buckets[i] == buckets[i - 1]) continue; // 如果当前桶装了当前选择的球后不超过容量限制，则可以装入 if (selected + buckets[i] \u0026lt;= limit) { buckets[i] += selected; // 递归装下一个球 if (check(index + 1, buckets, limit)) return true; // 如果这种策略无法装完所有球，则回溯 buckets[i] -= selected; } } return false; } 13. 小朋友分组最少调整次数\r#\r描述\nn 个学生排成一排，学生编号分别是 1 到 n，n 为 3 的整倍数。 老师随机抽签决定将所有学生分成 m 个 3 人的小组（n == 3 * m） ， 为了便于同组学生交流，老师决定将小组成员安排到一起，也就是同组成员彼此相连，同组任意两个成员之间无其它组的成员。 因此老师决定调整队伍，老师每次可以调整任何一名学生到队伍的任意位置，计为调整了一次， 请计算最少调整多少次可以达到目标。 注意：对于小组之间没有顺序要求，同组学生之间没有顺序要求。 输入描述： 第一行输入初始排队顺序序列 第二行输入分组排队顺序序列 输出描述： 最少调整多少次数 输入：4 2 8 5 3 6 1 9 7 6 3 1 2 4 8 7 9 5 输出：1 输入：7 9 8 5 6 4 2 1 3 7 8 9 4 2 1 3 5 6 输出：1 题解\n// 分块（即连续的相同组的小朋友） static class NumCount { int num; int count; public NumCount(int num, int count) { this.num = num; this.count = count; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); // 初始小朋友（序号）排队顺序 String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); int n = nums.length; // 序号-\u0026gt;组号 映射关系 int[] map = new int[n + 1]; for (int i = 0; i \u0026lt; n; i++) { int num = sc.nextInt(); map[num] = i / 3; } // 初始小朋友（组号）排队顺序 nums = Arrays.stream(nums).map(num -\u0026gt; map[num]).toArray(); // key是组号，val是对应组号的小朋友分块 HashMap\u0026lt;Integer, ArrayList\u0026lt;NumCount\u0026gt;\u0026gt; blocks = new HashMap\u0026lt;\u0026gt;(); // 相邻相同组号合并为块 LinkedList\u0026lt;NumCount\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int num : nums) { if (queue.isEmpty() || queue.getLast().num != num) { queue.addLast(new NumCount(num, 1)); // 记录相同组号的各个分块 blocks.putIfAbsent(num, new ArrayList\u0026lt;\u0026gt;()); blocks.get(num).add(queue.getLast()); } else { queue.getLast().count++; } } // 记录调整位置次数 int moved_count = 0; while (queue.size() \u0026gt; 0) { NumCount first = queue.removeFirst(); // 如果开头块是空的，或者开头块已经包含3个小朋友，那么不需要调整位置 if (first.count == 0 || first.count == 3) continue; if (queue.size() == 0) break; // 第二块 NumCount second = queue.getFirst(); while (second.count == 0) { queue.removeFirst(); second = queue.getFirst(); } // 如果开头块和第二块组号相同，则合并（前面并入后面） if (first.num == second.num) { second.count += first.count; continue; } /* 如果开头块和第二块组号不同，则进入具体情况分析 */ if (first.count == 2) { // 开头块有2个小朋友，则情况如下组号1例子， // 此时需要将后面的单独1，并入开头两个1中，即调整一次 // 1 1 x 1 moved_count += 1; // 后面单独1所在块的小朋友数量清空 blocks.get(first.num).forEach(block -\u0026gt; block.count = 0); continue; } if (first.count == 1) { // 开头块只有1个小朋友，则有两种情况 if (blocks.get(first.num).size() == 3) { // 对于组号的分块有三个，即如下组号1例子 // 1 x 1 y 1 z // 此时需要将后面两个单独1，并入到开头1中，即调整两次 moved_count += 2; // 后面两个单独1所在块的小朋友数量清空 blocks.get(first.num).forEach(block -\u0026gt; block.count = 0); } else { // 对于组号的分块有两个，则如下组号1例子 // 1 x 1 1 // 此时需要将开头单独1并入到后面两个1中，即调整一次 moved_count += 1; // 后面两个1所在块的小朋友数量变为3个 blocks.get(first.num).forEach(block -\u0026gt; block.count = 3); } } } System.out.println(moved_count); } 14. 信道分配\r#\r描述\n算法工程师小明面对着这样一个问题 ，需要将通信用的信道分配给尽量多的用户: 给出一组信道资源，最多可以为多少用户传输数据? 信道的条件及分配规则如下: 1. 所有信道都有属性:”阶”。阶为 r的信道的容量为 2^r比特; 2. 所有用户需要传输的数据量都一样:D比特; 3. 一个用户可以分配多个信道，但每个信道只能分配给一个用户; 4. 只有当分配给一个用户的所有信道的容量和\u0026gt;=D，用户才能传输数据; 输入描述： 第一行，一个数字 R。R为最大阶数。0≤R＜20 第二行，R+1个数字，用空格隔开。代表每种信道的数量 Ni。按照阶的值从小到大排列。0≤i≤R，0≤Ni＜1000. 第三行，一个数字 D。D为单个用户需要传输的数据量。0＜D＜1000000 输出描述： 一个数字（代表最多可以供多少用户传输数据） 输入：5 10 5 0 1 3 2 30 输出：4 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int R = sc.nextInt(); int[] N = new int[R + 1]; for (int i = 0; i \u0026lt;= R; i++) { N[i] = sc.nextInt(); } int D = sc.nextInt(); System.out.println(getResult(R, N, D)); } public static int getResult(int R, int[] N, int D) { // 将D值转化为二进制形式，并且为了和N[]的阶位进行对应，这里将D的二进制进行了反转 String[] split = new StringBuilder(Integer.toBinaryString(D)) .reverse().toString().split(\u0026#34;\u0026#34;); int[] subtrahend = Arrays.stream(split) .mapToInt(Integer::parseInt) .toArray(); // count记录N能承载几个D int count = 0; // N中高阶信道的单个信道就能满足D，因此这些高阶信道有几个，即能承载几个D for (int i = R; i \u0026gt;= subtrahend.length; i--) { // R ~ subtrahend.length 阶的单个信道就能承载一个D，因此这些信道有几个，就能承载几个D count += N[i]; } // 0 ~ subtrahend.length - 1 阶的单个信道无法承载一个D，因此这些阶需要组合起来才能承载一个D int[] minuend = Arrays.copyOfRange(N, 0, subtrahend.length); // 进行二进制减法 while (binary_sub(minuend, subtrahend)) { count++; } return count; } /** * 二进制减法 * * @param minuend 被减数 * @param subtrahend 减数 * @return 被减数是否为正数 */ public static boolean binary_sub(int[] minuend, int[] subtrahend) { // 进行减法运算逻辑, 从高位开始 for (int i = minuend.length - 1; i \u0026gt;= 0; i--) { if (minuend[i] \u0026gt;= subtrahend[i]) { // 如果对应位的信道数足够，则直接相减 minuend[i] -= subtrahend[i]; } else { // 如果对应位的信道数不足，此时有两种策略，一是向低位借，一是向高位借 // 具体向哪里借，需要看 minuend 的 [0,i] 低位部分是否能够承载 subtrahend[0, i] 低位部分 if (calc_bin(Arrays.copyOfRange(minuend, 0, i + 1)) \u0026lt; calc_bin(Arrays.copyOfRange(subtrahend, 0, i + 1))) { // 如果minuend 的 [0,i]不能承载，则向高位借，即从j=i+1位开始借 int j = i + 1; while (j \u0026lt; minuend.length) { if (minuend[j] \u0026gt; 0) { // 如果高位 j 有信道可借，则借 minuend[j] -= 1; return true; } else { // 否则继续向更高位探索 j += 1; } } // 如果所有高位都没有富余信道数，则说明减法结果为负数 return false; } else { // 如果minuend 的 [0,i]可以承载，则向低位借(向低位借，可以避免浪费) // 此时minuend[i]为负数，表示欠债 minuend[i] -= subtrahend[i]; // 将当前阶位的欠债，转移到前面的低阶位上，注意转移时，欠债x2 minuend[i - 1] += minuend[i] \u0026lt;\u0026lt; 1; // 转移后，当前阶位的欠债变为0 minuend[i] = 0; } } } return true; } public static int calc_bin(int[] bin) { int ans = 0; for (int i = 0; i \u0026lt; bin.length; i++) { ans += bin[i] * (1 \u0026lt;\u0026lt; i); } return ans; } 15. 寻找最优的路测线路\r#\r描述\n评估一个网络的信号质量，其中一个做法是将网络划分为栅格，然后对每个栅格的信号质量计算。 路测的时候，希望选择一条信号最好的路线（彼此相连的栅格集合）进行演示。 现给出 R 行 C 列的整数数组 Cov，每个单元格的数值 S 即为该栅格的信号质量（已归一化，无单位，值越大信号越好）。 要求从 [0, 0] 到 [R-1, C-1]设计一条最优路测路线。返回该路线得分。 规则： 路测路线可以上下左右四个方向，不能对角 路线的评分是以路线上信号最差的栅格为准的，例如路径 8→4→5→9 的值为4，该线路评分为4。线路最优表示该条线路的评分最高。 输入描述： 第一行表示栅格的行数 R 第二行表示栅格的列数 C 第三行开始，每一行表示栅格地图一行的信号值，如5 4 5 输出描述： 最优路线的得分 备注： 1 ≤ R，C ≤ 20 0 ≤ S ≤ 65535 输入：3 3 5 4 5 1 2 6 7 4 6 输出：4 说明：路线为：5→4→5→6→6 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int r = sc.nextInt(); int c = sc.nextInt(); int[][] matrix = new int[r][c]; for (int i = 0; i \u0026lt; r; i++) { for (int j = 0; j \u0026lt; c; j++) { matrix[i][j] = sc.nextInt(); } } // dist[i]记录的 起点0 到 终点i 的所有路径中“最大的”最小权值节点的权值 // 其中 i 是将二维坐标一维化后的值，比如(x,y)坐标一维化后为 x * c + y; (c是列数) // dist[i] 记录的 “最大的”最小权值节点的权值，因此需要初始化为一个 \u0026#34;最小的\u0026#34; 最小权值节点的权值， // 方便后面被更大者取代，由于本题节点的最小权值\u0026gt;=0，因此这里可以初始化为0 int[] dist = new int[r * c]; // 起点0 到 终点0 路径的最小权值节点就是自身，即matrix[0][0]点的权重 dist[0] = matrix[0][0]; // 优先队列记录路径（终点），并且路径中的最小权值节点的权值越大，优先级越高 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; dist[b] - dist[a]); // 初始时将(0,0)入队 pq.add(0); // 上下左右的方向偏移量 int[][] offsets = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}; while (pq.size() \u0026gt; 0) { // 取出优先队列中优先级最大的路径（终点） int u = pq.poll(); // 将一维化坐标u，解析为二维坐标(x,y) int x = u / c; int y = u % c; // 已找到dist[r-1][c-1]最优解，则可以提前结束 if (x == r - 1 \u0026amp;\u0026amp; y == c - 1) break; // 向上下左右四个方向探索 for (int[] offset : offsets) { // 新位置坐标 int newX = x + offset[0]; int newY = y + offset[1]; // 新位置越界则无法访问 if (newX \u0026lt; 0 || newX \u0026gt;= r || newY \u0026lt; 0 || newY \u0026gt;= c) continue; // 新位置的一维化坐标 int v = newX * c + newY; // 当前路径（终点u）的最小权值节点的权值为dist[u] // 要加入当前路径的新位置的点的权值 matrix[newX][newY] // 那么形成的新路径的最小权值节点的权值即为 w = min(dist[u], matrix[newX][newY]) int w = Math.min(dist[u], matrix[newX][newY]); // 形成的新路径的终点为 v（即新位置一维化坐标） // 而dist[v]记录的是起点到点v的所有路径中“最大的”最小权值节点 if (dist[v] \u0026lt; w) { // 因此如果dist[v] \u0026lt; w的话，则更新dist[v] dist[v] = w; // 并将新路径加入优先队列，参与下一轮比较 pq.add(v); } } } // 返回起点（0，0）到终点(r-1, c-1)的所有路径中\u0026#34;最大的\u0026#34;最小权值节点的权值 System.out.println(dist[r * c - 1]); } 16. 园区参观路径\r#\r描述\n园区某部门举办了Family Day，邀请员工及其家属参加； 将公司园区视为一个矩形，起始园区设置在左上角，终点园区设置在右下角； 家属参观园区时，只能向右和向下园区前进，求从起始园区到终点园区会有多少条不同的参观路径。 输入描述： 第一行为园区的长和宽； 后面每一行表示该园区是否可以参观，0表示可以参观，1表示不能参观 输出描述： 输出为不同的路径数量 输入：3 3 0 0 0 0 1 0 0 0 0 输出：2 题解\nstatic int n; static int m; static int[][] matrix; static int[][] offsets = {{1, 0}, {0, 1}}; static int ans = 0; public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); // 长 -\u0026gt; 行数 m = sc.nextInt(); // 宽 -\u0026gt; 列数 matrix = new int[n][m]; // 地图矩阵 for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { matrix[i][j] = sc.nextInt(); } } // 从(0,0)位置开始深搜，深搜对应的每条分支都对应一条路径 if (matrix[0][0] == 0) { dfs(0, 0); } System.out.println(ans); } public static void dfs(int x, int y) { if (x == n - 1 \u0026amp;\u0026amp; y == m - 1) { // 如果当前分支可以走到终点，则对应分支路径可行 ans++; return; } // 从当前位置(x, y)向下或者向右走 for (int[] offset : offsets) { // 新位置(newX, newY) int newX = x + offset[0]; int newY = y + offset[1]; // 如果新位置越界了，或者新位置不能参观，则无法进入 if (newX \u0026lt; 0 || newX \u0026gt;= n || newY \u0026lt; 0 || newY \u0026gt;= m || matrix[newX][newY] == 1) continue; // 否则进入新位置，继续深搜 dfs(newX, newY); } } 17. 员工派遣\r#\r描述\n某公司部门需要派遣员工去国外做项目。 现在，代号为 x 的国家和代号为 y 的国家分别需要 cntx 名和 cnty 名员工。 部门每个员工有一个员工号（1,2,3,......），工号连续，从1开始。 部长派遣员工的规则： 规则1：从 [1, k] 中选择员工派遣出去 规则2：编号为 x 的倍数的员工不能去 x 国，编号为 y 的倍数的员工不能去 y 国。 问题： 找到最小的 k，使得可以将编号在 [1, k] 中的员工分配给 x 国和 y 国，且满足 x 国和 y 国的需求。 输入描述： 四个整数 x，y，cntx，cnty。 2 ≤ x ＜ y ≤ 30000 x 和 y 一定是质数 1 ≤ cntx, cnty ＜ 10^9 cntx + cnty ≤ 10^9 输出描述： 满足条件的最小的k 输入：2 3 3 1 输出：5 题解\nstatic long x; static long y; static long cntx; static long cnty; public static void main(String[] args) { Scanner sc = new Scanner(System.in); x = sc.nextInt(); y = sc.nextInt(); cntx = sc.nextInt(); cnty = sc.nextInt(); long min = cntx + cnty; // long max = Long.MAX_VALUE; // 使用此上限，实际通过率55% long max = 1000000000L; // 使用此上限，实际通过率可以100% while (min \u0026lt;= max) { long mid = min + (max - min) / 2; if (check(mid)) { max = mid - 1; } else { min = mid + 1; } } System.out.println(min); } public static boolean check(long k) { long A = k / x; // 1~k范围内x倍数的数量 long B = k / y; // 1~k范围内y倍数的数量 long C = k / (x * y); // 1~k范围内x*y倍数的数量 return Math.max(0, cntx - (B - C)) + Math.max(0, cnty - (A - C)) \u0026lt;= k - A - B + C; } 18. 运输时间\r#\r描述\nM（1 ≤ M ≤ 20）辆车需要在一条不能超车的单行道到达终点，起点到终点的距离为 N（1 ≤ N ≤ 400）。 速度快的车追上前车后，只能以前车的速度继续行驶，求最后一辆车到达目的地花费的时间。 注：每辆车固定间隔 1 小时出发，比如第一辆车 0 时出发，第二辆车 1 时出发，依次类推 输入描述： 第一行两个数字：M N，分别代表车辆数和到终点的距离，以空格分隔 接下来 M 行，每行一个数字 S，代表每辆车的速度。0 ＜ S ＜ 30 输出描述： 最后一辆车到达目的地花费的时间 输入：2 11 3 2 输出：5.5 说明：2辆车，距离11，0时出发的车速度快，1时出发的车，到达目的地花费5.5 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); int n = sc.nextInt(); // 记录前车到达终点的时刻，本题后车不可能比前车更早到达， // 因此如果后车到达时刻 \u0026lt; 前车到达时刻arrived，则后车也是按照前车arrived时刻达到 double arrived = 0; for (int i = 0; i \u0026lt; m; i++) { // 当前车的速度 double speed = sc.nextDouble(); // 当前车到达终点的时刻 // * 当前车如果比前车更早到达，则被前车阻碍，按前车到达时间算 // * 当前车如果比前车更晚到达，则不被前车阻碍，按后车到达时间算 // n*1.0/speed是行驶花费时间； i是第i辆车的出发时间 arrived = Math.max(arrived, n / speed + i); } // 到达时刻 - 出发时刻 = 路上花费的时间 double cost = arrived - (m - 1); // 格式化打印小数 NumberFormat nf = NumberFormat.getInstance(); nf.setMinimumFractionDigits(0); // 没有小数位则不保留 nf.setMaximumFractionDigits(3); // 有小数位则至多保留3位 System.out.println(nf.format(cost)); } 19. 找城市\r#\r描述\n一张地图上有n个城市，城市和城市之间有且只有一条道路相连： 要么直接相连，要么通过其它城市中转相连（可中转一次或多次）。城市与城市之间的道路都不会成环。 当切断通往某个城市 i 的所有道路后，地图上将分为多个连通的城市群， 设该城市i的聚集度为DPi，DPi = max（城市群1的城市个数，城市群2的城市个数，…城市群m 的城市个数）。 请找出地图上DP值最小的城市（即找到城市j，使得DPj = min(DP1,DP2 … DPn)) 提示：如果有多个城市都满足条件，这些城市都要找出来（可能存在多个解） 提示：DPi的计算，可以理解为已知一棵树，删除某个节点后；生成的多个子树，求解多个子数节点数的问题。 输入描述： 每个样例：第一行有一个整数N，表示有N个节点。1 ≤ N ≤ 1000。 接下来的N-1行每行有两个整数x，y，表示城市x与城市y连接。1 ≤ x, y ≤ N 输出描述： 输出城市的编号。如果有多个，按照编号升序输出。 输入：5 1 2 2 3 3 4 4 5 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[][] relations = new int[n - 1][2]; for (int i = 0; i \u0026lt; n - 1; i++) { relations[i][0] = sc.nextInt(); relations[i][1] = sc.nextInt(); } System.out.println(getResult(n, relations)); } public static String getResult(int n, int[][] relations) { // 记录最小dpi int minDp = Integer.MAX_VALUE; // 记录最小dpi对应的切断城市 ArrayList\u0026lt;Integer\u0026gt; city = new ArrayList\u0026lt;\u0026gt;(); // i 是被切断城市 for (int i = 1; i \u0026lt;= n; i++) { // 利用并查集对城市进行关联 UnionFindSet ufs = new UnionFindSet(n + 1); for (int[] relation : relations) { int x = relation[0]; int y = relation[1]; // 如果x或y是被切断城市，则对应连接关系不成立 if (x == i || y == i) continue; // 否则连接x和y ufs.union(x, y); } int[] cnts = new int[n + 1]; for (int j = 1; j \u0026lt;= n; j++) { // 对j=1~n每个城市找根fa int fa = ufs.find(j); // 根fa下的子城市个数++ cnts[fa]++; } // cnts的最大值即最大城市群大小 int dp = Arrays.stream(cnts).max().orElse(0); // 和minDp比较，保留最小值 if (dp \u0026lt; minDp) { minDp = dp; city = new ArrayList\u0026lt;\u0026gt;(); city.add(i); } else if (dp == minDp) { city.add(i); } } // 如果有多个，按照编号升序输出。 city.sort((a, b) -\u0026gt; a - b); StringJoiner sj = new StringJoiner(\u0026#34; \u0026#34;); for (Integer c : city) { sj.add(c + \u0026#34;\u0026#34;); } return sj.toString(); } // 并查集实现 static class UnionFindSet { int[] fa; public UnionFindSet(int n) { this.fa = new int[n]; for (int i = 0; i \u0026lt; n; i++) fa[i] = i; } public int find(int x) { if (this.fa[x] != x) { return this.fa[x] = this.find(this.fa[x]); } return x; } public void union(int x, int y) { int x_fa = this.find(x); int y_fa = this.find(y); if (x_fa != y_fa) { this.fa[y_fa] = x_fa; } } } 20. 找单词\r#\r描述\n给一个字符串和一个二维字符数组，如果该字符串存在于该数组中， 则按字符串的字符顺序输出字符串每个字符所在单元格的位置下标字符串，如果找不到返回字符串“N”。 1.需要按照字符串的字符组成顺序搜索，且搜索到的位置必须是相邻单元格，其中“相邻单元格”是指那些水平相邻或垂直相邻的单元格。 2.同一个单元格内的字母不允许被重复使用。 3.假定在数组中最多只存在一个可能的匹配。 输入描述： 第1行为一个数字N指示二维数组在后续输入所占的行数。 第2行到第N+1行输入为一个二维大写字符数组，每行字符用半角,分割。 第N+2行为待查找的字符串，由大写字符组成。 二维数组的大小为N*N，0＜N≤100。 单词长度K，0＜K＜1000。 输出描述： 输出一个位置下标字符串，拼接格式为：第1个字符行下标+”,”+第1个字符列下标+”,” +第2个字符行下标+”,”+第2个字符列下标… +”,” +第N个字符行下标+”,”+第N个字符列下标。 输入：4 A,C,C,F C,D,E,D B,E,S,S F,E,C,A ACCESS 输出：0,0,0,1,0,2,1,2,2,2,2,3 题解\nstatic int n; static String[][] matrix; static String tar; public static void main(String[] args) { // 将输入分隔符改为“,”和换行 Scanner sc = new Scanner(System.in).useDelimiter(\u0026#34;[,\\n]\u0026#34;); n = sc.nextInt(); matrix = new String[n][n]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { matrix[i][j] = sc.next(); } } tar = sc.next(); System.out.println(getResult()); } public static String getResult() { for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { LinkedList\u0026lt;Integer[]\u0026gt; path = new LinkedList\u0026lt;\u0026gt;(); if (dfs(i, j, 0, path)) { StringJoiner sj = new StringJoiner(\u0026#34;,\u0026#34;); for (Integer[] pos : path) sj.add(pos[0] + \u0026#34;,\u0026#34; + pos[1]); return sj.toString(); } } } return \u0026#34;N\u0026#34;; } public static boolean dfs(int i, int j, int k, LinkedList\u0026lt;Integer[]\u0026gt; path) { if (i \u0026lt; 0 || i \u0026gt;= n || j \u0026lt; 0 || j \u0026gt;= n || !tar.substring(k, k + 1).equals(matrix[i][j])) { return false; } path.add(new Integer[] {i, j}); if (path.size() == tar.length()) return true; String tmp = matrix[i][j]; matrix[i][j] = null; boolean res = dfs(i - 1, j, k + 1, path) || dfs(i + 1, j, k + 1, path) || dfs(i, j - 1, k + 1, path) || dfs(i, j + 1, k + 1, path); if (!res) { matrix[i][j] = tmp; path.removeLast(); } return res; } 21. 找到比自己强的人数\r#\r描述\n给定数组[[2,1],[3 2]]，每组表示师徒关系，第一个元素是第二个元素的老师，数字代表排名，现在找出比自己强的徒弟。 输入：[[2,1],[3,2]] 输出：[0,1,2] 说明\t输入： 第一行数据[2,1]表示排名第 2 的员工是排名第 1 员工的导师，后面的数据以此类推。 输出： 第一个元素 0 表示成绩排名第一的导师，没有徒弟考试超过他； 第二个元素 1 表示成绩排名第二的导师，有 1 个徒弟成绩超过他 第三个元素 2 表示成绩排名第三的导师，有 2 个徒弟成绩超过他 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); // 正则：(?\u0026lt;=\\]),(?=\\[) 的含义是，找这样一个“,“,它的前面跟着\u0026#34;]\u0026#34;，后面跟着\u0026#34;[\u0026#34; String[] split = str.substring(1, str.length() - 1).split(\u0026#34;(?\u0026lt;=\\\\]),(?=\\\\[)\u0026#34;); Integer[][] relations = Arrays.stream(split) .map(s -\u0026gt; Arrays.stream(s.substring(1, s.length() - 1).split(\u0026#34;,\u0026#34;)) .map(Integer::parseInt).toArray(Integer[]::new)).toArray(Integer[][]::new); System.out.println(getResult(relations)); } public static String getResult(Integer[][] relations) { // fa用于统计每个师傅名下的直接徒弟的排名，fa对象的属性是师傅排名， // 属性值是一个数组，里面元素是直接徒弟的排名 HashMap\u0026lt;Integer, ArrayList\u0026lt;Integer\u0026gt;\u0026gt; fa = new HashMap\u0026lt;\u0026gt;(); for (Integer[] relation : relations) { int f = relation[0]; int c = relation[1]; fa.putIfAbsent(f, new ArrayList\u0026lt;\u0026gt;()); fa.putIfAbsent(c, new ArrayList\u0026lt;\u0026gt;()); fa.get(f).add(c); } ArrayList\u0026lt;Integer[]\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); // 输出结果要求依次统计：排名第一的师傅的高于自己的徒弟的个数， // 排名第二的师傅的高于自己的徒弟的个数，...... for (Integer f : fa.keySet()) { ans.add(new Integer[] {f, getHighC(f, f, new HashSet\u0026lt;\u0026gt;(), fa)}); } // 按照师傅排名升序后，输出高于师傅排名的徒弟的个数 ans.sort((a, b) -\u0026gt; a[0] - b[0]); return Arrays.toString(ans.stream().map(arr -\u0026gt; arr[1]).toArray(Integer[]::new)); } /** * @param f 当前的师傅，初始时为源头祖师 * @param src 源头祖师 * @param highC 比源头祖师排名的高的徒弟的排名集合 * @param fa fa对象的属性是师傅排名，属性值是一个数组，里面元素是直接徒弟的排名 * @return 比源头祖师排名的高的徒弟的个数，即highC.size */ public static int getHighC( int f, int src, HashSet\u0026lt;Integer\u0026gt; highC, HashMap\u0026lt;Integer, ArrayList\u0026lt;Integer\u0026gt;\u0026gt; fa) { if (f == 1) return 0; // 如果当前师傅是第一名，那么肯定没有徒弟超过它，因此直接返回0 // 遍历当前师傅的所有徒弟 for (int c : fa.get(f)) { // flag标记是否需要统计间接徒弟，默认需要 boolean flag = true; // 如果徒弟的排名高于源头祖师（排名越高，值越小），则应该统计到highC集合中 if (c \u0026lt; src) { if (!highC.contains(c)) { // 如果highC集合没有这个徒弟，则统计，并需要统计这个徒弟的徒弟（即间接徒弟）的排名情况 highC.add(c); } else { // 如果highC中已经有了当前的徒弟，则说明当前徒弟已经统计过了， // 不需要再统计，且当前徒弟的徒弟也不需要再统计了 flag = false; } } else if (c == src) { // 形成环，需要打断 return 0; } // 统计间接徒弟 if (flag) getHighC(c, src, highC, fa); } return highC.size(); } 22. 找数字\r#\r描述\n小扇和小船今天又玩起来了数字游戏，小船给小扇一个正整数 n（1 ≤ n ≤ 1e9），小扇需要找到一个比 n 大的数字 m， 使得 m 和 n 对应的二进制中 1 的个数要相同，现在求 m 的最小值。 输入描述：输入一个正整数 n（1 ≤ n ≤ 1e9） 输出描述：输出一个正整数 m 输入：2 输出：4 输入：7 输出：11 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); // 将整数n转为二进制字符串 String nBinStr = \u0026#34;0\u0026#34; + Integer.toBinaryString(n); char[] mBinCharArr = nBinStr.toCharArray(); int countOne = 0; for (int i = mBinCharArr.length - 2; i \u0026gt;= 0; i--) { if (mBinCharArr[i] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; mBinCharArr[i + 1] == \u0026#39;1\u0026#39;) { // 从右向左找到了第一组\u0026#34;01\u0026#34;子串，则替换为\u0026#34;10\u0026#34; mBinCharArr[i] = \u0026#39;1\u0026#39;; mBinCharArr[i + 1] = \u0026#39;0\u0026#39;; // 如果第一组\u0026#34;01\u0026#34;子串右边存在1 if (countOne \u0026gt; 0) { // 则将第一组\u0026#34;01\u0026#34;子串的右边部分的\u0026#39;1\u0026#39;要全部集中到尾部 for (int j = i + 2; j \u0026lt; mBinCharArr.length; j++) { if (j \u0026lt; mBinCharArr.length - countOne) { mBinCharArr[j] = \u0026#39;0\u0026#39;; } else { mBinCharArr[j] = \u0026#39;1\u0026#39;; } } } break; } if (mBinCharArr[i + 1] == \u0026#39;1\u0026#39;) countOne++; // 记录第一组\u0026#34;01\u0026#34;子串右边1的个数 } int m = Integer.parseInt(new String(mBinCharArr), 2); System.out.println(m); } 23. 智能驾驶\r#\r描述\n有一辆汽车需要从 m * n 的地图左上角（起点）开往地图的右下角（终点）， 去往每一个地区都需要消耗一定的油量，加油站可进行加油。请你计算汽车确保从从起点到达终点时所需的最少初始油量。 说明： 1. 智能汽车可以上下左右四个方向移动 2. 地图上的数字取值是 0 或 -1 或 正整数： -1 ：表示加油站，可以加满油，汽车的油箱容量最大为100； 0 ：表示这个地区是障碍物，汽车不能通过 正整数：表示汽车走过这个地区的耗油量 3. 如果汽车无论如何都无法到达终点，则返回 -1 输入描述： 第一行为两个数字，M，N，表示地图的大小为 M * N，0 ＜ M,N ≤ 200， 后面一个 M * N 的矩阵，其中的值是 0 或 -1 或正整数，加油站的总数不超过 200 个 输出描述： 如果汽车无论如何都无法到达终点，则返回 -1 如果汽车可以到达终点，则返回最少的初始油量 输入：2,2 10,20 30,40 输出：70 题解\nstatic int m; static int n; static int[][] matrix; public static void main(String[] args) { Scanner sc = new Scanner(System.in).useDelimiter(\u0026#34;[,\\n]\u0026#34;); // 将逗号和换行符作为一次读取的截止符 m = sc.nextInt(); n = sc.nextInt(); matrix = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { matrix[i][j] = sc.nextInt(); } } System.out.println(bfs()); } // 上下左右四个方向对应的偏移量 static int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 记录路径中位置的几个状态 static class Node { int x; // 位置横坐标 int y; // 位置纵坐标 int init; // 到达此位置所需的最少初始油量 int remain; // 到达此位置时剩余可用油量 boolean flag; // 到达此位置前有没有加过油 public Node(int x, int y) { this.x = x; this.y = y; } } public static int bfs() { // 如果左上角和右下角不可达，则直接返回-1 if (matrix[0][0] == 0 || matrix[m - 1][n - 1] == 0) { return -1; } // 广搜队列 LinkedList\u0026lt;Node\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // 起始位置 Node src = new Node(0, 0); if (matrix[0][0] == -1) { // 如果起始位置就是加油站，则到达(0,0)位置所需初始油量为0， // 且剩余可用油量为100，且需要标记已加油 src.init = 0; src.remain = 100; src.flag = true; } else { // 如果起始位置不是加油站，则到达(0,0)位置所需的初始油量至少为matrix[0][0], // 剩余可用油量为0，未加油状态 src.init = matrix[0][0]; src.remain = 0; src.flag = false; } queue.add(src); // dist_init[x][y] 用于记录起点 (0, 0) 到达 (x, y) 的所有可达路径中最优路径 // （即初始油量需求最少的路径）的初始油量 int[][] dist_init = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { // 由于需要记录每个位置的最少需要的初始油量， // 因此每个位置所需的初始油量初始化为一个较大值 dist_init[i][j] = Integer.MAX_VALUE; } } // dist_remain 用于记录起点 (0,0) 到达 (x,y) 的所有可达路径中最优路径 // （即初始油量需求最少的路径）的最大剩余可用油量 // 即如果存在多条最优路径，我们应该选这些路径中到达此位置剩余油量最多的 int[][] dist_remain = new int[m][n]; // 起点（0,0）到达自身位置（0,0）所需的最少初始油量和最多剩余油量 dist_init[0][0] = src.init; dist_remain[0][0] = src.remain; // 广搜 while (queue.size() \u0026gt; 0) { Node cur = queue.removeFirst(); // 从当前位置cur开始向上下左右四个方向探路 for (int[] offset : offsets) { // 新位置 int newX = cur.x + offset[0]; int newY = cur.y + offset[1]; // 新位置越界 或者 新位置是障碍，则新位置不可达，继续探索其他方向 if (newX \u0026lt; 0 || newX \u0026gt;= m || newY \u0026lt; 0 || newY \u0026gt;= n || matrix[newX][newY] == 0) continue; // 如果新位置可达，则计算到达新位置的三个状态数据 int init = cur.init; // 到达新位置所需的最少初始油量 int remain = cur.remain; // 到达新位置时还剩余的最多可用油量 boolean flag = cur.flag; // 是否加油了 if (matrix[newX][newY] == -1) { // 如果新位置是加油站，则加满油 remain = 100; // 标记加过油了 flag = true; } else { // 如果新位置不是加油站，则需要消耗matrix[newX][newY]个油 remain -= matrix[newX][newY]; } // 如果到达新位置后，剩余油量为负数 if (remain \u0026lt; 0) { if (flag) { // 如果之前已经加过油了，则说明到达此路径前是满油状态， // 因此我们无法从初始油量里面\u0026#34;借\u0026#34;油 continue; } else { // 如果之前没有加过油，则超出的油量（-remain），可以从初始油量里面\u0026#34;借\u0026#34;， // 即需要初始油量 init + (-remain) 才能到达新位置 init -= remain; // 由于初始油量 init + (-remain) 刚好只能支持汽车到达新位置， // 因此汽车到达新位置后剩余可用油量为0 remain = 0; } } // 如果到达新位置所需的初始油量超过了满油100，则无法到达新位置 if (init \u0026gt; 100) { continue; } // 如果可达新位置，则继续检查当前路径策略到达新位置(newX, newY) // 所需的初始油量init是否比其他路径策略更少 if (init \u0026gt; dist_init[newX][newY]) { // 如果不是，则无需探索新位置(newX, newY) continue; } // 当前路径策略到达新位置(newX,newY)所需初始油量init更少， // 或者，init和前面路径策略相同，但是当前路径策略剩余可用油量remain更多 if (init \u0026lt; dist_init[newX][newY] || remain \u0026gt; dist_remain[newX][newY]) { // 则当前路径策略更优，记录更优路径的状态 dist_init[newX][newY] = init; dist_remain[newX][newY] = remain; // 将当前新位置加入BFS队列 Node next = new Node(newX, newY); next.init = init; next.remain = remain; next.flag = flag; queue.add(next); } } } // dist_init[m - 1][n - 1] 记录的是到达右下角终点位置所需的最少初始油量 return dist_init[m - 1][n - 1] == Integer.MAX_VALUE ? -1 : dist_init[m - 1][n - 1]; } 24. 中文分词模拟器\r#\r描述\n给定一个连续不包含空格的字符串，该字符串仅包含英文小写字母及英文标点符号（逗号、分号、句号）， 同时给定词库，对该字符串进行精确分词。 说明： 1. 精确分词：字符串分词后，不会出现重叠。即\u0026#34;ilovechina\u0026#34;， 不同词库可分割为\u0026#34;i,love,china\u0026#34;，\u0026#34;ilove,china\u0026#34;，不能分割出现重叠的\u0026#34;i,ilove,china\u0026#34;，i 出现重叠 2. 标点符号不成词，仅用于断句 3. 词库：根据外部知识库统计出来的常用词汇例：dictionary = [\u0026#34;i\u0026#34;, \u0026#34;love\u0026#34;, \u0026#34;china\u0026#34;, \u0026#34;lovechina\u0026#34;, \u0026#34;ilove\u0026#34;] 4. 分词原则：采用分词顺序优先且最长匹配原则 \u0026#34;ilovechina\u0026#34;，假设分词结果 [i,ilove,lo,love,ch,china,lovechina]，则输出 [ilove,china] 错误输出：[i,lovechina]，原因：\u0026#34;ilove\u0026#34; \u0026gt; 优先于 \u0026#34;lovechina\u0026#34; 成词 错误输出：[i,love,china]，原因：\u0026#34;ilove\u0026#34; \u0026gt; \u0026#34;i\u0026#34;遵循最长匹配原则 输入描述： 第一行输入待分词语句 \u0026#34;ilovechina\u0026#34; 字符串长度限制：0 ＜ length ＜ 256 第二行输入中文词库 \u0026#34;i,love,china,ch,na,ve,lo,this,is,this,word\u0026#34; 词库长度限制：1 ＜ length ＜ 100000 输出描述： 按顺序输出分词结果 \u0026#34;i,love,china\u0026#34; 输入：iat i,love,china,ch,na,ve,lo,this,is,the,word,beauti,tiful,ful 输出：i,a,t 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] sentences = sc.nextLine().split(\u0026#34;[,.;]\u0026#34;); String[] words = sc.nextLine().split(\u0026#34;[,.;]\u0026#34;); System.out.println(getResult(sentences, words)); } public static String getResult(String[] sentences, String[] words) { // wordSet 记录词库词汇 HashSet\u0026lt;String\u0026gt; wordSet = new HashSet\u0026lt;\u0026gt;(Arrays.asList(words)); // queue记录待分词语句 LinkedList\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(Arrays.asList(sentences)); // ans记录最终分词结果 LinkedList\u0026lt;String\u0026gt; ans = new LinkedList\u0026lt;\u0026gt;(); while (queue.size() \u0026gt; 0) { // 待分词的句子 String sentence = queue.removeFirst(); int r = sentence.length(); for (; r \u0026gt; 0; r--) { // 截取句子 [0,r) 范围子串词汇, 这样的就能实现优先最长匹配， // 并且由于是必须从0索引开始截取，因此满足了分词顺序优先 String fragment = sentence.substring(0, r); // 若词库中是否存在该子串词汇 if (wordSet.contains(fragment)) { // 则将对应子串词汇纳入结果 ans.addLast(fragment); // 我理解词库中每个词汇只能使用一次，因此这里将词库中使用过的词汇移除 wordSet.remove(fragment); // 若子串词汇只是句子部分，则句子剩余部分还要继续去词库中查找 if (r \u0026lt; sentence.length()) { queue.addFirst(sentence.substring(r)); } break; } } // 没有在词库中找到对应子串词汇，则输出单个字母 if (r == 0) { // 注意，这里只放一个字母到结果中，句子剩余部分继续去词库中查找 ans.add(sentence.charAt(0) + \u0026#34;\u0026#34;); if (sentence.length() \u0026gt; 1) { queue.addFirst(sentence.substring(1)); } } } StringJoiner sj = new StringJoiner(\u0026#34;,\u0026#34;); ans.forEach(sj::add); return sj.toString(); } 25. 转骰子\r#\r描述\n骰子是一个立方体，每个面一个数字，初始为左1，右2，前3(观察者方向)，后4，上5，下6，用123456表示这个状态，放置在平面上， 1. 可以向左翻转(用L表示向左翻转1次)， 2. 可以向右翻转(用R表示向右翻转1次)， 3. 可以向前翻转(用F表示向前翻转1次)， 4. 可以向后翻转(用B表示向后翻转1次)， 5. 可以逆时针旋转(用A表示逆时针旋转90度)， 6. 可以顺时针旋转(用C表示顺时针旋转90度)， 现从123456这个初始状态开始，根据输入的动作序列，计算得到最终的状态。 骰子的初始状态和初始状态转动后的状态如图所示。 输入描述： 输入一行，为只包含LRFBAC的字母序列，最大长度为50，字母可重复。 输出描述： 输出最终状态 输入：L R 输出：123456 输入：F C R 输出：342156 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] directives = sc.nextLine().split(\u0026#34; \u0026#34;); turnDice(directives); } public static void turnDice(String[] directives) { Dice dice = new Dice(); for (String directive : directives) { switch (directive) { case \u0026#34;L\u0026#34;: dice.turnL(); break; case \u0026#34;R\u0026#34;: dice.turnR(); break; case \u0026#34;F\u0026#34;: dice.turnF(); break; case \u0026#34;B\u0026#34;: dice.turnB(); break; case \u0026#34;A\u0026#34;: dice.turnA(); break; case \u0026#34;C\u0026#34;: dice.turnC(); break; } } dice.print(); } static class Dice { int left = 1; int right = 2; int front = 3; int back = 4; int top = 5; int bottom = 6; public void turnL() { // 前后不变，上变左，左变下，下变右，右变上 int tmp = this.right; this.right = this.bottom; this.bottom = this.left; this.left = this.top; this.top = tmp; } public void turnR() { // 前后不变，上变右，右变下，下变左，左变上 int tmp = this.left; this.left = this.bottom; this.bottom = this.right; this.right = this.top; this.top = tmp; } public void turnF() { // 左右不变，上变前，前变下，下变后，后变上 int tmp = this.front; this.front = this.top; this.top = this.back; this.back = this.bottom; this.bottom = tmp; } public void turnB() { // 左右不变，前变上，上变后，后变下，下边前 int tmp = this.top; this.top = this.front; this.front = this.bottom; this.bottom = this.back; this.back = tmp; } public void turnA() { // 上下不变， 前变右，右变后，后变左，左变前 int tmp = this.right; this.right = this.front; this.front = this.left; this.left = this.back; this.back = tmp; } public void turnC() { // 上下不变， 右变前，前变左，左变后，后变右 int tmp = this.front; this.front = this.right; this.right = this.back; this.back = this.left; this.left = tmp; } public void print() { String sb = String.valueOf(this.left) + this.right + this.front + this.back + this.top + this.bottom; System.out.println(sb); } } "},{"id":280,"href":"/algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%9314/","title":"机试题库 - 14","section":"华为OD","content":"\r01. 字符串比较\r#\r描述\n给定字符串A、B和正整数V，A的长度与B的长度相等， 请计算A中满足如下条件的最大连续子串的长度： 1. 该连续子串在A和B中的位置和长度均相同。 2. 该连续子串|A[i] – B[i]|之和小于等于V。其中|A[i] – B[i]|表示两个字母ASCII码之差的绝对值。 输入描述： 第一行为字符串A，仅包含小写字符，1 ≤ A.length ≤1000。 第二行为字符串B，仅包含小写字符，1 ≤ B.length ≤1000。 第三行为正整数V，0≤ V ≤ 10000。 输出描述： 字符串最大连续子串的长度，要求该子串|A[i] – B[i]|之和小于等于V。 输入：xxcdefg cdefghi 5 输出：2 说明：它的最大连续子串可以是cd-\u0026gt;ef,de-\u0026gt;fg,ef-\u0026gt;gh,fg-\u0026gt;hi，所以最大连续子串是2。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String a = sc.nextLine(); String b = sc.nextLine(); int v = Integer.parseInt(sc.nextLine()); System.out.println(getResult(a, b, v)); } public static int getResult(String a, String b, int v) { int n = a.length(); // a,b字符串的各位字符的ascii绝对值差距数组 int[] preSum = new int[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { preSum[i] = preSum[i - 1] + Math.abs(a.charAt(i - 1) - b.charAt(i - 1)); } int ans = 0; for (int l = 0; l \u0026lt;= n - 1; l++) { for (int r = l + 1; r \u0026lt;= n; r++) { // 区间 [l+1, r]的和 = preSum[r] - preSum[l] if (preSum[r] - preSum[l] \u0026lt;= v) { ans = Math.max(ans, r - l); } } } return ans; } 02. 字符串拼接\r#\r描述\n给定 M（0 ＜ M ≤ 30）个字符（a-z），从中取出任意字符（每个字符只能用一次）拼接成长度为 N（0 ＜ N ≤ 5）的字符串， 要求相同的字符不能相邻，计算出给定的字符列表能拼接出多少种满足条件的字符串， 输入非法或者无法拼接出满足条件的字符串则返回0。 输入描述：给定的字符列表和结果字符串长度，中间使用空格(\u0026#34; \u0026#34;)拼接 输出描述：满足条件的字符串个数 输入：abc 1 输出：3 输入：dde 2 输出：2 题解\nstatic String s; static int n; public static void main(String[] args) { Scanner sc = new Scanner(System.in); s = sc.next(); n = sc.nextInt(); System.out.println(getResult()); } public static int getResult() { if (s.length() \u0026lt; n) { // 无法拼接出满足条件的字符串 return 0; } char[] cArr = s.toCharArray(); for (char c : cArr) { // 输入非法 if (c \u0026lt; \u0026#39;a\u0026#39; || c \u0026gt; \u0026#39;z\u0026#39;) return 0; } // 排序cArr，可以方便后面求解全排列时，进行树层去重 Arrays.sort(cArr); return dfs(cArr, -1, 0, new boolean[cArr.length], 0); } /** * 全排列求解 * * @param cArr 基于cArr数组求解全排列 * @param pre 排列最后一个字符在cArr中的位置 * @param level 排列的长度 * @param used used[i] 用于标记 cArr[i] 元素是否已使用 * @param count 符号要求的排列有几个 * @return count */ public static int dfs(char[] cArr, int pre, int level, boolean[] used, int count) { // 当排列长度到达n，则是一个符合要求的排列 if (level == n) { // 符合要求的排列个数+1 return ++count; } for (int i = 0; i \u0026lt; cArr.length; i++) { // 每个字符只能用一次 if (used[i]) continue; // 相同的字符不能相邻， pre指向前面一个被选择的字符的在cArr中的位置， // i指向当前被选择的字符在cArr中的位置 if (pre \u0026gt;= 0 \u0026amp;\u0026amp; cArr[i] == cArr[pre]) continue; // 树层去重(去除重复排列) if (i \u0026gt; 0 \u0026amp;\u0026amp; cArr[i] == cArr[i - 1] \u0026amp;\u0026amp; !used[i - 1]) continue; used[i] = true; count = dfs(cArr, i, level + 1, used, count); used[i] = false; } return count; } 03. 最大社交距离\r#\r描述\n疫情期间需要大家保证一定的社交距离，公司组织开交流会议。 座位一排共 N 个座位，编号分别为 [0, N - 1] 。要求员工一个接着一个进入会议室，并且可以在任何时候离开会议室。 满足： 每当一个员工进入时，需要坐到最大社交距离（最大化自己和其他人的距离的座位）； 如果有多个这样的座位，则坐到索引最小的那个座位。 输入描述： 会议室座位总数 seatNum，1 ≤ seatNum ≤ 500 员工的进出顺序 seatOrLeave 数组 元素值为 1，表示进场 元素值为负数，表示出场（特殊：位置 0 的员工不会离开） 例如 -4 表示坐在位置 4 的员工离开（保证有员工坐在该座位上） 输出描述： 最后进来员工，他会坐在第几个位置，如果位置已满，则输出-1。 输入：10 [1, 1, 1, 1, -4, 1] 输出：5 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int seatNum = Integer.parseInt(sc.nextLine()); String tmp = sc.nextLine(); String[] split = tmp.substring(1, tmp.length() - 1).split(\u0026#34;, \u0026#34;); int[] searOrLeave = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(seatNum, searOrLeave)); } public static int getResult(int seatNum, int[] seatOrLeave) { // 记录已经坐人位置的序号 ArrayList\u0026lt;Integer\u0026gt; seatIdx = new ArrayList\u0026lt;\u0026gt;(); // 记录题解 int lastSeatIdx = -1; // 遍历员工的进出顺序 for (int info : seatOrLeave) { // 如果当前元素值为负数，表示出场（特殊：位置 0 的员工不会离开） // 例如 -4 表示坐在位置 4 的员工离开（保证有员工坐在该座位上） if (info \u0026lt; 0) { int leaveIdx = -info; seatIdx.remove(leaveIdx); continue; } // 如果当前元素值为 1，表示进场 // 如果没有空闲位置，则坐不下 if (seatIdx.size() == seatNum) { // 假设当前人就是最后一个人 lastSeatIdx = -1; continue; } if (seatIdx.size() == 0) { // 当前人员进场前，座位上没有人，则当前人员是第一个进场的，直接坐第0个位置 seatIdx.add(0); lastSeatIdx = 0; } else if (seatIdx.size() == 1) { // 当前人员进场前，座位上只有一个人，那么这个人肯定坐在第0个位置， // 则当前进场的人坐在 seatNum - 1 位置才能离 0 位置最远 seatIdx.add(seatNum - 1); lastSeatIdx = seatNum - 1; } else { // 记录具有最大社交距离的座位号 int bestSeatIdx = -1; // 记录最大社交距离 int bestSeatDis = -1; // 找到连续空闲座位区域（该区域左、右边界是坐了人的座位） int left = seatIdx.get(0); // 左边界 for (int i = 1; i \u0026lt; seatIdx.size(); i++) { int right = seatIdx.get(i); // 右边界 // 连续空闲座位区域的长度 int dis = right - left - 1; // 如果连续空闲座位区域长度为0，则无法坐人，此时遍历下一个连续空闲座位区域 // 如果连续空闲座位区域长度大于0，则可以坐人 if (dis \u0026gt; 0) { // 当前空闲区域能产生的最大社交距离 int curSeatDis = dis / 2 - (dis % 2 == 0 ? 1 : 0); // 当前空闲区域中具备最大社交距离的位置 int curSeatIdx = left + curSeatDis + 1; // 保留最优解 if (curSeatDis \u0026gt; bestSeatDis) { bestSeatDis = curSeatDis; bestSeatIdx = curSeatIdx; } } left = right; } // 如果最后一个座位，即第 seatNum - 1 号座位没有坐人的话， // 比如 1 0 0 0 1 0 0 0 0，此时最后一段空闲区域是没有右边界的，需要特殊处理 if (seatIdx.get(seatIdx.size() - 1) \u0026lt; seatNum - 1) { // 此时可以直接坐到第 seatNum - 1 号座位，最大社交距离为 curSeatDis int curSeatDis = seatNum - 1 - seatIdx.get(seatIdx.size() - 1) - 1; int curSeatIdx = seatNum - 1; // 保留最优解 if (curSeatDis \u0026gt; bestSeatDis) { bestSeatIdx = curSeatIdx; } } // 如果能坐人，则将坐的位置加入seatIdx中 if (bestSeatIdx \u0026gt; 0) { seatIdx.add(bestSeatIdx); seatIdx.sort((a, b) -\u0026gt; a - b); } // 假设当前人就是最后一个人，那么无论当前人是否能坐进去， // 都更新lastSeatIdx = bestSeatIdx lastSeatIdx = bestSeatIdx; } } return lastSeatIdx; } 04. 最小传输时延Ⅱ\r#\r描述\n有M*N的节点矩阵，每个节点可以向8个方向（上、下、左、右及四个斜线方向）转发数据包，每个节点转发时会消耗固定时延， 连续两个相同时延可以减少一个时延值（即当有K个相同时延的节点连续转发时可以减少K- 1个时延值）， 求左上角（0，0）开始转发数据包到右下角（M-1，N- 1）并转发出的最短时延。 输入描述：第一行两个数字，M、N，接下来有M行，每行有N个数据，表示M* N的矩阵。 输出描述：最短时延值。 输入：3 3 0 2 2 1 2 1 2 2 1 输出：3 题解\n// 地图矩阵 static int[][] matrix; // 最短路径矩阵，即dist[i][j]记录的是坐标(i,j)到(0,0)的最短距离 static int[][] dist; // 地图矩阵行数 static int m; // 地图矩阵列数 static int n; // 八个方向偏移量 static int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {-1, -1}, {-1, 1}, {1, -1}, {1, 1}}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); m = sc.nextInt(); n = sc.nextInt(); matrix = new int[m][n]; dist = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { matrix[i][j] = sc.nextInt(); // 最短路径矩阵初始化，假设每个点到(0,0)距离无穷大 dist[i][j] = Integer.MAX_VALUE; } } System.out.println(spfa()); } public static int spfa() { LinkedList\u0026lt;int[]\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.add(new int[] {0, 0}); dist[0][0] = matrix[0][0]; while (queue.size() \u0026gt; 0) { int[] tmp = queue.removeFirst(); int x = tmp[0], y = tmp[1]; for (int[] offset : offsets) { int newX = x + offset[0]; int newY = y + offset[1]; if (newX \u0026gt;= 0 \u0026amp;\u0026amp; newX \u0026lt; m \u0026amp;\u0026amp; newY \u0026gt;= 0 \u0026amp;\u0026amp; newY \u0026lt; n) { int newDist = dist[x][y] + matrix[newX][newY]; // 题目说：连续两个相同时延可以减少一个时延值 // 但是需要注意的是，应该不能产生负的时延值，比如前一个时延是0， // 当前时延也是0，则减少1个时延值，不应该变为-1 if (matrix[newX][newY] == matrix[x][y] \u0026amp;\u0026amp; matrix[newX][newY] \u0026gt;= 1) { newDist -= 1; } if (newDist \u0026lt; dist[newX][newY]) { dist[newX][newY] = newDist; queue.add(new int[] {newX, newY}); } } } } return dist[m - 1][n - 1]; } 05. 最小矩阵宽度\r#\r描述\n给定一个矩阵，包含 N * M 个整数，和一个包含 K 个整数的数组。 现在要求在这个矩阵中找一个宽度最小的子矩阵，要求子矩阵包含数组中所有的整数。 输入描述： 第一行输入两个正整数 N，M，表示矩阵大小。 接下来 N 行 M 列表示矩阵内容。 下一行包含一个正整数 K。 下一行包含 K 个整数，表示所需包含的数组，K 个整数可能存在重复数字。 所有输入数据小于1000。 输出描述： 输出包含一个整数，表示满足要求子矩阵的最小宽度，若找不到，输出-1。 输入：2 5 1 2 2 3 1 2 3 2 3 2 3 1 2 3 输出：2 说明：矩阵第0、3列包含了1，2，3，矩阵第3，4列包含了1，2，3 题解\nstatic int n; // 矩阵行数 static int m; // 矩阵列数 static int[][] matrix; // 矩阵 static int k; // 目标数组长度 static int[] cnts; // cnts[num] 记录的是 目标数组中num元素的个数 public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); m = sc.nextInt(); matrix = new int[n][m]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { matrix[i][j] = sc.nextInt(); } } k = sc.nextInt(); cnts = new int[1000]; for (int i = 0; i \u0026lt; k; i++) { int num = sc.nextInt(); cnts[num]++; } System.out.println(getResult()); } public static int getResult() { // 未完成匹配的元素的个数 int total = k; // 记录最小子矩阵的宽度 int minLen = Integer.MAX_VALUE; // 当前子矩阵的左边界（列号） int l = 0; // 当前子矩阵的右边界（列号） int r = 0; // 如果右边界未越界，则可以继续尝试找最小子矩阵 while (r \u0026lt; m) { // 将第r列所有元素纳入子矩阵 for (int i = 0; i \u0026lt; n; i++) { // 第r列的元素num int num = matrix[i][r]; // cnts[num] 记录的是 目标数组中num元素的个数，也可以理解为： // 目标数组中num元素剩余未匹配的个数 // 如果num不是目标数组元素，则cnts[num]初始时必然为0， // 对于非目标数组元素num, 即使进行了 cnts[num]--， 也不影响总的未匹配数量 total // 如果num是目标数组元素，则cnts[num]初始时必然大于0， // 且随着子矩阵扩大范围，如果子矩阵中包含num元素个数超过了初始cnts[num]数量， // 则超出部分起不到匹配效果，即不能影响总的未匹配数量 if (cnts[num]-- \u0026gt; 0) { total--; } } // 纳入r列后，看看总的未匹配元素数量total还有几个，如果total为0， // 则说明当前子矩阵匹配到了所有目标数组元素 while (total == 0) { // 若此时子矩阵宽度 r - l + 1 更小，则更新最小子矩阵宽度 minLen = Math.min(minLen, r - l + 1); // 由于当前子矩阵已经匹配到所有目标数组元素， // 因此下一步应该将 l 右移，尝试更小宽度的子矩阵 for (int i = 0; i \u0026lt; n; i++) { // l 右移，相当于当前子矩阵移除了第 l 列所有元素， // 被移除的元素num如果是目标数组元素，则对应的未匹配数量应该被恢复 int num = matrix[i][l]; // 如果当前num不是目标数组元素，或者当前num是目标数组元素， // 但是属于超出部分（这两种情况必然cnts[num] \u0026lt; 0）， // 则对应num元素的恢复，不能影响到整体未匹配数量total， // 如果当前num是目标数组元素，且不是超出部分（此时必然cnts[num] \u0026gt;= 0）， // 则对应num元素的恢复，会影响到整体未匹配数量total if (cnts[num]++ \u0026gt;= 0) { total++; } } // l右移，且下一轮要继续检查l右移后的子矩阵是否依旧能覆盖目标数组所有元素 l++; } // r右移 r++; } if (minLen == Integer.MAX_VALUE) { return -1; } else { return minLen; } } 06. 最长子字符串的长度(二)\r#\r描述\n给你一个字符串 s，字符串 s 首尾相连成一个环形，请你在环中找出 \u0026#39;l\u0026#39;、\u0026#39;o\u0026#39;、\u0026#39;x\u0026#39; 字符都恰好出现了偶数次最长子字符串的长度。 输入描述：输入是一串小写的字母组成的字符串 输出描述：输出是一个整数 备注： 1 ≤ s.length ≤ 5 * 10^5 s 只包含小写英文字母 输入：alolobo 输出：6 输入：looxdolx 输出：7 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.nextLine(); System.out.println(getResult(s)); } public static int getResult(String s) { int status = 0b000; // map.get(i) 用于记录 状态i 出现的过的所有位置 ArrayList\u0026lt;LinkedList\u0026lt;Integer\u0026gt;\u0026gt; map = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 8; i++) { map.add(new LinkedList\u0026lt;\u0026gt;()); } map.get(0).add(-1); int maxLen = 0; for (int i = 0; i \u0026lt; s.length() * 2; i++) { // 第二轮时，i\u0026gt;=s.length()，此时i需要对s.length()求余，避免后面越界 char c = s.charAt(i % s.length()); switch (c) { case \u0026#39;l\u0026#39;: status ^= 0b100; break; case \u0026#39;o\u0026#39;: status ^= 0b010; break; case \u0026#39;x\u0026#39;: status ^= 0b001; break; } if (i \u0026lt; s.length()) { // 第一轮时，i ∈ [0, s.length()), 左闭右开 // 记录该状态出现过的所有位置 map.get(status).add(i); } while (map.get(status).size() \u0026gt; 0) { // status状态最早出现的位置 int earliest = map.get(status).getFirst(); // i 是当前位置，和 earliest 位置的状态相同 if (i - earliest \u0026gt; s.length()) { // 如果 [earliest, i] 范围子串长度超过s串长度， // 则说明earliest左越界，应该尝试更大一点的earliest map.get(status).removeFirst(); } else { // 如果 [earliest, i] 范围子串长度未超过s串长度， // 则该范围子串就是一个符合要求的子串，记录此时子串长度 maxLen = Math.max(maxLen, i - earliest); break; } } } return maxLen; } "},{"id":281,"href":"/algorithm/huawei-od/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/","title":"华为机试","section":"华为OD","content":"\rHJ1：字符串最后一个单词的长度\r#\r描述\n计算字符串最后一个单词的长度，单词以空格隔开，字符串长度小于5000。（注：字符串末尾不以空格为结尾） 输入描述：输入一行，代表要计算的字符串，非空，长度小于5000。 输出描述：输出一个整数，表示输入字符串最后一个单词的长度。 输入：hello nowcoder 输出：8 题解\n// 遍历字符串，每遍历一个字符，length++ // 如果遇到空格，则length归零 public static void main(String[] args) throws Exception{ InputStream InputStream = System.in; int length = 0; char c; while (\u0026#39;\\n\u0026#39; != (c=(char)InputStream.read())) { length++; if (c == \u0026#39; \u0026#39;) { length = 0; } } System.out.println(length); } HJ2：计算某字符出现次数\r#\r描述\n写出一个程序，接受一个由字母、数字和空格组成的字符串，和一个字符，然后输出输入字符串中该字符的出现次数。（不区分大小写字母） 数据范围：1 ≤ n ≤ 1000 输入描述：第一行输入一个由字母、数字和空格组成的字符串，第二行输入一个字符（保证该字符不为空格）。 输出描述：输出输入字符串中含有该字符的个数。（不区分大小写字母） 输入：ABCabc A 输出：2 题解\n// 字符串转为小写 // 遍历字符串数组，判断字符相等，累加count++ public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); char[] chars1 = br.readLine().toLowerCase().toCharArray(); char[] chars2 = br.readLine().toLowerCase().toCharArray(); int count = 0; for (int i = 0; i \u0026lt; chars1.length; i++) { if (chars1[i] == chars2[0]) { count++; } } System.out.println(count); } HJ3：明明的随机数\r#\r描述\n明明生成了个1到500之间的随机整数。请你删去其中重复的数字， 即相同的数字只保留一个，把其余相同的数去掉，然后再把这些数从小到大排序，按照排好的顺序输出。 数据范围：1≤n≤1000 ，输入的数字大小满足 1≤val≤500 输入描述：第一行先输入随机整数的个数 N 。 接下来的 N 行每行输入一个整数，代表明明生成的随机数。 输出描述：输出多行，表示输入数据处理后的结果 输入：3 2 2 1 输出：1 2 题解\n// 数组下标不重复，且有序 public static void main(String[] args)throws IOException { BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); String str; while((str=bf.readLine())!=null) { boolean[] stu = new boolean[1001]; StringBuilder sb=new StringBuilder(); int n = Integer.parseInt(str); for(int i=0;i\u0026lt;n;i++) { stu[Integer.parseInt(bf.readLine())] = true; } for(int i=1;i\u0026lt;1001;i++) { if(stu[i]) { sb.append(i).append(\u0026#34;\\n\u0026#34;); } } sb.deleteCharAt(sb.length()-1); System.out.println(sb.toString()); } } HJ4：字符串分隔\r#\r描述\n输入一个字符串，请按长度为8拆分每个输入字符串并进行输出； 长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。 输入描述：连续输入字符串(每个字符串长度小于等于100) 输出描述：依次输出所有分割后的长度为8的新字符串 输入：abc 输出：abc00000 题解\n// 足够8的部分：直接打印输出，记录字符位置 // 不足8的部分：构造零值数组，再放入字符，最后打印输出 public static void main(String[] args) throws IOException{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str; while((str = br.readLine())!=null){ int len = str.length(); int start = 0; while (len \u0026gt;= 8){ System.out.println(str.substring(start, start + 8)); start += 8; len -= 8; } if (len \u0026gt; 0) { char[] tmp = new char[8]; for(int i = 0;i\u0026lt;8;i++){ tmp[i]=\u0026#39;0\u0026#39;; } for(int i = 0; start \u0026lt; str.length(); i++) { tmp[i] = str.charAt(start++); } System.out.println(String.valueOf(tmp)); } } } HJ5：进制转换\r#\r描述\n写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。 数据范围：保证结果在1≤n≤2^31−1 输入描述：输入一个十六进制的数值字符串。 输出描述：输出该数值的十进制字符串。不同组的测试用例用\\n隔开。 示例： 输入：0xAA 输出：170 题解\n// 判断字符：ASCII码值大于等于65 // 字符代表的值：charNum-65+10 // 数字代表的值：charNum-48 public static void main(String[] args) throws IOException{ BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); String input; while((input = bf.readLine())!=null){ String temp = input.substring(2,input.length()); int sum = 0; int length = temp.length(); for(int i= length-1;i\u0026gt;=0;i--){ char c = temp.charAt(i); int tempNum = (int)c; if(tempNum\u0026gt;=65){ tempNum = tempNum - 65 + 10; }else{ tempNum = tempNum - 48; } sum = sum + (int) Math.pow(16, length-i-1)*tempNum; } System.out.println(sum); } } HJ6：质数因子\r#\r描述\n功能:输入一个正整数，按照从小到大的顺序输出它的所有质因子（重复的也要列举）（如180的质因子为2 2 3 3 5 ） 数据范围：1≤n≤2×10^9+14 输入描述：输入一个整数 输出描述：按照从小到大的顺序输出它的所有质数的因子，以空格隔开。 输入：180 输出：2 2 3 3 5 题解\n// 质数：又叫素数，指的是在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数 // 质数因子：能整除给定正整数的质数 public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str; while ((str = br.readLine()) != null) { int num = Integer.parseInt(str); StringBuilder sb = new StringBuilder(); for (int i = 2; i \u0026lt;= Math.sqrt(num); i++) { if (num % i == 0) { sb.append(i).append(\u0026#34; \u0026#34;); num = num / i; i--; } } sb.append(num).append(\u0026#34; \u0026#34;); System.out.println(sb.toString()); } } HJ7：取近似值\r#\r描述\n写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于 0.5 ,向上取整；小于 0.5 ，则向下取整。 数据范围：保证输入的数字在 32 位浮点数范围内 输入描述：输入一个正浮点数值 输出描述：输出该数值的近似整数值 输入：5.5 输出：6 题解\n// 判断小数点位置，及小数点后一位是否大于等于5 public static void main(String args[])throws Exception{ BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); String str = bf.readLine(); int index = str.indexOf(\u0026#34;.\u0026#34;); int a = Integer.parseInt(str.substring(0, index)); int b = Integer.parseInt(str.substring(index + 1, index + 2)); if(b \u0026gt;= 5){ a++; System.out.println(a); }else{ System.out.println(a); } } HJ8：合并表记录\r#\r描述\n数据表记录包含表索引index和数值value（int范围的正整数），请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照index值升序进行输出。 提示：0≤index≤11111111、1≤value≤100000 输入描述：先输入键值对的个数n（1≤n≤500），接下来n行每行输入成对的index和value值，以空格隔开 输出描述：输出合并后的键值对（多行） 输入：4 0 1 0 2 1 2 3 4 输出：0 3 1 2 3 4 题解\n// 使用HashMap // 使用jdk8流排序 public static void main(String[] args){ Scanner input = new Scanner(System.in); int size = input.nextInt(); Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; size; i++) { int key = input.nextInt(); int value = input.nextInt(); if (map.containsKey(key)) { map.put(key, map.get(key) + value); } else { map.put(key, value); } } List\u0026lt;Integer\u0026gt; list = map.keySet().stream().sorted().collect( Collectors.toList()); for (Integer key : list) { System.out.println( key + \u0026#34; \u0026#34; + map.get(key)); } } HJ9：提取不重复的整数\r#\r描述\n输入一个 int 型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。 保证输入的整数最后一位不是 0 。 数据范围：1≤n≤10^8 输入描述：输入一个int型整数 输出描述：按照从右向左的阅读顺序，返回一个不含重复数字的新的整数 输入：9876673 输出：37689 题解\n// String.charAt() // 去重判断：String.contains() public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String str1=sc.nextLine(); String str2=\u0026#34;\u0026#34;; for(int i=str1.length()-1;i\u0026gt;=0;i--){ String c=String.valueOf(str1.charAt(i)); if(!str2.contains(c)){ str2=str2+c; } } System.out.println(str2); } } HJ10：字符个数统计\r#\r描述\n编写一个函数，计算字符串中含有的不同字符的个数。字符在 ASCII 码范围内( 0~127 ，包括 0 和 127 )，换行表示结束符，不算在字符里。不在范围内的不作统计。多个相同的字符只计算一次 例如，对于字符串 abaca 而言，有 a、b、c 三种不同的字符，因此输出 3 。 数据范围：1≤n≤500 输入描述：输入一行没有空格的字符串。 输出描述：输出 输入字符串 中范围在(0~127，包括0和127)字符的种数。 输入：abc 输出：3 题解\n// String.charAt() // 数组下标不重复，且有序 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String s = sc.nextLine(); int[] a = new int[128]; int count = 0; for (int i = 0; i \u0026lt; s.length(); i++) { char b = s.charAt(i); if (a[b] == 0) { count++; a[b] = 1; } } System.out.println(count); } } HJ11：数字颠倒\r#\r描述\n输入一个整数，将这个整数以字符串的形式逆序输出 程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001 数据范围：0≤n≤2^30−1 输入描述：输入一个int整数 输出描述：将这个整数以字符串的形式逆序输出 输入：1516000 输出：0006151 题解\n// 反转StringBuilder.reverse() public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String input=sc.nextLine(); StringBuilder sb=new StringBuilder(input); sb.reverse(); System.out.println(sb.toString()); } } HJ12：字符串反转\r#\r描述\n接受一个只包含小写字母的字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000） 输入描述：输入一行，为一个只包含小写字母的字符串。 输出描述：输出该字符串反转后的字符串。 输入：abcd 输出：dcba 题解\n同HJ11 HJ13：句子逆序\r#\r描述\n将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I” 所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符 数据范围：输入的字符串长度满足1≤n≤1000，注意本题有多组输入 输入描述：输入一个英文语句，每个单词用空格隔开。保证输入只包含空格和字母。 输出描述：得到逆序的句子 输入：I am a boy 输出：boy a am I 题解\n// 字符串分割String.split() public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String line=sc.nextLine(); String[] arr=line.split(\u0026#34; \u0026#34;); List\u0026lt;String\u0026gt; list=new ArrayList\u0026lt;\u0026gt;(); for(int i=arr.length-1;i\u0026gt;=0;i--){ list.add(arr[i]); } System.out.println(String.join(\u0026#34; \u0026#34;,list)); } } HJ14：字符串排序\r#\r描述\n给定 n 个字符串，请对 n 个字符串按照字典序排列。 数据范围：1≤n≤1000，字符串长度满足 1≤len≤100 输入描述：输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。 输出描述：数据输出n行，输出结果为按照字典序排列的字符串。 输入：5 cap to cat boat boot 输出：boat boot cap cat to 题解\n// 排序Arrays.sort() public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { int sum = Integer.valueOf(sc.nextLine()); String[] arr = new String[sum]; for (int i = 0; i \u0026lt; sum; i++) { arr[i] = sc.nextLine(); } Arrays.sort(arr); for (int j = 0; j \u0026lt; sum; j++) { System.out.println(arr[j]); } } } HJ15：求int型正整数在内存中存储时1的个数\r#\r描述\n输入一个 int 型的正整数，计算出该 int 型数据在内存中存储时 1 的个数。 数据范围：保证在 32 位整型数字范围内 输入描述：输入一个整数（int类型） 输出描述：这个数转换成2进制后，输出1的个数 输入：5 输出：2 题解\n// 十进制转二进制Integer.toBinaryString() public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { int num=Integer.valueOf(sc.nextLine()); char[] arr=Integer.toBinaryString(num).toCharArray(); int count=0; for (int i = 0; i \u0026lt; arr.length; i++) { if(arr[i]==\u0026#39;1\u0026#39;){ count++; } } System.out.println(count); } } HJ16：购物单\r#\r王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的 如果要买归类为附件的物品，必须先买该附件所属的主件，且每件物品只能购买一次。 每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。 王强查到了每件物品的价格（都是 10 元的整数倍），而他只有 N 元的预算。除此之外，他给每件物品规定了一个重要度，用整数 1 ~ 5 表示。他希望在花费不超过 N 元的前提下，使自己的满意度达到最大。 满意度是指所购买的每件物品的价格与重要度的乘积的总和，假设设第i件物品的价格为v[i]，重要度为w[i]，共选中了k件物品， 编号依次为j1、j2、...、jk，则满意度为：v[j1]*w[j1]+v[j2]*w[j2]+...+v[jk]*w[jk]。（其中 * 为乘号） 请你帮助王强计算可获得的最大的满意度。 输入描述： 输入的第 1 行，为两个正整数N，m，用一个空格隔开：（其中 N （ N＜32000 ）表示总钱数， m （m ＜60 ）为可购买的物品的个数。） 从第 2 行到第 m+1 行，第 j 行给出了编号为 j-1 的物品的基本数据，每行有 3 个非负整数 v p q （其中 v 表示该物品的价格（ v＜10000 ）， p 表示该物品的重要度（ 1 ~ 5 ）， q 表示该物品是主件还是附件。如果 q=0 ，表示该物品为主件，如果 q\u0026gt;0 ，表示该物品为附件， q 是所属主件的编号） 输出描述： 输出一个正整数，为张强可以获得的最大的满意度。 输入：1000 5 800 2 0 400 5 1 300 5 1 400 3 0 500 2 0 输出：2200 题解\npublic static void main(String[]args) throws IOException{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str= br.readLine(); String [] money_number = str.split(\u0026#34; \u0026#34;); int money = Integer.parseInt(money_number[0]);//钱数 int count = Integer.parseInt(money_number[1]);//物品数 int v[] = new int[count + 1];//物品的v p q和附件序号 int p[] = new int[count + 1]; int q[] = new int[count + 1]; int sub1[] = new int[count + 1]; int sub2[] = new int[count + 1]; int dw = 100; boolean flag = true; for(int i = 1;i \u0026lt; count + 1;i++){//第i件物品的属性 String obj[] = br.readLine().split(\u0026#34; \u0026#34;); v[i] = Integer.parseInt(obj[0]); if (flag \u0026amp;\u0026amp; v[i] % dw != 0) { dw = 10; flag = false; for (int m = 1; m \u0026lt; i; m ++) {//出现不是整百的，按整十除 v[m] *=10; p[m] *=10; } } v[i] = v[i] / dw; p[i] = Integer.parseInt(obj[1]) * v[i];//价值=价格*权重，需要的是p最大 q[i] = Integer.parseInt(obj[2]); if (q[i] \u0026gt; 0) {//是附件 if(sub1[q[i]] == 0) sub1[q[i]] = i;//是附件1 else sub2[q[i]] = i;//是附件2 } } money /= dw; int dp[][] = new int[count +1][money + 1];//money为啥+1？ for(int i = 1; i \u0026lt; count + 1; i++) {//两层for循环，动态规划二维表逐列逐行 int p1 = 0, p2 = 0, p3 = 0;//根据附件数量，分4种情况v[i]、v1、v2、v3 int v1 = -1, v2 = -1, v3 = -1;// if(sub1[i] != 0) { v1 = v[i] + v[sub1[i]]; p1 = p[i] + p[sub1[i]]; } if(sub2[i] != 0) { v2 = v[i] + v[sub2[i]]; p2 = p[i] + p[sub2[i]]; } if(sub1[i] != 0 \u0026amp;\u0026amp; sub2[i] != 0) { v3 = v1 + v2 - v[i]; p3 = p1 + p2 - p[i]; } for (int j = 1; j \u0026lt; money + 1; j++) { dp[i][j] = dp[i-1][j];//最大价值最少是这一件不放进去的大小 if(q[i] == 0) { if(j \u0026gt;= v[i]) dp[i][j] = Math.max(dp[i][j], dp[i-1][j-v[i]] + p[i]); if(v1 != -1 \u0026amp;\u0026amp; j \u0026gt;= v1) dp[i][j] = Math.max(dp[i][j], dp[i-1][j-v1] + p1); if(v2 != -1 \u0026amp;\u0026amp; j \u0026gt;= v2) dp[i][j] = Math.max(dp[i][j], dp[i-1][j-v2] + p2); if(v3 != -1 \u0026amp;\u0026amp; j \u0026gt;= v3) dp[i][j] = Math.max(dp[i][j], dp[i-1][j-v3] + p3); } } } System.out.println(dp[count][money] * dw); } HJ17：坐标移动\r#\r描述\n开发一个坐标计算工具， A表示向左移动，D表示向右移动，W表示向上移动，S表示向下移动。从（0,0）点开始移动，从输入字符串里面读取一些坐标，并将最终输入结果输出到输出文件里面。 输入：合法坐标为A(或者D或者W或者S) + 数字（两位以内），坐标之间以;分隔。非法坐标点需要进行丢弃。 数据范围：每组输入的字符串长度满足1≤n≤10000，坐标保证满足-2^31 ≤ x,y ≤ 2^31-1，且数字部分仅含正数 输入描述：一行字符串 输出描述：最终坐标，以逗号分隔 输入：A10;S20;W10;D30;X;A1A;B10A11;;A10; 输出：10,-10 题解\npublic static void main(String[] args) throws IOException { BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); String[] in = bf.readLine().split(\u0026#34;;\u0026#34;); int x = 0; int y = 0; for(String s : in){ if(!s.matches(\u0026#34;[WASD][0-9]{1,2}\u0026#34;)){ continue; } int val = Integer.valueOf(s.substring(1)); switch(s.charAt(0)){ case \u0026#39;W\u0026#39;: y += val; break; case \u0026#39;S\u0026#39;: y -= val; break; case \u0026#39;A\u0026#39;: x -= val; break; case \u0026#39;D\u0026#39;: x += val; break; } } System.out.println(x+\u0026#34;,\u0026#34;+y); } HJ18：识别有效的IP地址和掩码并进行分类统计\r#\r描述\n请解析IP地址和对应的掩码，进行分类识别。要求按照A/B/C/D/E类地址归类，不合法的地址和掩码单独归类。 所有的IP地址划分为 A,B,C,D,E五类 A类地址从1.0.0.0到126.255.255.255 B类地址从128.0.0.0到191.255.255.255 C类地址从192.0.0.0到223.255.255.255 D类地址从224.0.0.0到239.255.255.255 E类地址从240.0.0.0到255.255.255.255 私网IP范围是： 从10.0.0.0到10.255.255.255 从172.16.0.0到172.31.255.255 从192.168.0.0到192.168.255.255 子网掩码为二进制下前面是连续的1，然后全是0。 例如：255.255.255.32就是一个非法的掩码，注意二进制下全是1或者全是0均为非法子网掩码 注意： 1. 类似于【0.*.*.*】和【127.*.*.*】的IP地址不属于上述输入的任意一类，也不属于不合法ip地址，计数时请忽略 2. 私有IP地址和A,B,C,D,E类地址是不冲突的 输入描述：多行字符串。每行一个IP地址和掩码，用~隔开。 输出描述：统计A、B、C、D、E、错误IP地址或错误掩码、私有IP的个数，之间以空格隔开。 输入：10.70.44.68~255.254.255.0 1.0.0.1~255.0.0.0 192.168.0.2~255.255.255.0 19..0.~255.255.255.0 输出：1 0 1 0 0 2 1 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int aNum = 0; int bNum = 0; int cNum = 0; int dNum = 0; int eNum = 0; int errNum = 0; int pNum = 0; while (sc.hasNextLine()) { String str = sc.nextLine(); String[] strArr = str.split(\u0026#34;~\u0026#34;); int ipFirst = getIpSeg(strArr[0], 0); if (ipFirst == 0 || ipFirst == 127) { continue; } if (maskIsInvaild(strArr[1])) { errNum++; continue; } if (ipIsInvaild(strArr[0])) { errNum++; continue; } if (ipFirst \u0026gt;= 1 \u0026amp;\u0026amp; ipFirst \u0026lt;= 126) { aNum++; } if (ipFirst \u0026gt;= 128 \u0026amp;\u0026amp; ipFirst \u0026lt;= 191) { bNum++; } if (ipFirst \u0026gt;= 192 \u0026amp;\u0026amp; ipFirst \u0026lt;= 223) { cNum++; } if (ipFirst \u0026gt;= 224 \u0026amp;\u0026amp; ipFirst \u0026lt;= 239) { dNum++; } if (ipFirst \u0026gt;= 240 \u0026amp;\u0026amp; ipFirst \u0026lt;= 255) { eNum++; } int ipSecond = getIpSeg(strArr[0], 1); if (ipFirst == 10 || (ipFirst == 172 \u0026amp;\u0026amp; ipSecond \u0026gt;= 16 \u0026amp;\u0026amp; ipSecond \u0026lt;= 31) || (ipFirst == 192 \u0026amp;\u0026amp; ipSecond == 168)) { pNum++; } } System.out.println(aNum + \u0026#34; \u0026#34; + bNum + \u0026#34; \u0026#34; + cNum + \u0026#34; \u0026#34; + dNum + \u0026#34; \u0026#34; + eNum + \u0026#34; \u0026#34; + errNum + \u0026#34; \u0026#34; + pNum); } public static boolean maskIsInvaild(String mask) { String[] maskArr = mask.split(\u0026#34;\\\\.\u0026#34;); if (maskArr.length != 4) { return true; } String maskBinary = toBinary(maskArr[0]) + toBinary(maskArr[1]) + toBinary(maskArr[2]) + toBinary(maskArr[3]); if (!maskBinary.matches(\u0026#34;[1]{1,}[0]{1,}\u0026#34;)) { return true; } return false; } public static String toBinary(String num) { String numBinary = Integer.toBinaryString(Integer.valueOf(num)); while (numBinary.length() \u0026lt; 8) { numBinary = \u0026#34;0\u0026#34; + numBinary; } return numBinary; } public static boolean ipIsInvaild(String ip) { String[] ipArr = ip.split(\u0026#34;\\\\.\u0026#34;); if (ipArr.length != 4) { return true; } if (Integer.valueOf(ipArr[0]) \u0026gt; 255 || Integer.valueOf(ipArr[1]) \u0026gt; 255 || Integer.valueOf(ipArr[2]) \u0026gt; 255 || Integer.valueOf(ipArr[3]) \u0026gt; 255) { return true; } return false; } public static int getIpSeg(String ip, int index) { String[] ipArr = ip.split(\u0026#34;\\\\.\u0026#34;); return Integer.valueOf(ipArr[index]); } HJ19：简单错误记录\r#\r描述\n开发一个简单错误记录功能小模块，能够记录出错的代码所在的文件名称和行号。 处理： 1、 记录最多8条错误记录，循环记录，最后只用输出最后出现的八条错误记录。对相同的错误记录只记录一条，但是错误计数增加。最后一个斜杠后面的带后缀名的部分（保留最后16位）和行号完全匹配的记录才做算是“相同”的错误记录。 2、 超过16个字符的文件名称，只记录文件的最后有效16个字符； 3、 输入的文件可能带路径，记录文件名称不能带路径。也就是说，哪怕不同路径下的文件，如果它们的名字的后16个字符相同，也被视为相同的错误记录 4、循环记录时，只以第一次出现的顺序为准，后面重复的不会更新它的出现时间，仍以第一次为准 数据范围：错误记录数量满足1≤n≤100，每条记录长度满足1≤len≤100 输入描述：每组只包含一个测试用例。一个测试用例包含一行或多行字符串。每行包括带路径文件名称，行号，以空格隔开。 输出描述：将所有的记录统计并将结果输出，格式：文件名 代码行数 数目，一个空格隔开 输入：D:\\zwtymj\\xccb\\ljj\\cqzlyaszjvlsjmkwoqijggmybr 645 E:\\je\\rzuwnjvnuz 633 C:\\km\\tgjwpb\\gy\\atl 637 F:\\weioj\\hadd\\connsh\\rwyfvzsopsuiqjnr 647 E:\\ns\\mfwj\\wqkoki\\eez 648 D:\\cfmwafhhgeyawnool 649 E:\\czt\\opwip\\osnll\\c 637 G:\\nt\\f 633 F:\\fop\\ywzqaop 631 F:\\yay\\jc\\ywzqaop 631 D:\\zwtymj\\xccb\\ljj\\cqzlyaszjvlsjmkwoqijggmybr 645 输出：rzuwnjvnuz 633 1 atl 637 1 rwyfvzsopsuiqjnr 647 1 eez 648 1 fmwafhhgeyawnool 649 1 c 637 1 f 633 1 ywzqaop 631 2 题解\npublic static void main(String[] args) throws Exception { BufferedReader buffer = new BufferedReader(new InputStreamReader(System.in)); String str; LinkedHashMap\u0026lt;String, Integer\u0026gt; data = new LinkedHashMap\u0026lt;String, Integer\u0026gt;(); while ((str = buffer.readLine()) != null) { int idx1 = str.lastIndexOf(\u0026#34; \u0026#34;); int idx2 = str.lastIndexOf(\u0026#34;\\\\\u0026#34;); String key = (idx1 - idx2) \u0026gt; 16 ? str.substring(idx1 - 16) : str.substring(idx2 + 1); data.put(key, data.getOrDefault(key, 0) + 1); } int count = 0; for (String key : data.keySet()) { count++; if (count \u0026gt; (data.size() - 8)) { System.out.println(key + \u0026#34; \u0026#34; + data.get(key)); } } } HJ20：密码验证合格程序\r#\r描述\n密码要求: 1.长度超过8位 2.包括大小写字母、数字、其它符号，以上四种至少三种 3.不能有长度大于2的包含公共元素的子串重复 （注：其他符号不含空格或换行） 数据范围：输入的字符串长度满足1≤n≤100 输入描述：一组字符串。 输出描述：如果符合要求输出：OK，否则输出NG 输入：021Abc9000 021Abc9Abc1 021ABC9000 021$bc9000 输出：OK NG NG OK 题解\npublic static void main(String[] args) throws IOException { BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); String input = null; while (null != (input = reader.readLine())) { char[] chars = input.toCharArray(); // 条件1：长度超过8位 if (chars.length \u0026lt; 9) { System.out.println(\u0026#34;NG\u0026#34;); continue; } // 条件2：包括大小写字母、数字、其它符号，以上四种至少三种 int flag1 = 0; int flag2 = 0; int flag3 = 0; int flag4 = 0; for (char ch : chars) { if (\u0026#39;A\u0026#39; \u0026lt;= ch \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;Z\u0026#39;) { flag1 = 1; } else if (\u0026#39;a\u0026#39; \u0026lt;= ch \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;z\u0026#39;) { flag2 = 1; } else if (\u0026#39;0\u0026#39; \u0026lt;= ch \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { flag3 = 1; } else { flag4 = 1; } } if ((flag1 + flag2 + flag3 + flag4) \u0026lt; 3) { System.out.println(\u0026#34;NG\u0026#34;); continue; } // 条件3：不存在两个大于2的子串相同 String msg = \u0026#34;OK\u0026#34;; Map\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; chars.length - 2; i++) { String key = input.substring(i, i + 3); if (map.containsKey(key)) { msg = \u0026#34;NG\u0026#34;; break; } map.put(key, \u0026#34;1\u0026#34;); } System.out.println(msg); } } HJ21：简单密码\r#\r描述\n现在有一种密码变换算法。 九键手机键盘上的数字与字母的对应： 1--1， abc--2, def--3, ghi--4, jkl--5, mno--6, pqrs--7, tuv--8 wxyz--9, 0--0，把密码中出现的小写字母都变成九键键盘对应的数字，如：a 变成 2，x 变成 9. 而密码中出现的大写字母则变成小写之后往后移一位，如：X ，先变成小写，再往后移一位，变成了 y ，例外：Z 往后移是 a 。 数字和其它的符号都不做变换。 数据范围：输入的字符串长度满足1≤n≤100 输入描述：输入一组密码，长度不超过100个字符。 输出描述：输出密码变换后的字符串 输入：YUANzhi1987 输出：zvbo9441987 题解\npublic static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str = br.readLine(); StringBuffer sb = new StringBuffer(); for (int i = 0; i \u0026lt; str.length(); i++) { //获取第i个字符 char c = str.charAt(i); //判断，处理 if (c \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c \u0026lt; \u0026#39;Z\u0026#39;) { c = (char) (c + \u0026#39;b\u0026#39; - \u0026#39;A\u0026#39;); } else if (c == \u0026#39;Z\u0026#39;) { c = \u0026#39;a\u0026#39;; } else if (c\u0026gt;=\u0026#39;a\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;c\u0026#39;) { c = \u0026#39;2\u0026#39;; } else if (c\u0026gt;=\u0026#39;d\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;f\u0026#39;) { c = \u0026#39;3\u0026#39;; } else if (c\u0026gt;=\u0026#39;g\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;i\u0026#39;) { c = \u0026#39;4\u0026#39;; } else if (c\u0026gt;=\u0026#39;j\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;l\u0026#39;) { c = \u0026#39;5\u0026#39;; } else if (c\u0026gt;=\u0026#39;m\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;o\u0026#39;) { c = \u0026#39;6\u0026#39;; } else if (c\u0026gt;=\u0026#39;p\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;s\u0026#39;) { c = \u0026#39;7\u0026#39;; } else if (c\u0026gt;=\u0026#39;t\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;v\u0026#39;) { c = \u0026#39;8\u0026#39;; } else if (c\u0026gt;=\u0026#39;w\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;z\u0026#39;) { c = \u0026#39;9\u0026#39;; } sb.append(c); } System.out.println(sb.toString().trim()); } HJ22：汽水瓶\r#\r描述\n某商店规定：三个空汽水瓶可以换一瓶汽水，允许向老板借空汽水瓶（但是必须要归还）。 小张手上有n个空汽水瓶，她想知道自己最多可以喝到多少瓶汽水。 数据范围：输入的正整数满足1≤n≤100 注意：本题存在多组输入。输入的 0 表示输入结束，并不用输出结果。 输入描述：输入文件最多包含 10 组测试数据，每一行仅包含一个正整数 n（1≤n≤100），表示小张手上的空汽水瓶数。n=0表示输入结束 输出描述：对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出0。 输入：3 10 81 0 输出：1 5 40 题解\n// 每两个空瓶可以喝一瓶：2空瓶加上借的1空瓶，兑换1瓶汽水，喝掉后将空瓶还回给老板 public static void main(String[] args){ Scanner sc = new Scanner(System.in); while(sc.hasNextInt()){ int bottle = sc.nextInt(); if(bottle==0){ break; } System.out.println(bottle/2); } } HJ23：删除字符串中出现次数最少的字符\r#\r描述\n实现删除字符串中出现次数最少的字符，若出现次数最少的字符有多个，则把出现次数最少的字符都删除。 输出删除这些单词后的字符串，字符串中其它字符保持原来的顺序。 数据范围：输入的字符串长度满足1≤n≤20，保证输入的字符串中仅出现小写字母 输入描述：字符串只包含小写英文字母, 不考虑非法输入，输入的字符串长度小于等于20个字节。 输出描述：删除字符串中出现次数最少的字符后的字符串。 输入：aabcddd 输出：aaddd 题解\npublic static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { String s = scanner.nextLine(); char[] chars = s.toCharArray(); //统计每个字母的数量 HashMap\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (char aChar : chars) { map.put(aChar, (map.getOrDefault(aChar, 0) + 1)); } //找到数量最少的字符数量 Collection\u0026lt;Integer\u0026gt; values = map.values(); Integer min = Collections.min(values); //用空字符串替换该字母 for (Character character : map.keySet()) { if (map.get(character) == min){ s = s.replaceAll(String.valueOf(character), \u0026#34;\u0026#34;); } } System.out.println(s); } } HJ26：字符串排序\r#\r描述\n编写一个程序，将输入字符串中的字符按如下规则排序。 规则1：英文字母从 A 到 Z 排列，不区分大小写。如，输入： Type 输出： epTy 规则2：同一个英文字母的大小写同时存在时，按照输入顺序排列。如，输入： BabA 输出： aABb 规则3：非英文字母的其它字符保持原来的位置。如，输入： By?e 输出： Be?y 数据范围：输入的字符串长度满足1≤n≤1000 输入描述：输入字符串 输出描述：输出字符串 输入：A Famous Saying: Much Ado About Nothing (2012/8). 输出：A aaAAbc dFgghh: iimM nNn oooos Sttuuuy (2012/8). 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String str = sc.nextLine(); String res = sort(str); System.out.println(res); } } public static String sort(String str) { // 先将英文字母收集起来 List\u0026lt;Character\u0026gt; letters = new ArrayList\u0026lt;\u0026gt;(); char[] chars = str.toCharArray(); for (char ch : chars) { if (Character.isLetter(ch)) { letters.add(ch); } } // 将英文字母先排序好 letters.sort(Comparator.comparingInt(Character::toLowerCase)); // 若是非英文字母则直接添加 StringBuilder result = new StringBuilder(); for (int i = 0, j = 0; i \u0026lt; str.length(); i++) { if (Character.isLetter(str.charAt(i))) { result.append(letters.get(j++)); } else { result.append(str.charAt(i)); } } return result.toString(); } HJ27：查找兄弟单词\r#\r定义一个单词的“兄弟单词”为：交换该单词字母顺序（注：可以交换任意次），而不添加、删除、修改原有的字母就能生成的单词。 兄弟单词要求和原来的单词不同。例如： ab 和 ba 是兄弟单词。 ab 和 ab 则不是兄弟单词。 现在给定你 n 个单词，另外再给你一个单词 x ，让你寻找 x 的兄弟单词里，按字典序排列后的第 k 个单词是什么？ 注意：字典中可能有重复单词。 数据范围：1≤n≤1000 ，输入的字符串长度满足1≤len(str)≤10，1≤k\u0026lt;n 输入描述：输入只有一行。 先输入字典中单词的个数n，再输入n个单词作为字典单词。 然后输入一个单词x最后后输入一个整数k 输出描述：第一行输出查找到x的兄弟单词的个数m，第二行输出查找到的按照字典顺序排序后的第k个兄弟单词，没有符合则不用输出。 输入：3 abc bca cab abc 1 输出：2 bca 题解\npublic static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { String[] arr = scanner.nextLine().split(\u0026#34; \u0026#34;); int num = Integer.parseInt(arr[0]); String x = arr[arr.length - 2]; int k = Integer.parseInt(arr[arr.length - 1]); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt;= num; i++) { if (isBrother(x, arr[i])) { list.add(arr[i]); } } int size = list.size(); System.out.println(size); if (size \u0026gt;= k) { Collections.sort(list); System.out.println(list.get(k - 1)); } } } public static boolean isBrother(String str1, String str2) { if (str1.length() != str2.length() || str2.equals(str1)) { return false; } char[] chars1 = str1.toCharArray(); char[] chars2 = str2.toCharArray(); Arrays.sort(chars1); Arrays.sort(chars2); return new String(chars1).equals(new String(chars2)); } HJ28：素数伴侣\r#\r描述\n若两个正整数的和为素数，则这两个正整数称之为“素数伴侣”，如2和5、6和13 从已有的N（N为偶数）个正整数中挑选出若干对组成“素数伴侣”，能组成“素数伴侣”最多的方案称为“最佳方案” 例如有4个正整数：2，5，6，13，如果将5和6分为一组中只能得到一组“素数伴侣”，而将2和5、6和13编组将得到两组“素数伴侣”，能组成“素数伴侣”最多的方案称为“最佳方案” 输入：有一个正偶数 n ，表示待挑选的自然数的个数。后面给出 n 个具体的数字。 输出：输出一个整数 K ，表示你求得的“最佳方案”组成“素数伴侣”的对数。 数据范围：1≤n≤100，输入的数据大小满足2≤val≤30000 输入描述：输入一个正偶数 n，输入 n 个整数 输出描述：求得的“最佳方案”组成“素数伴侣”的对数。 输入：4 2 5 6 13 输出：2 题解\n// 素数一定是奇数，因此素数伴侣一定是奇数+偶数 public static void main(String[] args) { //标准输入 Scanner sc = new Scanner(System.in); while (sc.hasNext()) { //输入正偶数 int n = sc.nextInt(); //用于记录输入的n个整数 int[] arr = new int[n]; //用于存储所有的奇数 ArrayList\u0026lt;Integer\u0026gt; odds = new ArrayList\u0026lt;\u0026gt;(); //用于存储所有的偶数 ArrayList\u0026lt;Integer\u0026gt; evens = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { arr[i] = sc.nextInt(); //将奇数添加到odds if (arr[i] % 2 == 1) { odds.add(arr[i]); } //将偶数添加到evens if (arr[i] % 2 == 0) { evens.add(arr[i]); } } //下标对应已经匹配的偶数的下标，值对应这个偶数的伴侣 int[] matcheven = new int[evens.size()]; //记录伴侣的对数 int count = 0; for (int j = 0; j \u0026lt; odds.size(); j++) { //用于标记对应的偶数是否查找过 boolean[] v = new boolean[evens.size()]; //如果匹配上，则计数加1 if (find(odds.get(j), matcheven, evens, v)) { count++; } } System.out.println(count); } } //判断奇数x能否找到伴侣 private static boolean find(int x, int[] matcheven, ArrayList\u0026lt;Integer\u0026gt; evens, boolean[] v) { for (int i = 0; i \u0026lt; evens.size(); i++) { //该位置偶数没被访问过，并且能与x组成素数伴侣 if (isPrime(x + evens.get(i)) \u0026amp;\u0026amp; v[i] == false) { v[i] = true; // 如果i位置偶数还没有伴侣，则与x组成伴侣 // 如果已经有伴侣，并且这个伴侣能重新找到新伴侣，则把原来伴侣让给别人，自己与x组成伴侣 if (matcheven[i] == 0 || find(matcheven[i], matcheven, evens, v)) { matcheven[i] = x; return true; } } } return false; } //判断x是否是素数 private static boolean isPrime(int x) { if (x == 1) return false; //如果能被2到根号x整除，则一定不是素数 for (int i = 2; i \u0026lt;= (int) Math.sqrt(x); i++) { if (x % i == 0) { return false; } } return true; } HJ29：字符串加解密\r#\r描述\n对输入的字符串进行加解密，并输出。 加密方法为： 当内容是英文字母时则用该英文字母的后一个字母替换，同时字母变换大小写,如字母a时则替换为B；字母Z时则替换为a； 当内容是数字时则把该数字加1，如0替换1，1替换2，9替换0； 其他字符不做变化。 解密方法为加密的逆过程。 数据范围：输入的两个字符串长度满足 1≤n≤1000，保证输入的字符串都是只由大小写字母或者数字组成 输入描述： 第一行输入一串要加密的密码 第二行输入一串加过密的密码 输出描述： 第一行输出加密后的字符 第二行输出解密后的字符 输入：abcdefg BCDEFGH 输出：BCDEFGH abcdefg 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { System.out.println(encode(sc.nextLine())); System.out.println(decode(sc.nextLine())); } } //加密函数 private static String encode(String code) { char[] t = code.toCharArray(); for (int i = 0; i \u0026lt; t.length; i++) { if (t[i] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; t[i] \u0026lt; \u0026#39;z\u0026#39;) { t[i] = (char) (t[i] - \u0026#39;a\u0026#39; + \u0026#39;A\u0026#39; + 1); } else if (t[i] == \u0026#39;z\u0026#39;) { t[i] = \u0026#39;A\u0026#39;; } else if (t[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; t[i] \u0026lt; \u0026#39;Z\u0026#39;) { t[i] = (char) (t[i] - \u0026#39;A\u0026#39; + \u0026#39;a\u0026#39; + 1); } else if (t[i] == \u0026#39;Z\u0026#39;) { t[i] = \u0026#39;a\u0026#39;; } else if (t[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; t[i] \u0026lt; \u0026#39;9\u0026#39;) { t[i] = (char) (t[i] + 1); } else if (t[i] == \u0026#39;9\u0026#39;) { t[i] = \u0026#39;0\u0026#39;; } } return String.valueOf(t); } //解密函数 private static String decode(String password) { char[] t = password.toCharArray(); for (int i = 0; i \u0026lt; t.length; i++) { if (t[i] \u0026gt; \u0026#39;a\u0026#39; \u0026amp;\u0026amp; t[i] \u0026lt;= \u0026#39;z\u0026#39;) { t[i] = (char) (t[i] - \u0026#39;a\u0026#39; + \u0026#39;A\u0026#39; - 1); } else if (t[i] == \u0026#39;a\u0026#39;) { t[i] = \u0026#39;Z\u0026#39;; } else if (t[i] \u0026gt; \u0026#39;A\u0026#39; \u0026amp;\u0026amp; t[i] \u0026lt;= \u0026#39;Z\u0026#39;) { t[i] = (char) (t[i] - \u0026#39;A\u0026#39; + \u0026#39;a\u0026#39; - 1); } else if (t[i] == \u0026#39;A\u0026#39;) { t[i] = \u0026#39;z\u0026#39;; } else if (t[i] \u0026gt; \u0026#39;0\u0026#39; \u0026amp;\u0026amp; t[i] \u0026lt;= \u0026#39;9\u0026#39;) { t[i] = (char) (t[i] - 1); } else if (t[i] == \u0026#39;0\u0026#39;) { t[i] = \u0026#39;9\u0026#39;; } } return String.valueOf(t); } "},{"id":282,"href":"/algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%9321/","title":"机试题库 - 21","section":"华为OD","content":"\r01. 盛最多水的容器\r#\r描述\n给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 说明：你不能倾斜容器。 输入：[1,8,6,2,5,4,8,3,7] 输出：49 题解\npublic int maxArea(int[] height) { int res = 0; int i = 0; int j = height.length - 1; while (i \u0026lt; j) { int area = (j - i) * Math.min(height[i], height[j]); res = Math.max(res, area); if (height[i] \u0026lt; height[j]) { i++; } else { j--; } } return res; } 02. 接雨水\r#\r描述\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 题解\npublic int trap(int[] height) { int sum = 0; //最两端的列不用考虑，因为一定不会有水。所以下标从 1 到 length - 2 for (int i = 1; i \u0026lt; height.length - 1; i++) { int max_left = 0; //找出左边最高 for (int j = i - 1; j \u0026gt;= 0; j--) { if (height[j] \u0026gt; max_left) { max_left = height[j]; } } int max_right = 0; //找出右边最高 for (int j = i + 1; j \u0026lt; height.length; j++) { if (height[j] \u0026gt; max_right) { max_right = height[j]; } } //找出两端较小的 int min = Math.min(max_left, max_right); //只有较小的一段大于当前列的高度才会有水，其他情况不会有水 if (min \u0026gt; height[i]) { sum = sum + (min - height[i]); } } return sum; } 03. 无重复字符的最长子串\r#\r描述\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。 输入: s = \u0026#34;abcabcbb\u0026#34; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026#34;abc\u0026#34;，所以其长度为 3。 题解\npublic int lengthOfLongestSubstring(String s) { int n = s.length(), ans = 0; Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int end = 0, start = 0; end \u0026lt; n; end++) { char alpha = s.charAt(end); if (map.containsKey(alpha)) { start = Math.max(map.get(alpha), start); } ans = Math.max(ans, end - start + 1); map.put(s.charAt(end), end + 1); } return ans; } 04. 岛屿数量\r#\r描述\n给你一个由 \u0026#39;1\u0026#39;（陆地）和 \u0026#39;0\u0026#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 输入：grid = [ [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;] ] 输出：3 题解\npublic int maxAreaOfIsland(int[][] grid) { int res = 0; for (int r = 0; r \u0026lt; grid.length; r++) { for (int c = 0; c \u0026lt; grid[0].length; c++) { if (grid[r][c] == 1) { int a = area(grid, r, c); res = Math.max(res, a); } } } return res; } int area(int[][] grid, int r, int c) { // 判断 base case if (!inArea(grid, r, c)) { return 0; } // 如果这个格子不是岛屿，直接返回 if (grid[r][c] != 1) { return 0; } // 将格子标记为「已遍历过」 grid[r][c] = 2; // 访问上、下、左、右四个相邻结点 return 1 + area(grid, r - 1, c) + area(grid, r + 1, c) + area(grid, r, c - 1) + area(grid, r, c + 1); } // 判断坐标 (r, c) 是否在网格中 boolean inArea(int[][] grid, int r, int c) { return 0 \u0026lt;= r \u0026amp;\u0026amp; r \u0026lt; grid.length \u0026amp;\u0026amp; 0 \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt; grid[0].length; } 05. 不同的二叉搜索树\r#\r描述\n给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 输入：n = 3 输出：5 题解\npublic int numTrees(int n) { // 提示：我们在这里需要用 long 类型防止计算过程中的溢出 long C = 1; for (int i = 0; i \u0026lt; n; ++i) { C = C * 2 * (2 * i + 1) / (i + 2); } return (int) C; } /* dp[i] = i个不同的数组成的二叉搜索数的个数 假设 i = 5 当根节点等于 1 时 ，其余数字都比1大，只能在右边 dp[i] += dp[4] 当根节点等于 2 时，左边有一个1比2小，右边有三个比2大的数字 dp[i] += dp[1] * dp[3] 当根节点等于 3 时，左边有两个数比3小，右边有两个数比3大的数字 dp[i] += dp[2] * dp[2] ... 知道根节点等于5，左边有4个数字比5小，只能放在5的左边,dp[i] += dp[4] */ public int numTrees(int n) { int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= i; j++) { int leftNum = dp[j - 1]; int rightNum = dp[i - j]; dp[i] += leftNum * rightNum; } } return dp[n]; } 06. 买卖股票的最佳时机 II\r#\r描述\n给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。 返回 你能获得的 最大 利润 。 输入：prices = [7,1,5,3,6,4] 输出：7 题解\npublic int maxProfit(int[] prices) { int profit = 0; for (int i = 1; i \u0026lt; prices.length; i++) { int tmp = prices[i] - prices[i - 1]; if (tmp \u0026gt; 0) profit += tmp; } return profit; } 07. 买卖股票的最佳时机 III\r#\r描述\n给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 题解\npublic int maxProfit(int[] prices) { // 第一次买入，第一次卖出，第二次买入，第二次卖出 int f1 = -prices[0], f2 = 0, f3 = -prices[0], f4 = 0; for (int i = 1; i \u0026lt; prices.length; ++i) { f1 = Math.max(f1, -prices[i]); f2 = Math.max(f2, f1 + prices[i]); f3 = Math.max(f3, f2 - prices[i]); f4 = Math.max(f4, f3 + prices[i]); } return f4; } 08. 打家劫舍II\r#\r描述\n你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。 输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 题解\npublic int rob(int[] nums) { int length = nums.length; if (length == 1) { return nums[0]; } else if (length == 2) { return Math.max(nums[0], nums[1]); } return Math.max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1)); } public int robRange(int[] nums, int start, int end) { int first = nums[start]; int second = Math.max(nums[start], nums[start + 1]); for (int i = start + 2; i \u0026lt;= end; i++) { int temp = second; second = Math.max(first + nums[i], second); first = temp; } return second; } 09. 爬楼梯\r#\r描述\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 输入：n = 3 输出：3 解释：有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 题解\n// 状态定义： 设 dp 为一维数组，其中 dp[i] 的值代表斐波那契数列的第 i 个数字。 // 转移方程： dp[i+1]=dp[i]+dp[i−1] ，即对应数列定义 f(n+1)=f(n)+f(n−1) 。 // 初始状态： dp[0]=1, dp[1]=1 ，即初始化前两个数字。 // 返回值： dp[n] ，即斐波那契数列的第 n 个数字。 public int climbStairs(int n) { int a = 1, b = 1, sum; for(int i = 0; i \u0026lt; n - 1; i++){ sum = a + b; a = b; b = sum; } return b; } 10. 路径总和\r#\r描述\n给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 叶子节点 是指没有子节点的节点。 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 输出：true 题解\npublic boolean hasPathSum(TreeNode root, int sum) { if (root == null) { return false; } if (root.left == null \u0026amp;\u0026amp; root.right == null) { return sum == root.val; } return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); } public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } 11. 斐波那契数\r#\r描述\n斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。 该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n \u0026gt; 1 给定 n ，请计算 F(n) 。 输入：n = 4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3 题解\npublic int fib(int n) { int a = 0, b = 1, sum; for(int i = 0; i \u0026lt; n; i++){ sum = a + b; a = b; b = sum; } return a; } 12. 合并 K 个升序链表\r#\r描述\n给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 输入：lists = [[1,4,5],[1,3,4],[2,6]] 输出：[1,1,2,3,4,4,5,6] 题解\npublic class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) { return null; } // 将所有链表的所有节点加入列表 List\u0026lt;Integer\u0026gt; list = new ArrayList(); for(ListNode node : lists){ while(node != null){ list.add(node.val); node = node.next; } } // 列表排序 list = list.stream().sorted().collect(Collectors.toList()); // 列表转链表 ListNode head = new ListNode(0); ListNode cur = head; for(int val : list){ cur.next = new ListNode(val); cur = cur.next; } return head.next; } 13. 多数元素\r#\r描述\n给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 输入：nums = [3,2,3] 输出：3 题解\npublic int majorityElement(int[] nums) { Arrays.sort(nums); return nums[nums.length / 2]; } 14. 搜索二维矩阵 II\r#\r描述\n编写一个高效的算法来搜索 m * n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5 输出：true 题解\npublic boolean searchMatrix(int[][] matrix, int target) { int i = matrix.length - 1, j = 0; while (i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; matrix[0].length) { if (matrix[i][j] \u0026gt; target) i--; else if (matrix[i][j] \u0026lt; target) j++; else return true; } return false; } 15. 柱状图中最大的矩形\r#\r描述\n给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中红色区域，面积为 10 题解\npublic int largestRectangleArea(int[] heights) { int len = heights.length; // 特判 if (len == 0) { return 0; } int res = 0; for (int i = 0; i \u0026lt; len; i++) { // 找左边最后 1 个大于等于 heights[i] 的下标 int left = i; int curHeight = heights[i]; while (left \u0026gt; 0 \u0026amp;\u0026amp; heights[left - 1] \u0026gt;= curHeight) { left--; } // 找右边最后 1 个大于等于 heights[i] 的索引 int right = i; while (right \u0026lt; len - 1 \u0026amp;\u0026amp; heights[right + 1] \u0026gt;= curHeight) { right++; } int width = right - left + 1; res = Math.max(res, width * curHeight); } return res; } 16. 最大矩形\r#\r描述\n给定一个仅包含 0 和 1 、大小为 rows * cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 输入：matrix = [ [\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;]] 输出：6 题解\npublic int maximalRectangle(char[][] matrix) { int m = matrix.length; if (m == 0) { return 0; } int n = matrix[0].length; int[][] left = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (matrix[i][j] == \u0026#39;1\u0026#39;) { left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1; } } } int ret = 0; for (int j = 0; j \u0026lt; n; j++) { // 对于每一列，使用基于柱状图的方法 int[] up = new int[m]; int[] down = new int[m]; Deque\u0026lt;Integer\u0026gt; stack = new LinkedList\u0026lt;Integer\u0026gt;(); for (int i = 0; i \u0026lt; m; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; left[stack.peek()][j] \u0026gt;= left[i][j]) { stack.pop(); } up[i] = stack.isEmpty() ? -1 : stack.peek(); stack.push(i); } stack.clear(); for (int i = m - 1; i \u0026gt;= 0; i--) { while (!stack.isEmpty() \u0026amp;\u0026amp; left[stack.peek()][j] \u0026gt;= left[i][j]) { stack.pop(); } down[i] = stack.isEmpty() ? m : stack.peek(); stack.push(i); } for (int i = 0; i \u0026lt; m; i++) { int height = down[i] - up[i] - 1; int area = height * left[i][j]; ret = Math.max(ret, area); } } return ret; } 17. 每日温度\r#\r描述\n给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。 输入: temperatures = [73,74,75,71,69,72,76,73] 输出: [1,1,4,2,1,1,0,0] 题解\npublic int[] dailyTemperatures(int[] T) { int length = T.length; int[] result = new int[length]; for (int i = 0; i \u0026lt; length; i++) { int current = T[i]; if (current \u0026lt; 100) { for (int j = i + 1; j \u0026lt; length; j++) { if (T[j] \u0026gt; current) { result[i] = j - i; break; } } } } return result; } 18. 下一个更大元素 II\r#\r描述\n给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。 数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。 输入: nums = [1,2,3,4,3] 输出: [2,3,4,-1,4] 题解\npublic int[] nextGreaterElements(int[] nums) { int n = nums.length; int[] ret = new int[n]; Arrays.fill(ret, -1); Deque\u0026lt;Integer\u0026gt; stack = new LinkedList\u0026lt;Integer\u0026gt;(); for (int i = 0; i \u0026lt; n * 2 - 1; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; nums[stack.peek()] \u0026lt; nums[i % n]) { ret[stack.pop()] = nums[i % n]; } stack.push(i % n); } return ret; } 19. 和为 K 的子数组\r#\r描述\n给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。 子数组是数组中元素的连续非空序列。 输入：nums = [1,1,1], k = 2 输出：2 题解\npublic int subarraySum(int[] nums, int k) { int len = nums.length; // 计算前缀和数组 int[] preSum = new int[len + 1]; preSum[0] = 0; for (int i = 0; i \u0026lt; len; i++) { preSum[i + 1] = preSum[i] + nums[i]; } int count = 0; for (int left = 0; left \u0026lt; len; left++) { for (int right = left; right \u0026lt; len; right++) { // 区间和 [left..right]，注意下标偏移 if (preSum[right + 1] - preSum[left] == k) { count++; } } } return count; } 20. 买卖股票的最佳时机\r#\r描述\n定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 输入：[7,1,5,3,6,4] 输出：5 题解\npublic int maxProfit(int[] prices) { int cost = Integer.MAX_VALUE, profit = 0; for (int price : prices) { cost = Math.min(cost, price); profit = Math.max(profit, price - cost); } return profit; } 21. 课程表 II\r#\r描述\n现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。 返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。 输入：numCourses = 2, prerequisites = [[1,0]] 输出：[0,1] 题解\n// 简单的 BFS public int[] findOrder(int numCourses, int[][] prerequisites) { if (numCourses == 0) return new int[0]; int[] inDegrees = new int[numCourses]; // 建立入度表 for (int[] p : prerequisites) { // 对于有先修课的课程，计算有几门先修课 inDegrees[p[0]]++; } // 入度为0的节点队列 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; inDegrees.length; i++) { if (inDegrees[i] == 0) queue.offer(i); } int count = 0; // 记录可以学完的课程数量 int[] res = new int[numCourses]; // 可以学完的课程 // 根据提供的先修课列表，删除入度为 0 的节点 while (!queue.isEmpty()){ int curr = queue.poll(); res[count++] = curr; // 将可以学完的课程加入结果当中 for (int[] p : prerequisites) { if (p[1] == curr){ inDegrees[p[0]]--; if (inDegrees[p[0]] == 0) queue.offer(p[0]); } } } if (count == numCourses) return res; return new int[0]; } 22. 单词替换\r#\r描述\n在英语中，我们有一个叫做 词根(root) 的概念，可以词根 后面 添加其他一些词组成另一个较长的单词——我们称这个词为 衍生词 (derivative)。例如，词根 help，跟随着 继承词 \u0026#34;ful\u0026#34;，可以形成新的单词 \u0026#34;helpful\u0026#34;。 现在，给定一个由许多 词根 组成的词典 dictionary 和一个用空格分隔单词形成的句子 sentence。你需要将句子中的所有 衍生词 用 词根 替换掉。如果 衍生词 有许多可以形成它的 词根，则用 最短 的 词根 替换它。 你需要输出替换之后的句子。 输入：dictionary = [\u0026#34;cat\u0026#34;,\u0026#34;bat\u0026#34;,\u0026#34;rat\u0026#34;], sentence = \u0026#34;the cattle was rattled by the battery\u0026#34; 输出：\u0026#34;the cat was rat by the bat\u0026#34; 题解\npublic String replaceWords(List\u0026lt;String\u0026gt; dictionary, String sentence) { Set\u0026lt;String\u0026gt; dictionarySet = new HashSet\u0026lt;String\u0026gt;(); for (String root : dictionary) { dictionarySet.add(root); } String[] words = sentence.split(\u0026#34; \u0026#34;); for (int i = 0; i \u0026lt; words.length; i++) { String word = words[i]; for (int j = 0; j \u0026lt; word.length(); j++) { if (dictionarySet.contains(word.substring(0, 1 + j))) { words[i] = word.substring(0, 1 + j); break; } } } return String.join(\u0026#34; \u0026#34;, words); } 23.\r#\r描述\n题解\n24.\r#\r描述\n题解\n25.\r#\r描述\n题解\n"},{"id":283,"href":"/algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%9322/","title":"机试题库 - 22","section":"华为OD","content":"\r01.\r#\r描述\n题解\n02.\r#\r描述\n题解\n03.\r#\r描述\n题解\n04.\r#\r描述\n题解\n05.\r#\r描述\n题解\n06.\r#\r描述\n题解\n07.\r#\r描述\n题解\n08.\r#\r描述\n题解\n09.\r#\r描述\n题解\n10.\r#\r描述\n题解\n11.\r#\r描述\n题解\n12.\r#\r描述\n题解\n13.\r#\r描述\n题解\n14.\r#\r描述\n题解\n15.\r#\r描述\n题解\n16.\r#\r描述\n题解\n17.\r#\r描述\n题解\n18.\r#\r描述\n题解\n19.\r#\r描述\n题解\n20.\r#\r描述\n题解\n21.\r#\r描述\n题解\n22.\r#\r描述\n题解\n23.\r#\r描述\n题解\n24.\r#\r描述\n题解\n25.\r#\r描述\n题解\n"},{"id":284,"href":"/algorithm/huawei-od/%E5%85%A8/","title":"索引","section":"华为OD","content":"\r必会题 - 1\r#\r#01-字符串分割 01. 字符串分割 02. 组成最大数 03. 统计射击比赛成绩 04. 字符串序列判定 05. 数据分类 06. 五键键盘的输出 07. 检查是否存在满足条件的数字组合 08. 数组拼接 09. 数列描述 10. 考勤信息 11. 按单词下标区间翻转文章内容 12. 最大括号深度 13. 字符串加密 14. 整数对最小和 15. 求字符串中所有整数的最小和 16. 乱序整数序列两数之和绝对值最小 17. 非严格递增连续数字序列 18. 分积木 19. 连续字母长度 20. 滑动窗口最大和 21. 素数之积 22. 仿LISP运算 23. 贪吃蛇 24. 解密犯罪时间 25. 求满足条件的最长子串的长度\n必会题 - 2\r#\r01. 机器人走迷宫 02. 高效的任务规划 03. 二叉树遍历 04. 书籍叠放 05. 区间交集 06. 分月饼 07. 找最小数 08. 简易内存池 09. 服务失效判断 10. 图像物体的边界 11. 跳格子游戏 12. 最小叶子节点 13. 考古学家 14. 解压报文 15. 最长的指定瑕疵度的元音子串 16. 目录删除 17. 吃火锅 18. 服务器广播 19. 二叉树的广度优先遍历 20. 单词搜索 21. 最少面试官数 22. 斗地主之顺子\n参考题 - 1\r#\r01. 字符串反转 02. 数字颠倒 03. 表达式求值 04. 字符逆序 05. 尼科彻斯定力 06. 公共子串计算 07. 求最大连续bit数 08. 最长回文子串 09. 等差数列 10. 密码强度等级 11. 字符个数统计 12. 截取字符串 13. 查找组成一个偶数最接近的两个素数 14. 统计字符 15. 字符串排序 16. 进制转换 17. 找出字符串中第一个只出现一次的字符 18. 输入n个整数，输出其中最小的K个 19. 字符串字符匹配\n机库题 - 1\r#\r01. 车路协同场景 02. API集群负载统计 03. CPU算力分配 04. We Are A Team 05. 爱吃蟠桃的孙悟空 06. 按身高和体重排队 07. 报数游戏 08. 表达式括号匹配 09. 部门人力分配 10. 求幸存数之和 11. 测试用例执行计划 12. 查找接口成功率最优时间段 13. 查找众数及中位数 14. 单词加密 15. 单词接龙 16. 单词重量 17. 德州扑克 18. 第k个排列 19. 堆内存申请 20. 堆栈中的剩余数字 21. 多段线数据压缩 22. 翻牌求最大分 23. 分割均衡字符串 24. 分配土地 25. 分披萨\n机库题 - 2\r#\r01. 工号不够用了怎么办 02. 勾股数元组 03. 冠亚军排名，奖牌榜排名 04. 猴子爬山 05. 滑动窗口最大和 06. 灰度图存储 07. 会议室占用时间 08. 绘图机器 09. 火星文计算 10. 机场航班调度程序 11. 机器人搬砖 12. 计算礼品发放的最小分组数目 13. 计算三叉搜索树的高度 14. 检查是否存在满足条件的数字组合 15. 解密犯罪时间 16. 精准核酸检测 17. 开源项目热度榜单 18. 考勤信息 19. 靠谱的车 20. 快递运输 21. 括号匹配 22. 来自异国的客人 23. 连续字母长度 24. 两数之和绝对值最小 25. 螺旋数字矩阵\n机库题 - 3\r#\r01. 密码解密 02. 密码输入检测 03. 密钥格式化 04. 免单统计 05. 内存冷热标记 06. 攀登者 07. 判断字符串子序列 08. 拼接URL 09. 悄悄话 10. 求符合要求的结对方式 11. 求解连续数列 12. 求满足条件的最长子串的长度 13. 求字符串中所有整数的最小和 14. 求最多可以派出多少支团队 15. 全排列 16. 生成哈夫曼树 17. 剩余银饰的重量 18. 石头剪刀布游戏 19. 手机App防沉迷系统 20. 输出指定字母在字符串的中的索引 21. 数的分解 22. 数据单元的变化替换 23. 数字涂色 24. 数字字符串组合倒序 25. 数组连续和\n机库题 - 4\r#\r01. 数组组成的最小数字 02. 水仙花数 03. 素数之积 04. 提取字符串中的最长合法简单数学表达式 05. 停车场车辆统计 06. 围棋的气 07. 消消乐游戏 08. 小华地图寻宝 09. 小明的幸运数 10. 小明找位置 11. 小朋友来自多少小区 12. 虚拟理财游戏 13. 寻找身高相近的小朋友 14. 寻找相同子串 15. 一种字符串压缩表示的解压 16. 英文输入法 17. 用户调度问题 18. 用连续自然数之和来表达整数 19. 游戏分组 20. 约瑟夫问题 21. 在字符串中找出连续最长的数字串 22. 掌握的单词个数 23. 找出符合要求的字符串子串 24. 找出经过特定点的路径长度 25. 找朋友\n机库题 - 5\r#\r01. 找座位 02. 整数对最小和 03. 整型数组按个位值排序 04. 执行任务赚积分 05. 执行时长 06. 智能成绩表 07. 转盘寿司 08. 字符串变换最小字符串 09. 字符串分割 10. 字符串排序 11. 字符串筛选排序 12. 字符串序列判定 13. 字符统计及重排 14. 最大N个数与最小N个数的和 15. 最大股票收益 16. 最大矩阵和 17. 最大括号深度 18. 最大时间 19. 最多购买宝石数目 20. 最富裕的小家庭 21. 最长的指定瑕疵度的元音子串 22. 最长子字符串的长度 23. 堆内存申请\n机库题 - 11\r#\r01. 5G网络建设 02. N进制减法 03. TLV解析 04. Wonderland 05. 比较两个版本号的大小 06. 猜密码 07. 查找一个有向网络的头节点和尾节点 08. 出错的或电路 09. 打印任务排序 10. 导师请吃火锅 11. 电脑病毒感染 12. 叠积木 13. 二叉树的广度优先遍历 14. 二叉树计算 15. 发广播 16. 伐木工 17. 反射计数 18. 分月饼 19. 符号运算 20. 高效的任务规划 21. 高效货运 22. 根据IP查找城市 23. 欢乐的周末 24. 机器人走迷宫 25. 计算疫情扩散时间\n机库题 - 12\r#\r01. 简易内存池 02. 结队编程 03. 九宫格按键输入 04. 矩阵匹配 05. 考古学家 06. 可以处理的最大任务数 07. 可以组成网络的服务器 08. 快递员的烦恼 09. 快速人名查找 10. 篮球游戏 11. 连续出牌数量 12. 两个字符串间的最短路径问题 13. 路口最短时间问题 14. 没有回文串 15. 迷宫问题 16. 模拟目录管理功能 17. 模拟数据序列化传输 18. 攀登者2 19. 启动多任务排序 20. 抢7游戏 21. 亲子游戏 22. 任务最优调度 23. 数字排列 24. 数组二叉树 25. 贪吃的猴子\n机库题 - 13\r#\r01. 贪吃蛇 02. 贪心歌手 03. 特殊的加密算法 04. 田忌赛马 05. 跳格子3 06. 跳马 07. 图像物体的边界 08. 推荐多样性 09. 文本统计分析 10. 文件缓存系统 11. 污染水域 12. 项目排期 13. 小朋友分组最少调整次数 14. 信道分配 15. 寻找最优的路测线路 16. 园区参观路径 17. 员工派遣 18. 运输时间 19. 找城市 20. 找单词 21. 找到比自己强的人数 22. 找数字 23. 智能驾驶 24. 中文分词模拟器 25. 转骰子\n机库题 - 14\r#\r01. 字符串比较 02. 字符串拼接 03. 最大社交距离 04. 最小传输时延Ⅱ 05. 最小矩阵宽度 06. 最长子字符串的长度(二)\n华为机试\r#\rHJ1：字符串最后一个单词的长度 HJ2：计算某字符出现次数 HJ3：明明的随机数 HJ4：字符串分隔 HJ5：进制转换 HJ6：质数因子 HJ7：取近似值 HJ8：合并表记录 HJ9：提取不重复的整数 HJ10：字符个数统计 HJ11：数字颠倒 HJ12：字符串反转 HJ13：句子逆序 HJ14：字符串排序 HJ15：求int型正整数在内存中存储时1的个数 HJ16：购物单 HJ17：坐标移动 HJ18：识别有效的IP地址和掩码并进行分类统计 HJ19：简单错误记录 HJ20：密码验证合格程序 HJ21：简单密码 HJ22：汽水瓶 HJ23：删除字符串中出现次数最少的字符 HJ26：字符串排序 HJ27：查找兄弟单词 HJ28：素数伴侣 HJ29：字符串加解密\n机库题 - 21\r#\r01. 盛最多水的容器 02. 接雨水 03. 无重复字符的最长子串 04. 岛屿数量 05. 不同的二叉搜索树 06. 买卖股票的最佳时机 II 07. 买卖股票的最佳时机 III 08. 打家劫舍II 09. 爬楼梯 10. 路径总和 11. 斐波那契数 12. 合并 K 个升序链表 13. 多数元素 14. 搜索二维矩阵 II 15. 柱状图中最大的矩形 16. 最大矩形 17. 每日温度 18. 下一个更大元素 II 19. 和为 K 的子数组 20. 买卖股票的最佳时机 21. 课程表 II 22. 单词替换\n"}]