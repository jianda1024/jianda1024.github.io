<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据算法 on IWiki</title>
    <link>https://jianda1024.github.io/program-design/data-algorithm/</link>
    <description>Recent content in 数据算法 on IWiki</description>
    <generator>Hugo</generator>
    <language>iwiki</language>
    <atom:link href="https://jianda1024.github.io/program-design/data-algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>前缀和</title>
      <link>https://jianda1024.github.io/program-design/data-algorithm/%E5%89%8D%E7%BC%80%E5%92%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://jianda1024.github.io/program-design/data-algorithm/%E5%89%8D%E7%BC%80%E5%92%8C/</guid>
      <description>&lt;h1 id=&#34;前缀和&#34;&gt;&#xD;&#xA;  前缀和&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%89%8d%e7%bc%80%e5%92%8c&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h3 id=&#34;简述&#34;&gt;&#xD;&#xA;  简述&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ae%80%e8%bf%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;是一种数据预处理方法，可用于快速求数组的区间和&lt;/li&gt;&#xA;&lt;li&gt;核心思想：是通过移动这两个指针来实现特定的目标&lt;/li&gt;&#xA;&lt;li&gt;滑动窗口算法是双指针算法中的一种特定形式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;示例&#34;&gt;&#xD;&#xA;  示例&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%a4%ba%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;区域和检索 - 数组不可变&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;给定一个整数数组 nums，实现 NumArray 类：&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1. NumArray(int[] nums) 使用数组 nums 初始化对象&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2. int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的总和&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   包含 left 和 right，其中 left ≤ right&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;输入：&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&amp;#34;NumArray&amp;#34;, &amp;#34;sumRange&amp;#34;, &amp;#34;sumRange&amp;#34;, &amp;#34;sumRange&amp;#34;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;输出：&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[null, 1, -1, -3]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;解释：&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>双指针</title>
      <link>https://jianda1024.github.io/program-design/data-algorithm/%E5%8F%8C%E6%8C%87%E9%92%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://jianda1024.github.io/program-design/data-algorithm/%E5%8F%8C%E6%8C%87%E9%92%88/</guid>
      <description>&lt;h1 id=&#34;双指针&#34;&gt;&#xD;&#xA;  双指针&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%8c%e6%8c%87%e9%92%88&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h3 id=&#34;简述&#34;&gt;&#xD;&#xA;  简述&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ae%80%e8%bf%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定义两个指针：左指针、右指针，以便协同进行遍历或搜索&lt;/li&gt;&#xA;&lt;li&gt;核心思想：是通过移动这两个指针来实现特定的目标&lt;/li&gt;&#xA;&lt;li&gt;滑动窗口算法是双指针算法中的一种特定形式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;示例&#34;&gt;&#xD;&#xA;  示例&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%a4%ba%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;无重复字符的最长子串&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;请注意 ，必须在不复制数组的情况下原地对数组进行操作。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;输入: nums = [0,1,0,3,12]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;输出: [1,3,12,0,0]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>并查集</title>
      <link>https://jianda1024.github.io/program-design/data-algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://jianda1024.github.io/program-design/data-algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid>
      <description>&lt;h1 id=&#34;并查集&#34;&gt;&#xD;&#xA;  并查集&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b6%e6%9f%a5%e9%9b%86&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h3 id=&#34;简述&#34;&gt;&#xD;&#xA;  简述&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ae%80%e8%bf%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Union-Find Sets，是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题&lt;/li&gt;&#xA;&lt;li&gt;基本思想：是将元素分组，每组的元素之间具有某种关系（如连通性），并且这种关系具有传递性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;实现&#34;&gt;&#xD;&#xA;  实现&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过维护一个父节点数组，来实现元素的分组。初始时每个元素的父节点都是自己。&lt;/li&gt;&#xA;&lt;li&gt;通过修改父节点数组，将其中一个集合的根节点的父节点指向另一个集合的根节点，来实现两个集合的合并&lt;/li&gt;&#xA;&lt;li&gt;通过查找元素的根节点是否相同，来判断是否属于同一个集合&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;示例&#34;&gt;&#xD;&#xA;  示例&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%a4%ba%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;We Are A Team&lt;/p&gt;</description>
    </item>
    <item>
      <title>二分查找</title>
      <link>https://jianda1024.github.io/program-design/data-algorithm/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://jianda1024.github.io/program-design/data-algorithm/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
      <description>&lt;h1 id=&#34;二分查找&#34;&gt;&#xD;&#xA;  二分查找&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h3 id=&#34;简述&#34;&gt;&#xD;&#xA;  简述&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ae%80%e8%bf%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;前提条件：要求待查找的数据集合&lt;strong&gt;有序&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到知道要查找的元素，或者区间被缩小为0&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;步骤&#34;&gt;&#xD;&#xA;  步骤&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%ad%a5%e9%aa%a4&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每次取中间位置的值与待查值比较，&lt;/li&gt;&#xA;&lt;li&gt;如果中间位置的值比待查值大，则在前半部分循环这个查找的过程，&lt;/li&gt;&#xA;&lt;li&gt;如果中间位置的值比待查值小，则在后半部分循环这个查找的过程。&lt;/li&gt;&#xA;&lt;li&gt;直到查找到了为止，否则序列中没有待查的关键字。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;示例&#34;&gt;&#xD;&#xA;  示例&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%a4%ba%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;搜索插入位置&lt;/p&gt;</description>
    </item>
    <item>
      <title>贪心算法</title>
      <link>https://jianda1024.github.io/program-design/data-algorithm/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://jianda1024.github.io/program-design/data-algorithm/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h1 id=&#34;贪心算法&#34;&gt;&#xD;&#xA;  贪心算法&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h3 id=&#34;简述&#34;&gt;&#xD;&#xA;  简述&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ae%80%e8%bf%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指在求解最优化问题时，每一步都选择在当前状态下最好或最优的策略，从而逐步推导出最优解的算法。&lt;/li&gt;&#xA;&lt;li&gt;应用：有最优子结构的问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;步骤&#34;&gt;&#xD;&#xA;  步骤&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%ad%a5%e9%aa%a4&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;建立数学模型来描述问题。&lt;/li&gt;&#xA;&lt;li&gt;把求解的问题分成若干个子问题。&lt;/li&gt;&#xA;&lt;li&gt;对每一子问题求解，得到子问题的局部最优解。&lt;/li&gt;&#xA;&lt;li&gt;把子问题的解局部最优解合成原来解问题的一个解。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;示例&#34;&gt;&#xD;&#xA;  示例&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%a4%ba%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;分发饼干&lt;/p&gt;</description>
    </item>
    <item>
      <title>动态规划</title>
      <link>https://jianda1024.github.io/program-design/data-algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://jianda1024.github.io/program-design/data-algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>&lt;h1 id=&#34;动态规划&#34;&gt;&#xD;&#xA;  动态规划&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h3 id=&#34;简述&#34;&gt;&#xD;&#xA;  简述&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ae%80%e8%bf%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Dynamic Programming，简称DP&lt;/li&gt;&#xA;&lt;li&gt;通过把复杂问题拆分为一系列单阶段子问题，利用各阶段之间的关系，递推出最终解&lt;/li&gt;&#xA;&lt;li&gt;核心思想：是利用空间换时间，通过存储已经计算过的子问题的解，从而减少计算量&lt;/li&gt;&#xA;&lt;li&gt;经典应用：背包问题、最短路径问题、最长公共子序列、股票买卖问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;特征&#34;&gt;&#xD;&#xA;  特征&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%b9%e5%be%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;重叠子问题：原问题的求解过程中，相同的子问题会多次出现&lt;/li&gt;&#xA;&lt;li&gt;最优子结构：原问题的最优解可以由其子问题的最优解递归地构建而成&lt;/li&gt;&#xA;&lt;li&gt;无后效性：某阶段状态一旦确定，就不会受到后续决策的影响&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;步骤&#34;&gt;&#xD;&#xA;  步骤&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%ad%a5%e9%aa%a4&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定义状态：确定问题的状态，将大问题分解为子问题，并确定子问题所对应的状态&lt;/li&gt;&#xA;&lt;li&gt;状态转移：根据问题的性质，建立状态之间的转移关系，即状态转移方程&lt;/li&gt;&#xA;&lt;li&gt;确定边界：确定初始状态和边界条件&lt;/li&gt;&#xA;&lt;li&gt;求最优解：从初始状态开始求解问题，并保存中间结果，递推得到最终问题的最优解&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;示例&#34;&gt;&#xD;&#xA;  示例&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%a4%ba%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;爬楼梯&lt;/p&gt;</description>
    </item>
    <item>
      <title>回溯算法</title>
      <link>https://jianda1024.github.io/program-design/data-algorithm/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://jianda1024.github.io/program-design/data-algorithm/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h1 id=&#34;回溯算法&#34;&gt;&#xD;&#xA;  回溯算法&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9b%9e%e6%ba%af%e7%ae%97%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h3 id=&#34;简述&#34;&gt;&#xD;&#xA;  简述&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ae%80%e8%bf%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实际上一个类似枚举的搜索尝试过程&lt;/li&gt;&#xA;&lt;li&gt;主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就”回溯”返回，尝试别的路径&lt;/li&gt;&#xA;&lt;li&gt;基本思想：从一条路往前走，能进则进，不能进则退回来，换一条路再试&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;示例&#34;&gt;&#xD;&#xA;  示例&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%a4%ba%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;括号生成&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;输入：n = 3&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;输出：[&amp;#34;((()))&amp;#34;,&amp;#34;(()())&amp;#34;,&amp;#34;(())()&amp;#34;,&amp;#34;()(())&amp;#34;,&amp;#34;()()()&amp;#34;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;范围：1 ≤ n ≤ 8&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>DFS/BFS搜索</title>
      <link>https://jianda1024.github.io/program-design/data-algorithm/DFS-BFS%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://jianda1024.github.io/program-design/data-algorithm/DFS-BFS%E6%90%9C%E7%B4%A2/</guid>
      <description>&lt;h1 id=&#34;dfsbfs搜索&#34;&gt;&#xD;&#xA;  DFS/BFS搜索&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dfsbfs%e6%90%9c%e7%b4%a2&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h3 id=&#34;dfs搜索&#34;&gt;&#xD;&#xA;  DFS搜索&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dfs%e6%90%9c%e7%b4%a2&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;深度优先搜索，Depth-First-Search&lt;/li&gt;&#xA;&lt;li&gt;DFS：从起始节点开始，沿着一条路径一直深入直到无法继续为止，然后回溯到上一个节点继续探索&lt;/li&gt;&#xA;&lt;li&gt;DFS：使用栈来记录遍历的路径，它优先访问最近添加到栈的节点&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;bfs搜索&#34;&gt;&#xD;&#xA;  BFS搜索&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#bfs%e6%90%9c%e7%b4%a2&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;广度优先搜索，Breadth-First-Search&lt;/li&gt;&#xA;&lt;li&gt;BFS：从起点开始，先访问当前节点的所有邻居节点，然后再访问邻居节点的邻居节点，逐层地向外扩展&lt;/li&gt;&#xA;&lt;li&gt;BFS：使用队列来记录遍历的路径，它优先访问最早添加到队列的节点&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;示例&#34;&gt;&#xD;&#xA;  示例&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%a4%ba%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;岛屿数量&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
