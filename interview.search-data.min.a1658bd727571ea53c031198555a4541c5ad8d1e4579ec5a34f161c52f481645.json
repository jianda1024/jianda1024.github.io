[{"id":0,"href":"/interview/dev-tool/git/","title":"Git","section":"开发工具","content":"\r\u0026ndash; 版本控制\r#\rSVN：是基于差异的版本控制，存储的是一组基本文件和每个文件随时间逐步累积的差异\n优缺点：节省磁盘空间，耗时、效率低。 不适合的领域：跨地域的协同开发、追求高质量代码和代码门禁 Git：是基于快照的版本控制，存储的是文件的一系列快照\n优缺点：版本切换时非常快，占用磁盘空间较大 不适合的领域：目录级别的读授权、word等二进制文档的版本控制 \u0026ndash; Git 工作流程\r#\r工作区：日常工作的工程目录\n暂存区：又称索引，工程根目录.git/index 文件夹\n版本区：又称本地仓库，工程根目录.git文件夹\n\u0026ndash; Git 基本命令\r#\r"},{"id":1,"href":"/interview/framework/mq/mq/","title":"MQ","section":"MQ","content":"\r\u0026ndash; MQ\r#\rMessage Queue，消息队列 是一种面向消息的中间件，用于实现不同系统之间的异步通信 优点：解耦、异步、削峰 \u0026ndash; MQ 原理\r#\r1. 生产者（Producer）将消息发送到消息队列中，而不是直接发送给消费者（Consumer）。 2. 消息队列将接收到的消息存储在内部的消息存储区（Message Store）中。 3. 消费者从消息队列中拉取消息，并进行处理。 4. 消费者处理完消息后，可以发送确认消息给消息队列，表示消息已经成功处理。 5. 消息队列根据消费者的确认消息，决定是否将消息从消息存储区中删除。 \u0026ndash; MQ 消息传递模式\r#\r1. 点对点模式 一对一，消费者主动拉取数据，消息收到后消息清除 2. 发布/订阅模式 一对多，数据生产后，推送给所有订阅者 \u0026ndash; RabbitMQ、RocketMQ、Kafka\r#\rRabbitMQ RocketMQ Kafka 单机吞吐量 最差（万级） 最高（十万级） 次之（十万级） 消息延迟 微秒级 毫秒级，比Kafka快 毫秒级 消息批量操作 不支持 支持 支持 事务 不支持 支持 不支持 "},{"id":2,"href":"/interview/database/mysql/p1/","title":"Part.1","section":"MySQL","content":"\r\u0026ndash; 数据库三范式\r#\r第一范式：原子性，字段是最小数据单元\n员工表，姓名字段仅包含员工的正式名称，就符合第一范式， 反之包含中文名、英文名、别名等，则意味着姓名字段是再拆分的 第二范式：唯一性，每一行都有唯一标识\n员工表，定义工号作为主键 第三范式：独立性，非主键字段完全依赖于主键字段\n员工表包含了部门编码，它引用到部门表中的部门编号这个主键，此时符合第三范式 如果在员工表中又包含一个部门名称，则造成了数据的冗余，不符合第三范式 \u0026ndash; InnoDB、MyISAM\r#\r区别\n区别 InnoDB MyISAM 锁级别 行级锁 表级锁 主键 必须有 可以没有 事务、外键、自增列 支持 不支持 . 全文索引 不支持 支持 表的具体行数 不保存 保存 存储空间 占用较多 占用较少 使用建议\nInnoDB：可靠性高或者要求事务处理的、表更新和查询都相当频繁的 MyISAM：做很多count的计算的、插入修改不频繁而查询非常频繁的 \u0026ndash; 事务\r#\r多条sql语句，要么全部成功，要么全部失败 \u0026ndash; 事务特性\r#\r特性 ACID 说明 原子性 Atomicity 事务应该当作一个单独单元的操作，要么成功，要么失败 一致性 Consistency 事务的执行不能破坏数据库数据的完整性和一致性 隔离性 Isolation 并发事务执行之间无影响 持久性 Durability 事务一旦执行成功，它对数据库的数据的改变必须是永久的 \u0026ndash; 事务并发问题\r#\r问题 说明 脏读 一个事务处理过程里读取了另一个未提交的事务中的数据。 不可重复读 在一个事务中，对同一条记录，多次查询到的数据值不一致。（针对 update） 幻读 在一个事务中，对于多条记录，多次查询到的记录条数不一致。（针对 insert） \u0026ndash; 事务隔离级别\r#\r级别 隔离级别 描述 脏读 不可重复读 幻读 级别一 读未提交 可以读取到其他事务未提交的内容 √ √ √ 级别二 读已提交 只能读取到其他事务已经提交的数据 × √ √ 级别三 可重复读 整个事务过程中，对同数据的多次读取结果是相同的 × × √ 级别四 串行化 所有事务操作都依次顺序执行，性能最差 × × × \u0026ndash; 索引\r#\r是帮助 MySQL 高效获取数据的数据结构 优点：类似书的目录，可以极大地提高数据检索速度 缺点：维护索引会增加额外的开销 \u0026ndash; 索引类型\r#\r索引 说明 普通索引 最基本的索引，没有任何限制 唯一索引 索引列的值必须是唯一的，允许有空值 主键索引 索引列的值必须是唯一的，不允许有空值，一张表中只能定义一个主键 全文索引 只能在文本类型CHAR、VARCHAR、TEXT类型字段上创建全文索引 组合索引 由多个列组合创建的索引，用于组合查询优化 \u0026ndash; 视图\r#\r是一个虚拟的表，它基于一个或多个数据库表的查询结果而创建，具有和物理表相同的功能。 视图的数据实际上存放在基本中，改变基表的数据会自动反映在其视图中 \u0026ndash; 内联接、左联接、右联接\r#\r内连接 INNER JOIN 获取两个表中，符合字段匹配关系的记录 左连接 LEFT JOIN 获取左表所有记录，及右表匹配到的记录，右表中未匹配到的字段则用NULL表示 右连接 RIGHT JOIN 获取右表所有记录，及左表匹配到的记录，左表中未匹配到的字段则用NULL表示 \u0026ndash; SQL优化\r#\r1. 查询语句中不要使用select * 2. 尽量减少子查询，使用关联查询替代 3. 尽量减少使用in、not in，使用exists、not exists或者关联查询语句替代 4. 尽量减少使用or, 使用 union、union all代替 5. 对于字符串类型的列，查询时没有加上引号，会使索引失效 6. 对于like查询，占位符放在前部，会使索引失效 7. 在where子句中，尽量避免以下操作，这将导致引擎放弃使用索引而进行全表扫描 a. 使用!=或\u0026lt;\u0026gt;操作 b. 进行null值判断 c. 对字段进行函数/表达式运算 d. = 的左边进行函数/表达式运算 \u0026ndash; 大表优化\r#\r1. 限定数据的范围 务必禁止不带任何限制数据范围条件的SQL查询语句。 2. 读/写分离 主库负责写，从库负责读 3. 垂直分区 根据数据表的相关性，拆分数据表的列，把一张列比较多的表拆分为多张表 4. 水平分区 保持数据表结构不变，通过某种策略存储数据分片。 这样每一片数据分散到不同的表或者库中，达到了分布式的目的 \u0026ndash; char、varchar\r#\r定长字符串类型：char 变长字符串类型：varchar 对效率要求高用 char，对空间使用要求高用 varchar \u0026ndash; delete、truncate、drop\r#\r区别 delete truncate drop 速度 慢 中 快 空间 不释放空间 恢复到初始大小 释放全部空间 表结构 不删 不删 删除 类型 DML DDL DDL 事务 支持 不支持 不支持 trigger 触发 不触发 不触发 生效时机 事务提交后生效 执行立即生效 执行立即生效 "},{"id":3,"href":"/interview/database/redis/p1/","title":"Part.1","section":"Redis","content":"\r\u0026ndash; Redis\r#\rRemote Dictionary Server 是一个开源、基于内存、支持多种数据结构的存储系统，可以作为数据库、缓存和消息中间件。 \u0026ndash; Redis 持久化：RDB\r#\rRedis DataBase\n在指定的时间间隔内，定时的将Redis存储的数据生成快照并存储到磁盘上 持久化文件：dump.rdb 触发时机\n1. 通过配置文件的配置参数自动触发 save 300 10 # 在300秒内，如果至少有10个键发生变化，就会触发RDB快照保存 2. 通过调用Redis命令手动触发 SAVE # 会阻塞当前Redis服务器，直到持久化完成，线上应该禁止使用 BGSAVE # 该触发方式会fork一个子进程，由子进程负责持久化过程，因此阻塞只会发生在fork子进程的时候 优点\n1. 只有一个文件dump.rdb，方便持久化。 2. 容灾性好，一个文件可以保存到安全的磁盘。 3. 性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，保证了Redis的高性能 4. 相对于数据集大时，比AOF的启动效率更高。 缺点\n1. 数据安全性低。如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改 2. 每次保存RDB的时候，Redis都要fork()出一个子进程。这可能会非常耗时，造成服务器暂时停止处理客户端。 \u0026ndash; Redis 持久化：AOF\r#\rAppend Only File\n以日志的形式来记录每个写指令，并追加到文件中。当Redis重启时，通过重新执行这些写命令，就能实现数恢复。 持久化文件：appendonly.aof 触发时机\n1. 通过配置文件的配置参数自动触发 auto-aof-rewrite-min-size 64mb # AOF文件的最小大小 auto-aof-rewrite-percentage 100 # AOF文件大小相对于上次重写后的增长比例 2. 通过调用Redis命令手动触发 BGREWRITEAOF # 开启AOF文件的重写，且不会影响Redis的正常运行 优点\n1. 数据安全性高 2. 解决了数据一致性问题 3. AOF机制的rewrite模式 缺点\n1. AOF文件比RDB文件大，且恢复速度慢。 2. 数据集大的时候，比RDB启动效率低。 \u0026ndash; Redis 数据类型\r#\r字符串：String\n最基本的数据类型，可以存储字符串或数字 应用场景：缓存会话、配置参数、计数器 哈希：Hash\n键值对的集合 应用场景：用户属性、配置文件 列表：List\n有序列表，支持两端插入和删除 应用场景：消息队列、栈或队列、最新帖子列表 集合：Set\n无序集合，元素唯一 应用场景：共同好友、标签、去重 有序集合：Zset\n有序集合，元素唯一，每个元素关联一个分数，元素按分数排序 应用场景：排行榜、延迟队列 \u0026ndash; Redis 过期策略\r#\rRedis采用：定期删除+惰性删除 过期策略 说明 优点 缺点 定时删除 为每个定时键创建一个定时器，一旦过期就立即删除 对内存友好 对CPU不友好 定期删除 每隔一段时间随机抽查一些键，删除其中已经过期的键 兼顾内存与CPU 难以衡量删除操作的执行频率 惰性删除 只有在访问键时，才会检查键是否过期，过期则删除 对CPU友好 对内存不友好，会造成内存泄漏 \u0026ndash; Redis 内存淘汰策略\r#\r如果定期删除漏掉了很多过期的key，也没有及时去查（即未走惰性删除），则通过内存淘汰策略释放内存\n内存淘汰策略：当Redis的内存超过了配置的最大内存值时，以一定的策略释放内存\n策略 说明 noeviction 默认策略，不进行内存淘汰，当内存不足时，新写入命令会报错 allkeys-lru 从所有键值对中，移除最近最少使用的键值对 allkeys-random 从所有键值对中，随机移除某个键值对 volatile-lru 在设置了过期时间的键值对中，移除最近最少使用的键值对 volatile-random 在设置了过期时间的键值对中，随机移除某个键值对 volatile-ttl 在设置了过期时间的键值对中，移除剩余生存时间最短的键值对 \u0026ndash; Redis 单线程却高效的原因\r#\rC语言实现 纯内存操作 高效的数据结构和算法‌ 基于非阻塞的IO复用模型机制 单线程操作，避免了频繁的上下文切换 \u0026ndash; 缓存雪崩\r#\r缓存雪崩\n同一时间大面积的缓存数据过期，此时又有大批量的请求这些数据。 缓存中取不到数据，就会将请求全部转发到数据库，造成数据库瞬时压力过重宕机。 从而形成一系列连锁反应，造成整个系统崩溃 解决方法\n1. 尽量错开缓存过期时间 2. 并发不是特别多的时候，使用加锁或者队列的方式，防止瞬时大量并发 3. 给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存 \u0026ndash; 缓存穿透\r#\r缓存穿透\n指查询数据库中一定不存在的数据，在缓存中自然也查不到，每次都要去数据库再查询一遍， 以至于产生了两次无用查询，每次请求都会到达数据库，就失去了使用缓存的意义 解决方法\n1. 采用布隆过滤器 将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉 2. 缓存空查询 将空结果也缓存起来，设置较短的过期时间，如此第二次就不会继续访问数据库了 \u0026ndash; 缓存预热\r#\r缓存预热\n就是系统上线后，提前将相关的缓存数据直接加载到缓存系统 解决方法\n1. 直接写个缓存刷新页面，上线时手工操作下 2. 数据量不大，可以在项目启动的时候自动进行加载 3. 定时刷新缓存 "},{"id":4,"href":"/interview/framework/spring/p1/","title":"Part.1","section":"Spring","content":"\r\u0026ndash; Spring\r#\rSpring 是一个开源的轻量级 Java 开发框架 Spring 的核心是控制反转（IoC）和面向切面（AOP） \u0026ndash; Spring 优点\r#\r方便解耦，简化开发 用户可以将所有对象的创建和依赖关系的维护，交给Spring管理 支持AOP编程 Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能 支持声明式事务 只需要通过配置就可以完成对事务的管理，而无需手动编程 方便程序测试 Spring对Junit4支持，可以通过注解方便的测试Spring程序 集成各种优秀框架 Spring内部提供了对各种优秀框架的直接支持 简化JavaEE的使用 Spring对JavaEE开发中非常难用的一些API，都提供了封装，降低了使用难度 \u0026ndash; IOC\r#\rInversion of Control，即“控制反转”，是一种设计思想，用于解决对象之间的耦合问题。 以前对象的创建及依赖关系是由开发人员自己维护，现在反转交给 spring 来完成创建及注入 控制：指的是对象创建（实例化、管理）的权利 反转：控制权交给外部环境了（spring框架、IoC容器） \u0026ndash; IoC 容器\r#\r具有依赖注入功能的容器，它可以创建对象，负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖 IoC容器底层其实就是一个Bean工厂，Spring提供了两种IoC容器，即BeanFactory、ApplicationContext BeanFactory：最简单的IoC容器，它提供了IoC容器最基本的功能 ApplicationContext：BeanFactory的子接口，并添加了更多的企业特定的功能 \u0026ndash; IOC、DI\r#\rDI，Dependency Injection，即“依赖注入”，由容器动态的将某个依赖关系注入到组件之中。 IOC 是一种软件设计思想，DI 是这种软件设计思想的一个实现。 \u0026ndash; AOP\r#\rAspect Oriented Programming，面向切面编程，是一种编程思想 是通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术 在面向对象编程(OOP)中，基本单元是类(class)，而 AOP 中的基本单元是切面(aspect) OOP是解决了纵向的代码复用问题，AOP是解决了横向的代码复用问题 \u0026ndash; AOP 术语\r#\r术语 名称 描述 Jointpoint 连接点 程序类中，允许插入通知（Advice）的位置点 Pointcut 切入点 程序类中，已经插入通知（Advice）的位置点 Advice 通知、增强 在切入点（Pointcut）上要执行的代码 Aspect 切面 是切入点（Pointcut）和通知（Advice）的结合 Target 目标 被织入通知（Advice）的目标对象，这个对象永远是一个被代理对象 Weaving 织入 将通知（Advice）添加到目标类具体连接点上的过程 \u0026ndash; AOP 通知类型\r#\r通知 说明 备注 around 环绕通知 在建议方法调用之前和之后，执行通知。 before 前置通知 在一个方法执行之前，执行通知。 after 后置通知 在一个方法执行之后，不考虑其结果，执行通知。 after-returning 正常返回通知 在一个方法执行之后，只有在方法成功完成时，才能执行通知。 after-throwing 异常返回通知 在一个方法执行之后，只有在方法退出抛出异常时，才能执行通知。 \u0026ndash; Bean\r#\rBean是指由Spring IoC容器实例化、组装和管理的对象 可以把Spring IoC容器看作是一个大工厂，Bean就相当于工厂的产品 \u0026ndash; Bean 作用域\r#\r对于prototype作用域的Bean来说，Spring IoC 容器只负责创建 作用域 描述 singleton 默认值，在 spring IoC 容器仅存在一个 Bean 实例 prototype 每次通过 Spring 容器获取 Bean 时，容器都会创建一个新的 Bean 实例 request 每次 HTTP 请求，容器都会创建一个 Bean 实例， 仅在当前 HTTP Request 内有效 session 同一个 HTTP Session 共享一个 Bean 实例，仅在当前 HTTP Session 内有效 application 同一个 Web 应用共享一个 Bean 实例，在当前 ServletContext 内有效 \u0026ndash; Bean 生命周期\r#\r实例化\n对于BeanFactory容器，当被请求未初始化的bean时，容器就会调用createBean进行实例化。 对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean 属性注入\n实例化后的对象被封装在BeanWrapper对象中，Spring根据BeanDefinition、BeanWrapper完成属性注入 初始化\n1、处理Aware接口 若Bean实现了接口BeanNameAware，则执行setBeanName()，设置bean的名字 若Bean实现了接口BeanFactoryAware，则执行setBeanFactory()，设置BeanFactory 若Bean实现了接口ApplicationContextAware，则执行setApplicationContext()，设置应用上下文 2、BeanPostProcessor前置处理 若Bean实现了接口BeanPostProcessor，则先执行postProcessBeforeInitialization() 3、InitializingBean与init-method 若Bean实现了接口InitializingBean，则执行afterPropertiesSet() 若Bean配置了属性init-method，则执行自定义方法； 4、BeanPostProcessor后置处理 若Bean实现了接口BeanPostProcessor，则先执行postProcessAfterInitialization() 使用\n此时 Bean 已经准备就绪，可以被使用了 销毁\n当Bean不再需要时，会进入清理阶段 若Bean实现了DisposableBean接口，则会调用其destory()； 若Bean配置了destory-method属性，则会调用其配置的销毁方法。 \u0026ndash; Spring 用到的设计模式\r#\r单例模式\n当使用Bean默认作用域时，用到了单例模式 在整个应用程序中只有一个Bean实例，由Spring容器负责管理 类似的如Service层的业务逻辑组件、DAO层的数据访问组件也是单例 原型模式\n当设置Bean为prototype作用域时，用到了原型模式 每次获取的是通过克隆生成的新实例，对其进行修改时，对原有实例对象不造成任何影响。 工厂模式\nSpring中的BeanFactory、ApplicationContext类，用到了工厂模式 由工厂类根据传入的参数，动态的决定实例化哪个Bean 代理模式\nSpring的AOP功能，是通过代理模式中的动态代理实现的 模板模式\nSpring中的JdbcTemplate类，用到了模板模式 JdbcTemplate是Spring提供的用于简化JDBC操作的模板类，它封装了一些常见的JDBC操作 策略模式\nSpring中访问资源的Resource接口，用到了策略模式 ClassPathResourece、FileSystemResource、ServletContextResource、UrlResource定义了不同的资源访问策略 装饰器模式\nSpring中配置的DataSource可能是不同的数据源 SessionFactory根据用户的每次请求，将DataSource设置成不同的数据源，以达到切换数据源的目的 \u0026ndash; Spring 中的单例 Bean 是否线程安全\r#\r1. Spring并没有对单例Bean进行任何多线程的封装处理，需要开发者手动处理 2. Spring关注的是：根据配置，创建单例Bean或多例Bean \u0026ndash; @Autowired、@Resource\r#\r共同点\n1. 都是用于Bean的注入 2. 都可以标注在字段和setter方法上 @Autowired\n1. 是Spring提供的注解 2. 只能按照类型（byType）注入Bean 3. 可与@Qualifier一起使用，改为按照名称（ByName）注入Bean @Resource\n1. 是J2EE提供的注解，Spring 做了支持 2. 默认按照名称（ByName）注入bean 3. 可以通过属性（name、type）指定注入策略 \u0026ndash; @Transactional\r#\r1. 表明该方法要参与事务\r2. 配置相关属性来定制事务的参与方式和运行行为\r声明式事务主要是得益于Spring AOP。使用一个事务拦截器，在方法调用的前后/周围进行事务性\r增强（advice），来驱动事务完成。 "},{"id":5,"href":"/interview/program-design/distributed/p1/","title":"Part.1","section":"分布式","content":"\r\u0026ndash; 分布式幂等性\r#\r幂等性\n幂等性：对于同一操作，不论该操作被执行多少次，产生的影响都是相同的 例如：支付功能，用户多点了几次，不做幂等校验就可能重复支付了 解决方案\n1. 分布式锁 2. 数据表唯一索引 3. token机制 \u0026ndash; CAP 原则\r#\rCAP\n1. 一致性（Consistency） 在分布式系统中的所有数据备份，在同一时刻是否同样的值 2. 可用性（Availability） 系统提供的整体服务一直处于可用的状态，每次请求都能获得正确的响应 3. 分区容忍性（Partition tolerance） 系统在遇到任何网络分区故障的时候，仍然能够保持运行和提供服务 CAP原则\n指的是在一个分布式系统中，CAP这三个要素最多只能同时实现两点，不可能三者兼顾 BASE理论\n核心思想：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。 1. 基本可用，Basically Available 2. 软状态，Soft state 3. 最终一致性，Eventually consistent \u0026ndash; 分布式事务方案\r#\r1. 两阶段提交(2PC) 2. 三阶段提交(3PC) 3. 补偿事务(TCC=Try-Confirm-Cancel) 4. 本地消息队列表(MQ) 5. Sagas事务模型(最终一致性) \u0026ndash; 限流算法\r#\r固定窗口算法\n又称计算器算法，使用计数器在周期内累加访问次数，当达到设定的限流值时，触发限流策略。 下一个周期开始时，进行清零，重新计数。 滑动窗口算法\n将时间周期分为N个小周期，分别记录每个小周期内访问次数。 跟随时间的滑动，删除超限的小周期数据，以便更精确地控制流量。 漏桶算法\n使用一个固定容量、固定流出速度的漏桶，访问请求到达后，直接放入漏桶中。 如果漏桶未满，请求将被接受并排队等待处理；如果漏桶已满，则根据算法策略处理。 令牌桶算法\n使用一个固定容量、固定速率添加令牌的令牌桶，请求到达时向令牌桶请求令牌。 如获取到令牌则通过请求，否则触发限流策略 "},{"id":6,"href":"/interview/program-lang/java-base/p1/","title":"Part.1","section":"Java基础","content":"\r\u0026ndash; 面向过程、面向对象\r#\r面向过程\n是一种以过程为中心的编程思想 分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现 面向对象\n是一种以对象为中心的编程思想 把构成问题的事务分解成各个对象，建立对象，来描述某个事物在解决整个问题的过程中所发生的行为 \u0026ndash; 四种引用类型\r#\r引用类型 说明 强引用 最常见的引用类型，引用存在时，对象不会被回收 软引用 适用于内存敏感的缓存，当内存不足时，对象才会被回收 弱引用 适用于非重要对象，当垃圾收集器运行时，对象就可能被回收 虚引用 适用于对象回收跟踪，就和没有引用一样，在任何时候都可能被回收 // 强引用 String strongRef = new String(\u0026#34;abc\u0026#34;); // 软引用 SoftReference\u0026lt;String\u0026gt; softRef = new SoftReference\u0026lt;\u0026gt;(\u0026#34;abc\u0026#34;); // 弱引用 WeakReference\u0026lt;String\u0026gt; weakRef = new WeakReference\u0026lt;\u0026gt;(\u0026#34;abc\u0026#34;); // 虚引用 ReferenceQueue queue = new ReferenceQueue(); PhantomReference phantomRef = new PhantomReference(\u0026#34;abc\u0026#34;, queue); \u0026ndash; 访问修饰符\r#\r修饰符 当前类 同包 子类 其他包 public OK OK OK OK protected OK OK OK default OK OK private OK \u0026ndash; 数据类型\r#\r基本数据类型\n字符型：char 布尔型：boolean 数值型： 整数类型：byte, short, int, long 浮点类型：float, double 引用数据类型\n类： class 接口： interface 数组： [] \u0026ndash; 创建对象的方式\r#\r1. new创建新对象 2. 通过反射机制 3. 采用clone机制 4. 通过序列化机制 \u0026ndash; 获取Class对象的方式\r#\rString str = new String(\u0026#34;abc\u0026#34;); // 方式一：通过类对象的 getClass() Class\u0026lt;?\u0026gt; clazz = str.getClass(); // 方式二：通过类的静态成员 Class\u0026lt;?\u0026gt; clazz = String.class; // 方式三：通过Class 类的静态方法 forName() Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;java.lang.String\u0026#34;); \u0026ndash; 浅拷贝、深拷贝\r#\r浅拷贝： 在拷贝一个对象时，对基本数据类型的成员变量进行拷贝，对引用类型的成员变量只进行引用的传递 深拷贝： 在拷贝一个对象时，对基本数据类型的成员变量进行拷贝，对引用类型的成员变量，创建一个新的对象，并复制其内容。 实现深拷贝的方式： 1. 将对象序列化为字节流，然后再反序列化为新的对象 2. 逐个复制引用类型属性 \u0026ndash; 自动装箱、自动拆箱\r#\r自动装箱： 自动将基本数据类型转换为包装器类型（int--\u0026gt;Integer），调用Integer的valueOf(int)方法 自动拆箱： 自动将包装器类型转换为基本数据类型（Integer--\u0026gt;int），调用Integer的intValue()方法 // 试题 Integer i1 = 100; Integer i2 = 100; Integer i3 = 200; Integer i4 = 200; System.out.println(i1==i2); System.out.println(i3==i4); 运行结果： true false ---------------------------------------------------------------------- 在通过valueOf方法创建Integer对象的时候， 如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用； 否则创建一个新的Integer对象 ps：在某个范围内的整型数值的个数是有限的，而浮点数不是 \u0026ndash; 方法重载、方法重写\r#\r重载 overload\n在一个类里面，方法名字相同，而参数不同 每个重载的方法都必须有独一无二的参数类型列表（参数个数、参数类型、参数顺序） 重写 override\n是子类对父类方法的实现进行重新编写 方法名、参数列表均相同 重写方法抛出的异常，需宽于被重写方法 构造方法不能被重写 区别\n区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常捕获 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问限制 可以修改 一定不能做更严格的限制（可以降低限制） \u0026ndash; 红黑树的特征\r#\r1. 节点颜色：每个节点被标记为红色或黑色 2. 根节和叶子节点都是黑色的 3. 红色节点的子节点不能是红色，即红色节点不能连续存在 4. 从任意节点到其每个叶子节点的路径包含相同数量的黑色节点 \u0026ndash; switch 能作用的类型\r#\rswitch可以作用于 byte、short、char、int 类型 从Java5开始，可以作用于 enum 类型 从Java7开始，可以作用于 String 类型 "},{"id":7,"href":"/interview/program-lang/java-jvm/p1/","title":"Part.1","section":"Java虚拟机","content":"\r\u0026ndash; JVM 结构\r#\r类加载器，Class Loader 执行引擎，Execution Engine 运行时数据区，Runtime Data Area 本地方法接口，Native Interface \u0026ndash; 类加载过程\r#\r\u0026ndash; 类加载机制\r#\r双亲委派模式\n1. 当类加载器需要加载某一个 .class 字节码文件时，它会首先将这个任务委托给其父类加载器。 2. 递归这个操作，直至传递到顶层的启动类加载器。 3. 只有当父类加载器无法完成此加载任务时，子类加载器才会自己去加载。 优点\n1. 避免类的重复加载 2. 避免Java的核心API被篡改 3. Java类随着类加载器一起具备了带有优先级的层级关系 \u0026ndash; JVM 内存模型\r#\r方法区\n即永久代 用于存储类信息、常量、静态常量、即时编译后的代码 运行时常量池，也是方法区的一部分，用于存放编译期生成的各种字面量和符号引用 堆内存\n用于存储对象实例、数组 是垃圾收集器管理的主要区域 堆内存采用分代收集算法，又细分为：新生代（Eden区、SurvivorFrom区、SurvivorTo区）、老年代 虚拟机栈\n栈内存，是Java方法执行的内存模型 每个方法被执行时，都会创建一个栈帧来存储局部变量表、操作数栈、动态链接、方法出口等信息 方法从被调用到执行完成的过程，就对应着栈帧在虚拟机栈中从入栈到出栈的过程 本地方法栈\n与虚拟机栈相同，区别是虚拟机栈为执行 Java 方法服务，而本地方法栈则为 Native 方法服务 程序计算器\n在 Java 虚拟机中，唯一没有 OOM 的区域 是一小块内存空间，用于存储当前线程正在执行字节码指令的地址值 正在执行 Java 方法时，记录的是当前指令的地址 正在执行 Native 方法时，则为 Undefined \u0026ndash; 内存区域分代\r#\r新生代\n由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收 分为：Eden区、ServivorFrom区、ServivorTo区 老年代\n主要存放应用程序中生命周期长的内存对象，老年代的对象比较稳定，所以 MajorGC 不会频繁执行 永久代\n指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息 GC 不会在主程序运行期对永久区域进行清理 在JDK1.8中，永久代被元空间取代，元空间并不在虚拟机中，而是使用本地内存 \u0026ndash; 堆和栈的区别\r#\r堆内存\r栈内存\r功能不同\r存储Java中的对象\r存储局部变量和方法调用\r共享性不同\r是线程共有的\r是线程私有的\r异常错误不同\r堆空间不足：java.lang.OutOfMemoryError\r栈空间不足：java.lang.StackOverFlowError\r空间大小\r堆内存远远大于栈内存\r\u0026ndash; 垃圾收集算法\r#\r标记-清除\n标记：扫描内存空间，对存活的对象进行标记 清除：扫描内存空间，回收未标记的对象。 标记-压缩\n标记：扫描内存空间，对存活的对象进行标记 压缩：再次扫描，并整理存活的对象 复制算法\n从 From 区找到存活的对象，复制到 To 区。 From、To区交互身份，进行下一轮垃圾收集。 \u0026ndash; 垃圾判定算法\r#\r引用计数法\n1、给对象添加一个引用计数器，记录引用该对象的次数 2、新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收 3、缺陷：无法解决对象间循环引用的问题 可达性分析法\n1、从GC Roots开始向下搜索，搜索所走过的路径称为引用链。 2、当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，即垃圾对象 \u0026ndash; 垃圾回收方式\r#\r串行（Serial）、并行（Parallel）、并发（Concurrent）、STW \u0026ndash; JVM 垃圾收集器\r#\r垃圾收集器 作用区域 收集算法 收集方式 说明 Serial 新生代 复制算法 串行 优点：简单高效 ParNew 新生代 复制算法 并行 Serial的多线程版本 Serial Old 老年代 标记-整理算法 串行 Serial的老年代版本 . Parallel Scavenge 新生代 复制算法 并行 追求高吞吐量，高效利用 CPU Parallel Old 老年代 标记-整理算法 并行 Parallel Scavenge的老年代版本 . CMS 老年代 标记-清除算法 并行 优点：高并发、低停顿 G1 新生代、老年代 标记-整理算法 并行 \u0026ndash; 触发FullGC执行的场景\r#\r1、直接触发 直接调用System.gc jvm参数显式地触发 2、内存区域已满 永久代或元空间内存不足 老年代内存不足 3、CMS垃圾回收失败 4、内存分配失败 当JVM尝试分配对象时，如果堆内存中没有足够的空间来容纳新的对象 \u0026ndash; 永久代中会发生垃圾回收吗\r#\r垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(FullGC) "},{"id":8,"href":"/interview/program-lang/java-thread/p1/","title":"Part.1","section":"Java多线程","content":"\r\u0026ndash; 程序、进程、线程\r#\r程序\n是含有指令和数据的文件，存储在硬件设备中，因此程序是静态的 进程\n是程序的一次执行过程，是程序的一个运行实例，因此进程是动态的 进程之间是相互独立的，各自有自己独立的内存空间和系统资源 线程\n是指在一个进程内的独立执行路径。一个进程可以包含多个线程。 每个线程都是独立运行的，有自己的执行顺序和状态。 多个线程可以共享内存空间和系统资源。 \u0026ndash; 创建线程的方式\r#\r继承Thread类 实现Runnable接口 实现Callable接口 使用线程池创建 \u0026ndash; 停止线程的方式\r#\r使用退出标志，使线程正常退出 使用interrupt()方法中断线程 使用stop()方法强行终止，但不推荐，可能会产生不可预料的结果 \u0026ndash; 线程安全\r#\r如果在多线程下执行和在单线程下执行永远都能获得一样的结果，那么代码就是线程安全的 \u0026ndash; 并发三特性\r#\r原子性\n不可分割，是一个整体 即一个操作或者多个操作，要么全部执行并且不被打断，要么就都不执行 可见性\n当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值 有序性\n程序执行的顺序按照代码的先后顺序执行 \u0026ndash; 线程池\r#\r核心参数\n工作过程\n1. 创建线程池后，等待提交过来的任务请求 2. 当调用execute()添加一个新任务时，线程池会做如下判断： a. 如果当前运行的线程数量还小于corePoolSize，则会创建新线程来执行新任务 b. 如果当前运行的线程数量不小于corePoolSize，则会将提交的任务放入阻塞队列中 c. 如果当前阻塞队列满了，且当前运行的线程数量还小于maximumPoolSize，则创建线程运行这个任务 d. 如果当前阻塞队列满了，且当前运行的线程数量不小于maximumPoolSize，则启动拒绝策略 3. 当一个线程完成任务时，它会从队列中取下一个任务来执行 4. 当一个线程空闲超过一定时间，并且此时当前运行的线程大于corePoolSize时，这个线程会被销毁 \u0026ndash; 常见线程池\r#\rnewSingleThreadExecutor：\n创建一个单线程的线程池 此线程池保证所有任务的执行顺序按照任务的提交顺序执行 newFixedThreadPool：\n创建固定大小的线程池 每次提交一个任务就创建一个线程，直到线程数达到线程池的最大数量 newCachedThreadPool：\n创建一个可缓存的线程池 此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程数量 newScheduledThreadPool：\n创建一个大小无限的线程池 此线程池支持定时以及周期性执行任务的需求 \u0026ndash; 线程池拒绝策略\r#\r拒绝策略 说明 AbortPolicy 默认策略，直接丢弃任务，抛出异常 CallerRunsPolicy 由调用者所在的线程处理该任务 DiscardPolicy 直接丢弃任务，也不抛出异常 DiscardOldestPolicy 丢弃等待队列中最旧的任务，并执行当前任务 \u0026ndash; 死锁的必要条件\r#\r互斥使用 一个资源每次只能被一个线程使用 不可抢占 资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放 请求和保持 当资源请求者在请求其他的资源的同时保持对原有资源的占有 循环等待 若干线程之间形成一种头尾相接的循环等待资源关系 \u0026ndash; CAS\r#\rCAS\n1. 比较并交换，Compare-And-Swap 2. 通过处理器的指令来保证操作的原子性，是一种无锁算法 3. Java CAS硬件底层接口：sun.misc.Unsafe 原理\n涉及三个操作数： 1. V：变量内存地址 2. A：旧的预期值 3. B：准备设置的新值 当执行CAS指令时，只有当V等于A时，才会用B去更新V的值，否则就不会执行更新操作 一般情况下是一个自旋操作，即不断的重试 缺点\n1. 自旋时间长开销很大 2. 只能保证一个共享变量的原子性 3. 存在ABA问题 ABA问题： 存在场景：在一段时间内，其他线程将A值改成B值，又改回A值 而CAS却误认为数据未被修改 \u0026ndash; AQS\r#\rAQS\n抽象的队列同步器，AbstarctQueuedSynchronizer，简称AQS AQS定义了一套多线程访问共享资源的同步器基础框架，许多同步类实现都依赖于它 AQS原理\n1. AQS维护了一个共享变量state和一个CLH队列（FIFO先入先出双向队列）。 2. 线程通过CAS去改变state状态，成功则获取锁成功，失败则进入等待队列，等待被唤醒。 AQS实现\n1、AQS的设计是基于模板模式。 2、AQS已实现了对等待队列的维护，自定义同步器只需要实现共享资源state的获取与释放方式即可。 3、AQS定义了两种资源共享方式： a. 独占方式：Exclusive，只有一个线程能执行，如ReentrantLock b. 共享方式：Share，多个线程可以同时执行，如Semaphore、CountDownLatch "},{"id":9,"href":"/interview/service-manage/spring-boot/","title":"SpringBoot","section":"服务治理","content":"\r\u0026ndash; SpringBoot\r#\rSpringBoot\n是一个用来简化新Spring应用的初始搭建以及开发过程的框架 优点\n1. 简化配置依赖 SpringBoot通过约定的默认配置和默认依赖，可以自动化配置和快速引入依赖 2. 独立运行 SpringBoot内嵌了各种servlet容器，应用可以打包为可执行JAR或WAR文件，直接执行 3. 应用监控 SpringBoot提供了运行时的应用监控，能方便地监控应用程序的运行情况 4. 无代码生成和XML配置 SpringBoot的大部分功能都可以通过配置来实现，无需编写代码或者XML配置 \u0026ndash; SpringBoot 核心注解\r#\r注解 说明 @SpringBootApplication 是一个组合注解，组合了以下三个注解 @SpringBootConfiguration 标注当前类是一个配置类，是@Configuration的特化版本 @EnableAutoConfiguration 启用自动配置功能 @ComponentScan 启用组件扫描功能 \u0026ndash; SpringBoot 启动方式\r#\r在IDE中，直接执行main()方法 使用 Maven 或 Gradle 命令来运行 打包成可执行 JAR 文件来运行 \u0026ndash; SpringBoot 实现热部署\r#\r配置开启\n\u0026lt;!-- pom.xml --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; # application.properties spring.devtools.restart.enabled=true spring.devtools.restart.additional-paths=src/main/java IDE 工具开启\nIntelliJ IDEA： File ==\u0026gt; Setting ==\u0026gt; Build, Execution, Deployment ==\u0026gt; Compiler：勾选 [Build project automatically] \u0026ndash; SpringBoot 自动配置原理\r#\r1. 在spring-boot-autoconfigure.jar包中的META-INF/spring.factories文件列出了所有自动配置类 2. SpringBoot启动时，注解@EnableAutoConfiguration会查找并加载spring.factories中列出的所有自动配置类 3. 对每个自动配置类进行条件检查，如果需要自动配置，则将其配置加载到spring容器中 "},{"id":10,"href":"/interview/program-design/structure-algorithm/leetcode/%E5%93%88%E5%B8%8C/","title":"哈希","section":"leetcode","content":"\r哈希\r#\r哈希\r#\r用空间换时间，提高查询速度 两数之和\r#\r原题\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。 你可以按任意顺序返回答案。 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 题解\n枚举数组中的每一个数 x，寻找数组中是否存在 target - x import java.util.HashMap; public class Main { public int[] twoSum(int[] nums, int target) { HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { int choose = nums[i]; int diff = target - choose; if (map.containsKey(diff)) { return new int[]{map.get(diff), i}; } map.put(choose, i); } return null; } } 字母异位词分组\r#\r原题\n给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的所有字母得到的一个新单词。 输入: strs = [\u0026#34;eat\u0026#34;, \u0026#34;tea\u0026#34;, \u0026#34;tan\u0026#34;, \u0026#34;ate\u0026#34;, \u0026#34;nat\u0026#34;, \u0026#34;bat\u0026#34;] 输出: [[\u0026#34;bat\u0026#34;],[\u0026#34;nat\u0026#34;,\u0026#34;tan\u0026#34;],[\u0026#34;ate\u0026#34;,\u0026#34;eat\u0026#34;,\u0026#34;tea\u0026#34;]] 题解\n互为字母异位词的字符串，排序后的字符串一定是相同的 故可以将排序之后的字符串作为哈希表的键 import java.util.ArrayList; import java.util.Arrays; import java.util.HashMap; import java.util.List; public class Main { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groupAnagrams(String[] strs) { HashMap\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (String key : strs) { char[] chars = key.toCharArray(); Arrays.sort(chars); String sortKey = new String(chars); if (map.containsKey(sortKey)) { map.get(sortKey).add(key); } else { List\u0026lt;String\u0026gt; s = new ArrayList\u0026lt;\u0026gt;(); s.add(key); map.put(sortKey, s); } } return new ArrayList\u0026lt;\u0026gt;(map.values()); } } 最长连续序列\r#\r原题\n给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。 输入：nums = [100,4,200,1,3,2] 输出：4 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 题解\n如果数组中不存在 x-1，则 x 是序列的起始数 如果数组中不存在 x+1，则 x 是序列的终止数 import java.util.HashSet; public class Main { public int longestConsecutive(int[] nums) { HashSet\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int n : nums) { set.add(n); } int count = 0; int ans = 0; for (int n : set) { if (!set.contains(n - 1)) { //说明这部分是开始的数据：头 count = 1; int curr = n; while (set.contains(curr + 1)) { //如果存在说明是：中 count++; curr++; } //结束了不满足条件说明到了：尾 ans = Math.max(ans, count); } } return ans; } } "},{"id":11,"href":"/interview/program-design/structure-algorithm/huawei-od/%E5%BF%85%E4%BC%9A%E9%A2%981/","title":"必会题 - 1","section":"华为OD","content":"\r01. 字符串分割\r#\r描述\n给定一个非空字符串S，其被N个‘-’分隔成N+1的子串，给定正整数K，要求除第一个子串外，其余的子串每K个字符组成新的子串，并用‘-’分隔。 对于新组成的每一个子串， 如果它含有的小写字母比大写字母多，则将这个子串的所有大写字母转换为小写字母； 如果它含有的大写字母比小写字母多，则将这个子串的所有小写字母转换为大写字母； 大小写字母的数量相等时，不做转换。 输入描述：输入为两行，第一行为参数K，第二行为字符串S。 输出描述：输出转换后的字符串 输入： 3 12abc-abcABC-4aB@ 输出： 12abc-abc-ABC-4aB-@ 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); int k = Integer.parseInt(in.nextLine()); String input = in.nextLine(); String[] strings = input.split(\u0026#34;-\u0026#34;); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(strings[0]); StringBuilder str = new StringBuilder(); for (int i = 1; i \u0026lt; strings.length; i++) { str.append(strings[i]); } for (int i = 0; i \u0026lt; str.length(); i += k) { if (i + k \u0026lt;= str.length()) { list.add(caseConversion(str.substring(i, i + k))); } else { list.add(caseConversion(str.substring(i))); } } System.out.println(String.join(\u0026#34;-\u0026#34;, list)); } private static String caseConversion(String s) { int upperCaseLength = s.length() - s.replaceAll(\u0026#34;[A-Z]\u0026#34;, \u0026#34;\u0026#34;).length(); int lowerCaseLength = s.length() - s.replaceAll(\u0026#34;[a-z]\u0026#34;, \u0026#34;\u0026#34;).length(); if (upperCaseLength \u0026gt; lowerCaseLength) { return s.toUpperCase(Locale.ROOT); } if (lowerCaseLength \u0026gt; upperCaseLength) { return s.toLowerCase(Locale.ROOT); } return s; } 02. 组成最大数\r#\r描述\n小组中每位都有一张卡片，卡片上是6位内的正整数，将卡片连起来可以组成多种数字，计算组成的最大数字。 输入描述：“,”号分割的多个正整数字符串，不需要考虑非数字异常情况，小组最多25个人。 输出描述：最大的数字字符串 输入： 4589,101,41425,9999 输出： 9999458941425101 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); String input = in.nextLine(); String[] strings = input.split(\u0026#34;,\u0026#34;); Arrays.sort(strings); for (int i = strings.length - 1; i \u0026gt;= 0; i--) { System.out.print(strings[i]); } } 03. 统计射击比赛成绩\r#\r描述\n给定一个射击比赛成绩单，包含多个选手若干次射击的成绩分数， 请对每个选手按其最高3个分数之和进行降序排名，输出降序排名后的选手ID序列。 1、一个选手可以有多个射击成绩的分数，且次序不固定。 2、如果一个选手成绩少于3个，则认为选手的所有成绩无效，排名忽略该选手。 3、如果选手的成绩之和相等，则成绩之和相等的选手按照其ID降序排列。 输入描述： 输入第一行，一个整数N，表示该场比赛总共进行了N次射击，产生N个成绩分数（2≤N≤100）。 输入第二行，一个长度为N整数序列，表示参与每次射击的选手ID（0≤ID≤99）。 输入第三行，一个长度为N整数序列，表示参与每次射击的选手对应的成绩（0≤成绩≤100）。 输出描述：符合题设条件的降序排名后的选手ID序列。 输入: 13 3,3,7,4,4,4,4,7,7,3,5,5,5 53,80,68,24,39,76,66,16,100,55,53,80,55 输出： 5,3,7,4 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); int num = Integer.parseInt(in.nextLine()); String[] idArr = in.nextLine().split(\u0026#34;,\u0026#34;); String[] scoreArr = in.nextLine().split(\u0026#34;,\u0026#34;); Integer[] ids = Arrays.stream(idArr).map(Integer::parseInt).toArray(Integer[]::new); Integer[] scores = Arrays.stream(scoreArr).map(Integer::parseInt).toArray(Integer[]::new); Map\u0026lt;Integer, ArrayList\u0026lt;Integer\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; num; i++) { map.putIfAbsent(ids[i], new ArrayList\u0026lt;\u0026gt;()); map.get(ids[i]).add(scores[i]); } ArrayList\u0026lt;int[]\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int id : map.keySet()) { ArrayList\u0026lt;Integer\u0026gt; idScores = map.get(id); if (idScores.size() \u0026lt; 3) { continue; } int total = idScores.stream().sorted((a, b) -\u0026gt; b - a).limit(3).reduce(Integer::sum).orElse(0); ans.add(new int[]{id, total}); } ans.sort((a, b) -\u0026gt; a[1] != b[1] ? b[1] - a[1] : b[0] - a[0]); String result = ans.stream().map(arr -\u0026gt; String.valueOf(arr[0])).collect(Collectors.joining(\u0026#34;,\u0026#34;)); System.out.print(result); } 04. 字符串序列判定\r#\r描述\n给定两个字符串 s和 t ，判断 s是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度n ~= 500,000），而 s 是个短字符串（长度 ≤ 100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。 （例如，\u0026#34;ace\u0026#34;是\u0026#34;abcde\u0026#34;的一个子序列，而\u0026#34;aec\u0026#34;不是）。 输入描述：共两行，第一行为字符串s（1≤m≤100）, 第二行为字符串t（1≤n≤500000） 输出描述：输出true或者是false 输入： abc ahbgdc 输出： true 题解\npublic static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); char[] chars1 = br.readLine().toCharArray(); int read; int index = 0; char temp = \u0026#39; \u0026#39;; while ((read = br.read()) != \u0026#39;\\n\u0026#39;) { char ch = (char) read; if (index \u0026lt; chars1.length \u0026amp;\u0026amp; ch == chars1[index] \u0026amp;\u0026amp; ch != temp) { temp = ch; index++; } } String result = index == chars1.length ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;; System.out.print(result); } 05. 数据分类\r#\r描述\n对一个数据a进行分类， 分类方法是，此数据a(4个字节大小)的4个字节相加对一个给定值b取模， 如果得到的结果小于一个给定的值c则数据a为有效类型，其类型为取模的值。 如果得到的结果大于或者等于c则数据a为无效类型。 比如一个数据a = 0x01010103，b = 3 按分类方法计算：(0x01 + 0x01 + 0x01 + 0x03) % 3 = 0 所以如果c = 2则此a就是有效类型，其类型为0 如果c = 0则此a是无效类型 输入描述：输入12个数据， 第一个数据为c，第二个数据为b， 剩余10个数据为需要分类的数据 输出描述： 请找到有效类型中包含数据最多的类型， 并输出该类型含有多少个数据。 输入：3 4 256 257 258 259 260 261 262 263 264 265 输出：3 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); int[] ints = new int[12]; for (int i = 0; i \u0026lt; ints.length; i++) { ints[i] = in.nextInt(); } solution(ints); } private static void solution(int[] ints) { int c = ints[0]; int b = ints[1]; Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 2; i \u0026lt; ints.length; i++) { int r = intByteSum(ints[i]) % b; if (r \u0026lt; c) { map.putIfAbsent(r, 0); map.put(r, map.get(r) + 1); } } int max = 0; for (Integer value : map.values()) { if (value \u0026gt; max) { max = value; } } System.out.println(max); } private static int intByteSum(int x) { int sum = 0; for (int i = 0; i \u0026lt; 4; i++) { sum += (byte) (x \u0026gt;\u0026gt; (i * 8)); } return sum; } 06. 五键键盘的输出\r#\r描述\n有一个特殊的 5键键盘，上面有 a,ctrl-c,ctrl-x,ctrl-v,ctrl-a五个键，给定一系列键盘输入，输出最终屏幕上字母的数量。 a键在屏幕上输出一个字母 a; ctrl-c将当前选择的字母复制到剪贴板; ctrl-x将当前选择的 字母复制到剪贴板，并清空选择的字母; ctrl-v将当前剪贴板里的字母输出到屏幕; ctrl-a选择当前屏幕上所有字母。 注意: 1、剪贴板初始为空，新的内容被复制到剪贴板时会覆盖原来的内容 2、当屏幕上没有字母时，ctrl-a无效 3、当没有选择字母时，ctrl-c和 ctrl-x无效 4、当有字母被选择时，a和ctrl-v这两个有输出功能的键会先清空选择的字母，再进行输出 输入描述：输入为一行，为简化解析，用数字 12345代表 a,ctrl-c,ctrl-x,ctrl-v,ctrl-a五个键的输入，数字用空格分隔 输出描述：输出一个数字，为最终屏目上字母的数量。 输入：1 1 5 1 5 2 4 4 输出：2 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); String[] strings = in.nextLine().split(\u0026#34; \u0026#34;); int copy = 0; int sum = 0; boolean isCopy = false; boolean isSelect = false; for (String str : strings) { if (\u0026#34;1\u0026#34;.equals(str) \u0026amp;\u0026amp; isSelect) { sum = 1; isSelect = false; continue; } if (\u0026#34;1\u0026#34;.equals(str) \u0026amp;\u0026amp; !isSelect) { sum++; continue; } if (\u0026#34;2\u0026#34;.equals(str) \u0026amp;\u0026amp; isSelect) { copy = sum; isCopy = true; continue; } if (\u0026#34;3\u0026#34;.equals(str) \u0026amp;\u0026amp; isSelect) { copy = sum; sum = 0; isCopy = true; isSelect = false; continue; } if (\u0026#34;4\u0026#34;.equals(str) \u0026amp;\u0026amp; isCopy \u0026amp;\u0026amp; isSelect) { sum = copy; isSelect = false; continue; } if (\u0026#34;4\u0026#34;.equals(str) \u0026amp;\u0026amp; isCopy \u0026amp;\u0026amp; !isSelect) { sum = sum + copy; continue; } if (\u0026#34;5\u0026#34;.equals(str)) { copy = sum; isSelect=true; } } System.out.println(sum); } 07. 检查是否存在满足条件的数字组合\r#\r描述\n给定一个正整数数组，检查数组中是否存在满足规则的数字组合 规则：A = B + 2C 备注： 数组长度在3~100之间 数组成员为0~65535 数组成员可以重复，但每个成员只能在结果算式中使用一次， 如数组成员为 [0,0,1,5]，0出现两次允许，但结果0=0+2*0不允许 因为算式中使用了3个0 用例保证每组数字里最多只有一组符合要求的解 输入描述： 第一行输出数组的元素个数。 第二行输出所有数组元素，用空格隔开。 输出描述： 如果存在满足要求的数，在同一行里依次输出规则里A/B/C的取值，用空格隔开。 如果不存在，输出0。 输入： 4 2 7 3 0 输出： 7 3 2 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); in.nextLine(); String[] strings = in.nextLine().split(\u0026#34; \u0026#34;); int[] arr = new int[strings.length]; for (int i = 0; i \u0026lt; strings.length; i++) { arr[i] = Integer.parseInt(strings[i]); } Arrays.sort(arr); int flag = 0; for (int i = arr.length - 1; i \u0026gt;= 0; i--) { for (int j = arr.length - 2; j \u0026gt;= 0; j--) { for (int k = arr.length - 3; k \u0026gt;= 0; k--) { if ((arr[i] == arr[j] + 2 * arr[k]) \u0026amp;\u0026amp; (i != j \u0026amp;\u0026amp; i != k \u0026amp;\u0026amp; j != k)) { flag++; System.out.println(arr[i] + \u0026#34; \u0026#34; + arr[j] + \u0026#34; \u0026#34; + arr[k]); } } } } if (flag == 0) { System.out.println(0); } } 08. 数组拼接\r#\r描述\n现在有多组整数数组，需要将它们合并成一个新的数组。 合并规则，循环从每个数组里按顺序取出固定长度的内容合并到新的数组中，取完的内容会删除掉， 如果该行不足固定长度或者已经为空，则直接取出剩余部分的内容放到新的数组中，继续下一行。 输入描述： 第一行是每次读取的固定长度，0＜长度＜10 第二行是整数数组的数目，0＜数目＜1000 第3-n行是需要合并的数组，不同的数组用回车换行分隔，数组内部用逗号分隔，最大不超过100个元素 输出描述：输出一个新的数组，用逗号分隔。 输入： 3 2 2,5,6,7,9,5,7 1,7,4,3,4 输出： 2,5,6,1,7,4,7,9,5,3,4,7 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); int len = Integer.parseInt(in.nextLine()); int num = Integer.parseInt(in.nextLine()); List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; num; i++) { list.add(Arrays.asList(in.nextLine().split(\u0026#34;,\u0026#34;))); } int start = 0; int end; List\u0026lt;String\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); int count = 0; while (count \u0026lt; list.size()) { for (List\u0026lt;String\u0026gt; strings : list) { System.out.println(start + \u0026#34; \u0026#34; + count); if (start \u0026gt; strings.size() - 1) { continue; } end = Math.min(start + len, strings.size()); if (end == strings.size()) { count++; } result.addAll(strings.subList(start, end)); } start += len; } System.out.println(String.join(\u0026#34;,\u0026#34;, result)); } 09. 数列描述\r#\r描述\n有一个数列A[n]，从A[0]开始每一项都是一个数字，数列中A[n+1]都是A[n]的描述，其中A[0]=1，规则如下： A[0]:1 A[1]:11 表示A[0]从左到右连续出现了1次1 A[2]:21 表示A[1]从左到右连续出现了2次1 A[3]:1211 表示A[2]从左到右连续出现了一次2又连续出现了一次1 A[4]:111221 表示A[3]从左到右连续出现了一次1又连续出现了一次2又连续出现了2次1 输出第n项的结果 输入描述：数列第n项 0≤n≤59 输出描述：数列内容 输入：4 输出：111221 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); int num = Integer.parseInt(in.nextLine()); if (num == 0) { System.out.println(\u0026#34;1\u0026#34;); return; } String result = \u0026#34;1\u0026#34;; for (int i = 1; i \u0026lt;= num; i++) { result = getNext(result); } System.out.println(result); } private static String getNext(String str) { char[] chars = str.toCharArray(); int sum = 0; char ch = chars[0]; StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; chars.length; i++) { if (ch == chars[i]) { sum++; continue; } sb.append(sum).append(ch); ch = chars[i]; sum = 1; } sb.append(sum).append(ch); return sb.toString(); } 10. 考勤信息\r#\r描述\n公司用一个字符串来表示员工的出勤信息 缺勤-absent，迟到-late，早退-leaveearly，正常上班-resent 现需根据员工出勤信息，判断本次是否能获得出勤奖，能获得出勤奖的条件如下： 缺勤不超过一次； 没有连续的迟到/早退； 任意连续7次考勤，缺勤/迟到/早退不超过3次。 输入描述： 第一行输入一个整数n，表示有多少个员工 后面n行，每一行输入若干个字符串，表示第i名员工的出勤信息 输出描述： 输出n行，每一行表示这名员工能否获得出勤奖，如果可以，则输出“true\u0026#34;，否则输出”false\u0026#34; 输入： 2 present present absent present present leaveearly present absent 输出： true false 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); int num = Integer.parseInt(in.nextLine()); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; num; i++) { list.add(getResult(in.nextLine())); } System.out.println(String.join(\u0026#34; \u0026#34;, list)); } private static String getResult(String string) { String str = string.replaceFirst(\u0026#34;absent\u0026#34;, \u0026#34;\u0026#34;); if (str.contains(\u0026#34;absent\u0026#34;)) { return \u0026#34;false\u0026#34;; } if (string.contains(\u0026#34;late leaveearly\u0026#34;) || string.contains(\u0026#34;leaveearly late\u0026#34;)) { return \u0026#34;false\u0026#34;; } List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(string.split(\u0026#34; \u0026#34;))); if (list.size() \u0026lt; 7) { for (int i = 0; i \u0026lt; 7 - list.size(); i++) { list.add(\u0026#34;\u0026#34;); } } for (int i = 0; i \u0026lt; list.size() - 6; i++) { int time = 0; List\u0026lt;String\u0026gt; subList = list.subList(i, i + 7); for (String subStr : subList) { if (!\u0026#34;resent\u0026#34;.equals(subStr)) { time++; } if (time \u0026gt; 3) { return \u0026#34;false\u0026#34;; } } } return \u0026#34;ture\u0026#34;; } 11. 按单词下标区间翻转文章内容\r#\r描述\n给定一段英文文章片段，由若干单词组成，单词间以空格间隔，单词下标从0开始。 请翻转片段中指定区间的单词顺序并返回翻转后的内容。 例如给定的英文文章片段为\u0026#34;I am a developer\u0026#34;，翻转区间为[0,3]，则输出“developer a am I”。 输入描述：使用换行隔开三个参数 第一个参数为英文文章内容即英文字符串 第二个参数为待翻转内容起始单词下标 第三个参数为待翻转内容最后一个单词下标 输出描述：翻转后的英文文章片段所有单词之间以一个半角空格分隔进行输出。 输入：I am a developer. 0 3 输出：developer. a am I 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); String text = in.nextLine(); int left = Integer.parseInt(in.nextLine()); int right = Integer.parseInt(in.nextLine()); List\u0026lt;String\u0026gt; strList = Arrays.stream(text.split(\u0026#34; \u0026#34;)) .filter(str -\u0026gt; str != null \u0026amp;\u0026amp; !str.isBlank()).collect(Collectors.toList()); left = Math.min(left, 0); right = Math.min(right, strList.size() - 1); if (right == left || left \u0026gt; strList.size() - 1 || right \u0026lt; 0) { System.out.println(\u0026#34;EMPTY\u0026#34;); return; } List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; left; i++) { list.add(strList.get(i)); } for (int i = right; i \u0026gt;= left; i--) { list.add(strList.get(i)); } for (int i = right + 1; i \u0026lt; strList.size(); i++) { list.add(strList.get(i)); } System.out.println(String.join(\u0026#34; \u0026#34;, list)); } 12. 最大括号深度\r#\r描述\n现有一字符串 仅由 \u0026#39;(\u0026#39;, \u0026#39;)\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;}\u0026#39;, \u0026#39;[\u0026#39;, \u0026#39;]\u0026#39;一共六种括号组成。若字符串满足以下条件之一，则为无效字符串。 1、任意类型的左右括号数量不相等 2、存在未按正确顺序(先左后右)闭合的括号，输出括号的最大嵌套深度，若字符串无效则输出 0。 输入描述：一个只包括 \u0026#39;(\u0026#39;, \u0026#39;)\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;}\u0026#39;, \u0026#39;[\u0026#39;, \u0026#39;]\u0026#39; 以一共6种字符的字符串。 输出描述：一个整数，表示最大的括号深度。若字符串无效，则输出 0 输入：([]{()}) 输出：3 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); char[] chars = in.nextLine().toCharArray(); int depth = 0; Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (char ch : chars) { if (ch == \u0026#39;(\u0026#39; || ch == \u0026#39;{\u0026#39; || ch == \u0026#39;[\u0026#39;) { stack.push(ch); depth = Math.max(depth, stack.size()); continue; } if (stack.isEmpty()) { System.out.println(\u0026#34;0\u0026#34;); return; } char left = stack.pop(); if ((ch == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; left != \u0026#39;(\u0026#39;) || (ch == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; left != \u0026#39;{\u0026#39;) || (ch == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; left != \u0026#39;[\u0026#39;)) { System.out.println(\u0026#34;0\u0026#34;); return; } } System.out.println(depth); } 13. 字符串加密\r#\r描述\n给你一串未加密的字符串str，过对字符串的每一个字母进行改变来实现加密， 加密方式是在每一个字母str[i]偏移特定数组元素a[i]的量， 数组a前三位已经赋值：a[0]=1,a[1]=2,a[2]=4。 当i\u0026gt;=3时，数组元素a[i]=a[i-1]+a[i-2]+a[i-3]， 例如：原文 abcde 加密后 bdgkr，其中偏移量分别是1,2,4,7,13。 输入描述： 第一行为一个整数n（1 ≤ n ≤ 1000）， 表示有n组测试数据，每组数据包含一行， 原文str（只含有小写字母， 长度小于等于50）。 输出描述：每组测试数据输出一行，表示字符串的密文 输入：1 xy 输出：a 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); int num = Integer.parseInt(in.nextLine()); for (int i = 0; i \u0026lt; num; i++) { getResult(in.nextLine()); } } private static void getResult(String string) { char[] chars = string.toCharArray(); StringBuilder sb = new StringBuilder(); int temp1 = 1; int temp2 = 2; int temp3 = 4; int offset = 0; for (int i = 0; i \u0026lt; chars.length; i++) { if (i == 0) { sb.append(getNextChar(chars[i], temp1)); continue; } if (i == 1) { sb.append(getNextChar(chars[i], temp2)); continue; } if (i == 2) { sb.append(getNextChar(chars[i], temp3)); continue; } offset = temp1 + temp2 + temp3; sb.append(getNextChar(chars[i], offset)); temp1 = temp2; temp2 = temp3; temp3 = offset; } System.out.println(sb.toString()); } private static char getNextChar(char c, int offset) { offset = ((c - \u0026#39;a\u0026#39;) + offset) % 26; return (char) (\u0026#39;a\u0026#39; + offset); } 14. 整数对最小和\r#\r描述\n给定两个整数数组 array1、array2，数组元素按升序排列 假设从array1、array2中分别取出一个元素可构成一对元素 现在需要取出K个元素，对取出的所有元素求和，计算和的最小值 注意： 两对元素如果对应于array1、array2中的两个下标均相同，则视为同一个元素 输入两行数组：array1、array2, 每行首个数字为数组大小：size(0＜size≤100), 0＜array1[i]≤1000, 0＜array2[i]≤1000 接下来一行为正整数k：0＜k≤ array1.size()*array2.size() 输出描述： 满足要求的最小和 输入：3 1 1 2 3 1 2 3 2 输出：4 说明： 用例中，需要取2对元素 取第一个数组第0个元素与第二个数组第0个元素组成1对元素[1，1]； 取第一个数组第1个元素与第二个数组第0个元素组成1对元素[1，1]； 求和为1+1+1+1=4，为满足要求的最小和 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); int[] arr1 = Arrays.stream(in.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int[] arr2 = Arrays.stream(in.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int k = Integer.parseInt(in.nextLine()); int l = 2; int r = 2; Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;1-1\u0026#34;, arr1[1] + arr2[1]); while (map.size() \u0026lt; k) { if (arr1[l] \u0026lt;= arr2[r]) { for (int i = 1; i \u0026lt; r; i++) { String key = l + \u0026#34;-\u0026#34; + i; if (!map.containsKey(key)) { map.put(key, arr1[l] + arr2[i]); } } l++; continue; } if (arr1[l] \u0026gt; arr2[r]) { for (int i = 1; i \u0026lt; l; i++) { String key = i + \u0026#34;-\u0026#34; + r; if (!map.containsKey(key)) { map.put(key, arr1[i] + arr2[r]); } } r++; } } System.out.println(map.values().stream().reduce(Integer::sum).orElse(0)); } 15. 求字符串中所有整数的最小和\r#\r描述\n输入字符串s，输出s中包含所有整数的最小和。 说明： 字符串s，只包含 a-z A-Z ± ； 合法的整数包括 正整数：一个或者多个0-9组成，如0，2，3，002，102 负整数：负号 – 开头，数字部分由一个或者多个0-9组成，如-0，-012，-23，-00023 输入描述：包含数字的字符串。 输出描述：所有整数的最小和。 输入：b12-34aa 输出：-31 说明：1+2+(-34)=-31 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); char[] chars = in.nextLine().toCharArray(); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); String temp = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; chars.length; i++) { if (\u0026#39;-\u0026#39; == chars[i]) { temp = \u0026#34;-\u0026#34;; continue; } if (chars[i] \u0026lt; \u0026#39;0\u0026#39; || chars[i] \u0026gt; \u0026#39;9\u0026#39;) { if (temp.length() \u0026gt; 1) { list.add(temp); temp = \u0026#34;\u0026#34;; } continue; } if (!temp.isEmpty()) { temp += chars[i]; continue; } list.add(String.valueOf(chars[i])); } if (temp.length() \u0026gt; 1) { list.add(temp); } System.out.println(list.stream().mapToInt(Integer::parseInt).reduce(Integer::sum).orElse(0)); } 16. 乱序整数序列两数之和绝对值最小\r#\r描述\n给定一个随机的整数数组(可能存在正整数和负整数)nums, 请你在该数组中找出两个数，其和的绝对值(|nums[x]+nums[y]|)为最小值，并返回这两个数(按从小到大返回)以及绝对值。 每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 输入描述：一个通过空格空格分割的有序整数序列字符串，最多1000个整数，且整数数值范围是[-65535,65535] 输出描述：两个数、两数之和绝对值 输入：-1 -3 7 5 11 15 输出：-3 5 2 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); List\u0026lt;Integer\u0026gt; list = Arrays.stream(in.nextLine().split(\u0026#34; \u0026#34;)).distinct() .map(Integer::parseInt).collect(Collectors.toCollection(ArrayList::new)); int a = 0; int b = 0; int sum = Integer.MAX_VALUE; for (int i = 0; i \u0026lt; list.size(); i++) { for (int j = 0; j \u0026lt; list.size(); j++) { if (i == j) { continue; } int temp = Math.abs(list.get(i) + list.get(j)); if (temp \u0026lt; sum) { a = list.get(i); b = list.get(j); sum = temp; } } } System.out.print(Math.min(a, b) + \u0026#34; \u0026#34; + Math.max(a, b) + \u0026#34; \u0026#34; + sum); } 17. 非严格递增连续数字序列\r#\r描述\n输入一个字符串仅包含大小写字母和数字，求字符串中包含的最长的非严格递增连续数字序列长度 比如： 12234属于非严格递增数字序列 输入描述：输入一个字符串仅包含大小写字母和数字 输出描述：出字符串中包含的最长的非严格递增连续数字序列长度 输入：abc2234019A334bc 输出：4 说明：2234为最长的非严格递增连续数字序列 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); char[] chars = in.nextLine().toCharArray(); int curLen = 0; int maxLen = 0; char last = \u0026#39;0\u0026#39;; for (int i = 0; i \u0026lt; chars.length; i++) { char ch = chars[i]; if (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { curLen = 0; continue; } if (ch \u0026lt; last) { last = \u0026#39;0\u0026#39;; curLen = 1; continue; } curLen++; last = ch; maxLen = Math.max(maxLen, curLen); } System.out.println(maxLen); } 18. 分积木\r#\r描述\nsolo和koko是两兄弟，分一堆积木，每块积木有自己的重量，现在他们将积木分成两堆。 弟弟koko还小只会将数字转化为二进制进行计算，而且总是忘记进位。 弟弟koko按照他计算的方式要求两堆积木重量相等，要不然就会哭 哥哥solo进行分积木希望尽量给弟弟少分，并且不让弟弟哭 输入描述： 第一行是一个整数N (2 ≤ N ≤ 100)，表示有多少块积木 第二行为空格分开的N个整数Ci (1 ≤ Ci ≤ 10^6)，表示第i块积木的重量 输出描述：让koko不哭，输入solo所能获得积木的最大总重量否则输出 \u0026#34;No\u0026#34; 输入：3 3 5 6 输出：11 按koko计算，其得到的积木的重量都是11(二进制) 按真实计算，solo得到的积木的重量是5+6=11(十进制) 101 十进制--5 + 110 十进制--6 —————— 011 十进制--3 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); int num = Integer.parseInt(in.nextLine()); int[] arr = new int[num]; String[] strings = in.nextLine().split(\u0026#34; \u0026#34;); for (int i = 0; i \u0026lt; strings.length; i++) { arr[i] = Integer.parseInt(strings[i]); } String result = solution(arr); System.out.print(result); } private static String solution(int[] arr) { if (arr.length \u0026lt; 2 || (arr.length == 2 \u0026amp;\u0026amp; arr[0] != arr[1])) { return \u0026#34;NO\u0026#34;; } int min = arr[0]; int sum = min; int temp = min; for (int i = 1; i \u0026lt; arr.length; i++) { sum += arr[i]; min = Math.min(min, arr[i]); temp ^= arr[i]; } if (temp != 0) { return \u0026#34;NO\u0026#34;; } else { return String.valueOf(sum - min); } } 19. 连续字母长度\r#\r描述\n给定一个字符串，只包含大写字母，求在包含同一字母的子串中，长度第 k 长的子串的长度，相同字母只取最长的那个子串。 输入描述： 第一行有一个子串(1＜长度≤100)，只包含大写字母。 第二行为 k的值 输出描述：输出连续出现次数第k多的字母的次数。 输入：AABAAA 2 输出：1 说明：同一字母连续出现的最多的是A，3次；第二多的还是A，两次，但是A已经出现过了，故为B，一次； 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); char[] chars = in.nextLine().toCharArray(); int k = Integer.parseInt(in.nextLine()); Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); char lastCh = \u0026#39; \u0026#39;; int curLen = 1; for (int i = 0; i \u0026lt; chars.length; i++) { char curCh = chars[i]; if (curCh == lastCh) { curLen++; map.put(curCh, Math.max(curLen, map.get(curCh))); } else { map.putIfAbsent(curCh, 1); lastCh = curCh; curLen = 1; } } List\u0026lt;Integer\u0026gt; list = map.values().stream().sorted().collect(Collectors.toList()); int index = list.size() - k; if (index \u0026gt;= 0) { System.out.println(list.get(index)); } else { System.out.println(\u0026#34;-1\u0026#34;); } } 20. 滑动窗口最大和\r#\r描述\n给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 输入：1,3,-1,-3,5,3,6,7 3 输出：3,3,5,5,6,7 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); int[] ints = Arrays.stream(in.nextLine().split(\u0026#34;,\u0026#34;)).mapToInt(Integer::parseInt).toArray(); int k = Integer.parseInt(in.nextLine()); int max; List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; ints.length - k + 1; i++) { max = ints[i]; for (int j = 1; j \u0026lt; k; j++) { max = Math.max(max, ints[i + j]); } list.add(String.valueOf(max)); } System.out.println(String.join(\u0026#34;,\u0026#34;, list)); } 21. 素数之积\r#\r描述\nRSA加密算法在网络安全世界中无处不在，它利用了极大整数因数分解的困难度，数据越大，安全系数越高。 给定一个32位正整数，请对其进行因数分解，找出是哪两个素数的乘积。 输入描述：一个正整数num，0＜num≤2147483647 输出描述：如果成功找到，以单个空格分割，从小到大输出两个素数，分解失败，请输出-1 -1 输入： 15 输出： 3 5 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); int num = Integer.parseInt(in.nextLine()); int r1 = -1; int r2 = -1; for (int i = 2; i \u0026lt; Math.sqrt(num) + 1; i++) { if (num % i != 0) { continue; } if (isPrime(i) \u0026amp;\u0026amp; isPrime(num / i)) { r1 = i; r2 = num / i; break; } } System.out.println(r1 + \u0026#34; \u0026#34; + r2); } // 判断 n 是否为素数 private static boolean isPrime(int n) { if (n \u0026lt; 2) { return false; } for (int i = 2; i \u0026lt;= Math.sqrt(n); i++) { if (n % i == 0) { return false; } } return true; } 22. 仿LISP运算\r#\r描述\nLISP语言唯一的语法就是括号要配对。 形如 (OP P1 P2 …)，括号内元素由单个空格分割。其中第一个元素OP为操作符，后续元素均为其参数，参数个数取决于操作符类型 注意：参数 P1, P2 也有可能是另外一个嵌套的 (OP P1 P2 …) 当前OP类型为add/sub/mul/div(全小写)，分别代表整数的加减乘除法。简单起见，所以OP参数个数为2 输入描述：合法C字符串，字符串长度不超过512，用例保证了无语法错误 输出描述：合法C字符串，字符包括’0’-‘9’及负号’-‘或者’error’ 输入：(mul 3 -7)输出：-21 输入：(add 1 2) 输出：3 输入：(sub (mul 2 4) (div 9 3)) 输出 ：5 输入：(div 1 0) 输出：error 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); String str = in.nextLine(); solution(str); } public static void solution(String str) { Stack\u0026lt;Integer\u0026gt; numStack = new Stack\u0026lt;\u0026gt;(); Stack\u0026lt;String\u0026gt; opStack = new Stack\u0026lt;\u0026gt;(); int mark = 0; int paramOne = 0; int paramTwo = 0; for (int i = 0; i \u0026lt; str.length(); i++) { char chas = str.charAt(i); if (chas == \u0026#39;(\u0026#39;) { //截取符号位 opStack.push(str.substring(i + 1, i + 4)); //这里为空格的索引位置 i = i + 4; //符号位后第一个数字的索引坐标 mark = i + 1; } else if (chas == \u0026#39;)\u0026#39;) { if (mark \u0026lt; i) { //所有数字的截取 numStack.push(Integer.valueOf(str.substring(mark, i))); i++; mark = i + 1; } //得到一次（）的对应，就进行一次计算 paramTwo = numStack.pop(); paramOne = numStack.pop(); calc(numStack, opStack, paramOne, paramTwo); } else { //空格位将数字进行区分 if (chas == \u0026#39; \u0026#39;) { if (mark \u0026lt; i) { numStack.push(Integer.valueOf(str.substring(mark, i))); //下一个数字的索引为空格后面一位，故mark = i+1; mark = i + 1; } } } } //如果还有没计算完的，就进行再次计算 while (!opStack.isEmpty()) { paramTwo = numStack.pop(); paramOne = numStack.pop(); calc(numStack, opStack, paramOne, paramTwo); } System.out.println(numStack.pop()); } private static void calc(Stack\u0026lt;Integer\u0026gt; numStack, Stack\u0026lt;String\u0026gt; operStack, int paramOne, int paramTwo) { switch (operStack.pop()) { case \u0026#34;add\u0026#34;: numStack.push(paramOne + paramTwo); break; case \u0026#34;sub\u0026#34;: numStack.push(paramOne - paramTwo); break; case \u0026#34;mul\u0026#34;: numStack.push(paramOne * paramTwo); break; case \u0026#34;div\u0026#34;: if (paramTwo == 0) System.out.println(\u0026#34;error\u0026#34;); else numStack.push(paramOne / paramTwo); break; } } 23. 贪吃蛇\r#\r描述\n贪吃蛇是一个经典游戏，蛇的身体由若干方格连接而成，身体随蛇头移动。蛇头触碰到食物时，蛇的长度会增加一格。 蛇头和身体的任一方格或者游戏版图边界碰撞时，游戏结束。 贪吃蛇游戏的模拟： 给定一个NM的数组ar，代表NM个方格组成的版图，贪吃蛇每次移动一个方格。 若ar[i][j]==\u0026#39;H\u0026#39;，表示该方可为贪吃蛇的起始位置; 若ar[i][j]==\u0026#39;F\u0026#39;，表示该方格为食物， 若ar[i][j]==\u0026#39;E\u0026#39;，表示该方格为空格。 贪吃蛇初始长度为1，初始移动方向为向左。 输入为给定一系列贪吃蛇的移动操作，返回操作后蛇的长度，如果在操作执行完之前已经游戏结束，返回游戏结束时贪吃蛇的长度。 输入描述: 第1行：为空格分隔的字母，代表贪吃蛇的移动操作。字母取值为 U、D、L、R、G， 其中UDLR分别表示贪吃蛇往上下左右转向，转向时贪吃蛇不移动，G表示贪吃蛇按 当前的方向移动一格。用例保证输入的操作正确。 第2行：为空格分隔的两个数，指定为 N和 M，为数组的行和列数。 余下 N行每行是空格分 隔的 M个字母。字母取值为 H、F和 E，H表示贪吃蛇的起始位置，F表示食物，E表示该 方格为空。 用例保证有且只有一个 H，而 F和 E会有多个。 输出描述: 输出一个数字为蛇的长度。 输入：D G G 3 3 F F F F F H E F E 输出：1 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); String[] roadArr = in.nextLine().split(\u0026#34; \u0026#34;); String[] numArr = in.nextLine().split(\u0026#34; \u0026#34;); int n = Integer.parseInt(numArr[0]); int m = Integer.parseInt(numArr[1]); String[][] arr = new String[n][m]; for (int i = 0; i \u0026lt; n; i++) { String[] tempArr = in.nextLine().split(\u0026#34; \u0026#34;); for (int j = 0; j \u0026lt; m; j++) { arr[i][j] = tempArr[j]; } } int ans = solution(roadArr, arr, n, m); System.out.println(ans); } public static int solution(String[] roadArr, String[][] arr, int n, int m) { int[] start = {0, 0}; ArrayDeque\u0026lt;String\u0026gt; body = new ArrayDeque\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { if (\u0026#34;H\u0026#34;.equals(arr[i][j])) { body.add(i + \u0026#34;-\u0026#34; + j); start[0] = i; start[1] = j; } } } String curDir = \u0026#34;L\u0026#34;; for (int i = 0; i \u0026lt; roadArr.length; i++) { String str = roadArr[i]; if (\u0026#34;U\u0026#34;.equals(str) || \u0026#34;D\u0026#34;.equals(str) || \u0026#34;L\u0026#34;.equals(str) || \u0026#34;R\u0026#34;.equals(str)) { curDir = str; } if (\u0026#34;G\u0026#34;.equals(str)) { if (\u0026#34;U\u0026#34;.equals(curDir)) start = new int[]{start[0] - 1, start[1]}; if (\u0026#34;D\u0026#34;.equals(curDir)) start = new int[]{start[0] + 1, start[1]}; if (\u0026#34;L\u0026#34;.equals(curDir)) start = new int[]{start[0], start[1] - 1}; if (\u0026#34;R\u0026#34;.equals(curDir)) start = new int[]{start[0], start[1] + 1}; if (start[0] \u0026lt; 0 || start[1] \u0026lt; 0 || start[0] \u0026gt; n - 1 || start[1] \u0026gt; m - 1 || body.contains(start[0] + \u0026#34;-\u0026#34; + start[1])) { return body.size(); } if (\u0026#34;E\u0026#34;.equals(arr[start[0]][start[1]])) { body.addFirst(start[0] + \u0026#34;-\u0026#34; + start[1]); body.removeLast(); } if (\u0026#34;F\u0026#34;.equals(arr[start[0]][start[1]])) { body.addFirst(start[0] + \u0026#34;-\u0026#34; + start[1]); } } } return body.size(); } 24. 解密犯罪时间\r#\r描述\n警察在侦破一个案件时，得到了线人给出的可能犯罪时间，形如 “HH:MM” 表示的时刻。根据约定，为了隐蔽，该时间是修改过的， 解密规则为：利用当前出现过的数字，构造下一个距离当前时间最近的时刻，则该时间为可能的犯罪时间。 每个出现的数字都可以被无限次使用。 输入描述：形如 HH:SS 的字符串，表示原始输入 输出描述：形如 HH:SS 的字符串，表示推理出来的犯罪时间 注意事项：1、可以保证线人给定的字符串一定是合法的。2、最近的时刻有可能在第二天。 输入：18:52 输出：18:55 说明：利用数字 1, 8, 5, 2 构造出来的最近时刻是 18:55，是 3 分钟之后。 输入：23:59 输出：22:22 说明：利用数字 2, 3, 5, 9 构造出来的最近时刻是 22:22 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); String input = in.nextLine(); int pos = input.indexOf(\u0026#34;:\u0026#34;); // 记录已经出现的数字 boolean[] exists = new boolean[10]; for (char c : input.toCharArray()) { if (Character.isDigit(c)) { exists[c - \u0026#39;0\u0026#39;] = true; } } // 小时，分钟，最近的时间间隔（分钟） int hour = 0, minute = 0, d = Integer.MAX_VALUE; // 原始时间 int times = Integer.parseInt(input.substring(0, pos)) * 60 + Integer.parseInt(input.substring(pos + 1)); // 枚举所有时间，找到下一个距离当前事件最近的时刻 // -- 如果时间点中有字符未出现，则不考虑该时间点，因为该时间点已经不可能是答案了 // -- 如果时间点中有字符出现: // -- -- 如果时间相同，则不考虑该时间点，因为该时间点已经不可能是答案了 // -- -- 如果时间不同，则考虑该时间点，因为该时间点可能是答案了，但是要判断当天还是下一天 for (int h = 0; h \u0026lt; 24; h++) { if (!exists[h % 10] || !exists[h / 10]) continue; for (int m = 0; m \u0026lt; 60; m++) { int curTimes = h * 60 + m; // 字符未出现或时间相同 if (!exists[m % 10] || !exists[m / 10] || curTimes == times) continue; // 计算时间间隔，找到更近的时刻 int curD = (curTimes \u0026gt; times) ? curTimes - times : 24 * 60 - (times - curTimes); if (curD \u0026lt; d) { hour = h; minute = m; d = curD; } } } // %02d 表示将整数值按照至少占据两个字符的方式输出，不足两位时会在前面补零 // %n 表示一个换行符 System.out.printf(\u0026#34;%02d:%02d%n\u0026#34;, hour, minute); } 25. 求满足条件的最长子串的长度\r#\r描述\n给定一个字符串，只包含字母和数字，按要求找出字符串中的最长（连续）子串的长度，字符串本身是其最长的子串， 如果找不到满足要求的子串，如全是字母或全是数字，则返回-1。 子串要求： 1、只包含1个字母(a~z, A~Z)，其余必须是数字； 2、字母可以在子串中的任意位置； 输入描述：字符串(只包含字母和数字) 输出描述：子串的长度 输入：abC124ACb 输出：4 说明：满足条件的最长子串是C124或者124A，长度都是4 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); char[] chars = in.nextLine().toCharArray(); // 是否字母 boolean isCap = false; int maxLen = -1; for (int i = 0; i \u0026lt; chars.length; i++) { if (Character.isLetter(chars[i])) { isCap = true; } for (int j = i + 1; j \u0026lt; chars.length; j++) { if (Character.isLetter(chars[j])) { if (isCap) { if (j - i \u0026gt; 1) { maxLen = Math.max(maxLen, j - i); } isCap = false; break; } else { isCap = true; } } else { if (isCap) { maxLen = Math.max(maxLen, j - i + 1); } } } } System.out.println(maxLen); } "},{"id":12,"href":"/interview/program-base/network/","title":"网络","section":"编程基础","content":"\r\u0026ndash; 网络模型\r#\r\u0026ndash; TCP 协议\r#\r1. Transmission Control Protocol，传输控制协议 2. 是面向连接的协议，在收发数据前，必须和对方建立可靠的连接。 3. 一个TCP连接必须有三次握手、四次挥手 \u0026ndash; TCP 三次握手\r#\r三次握手：Three-way Handshake，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包\n第一次握手：客户端发出报文（SYN），请求建立连接 第二次握手：服务器收到报文（SYN），如果同意连接，则发出确认报文（SYN+ASK） 第三次握手：客户端收到确认报文（SYN+ASK）后，再发出确认报文（ASK） 过程简述： 第一次握手：A请求建立连接 第二次握手：A发送正常，B接收正常 第三次握手：B发送正常，A接收正常 类比打电话： A：你听清楚么？ B：能听清楚，你呢？ A：也能听清楚。 \u0026ndash; TCP 四次挥手\r#\r四次挥手：Four-way handshake，即TCP 的连接的拆除需要发送四个包\n第一次挥手：客户端发出报文（FIN），请求释放连接，停止发送数据 第二次挥手：服务器收到报文（FIN），发出确认报文（ASK），停止接收数据 第三次挥手：服务器发出报文（FIN），停止发送数据 第四次挥手：客户端收到报文（FIN），发出确认报文（ASK），停止接收数据 过程简述： 第一次挥手：A请求断开连接 第二次挥手：B收到请求，同意断开连接 第三次挥手：B确认断开连接 第四次挥手：A收到确认，断开连接 类比打电话： A：我要挂电话了？ B：收到，挂吧。 B：我也没有话要说了。 A：挂断电话。 \u0026ndash; TCP、UDP\r#\rTCP UDP 连接性 面向字节流，需要建立连接 面向报文，不需建立连接 可靠性 可靠，不丢包 不可靠，会丢包 传输效率 传输效率低，速度慢 传输效率高，速度快 流量控制 滑动窗口 无 拥塞控制 慢开始、拥塞避免、快重传、快恢复 无 应用场合 对效率要求低，对准确性要求高或要求有连接的场景 对效率要求高，对准确性要求低 连接方式 只支持点到点 支持一对一、一对多、多对多 首部开销 开销20字节 开销8字节 \u0026ndash; HTTP 协议\r#\r1. Hyper Text Transfer Protocol，超文本传输协议，是一种网络通信协议 2. 用于将超文本标记语言（HTML）文档从Web服务器传送到本地浏览器 3. 基于客户端/服务端（C/S）模型，将浏览器为客户端，通过URL向服务端发送所有请求 \u0026ndash; HTTP 状态码\r#\r状态码 含义 描述 1xx 消息响应 服务器收到请求，需要请求者继续执行操作 2xx 成功响应 操作被成功接收并处理 3xx 重定向 需要进一步的操作以完成请求 4xx 客户端错误 请求包含语法错误或无法完成请求 5xx 服务器错误 服务器在处理请求的过程中发生了错误 \u0026ndash; HTTP 请求步骤\r#\r1、DNS 解析 2、HTTP 请求，当输入一个请求时，建立一个 Socket 连接发起 TCP的 3 次握手 3.1、客户端向服务器发送请求命令 3.2、客户端发送请求头信息和数据。 4.1、服务器发送应答头信息。 4.2、服务器向客户端发送数据。 5、服务器关闭 TCP 连接（4次挥手）。 6、客户端根据返回的 HTML 、 CSS 、 JS 进行渲染。 \u0026ndash; HTTP、HTTPS\r#\r1. https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 4. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 \u0026ndash; URI、URL\r#\rURI： Uniform Resource Identifier，统一资源标识符 是一种语义上的抽象概念 唯一标识了资源 URL： Uniform Resource Location，统一资源定位符 是URI的一个子集，一种具体的URI 唯一标识并定位了资源 \u0026ndash; GET、POST\r#\r数据传输方式\nGET: 数据通过URL传递，数据以 key=value 的形式拼接在URL后面。 POST: 数据通过请求体传递，可以包含大量数据，格式灵活。 数据长度限制\nGET: 受到URL长度的限制，一般为2048字符。 POST: 请求体数据长度不受限制，可以传输大量数据。 安全性\nGET: 数据明文传输，容易被截取和篡改，适合传输少量不敏感数据。 POST: 数据在请求体中传输，经多重编码安全性较高，适合传输敏感数据。 缓存\nGET: 请求可以被浏览器缓存，可以被收藏为标签 POST: 请求不能被浏览器缓存，不能被收藏为标签 \u0026ndash; Cookie、Session\r#\rCookie、Session 都是一种用于维持客户端与服务端之间会话的机制 Cookie Session 数据存放位置 客户的浏览器 服务器 安全程度 可能会被篡改 安全 性能方面 只影响客户的浏览器 占用服务器性能 存储数据量 客户的浏览器对其有限制 不影响 存储结构 键值对形式的文本 哈希表结构 \u0026ndash; Forward、Redirect\r#\r转发是服务器行为，重定向是客户端行为 请求转发 请求重定向 服务器内部跳转，所有地址栏上的路径不会改变 是浏览器再次发送请求，地址栏上的路径会发生改变 只发送一次请求 会发送两次请求 只能在当前应用内部跳转 可以在内部跳转，也可以跳出当前应用 可以共享reqeust 不能可以共享reqeust request.getRequestDispatcher().forward(); response.sendRedirect(); "},{"id":13,"href":"/interview/program-base/linux/","title":"Linux","section":"编程基础","content":"\r\u0026ndash; 目录路径\r#\r绝对路径： /etc/init.d 当前目录： ./ 上层目录： ../ 主目录： ~/ 切换目录： cd \u0026ndash; 命令：查看文件\r#\r$ vi 文件名 #编辑方式查看，可修改 $ cat 文件名 #显示全部文件内容 $ more 文件名 #分页显示文件内容 $ less 文件名 #与 more 相似，更好的是可以往前翻页 $ tail 文件名 #仅查看尾部，还可以指定行数 $ head 文件名 #仅查看头部,还可以指定行数 "},{"id":14,"href":"/interview/dev-tool/maven/","title":"Maven","section":"开发工具","content":"\r\u0026ndash; Maven\r#\r是一款纯 java 开发的、用于项目构建和管理的工具\n作用： 1. 添加第三方jar包 2. 处理jar包之间的依赖关系 3. 获取第三方jar包 4. 将项目拆分为多个工程模块 \u0026ndash; Maven 生命周期\r#\r阶段 处理 描述 validate 验证 验证项目是否正确，且所有必须信息是可用的 compile 编译 编译源代码 test 测试 使用单元测试框架运行测试 package 打包 创建jar/war包 verify 检查 对集成测试结果进行检查，以保证质量达标 install 安装 安装打包的项目到本地仓库，以供其他项目使用 deploy 部署 拷贝最终的工程包到远程仓库，以共享给其他工程 \u0026ndash; Maven 常用命令\r#\rmvn clean # 清除项目目录中的生成结果 mvn compile # 编译源代码 mvn test-compile # 编译测试源代码 mvn test # 运行应用程序中的单元测试 mvn package # 根据项目生成的jar mvn install # 在本地Repository中安装jar mvn deploy # 发布项目 # 启动tomcat服务 mvntomcat:run # 清除以前的包后重新打包，跳过测试类 mvn clean package -Dmaven.test.skip=true \u0026ndash; Maven 依赖原则\r#\r1. 最短路径原则 依赖传递的路径越短越优先 2. 声明顺序优先 路径长度一样，则先声明的优先 3. 覆写原则 当前pom文件里声明的直接覆盖父工程传过来的 \u0026ndash; Maven 依赖冲突\r#\r使用exclusion进行排除\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.3.14.RELEASE\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;commons-logging\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;commons-logging\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; "},{"id":15,"href":"/interview/framework/spring/p2/","title":"Part.2","section":"Spring","content":"\r\u0026ndash; Spring MVC\r#\r一种基于 Java 的、实现了 MVC 设计模式的、请求驱动类型的轻量级 Web 框架。 \u0026ndash; MVC 设计模式\r#\rModel、View、Controller\n是一种软件设计典范，通过分离业务逻辑、数据、界面显示的方式来组织代码。\n使程序分层、分工合作，既相互独立，又协同合作。\nModel 模型 负责数据封装及业务逻辑处理 View 视图 负责渲染模型数据，进行可视化展示 Controller 控制器 负责居中调度。将接收的用户请求，指派给模型进行处理，并将结果传递给视图进行展示 \u0026ndash; Spring MVC 工作流程\r#\r1. 发起请求到前端控制器。 2. 前端控制器请求 HandlerMapping 查找 Handler。 3. HandlerMapping 向前端控制器返回 Handler 执行链。 4. 前端控制器调用 HandlerAdapter 去执行 Handler。 5. HandlerAdapter 执行 Handler。 6. Handler 执行完成后，向 HandlerAdapter 返回 ModelAndView。 7. HandlerAdapter 将 ModelAndView返回给前端控制器。 8. 前端控制器将 ModelAndView 传给 ViewReslover。 9. ViewReslover 解析后，向前端控制器返回具体 View。 10. 前端控制器根据 View 进行渲染视图。 11. 前端控制器响应用户。 \u0026ndash; Spring MVC 常用注解\r#\r@RequestMapping： 用于处理请求url映射的注解，可用于类或方法上。 用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。 @RequestBody： 注解实现接收http请求的json数据，将json转换为java对象。 @ResponseBody： 注解实现将conreoller方法返回对象转化为json对象响应给客户。 "},{"id":16,"href":"/interview/program-lang/java-base/p2/","title":"Part.2","section":"Java基础","content":"\r\u0026ndash; equals、==\r#\r==\n是一个运算符，用于比较两个对象的引用是否指向同一个内存地址 对于基本数据类型，比较的是值 对于引用数据类型，比较的是内存地址 equals\n是一个定义在 Object 类中的方法，用于比较两个对象的内容是否相等 默认情况下，equals 与 == 等同，但许多类会重写 equals 方法 \u0026ndash; final\r#\r修饰符，可以修饰类、变量、方法\n1. 被final修饰的类不可以被继承 2. 被final修饰的方法不可以被重写 3. 被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的 4. 被final修饰的常量，在编译阶段会存入常量池中 \u0026ndash; final、finally、finalize\r#\rfinal\n修饰符，可以修饰类、变量、方法 finally\n用于跟在try-catch代码块后， 表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。 finalize\n是java.lang.Object类中的一个方法 该方法一般由垃圾回收器来调用，当调用System.gc()方法时，由垃圾回收器调用finalize() \u0026ndash; String\r#\r字符串常量\n由final修饰，一经创建，便不能再改变 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象 字符串 + 拼接，JVM会进行优化\nString str = \u0026#34;abc\u0026#34; + \u0026#34;def\u0026#34;; // 优化成 String str = \u0026#34;abcdef\u0026#34;; String str1 = \u0026#34;abc\u0026#34;; String str2 = str1 + \u0026#34;abc\u0026#34;; // 优化成 String str2 = (new StringBuilder()).append(str1).append(\u0026#34;def\u0026#34;).toString(); \u0026ndash; String、StringBuffer、StringBuilder\r#\rString可以赋null值，后者两者不行 String StringBuffer StringBuilder 不可变字符串 可变字符串 可变字符串 线程安全 线程不安全 效率低 效率高 \u0026ndash; Vector、ArrayList、LinkedList\r#\r相同点\n1. 实现List接口 2. 有序性 3. 可包含重复元素 4. 可动态调整大小 ArrayList\n底层基于动态数组实现，非线程安全 随机访问和遍历方面，效率相对较高 插入和删除元素时，涉及到数组元素的移动，效率相对较低 LinkedList\n底层基于双向链表实现，非线程安全 随机访问元素时，需要遍历链表，效率相对较低 插入和删除元素时，只需要改变相邻节点的引用，效率相对较高 Vector\n底层基于动态数组实现，线程安全 底层与ArrayList类似，但由于线程同步的开销，性能通常不如ArrayList "},{"id":17,"href":"/interview/program-lang/java-jvm/p2/","title":"Part.2","section":"Java虚拟机","content":"\r\u0026ndash; JVM 调优工具\r#\rjconsole\nJDK中自带的java监控和管理控制台 用于对JVM中内存，线程和类等的监控 jvisualvm\njdk自带全能工具 可以分析内存快照、线程快照；监控内存变化、GC变化等 MAT\nMemory Analyzer Tool 一个基于Eclipse的内存分析工具 可以帮助查找内存泄漏和减少内存消耗 GChisto\n一款专业分析gc日志的工具 \u0026ndash; JVM 调优参数\r#\r示例 说明 -XX:-PrintGCDetails 关闭：打印GC收集细节 -XX:+PrintGCDetails 开启：打印GC收集细节 -XX:MetaspaceSize=128m 设置元空间的内存大小，默认21m 备注： 布尔类型：-XX:+或-某个属性（+ 表示开启，- 表示关闭） 键值类型：-XX:属性键=属性值 \u0026ndash; JVM 调优参数：堆栈内存\r#\r参数 说明 等价于 -Xms 设置堆的初始内存大小，默认是物理内存的1/64 -XX:InitialHeapSize -Xmx 设置堆的最大内存大小，默认是物理内存的1/4 -XX:MaxHeapSize -Xmn 设置新生代的内存大小，一般使用默认值 -XX:NewSize、-XX:MaxnewSize -Xss 设置单个线程栈的内存大小，一般默认512K ~ 1024K -XX:ThreadStackSize 参数 说明 -XX:MetaspaceSize 设置元空间的内存大小，默认21m -XX:NewRatio 设置新生代与老年代的比值 -XX:SurvivorRatio 设置新生代中Eden区与两个Survivor区的比值 -XX:MaxTenuringThreshold 设置新生代中对象最大存活次数 -XX:PretenureSizeThreshold 当创建的对象超过指定大小时，直接把对象分配在老年代 \u0026ndash; JVM 调优参数：垃圾收集器\r#\r参数 说明 XX:+UseSerialGC 使用 Serial 收集器 -XX:+UseParNewGC 使用 ParNew 收集器 -XX:+UseParallelGC 使用 Parallel Scavenge 收集器 -XX:+UseParallelOldGC 使用 Parallel Old 收集器 -XX:+UseConcMarkSweepGC 使用 CMS 收集器 . -XX:ParallelGCThreads 配置并行收集器的线程数 \u0026ndash; JVM 调优参数：辅助信息\r#\r参数 说明 -XX:+PrintFlagsInitial 打印全部初始默认参数 -XX:+PrintFlagsFinal 打印全部最终参数 -XX:+PrintCommandLineFlags 打印特定参数 -XX:+PrintGCDetails 打印GC详细信息 -XX:+PrintTLAB 打印TLAB空间的使用情况 -XX:+DisableExplicitGC 禁止系统System.gc() -XX:+HeapDumpOnOutOfMemoryError 在内存溢出的时候，自动生成内存快照 "},{"id":18,"href":"/interview/program-lang/java-thread/p2/","title":"Part.2","section":"Java多线程","content":"\r\u0026ndash; volatile\r#\rvolatile\n1. 是java提供的一种轻量级同步机制 2. 用于修饰变量，保证所修饰变量的可见性，不保证原子性 3. 会禁止指令重排优化 底层原理\n1. 当对volatile变量进行写操作的时候，JVM会增加Lock前缀指令 2. 基于缓存一致性协议，cpu会检查缓存是否过期，如果过期，则重新读取系统内存数据 2. 缓存一致性：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期 \u0026ndash; synchronized\r#\rsynchronized\n1. 是Java提供的一种基于内置锁的同步机制 2. 保证原子性、可见性、有序性 底层原理\n完全依赖于JVM虚拟机进行实现，基于Java对象头、Monitor监视器 当线程进入同步代码块时，如果此同步对象没有被锁定， JVM会在当前线程的栈中创建Lock Record空间，用于存储锁对象的Mark Word的拷贝。 每一个被锁住的对象Mark Word都会和一个Lock Record关联， Lock Record 锁记录\n1. Lock Record，是线程私有的数据结构 2. Lock Record中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用 Monitor监视器\n1. Monitor，可以理解为一种同步机制、一个对象。任何一个对象都有一个Monitor与之关联。 2. Monitor只能被一个线程持有，此时当前对象就处于锁定状态，其它线程只能阻塞等待。 3. 在JVM中，Synchronized是基于进入和退出Monitor对象，来实现方法同步和代码块同步。 java对象头\n\u0026ndash; synchronized 同步优化\r#\r为优化synchronized性能，在JDK1.6后增加了自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁等策略\n锁膨胀：方向不可逆\n1. 无锁 ——\u0026gt; 偏向锁： 当持有锁的线程再次请求该锁时，无需再做任何同步操作，即获取锁 2. 偏向锁 ——\u0026gt; 轻量级锁： 当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁 3. 轻量级锁——\u0026gt; 重量级锁： 当同一时间有多个线程竞争锁时，锁就会被升级成重量级锁，此时其申请锁带来的开销也就变大 其他策略\n锁消除 当检测到不可能存在共享数据的竞争时，JVM会对这些同步锁进行消除 锁粗化 将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁 自旋锁 是一种锁机制，尝试获取锁的线程不会立即阻塞，而是采用循环的方式去多次尝试 自适应自旋锁 自旋的次数不是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定 \u0026ndash; synchronized、ReentrantLock\r#\r相同点\n1. 都是用来协调多线程共享对象、变量的访问。 2. 都是可重入锁，同一线程可以多次获得同一个锁。 3. 都保证了可见性和互斥性。 不同点\n不同点 synchronized ReentrantLock 实现级别 是一个关键字，属于 JVM 级别 是一个接口，属于 API 级别 底层实现 是同步阻塞，使用悲观并发策略 同步非阻塞，使用乐观并发策略 锁 隐式的获得/释放锁，会自动释放锁 显式的获得/释放锁，须手动释放锁 ReentrantLock 高级功能\n1. 可实现公平锁 2. 可锁绑定多个条件 3. 等待可中断：当锁长时间不释放的时候，可以选择放弃等待 \u0026ndash; wait()、sleep()\r#\rwait() sleep() 所属类 java.lang.Object java.lang.Thread 对象锁 释放 不释放 使用位置 只能在同步块中使用 任意地方 捕获异常 不需要 需要 \u0026ndash; wait()、notify()、notifyAll()\r#\rwait()\n1. 使当前线程等待，把当前线程放入等待池中 2. 释放当前的锁 3. 满足一定条件时被唤醒, 重新尝试获取这个锁 4. 须在 synchronized 同步块中调用 notify()\n1. 唤醒在此对象监视器上等待的其中一个线程（由虚拟机控制） 2. 调用对象的 notify() 方法后，要等到执行 notify() 方法的线程将程序执行完，当前线程才会释放锁 3. 须在同步方法、同步块中调用 notifyAll()\n1. 唤醒在此对象监视器上等待的所有线程 2. 由这些线程重新竞争锁，竞争成功者则继续执行 \u0026ndash; interrupt()、interrupted()、isInterrupted()\r#\r1. 都是 java.lang.Thread 类中的方法 2. interrupt(): 是实例方法，中断线程，设置中断标识为true 3. interrupted(): 是静态方法，判断线程是否被中断，并清除中断状态 4. isInterrupted(): 是实例方法，获取线程的中断状态 \u0026ndash; ThreadLocal\r#\r线程本地变量\n1. ThreadLocal会为每个访问线程都创建一个本地副本 2. 各个线程实际上是操作独属于本线程的变量，从而起到线程隔离的作用，避免了线程安全问题 实现原理\n1. Thread类中，有个ThreadLocal.ThreadLocalMap 的成员变量 2. ThreadLocalMap的key是ThreadLocal实例本身，value则存储泛型对象值 3. 每个线程都是操作自己的成员变量，从而互相不影响 \u0026ndash; CountDownLatch\r#\rCountDownLatch\n倒计时器： 一个或多个线程一直等待，直到其他线程完成某件事情之后再执行 实现原理\n1. 通过一个计数器进行实现。计数器初始值为线程的数量。 2. 每当一个线程执行完毕后，计数器的值就减1。 3. 当计数器的值为0时，表示所有线程都执行完毕，然后在CountDownLatch上等待的线程就可以恢复执行了 \u0026ndash; CyclicBarrier\r#\rCyclicBarrier\n循环栅栏： 多个线程互相等待，直到全部都到达同一个同步点，再继续一起执行 实现原理\n1. 在CyclicBarrier类的内部有一个计数器 2. 每个线程在到达屏障点的时候都会调用await()将自己阻塞，此时计数器会减1 3. 当计数器减为0的时候，所有因调用await()而被阻塞的线程将被唤醒 \u0026ndash; Semaphore\r#\rSemaphore\n信号灯： 作为一种流量控制手段，用于控制同时访问特定资源的线程数量，保证合理的使用共享资源 实现原理\n1. Semaphore管理一系列许可（仅维护许可的计数）。 2. 线程通过acquire()获取许可。当没有可用的许可的时候，线程阻塞，直到有可用的许可为止。 3. 线程通过release()释放许可。 \u0026ndash; Exchanger\r#\rExchanger\n交换器： 是一个用于线程间协作的工具类，用于两个线程间交换数据。 实现原理\n1. Exchanger提供了一个交换的同步点，在这个同步点两个线程能够交换数据。 2. 如果一个线程先执行exchange()，那它会阻塞等待另一个线程也执行exchange()。 3. 当两个线程就都达到了同步点，它们就可以交换数据。 "},{"id":19,"href":"/interview/service-manage/spring-cloud/","title":"SpringCloud","section":"服务治理","content":"\r\u0026ndash; SpringCloud\r#\r分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的有序集合 \u0026ndash; SpringBoot、SpringCloud\r#\rSpringBoot： 专注于快速方便的开发单个个体微服务 SpringCloud： 关注全局的微服务协调治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来 SpringBoot可以离开SpringCloud独立使用开发项目，但是SpringCloud离不开SpringBoot，属于依赖的关系 \u0026ndash; 雪崩效应\r#\r1. 分布式系统环境下，各服务之前有依赖关系\r2. 由于各种原因，服务不能保证100%可用\r3. 如果单个服务不可用，会导致依赖于它的服务不可用，如此循环导致更多的服务不可用\r4. 这种将不可用逐渐放大导致系统崩溃的现象，即雪崩效应 \u0026ndash; 服务降级、服务熔断\r#\r服务降级： 是一种在服务不可用或响应过慢的情况下，通过执行预设的降级逻辑来保障核心功能和服务可用性的措施 服务熔断： 是一种保护系统的措施，当系统某个服务的异常调用达到预设的阈值时， 熔断器会主动阻止对该服务的调用，立即返回错误信息或执行降级处理，从而避免系统整体崩溃 "},{"id":20,"href":"/interview/program-design/structure-algorithm/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/","title":"双指针","section":"leetcode","content":"\r双指针\r#\r双指针\r#\r前提：数据具有规则性 由于数据的有序性（大小或正负），可以证明当前节点优于过往节点 从而可以通过数据的维度数量的指针，逐步的迭代收敛，最终找到最优解 移动零\r#\r原题\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0] 题解\n1、左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。 2、右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。 注意到以下性质： 左指针左边均为非零数； 右指针左边直到左指针处均为零。 public class Main { public void moveZeroes(int[] nums) { int n = nums.length, left = 0, right = 0; while (right \u0026lt; n) { if (nums[right] != 0) { swap(nums, left, right); left++; } right++; } } public void swap(int[] nums, int left, int right) { int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; } } 盛最多水的容器\r#\r原题\n给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 输入：[1,8,6,2,5,4,8,3,7] 输出：49 题解\n1、用左右指针位置表示容器的边界 2、由于容量由短边决定，移动短边的指针 public class Main { public int maxArea(int[] height) { int l = 0; int r = height.length - 1; int ans = 0; while (l \u0026lt; r) { int area = Math.min(height[l], height[r]) * (r - l); ans = Math.max(ans, area); if (height[l] \u0026lt;= height[r]) { ++l; } else { --r; } } return ans; } } 三数之和\r#\r原题\n给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 题解\n1、先排序，使用双指针 2、根据条件，移动左右指针 public class Main { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { Arrays.sort(nums); int n = nums.length; List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { // 处理重复 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } int right = n - 1; int target = -nums[i]; for (int left = i + 1; left \u0026lt; right; left++) { // 处理重复 if (left != i + 1 \u0026amp;\u0026amp; nums[left] == nums[left - 1]) { continue; } while (nums[left] + nums[right] \u0026gt; target \u0026amp;\u0026amp; right \u0026gt; left) { right--; } if (left == right) { break; } if (nums[left] + nums[right] == target) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(nums[i]); list.add(nums[left]); list.add(nums[right]); ans.add(list); } } } return ans; } } "},{"id":21,"href":"/interview/program-design/structure-algorithm/huawei-od/%E5%BF%85%E4%BC%9A%E9%A2%982/","title":"必会题 - 2","section":"华为OD","content":"\r01. 机器人走迷宫\r#\r描述\n1、房间有X*Y的方格组成，例如下图为6*4的大小。每一个放个以坐标(x,y)描述。 2、机器人固定从方格(0,0)出发，只能向东或者向北前进，出口固定为房间的最东北角，用例保证机器人可以从入口走到出口。 3、房间有些方格是墙壁，如(4,1),机器人不能经过那儿。 4、有些地方是一旦到达就无法走到出口的，如标记为B的方格，称之为陷阱方格。 5、有些地方是机器人无法达到的，如标记为A的方格，称之为不可达方格，不可达方格不包括墙壁所在的位置 6、如下实例图中，陷阱方格有2个，不可达方格有3个。 请为该机器人实现路径规划功能：给定房间大小，墙壁位置，请计算出陷阱方格与不可达方格分别有多少个 输入描述： 1、第一行为房间的x和y(0 ＜ x,y ≤ 1000) 2、第二行为房间中墙壁的个数N (0 ≤ N ＜ X*Y) 3、接着下面会有N行墙壁的坐标 同一行中如果有多个数据以一个空格隔开，用例保证所有的输入数据均合法，(结尾不带回车换行) 输出描述： 陷阱方格与不可达方格数量，两个信息在一行中输出，以一个空格隔开。(结尾不带回车换行) 输入：6 4 5 0 2 1 2 2 2 4 1 5 1 输出：2 3 题解\npublic static void main(String[] args) { // 0 是未踩过的。 1是墙。 2是踩过的。 Scanner in = new Scanner(System.in); String[] xyArr = in.nextLine().split(\u0026#34; \u0026#34;); int x = Integer.parseInt(xyArr[0]); int y = Integer.parseInt(xyArr[1]); int wallNum = Integer.parseInt(in.nextLine()); int[][] room = new int[x][y]; for (int i = 0; i \u0026lt; wallNum; i++) { String[] tempArr = in.nextLine().split(\u0026#34; \u0026#34;); int wallX = Integer.parseInt(tempArr[0]); int wallY = Integer.parseInt(tempArr[1]); room[wallX][wallY] = 1; } path(room, 0, 0, x - 1, y - 1); int badPath = 0; //陷阱 int noWay = 0; // 不可达 for (int i = 0; i \u0026lt; x; i++) { for (int j = 0; j \u0026lt; y; j++) { if (room[i][j] == 9) { badPath += 1; } else if (room[i][j] == 0) { noWay += 1; } } } System.out.println(badPath + \u0026#34; \u0026#34; + noWay); } // 不可达方格 : 机器人无法通过增加X Y值到的方格。走完还是0的方格 // 陷阱方格 : 走到该位置不能正确走到终点的方格。 向前/向上不可达、同为陷阱方格则也标记为 9 // 标记：0未踩过、 1墙、2已踩过、9陷阱 private static void path(int[][] room, int nextX, int nextY, int wallX, int wallY) { // 跳过：墙、已踩过 if (room[nextX][nextY] == 1 || room[nextX][nextY] == 2) { return; } // 已到出口 if (nextX == wallX \u0026amp;\u0026amp; nextY == wallY) { room[nextX][nextY] = 2; return; } // 递归走完所有能走的方格 if (nextX \u0026lt; wallX) { path(room, nextX + 1, nextY, wallX, wallY); } if (nextY \u0026lt; wallY) { path(room, nextX, nextY + 1, wallX, wallY); } // 标记：0未踩过、 1墙、2已踩过、9陷阱 if (nextX == wallX || nextY == wallY) { // 已走到x边，且向y一格不可达 if (nextX == wallX \u0026amp;\u0026amp; nextY \u0026lt; wallY \u0026amp;\u0026amp; room[nextX][nextY + 1] != 2) { room[nextX][nextY] = 9; return; } // 已走到y边，且向x一格不可达 if (nextY == wallY \u0026amp;\u0026amp; nextX \u0026lt; wallX \u0026amp;\u0026amp; room[nextX + 1][nextY] != 2) { room[nextX][nextY] = 9; return; } // 当前方格已踩过 room[nextX][nextY] = 2; return; } // 未到达xy边界，且向x向y一格都不可达 if (room[nextX + 1][nextY] != 2 \u0026amp;\u0026amp; room[nextX][nextY + 1] != 2) { room[nextX][nextY] = 9; } else { room[nextX][nextY] = 2; } } 02. 高效的任务规划\r#\r描述\n你有 n 台机器编号为 1~n，每台都需要完成完成一项工作，机器经过配置后都能完成独立完成一项工作。 假设第 i 台机器你需要花 B 分钟进行设置，然后开始运行，J 分钟后完成任务。 现在，你需要选择布置工作的顺序，使得用最短的时间完成所有工作。 注意，不能同时对两台进行配置，但配置完成的机器们可以同时执行他们各自的工作。 输入描述： 第一行输入代表总共有 M 组任务数据（1＜M≤10）。 每组数第一行为一个整数指定机器的数量 N（0＜N≤1000）。 随后的 N 行每行两个整数，第一个表示 B（0≤B≤10000），第二个表示 J（0≤J≤10000）。 每组数据连续输入，不会用空行分隔。各组任务单独计时。 输出描述： 对于每组任务，输出最短完成时间，且每组的结果独占一行。例如，两组任务就应该有两行输出。 输入：2 2 1 1 2 2 3 1 1 2 2 3 3 输出：4 7 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); int m = in.nextInt(); for (int i = 0; i \u0026lt; m; i++) { int n = in.nextInt(); int[][] jobs = new int[n][2]; for (int j = 0; j \u0026lt; n; j++) { jobs[j][0] = in.nextInt(); jobs[j][1] = in.nextInt(); } solution(jobs); } } // 因为是顺序配置，所以配置的总时长是固定的 // 因此只要让耗时长的先执行，即可保证最高效 private static void solution(int[][] jobs) { Arrays.sort(jobs, (job1, job2) -\u0026gt; job2[1] - job1[1]); int time = 0; int remaining = 0; for (int[] job : jobs) { // 添加配置时间 time += job[0]; remaining -= job[0]; if (remaining \u0026lt;= 0) { remaining = job[1]; } else { remaining = remaining - job[0] + job[1]; } } time += remaining; System.out.println(time); } 03. 二叉树遍历\r#\r描述\n根据给定的二叉树结构描述字符串，输出该二叉树按照中序遍历结果字符串。中序遍历顺序为:左子树，根结点，右子树。 输入描述：由大小写字母、左右大括号、逗号组成的字符串: 1、字母代表一个节点值，左右括号内包含该节点的子节点。 2、左右子节点使用逗号分隔，逗号前为空则表示左子节点为空,没有逗号则表示右子节点为空。 3、二叉树节点数最大不超过100。 注：输入字符串格式是正确的，无需考虑格式错误的情况。 输出描述 输出一个字符串，为二叉树中序遍历各节点值的拼接结果。 示例： 输入：a{b{d,e{g,h{,I}}},c{f}} 输出：dbgehIafc 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); char[] chars = in.nextLine().toCharArray(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode root = new TreeNode(chars[0]); stack.push(root); for (int i = 1; i \u0026lt; chars.length; i++) { if (chars[i] == \u0026#39;{\u0026#39;) { if (chars[i + 1] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; chars[i + 1] \u0026lt;= \u0026#39;z\u0026#39;) { TreeNode node = new TreeNode(chars[i + 1]); stack.peek().left = node; stack.push(node); } if (chars[i + 2] == \u0026#39;,\u0026#39;) { stack.pop(); } continue; } if (chars[i] == \u0026#39;,\u0026#39;) { TreeNode node = new TreeNode(chars[i + 1]); stack.peek().right = node; stack.push(node); if (chars[i + 2] == \u0026#39;}\u0026#39;) { stack.pop(); } continue; } if (chars[i] == \u0026#39;}\u0026#39;) { stack.pop(); } } StringBuilder sb = new StringBuilder(); show(sb, root); System.out.println(sb); } private static void show(StringBuilder sb, TreeNode node) { if (node == null) { return; } show(sb, node.left); sb.append(node.value); show(sb, node.right); } static class TreeNode { public TreeNode(char value) { this.value = value; } public char value; public TreeNode left; public TreeNode right; } 04. 书籍叠放\r#\r描述\n书籍的长宽都是整数对(l,w) 如果书A的长度宽度都比B长宽大，则允许将B排列放在A上面。 现在有一组规格的书籍，书籍叠放时要求书籍不能做旋转，请计算最多能有多少个规格书籍能叠放在一起。 输入描述：书本长宽对的数组 输出描述：最多可堆叠摆放的规则数量 输入：[[20,16],[15,11],[10,10],[9,10]] 输出：3 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); String input = in.nextLine(); String[] strings = input.replaceAll(\u0026#34;\\\\[\u0026#34;, \u0026#34;\u0026#34;) .replaceAll(\u0026#34;]\u0026#34;, \u0026#34;\u0026#34;).split(\u0026#34;,\u0026#34;); int num = strings.length / 2; int[][] books = new int[num][2]; int j = 0; for (int i = 0; i \u0026lt; num; i++) { books[i][0] = Integer.parseInt(strings[j]); j++; books[i][1] = Integer.parseInt(strings[j]); j++; } // 降序排序 Arrays.sort(books, ((o1, o2) -\u0026gt; { if (o1[0] != o2[0]) { return o2[0] - o1[0]; } return o2[1] - o1[1]; })); // 获取当前长宽最大的书籍作为基 int[] preArr = books[0]; int count = 1; for (int i = 1; i \u0026lt; books.length; i++) { int[] curArr = books[i]; if (preArr[0] \u0026gt; curArr[0] \u0026amp;\u0026amp; preArr[1] \u0026gt; curArr[1]) { count++; preArr = curArr; } } System.out.println(count); } 05. 区间交集\r#\r描述\n给定一组闭区间，其中部分区间存在交集。 任意两个给定区间的交集，称为公共区间(如:[1,2],[2,3]的公共区间为[2,2]，[3,5],[3,6]的公共区间为[3,5])。 公共区间之间若存在交集，则需要合并(如:[1,3],[3,5]区间存在交集[3,3]，需合并为[1,5])。 输入描述：一组区间列表，区间数为 N: 0≤N≤1000；区间元素为 X: -10000≤X≤10000。 输出描述：按升序输出合并后的区间列表。 备注说明：1、区间元素均为数字，不考虑字母、符号等异常输入。2、单个区间认定为无公共区间。 输入：0 3 1 3 3 5 3 6 输出：1 5 说明： [0,3]和[1,3]的公共区间为[1,3]，[0,3]和[3,5]的公共区间为[3,3]，[0,3]和[3,6]的公共区间为[3,3]， [1,3]和[3,5]的公共区间为[3,3]，[1,3]和[3,6]的公共区间为[3,3]， [3,5]和[3,6]的公共区间为[3,5]， 公共区间列表为[[1,3],[3,3],[3,5]]，存在交集，须合并为[1,5] 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); List\u0026lt;int[]\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); while (in.hasNextLine()) { String input = in.nextLine(); if (input.isBlank()) { break; } String[] strings = input.split(\u0026#34; \u0026#34;); int[] arr = new int[2]; arr[0] = Integer.parseInt(strings[0]); arr[1] = Integer.parseInt(strings[1]); list.add(arr); } List\u0026lt;int[]\u0026gt; regions = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; list.size(); i++) { for (int j = i + 1; j \u0026lt; list.size(); j++) { int[] arr = intersection(list.get(i), list.get(j)); if (arr != null) { regions.add(arr); } } } regions.sort(Comparator.comparingInt(r -\u0026gt; r[0])); int left = regions.get(0)[0]; int right = regions.get(0)[1]; List\u0026lt;int[]\u0026gt; resList = new ArrayList\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt; regions.size(); i++) { int[] tempArr = regions.get(i); if (right \u0026lt; tempArr[0]) { resList.add(new int[]{left, right}); left = tempArr[0]; right = tempArr[1]; } else if (right \u0026lt;= tempArr[1]) { right = tempArr[1]; } } resList.add(new int[]{left, right}); for (int[] ints : resList) { System.out.println(ints[0] + \u0026#34; \u0026#34; + ints[1]); } } private static int[] intersection(int[] r1, int[] r2) { if (r1[1] \u0026lt; r2[0] || r2[1] \u0026lt; r1[0]) { return null; } int[] arr = new int[2]; arr[0] = Math.max(r1[0], r2[0]); arr[1] = Math.min(r1[1], r2[1]); return arr; } 06. 分月饼\r#\r描述\n中秋节，公司要给员工分月饼。公司有m个员工，买了n个月饼，且m≤n。每个员工至少分到 1 个月饼，但可以分多个。 要求： 单人分到最多的月饼个数为Max1，单人分到第二多的月饼个数为Max2，需要满足Max1−Max2≤3。 单人分到倒数第二多的月饼个数为Max(n−1)，单人分到最少的月饼个数为Max(n)，需要满足Max(n−1)−Max(n)≤3。 问有多少种分月饼的方法？ 输入描述：第一行输入两个整数m和n，表示m个员工和n个月饼，m≤n。 输出描述：输出有多少种分月饼的方法。 输入：3 12 输出：6 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); String[] input = in.nextLine().split(\u0026#34; \u0026#34;); int m = Integer.parseInt(input[0]); int n = Integer.parseInt(input[1]); System.out.println(countWays(m, n)); } // 动态规划 // 定义状态 dp[i][j][k] 表示前 i 个人分配了 j 个月饼，且第 i 个人分配了 k 个月饼的方案数。 // 状态方程为 dp[i][j]=∑k=1\u0026gt;\u0026gt;3 dp[i−1][j−k] public static int countWays(int m, int n) { int[][][] dp = new int[m + 1][n + 1][n + 1]; // 初始化 for (int k = 1; k \u0026lt;= n; k++) { // 只有1个员工时，只有一种分法 dp[1][k][k] = 1; } // 动态规划 for (int i = 1; i \u0026lt;= m; i++) { // 确保月饼数量不少于员工数 for (int j = i; j \u0026lt;= n; j++) { // 每个员工至少分得1个月饼 for (int k = 1; k \u0026lt;= j; k++) { //确保当前分配不超过上一个员工的分配 for (int l = Math.max(1, k - 3); l \u0026lt;= k; l++) { dp[i][j][k] += dp[i - 1][j - k][l]; } } } } // 汇总结果 int count = 0; for (int k = 0; k \u0026lt;= n; k++) { System.out.println(\u0026#34;m=\u0026#34; + m + \u0026#34;, n=\u0026#34; + n + \u0026#34;, k=\u0026#34; + k + \u0026#34;, dp[m][n][k]=\u0026#34; + dp[m][n][k]); count += dp[m][n][k]; } return count; } 07. 找最小数\r#\r描述\n给一个正整数NUM1，计算出新正整数NUM2，NUM2为NUM1中移除N位数字后的结果，需要使得NUM2的值最小。 输入描述： 1.输入的第一行为一个字符串，字符串由0-9字符组成，记录正整数NUM1，NUM1长度小于32。 2.输入的第二行为需要移除的数字的个数，小于NUM1长度。 输出描述： 输出一个数字字符串，记录最小值NUM2。 输入：2615371 4 输出：131 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); char[] chars = in.nextLine().toCharArray(); int n = in.nextInt(); Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (char ch : chars) { while (!stack.empty() \u0026amp;\u0026amp; stack.peek() \u0026gt; ch \u0026amp;\u0026amp; n \u0026gt; 0) { stack.pop(); n--; } if (stack.empty() \u0026amp;\u0026amp; ch == \u0026#39;0\u0026#39;) { //跳过前置0 continue; } stack.push(ch); } StringBuilder sb = new StringBuilder(); while (!stack.empty()) { if (n \u0026gt; 0) { //当还要再移除数字的时候：从此时单调递增栈的top部删去数字 n--; } else if (n == 0) { //当不用再移除数字的时候：把字符串取出来到result sb.append(stack.peek()); } stack.pop(); } sb.reverse(); String res = sb.isEmpty() ? \u0026#34;0\u0026#34; : sb.toString(); System.out.println(res); } 08. 简易内存池\r#\r描述\n请实现一个简易内存池Q，根据请求命令完成内存分配和释放。 内存池支持两种操作命令，REQUEST和RELEASE， REQUEST=请求的内存大小 表示请求分配指定大小内存，如果分配成功，返回分配到的内存首地址；如果内存不足，或指定的大小为0,则输出error. RELEASE=释放的内存首地址， 表示释放掉之前分配的内存，释放成功无需输出，如果释放不存在的首地址则输出error。 注意： 1.内存池总大小为100字节。 2.内存池地址分配必须是连续内存，并优先从低地址分配。 3.内存释放后可被再次分配，已释放的内存在空闲时不能被二次释放 4.不会释放已申请的内存块的中间地址， 5.释放操作只是针对首地址所对应的单个内存块进行操作，不会影响其它内存块。 输入描述： 首行为整数N，表示操作命令的个数，取值范围：N≤100. 接下来的N行，每行将给出一个操作命令，操作命令和参数之间用等号分割。 输出描述： 根据操作命令返回输出 输入：5 REQUEST=10 REQUEST=20 RELEASE=0 REQUEST=15 RELEASE=10 输出：0 10 10 题解\n// 0 表示未分配 1表示已经分配 public static final int[] RAM_ARR = new int[100]; // 存放分配过的内存的首地址及长度 static final HashMap\u0026lt;Integer, Integer\u0026gt; MAP = new HashMap\u0026lt;\u0026gt;(); public static void main(String[] args) { Scanner in = new Scanner(System.in); int num = in.nextInt(); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; num; i++) { String[] strings = in.nextLine().split(\u0026#34;=\u0026#34;); int answer = answer(strings[0], Integer.parseInt(strings[1])); if (answer != -2) { list.add(answer == -1 ? \u0026#34;error\u0026#34; : answer + \u0026#34;\u0026#34;); } } list.forEach(System.out::println); } public static int answer(String str, int num) { if (str.equals(\u0026#34;REQUEST\u0026#34;)) { if (num == 0) { return -1; } int len = 0; for (int i = 0; i \u0026lt; RAM_ARR.length; i++) { if (RAM_ARR[i] != 0) { continue; } for (int j = i; j \u0026lt; RAM_ARR.length; j++) { if (RAM_ARR[j] == 0) { len++; } else { i = len - 1; len = 0; break; } if (len == num) { for (int k = i; k \u0026lt; i + num; k++) { RAM_ARR[k] = 1; } MAP.put(i, num); return i; } } } return -1; } if (str.equals(\u0026#34;RELEASE\u0026#34;)) { if (MAP.containsKey(num)) { Integer len = MAP.get(num); MAP.remove(num); for (int i = num; i \u0026lt; len + num; i++) { RAM_ARR[i] = 0; } return -2; } else { return -1; } } return -1; } 09. 服务失效判断\r#\r描述\n某系统中有众多服务，每个服务用字符串（只包含字母和数字，长度≤10）唯一标识， 服务间可能有依赖关系，如A依赖B，则当B故障时导致A也故障。 依赖具有传递性，如A依赖B，B依赖C，当C故障时导致B故障，也导致A故障。 给出所有依赖关系，以及当前已知故障服务，要求输出所有正常服务。 依赖关系：服务1-服务2 表示“服务1”依赖“服务2” 不必考虑输入异常，用例保证：依赖关系列表、故障列表非空，且依赖关系数，故障服务数都不会超过3000，服务标识格式正常。 输入描述： 第1行是依赖关系列表，用逗号分隔 第2行是故障服务列表，用逗号分隔 输出描述： 依赖关系列表中提到的所有服务中可以正常工作的服务列表，用逗号分隔， 按依赖关系列表中出现的顺序排序，如果没有正常节点，则输出一个逗号 输入： a1-a2,a5-a6,a2-a3 a5,a2 输出：a6,a3 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); // 服务器的状态 Map\u0026lt;String, Boolean\u0026gt; resMap = new LinkedHashMap\u0026lt;\u0026gt;(); // 依赖关系 Map\u0026lt;String, String\u0026gt; tempMap = new HashMap\u0026lt;\u0026gt;(); String[] strings = in.nextLine().split(\u0026#34;,\u0026#34;); for (int i = 0; i \u0026lt; strings.length; i++) { String[] arr = strings[i].split(\u0026#34;-\u0026#34;); resMap.put(arr[0], true); resMap.put(arr[1], true); tempMap.put(arr[0], arr[1]); } String[] arr = in.nextLine().split(\u0026#34;,\u0026#34;); for (String str : arr) { resMap.put(str, false); } boolean flag = true; while (flag) { int sum = 0; for (String s1 : tempMap.keySet()) { String s2 = tempMap.get(s1); if (!resMap.get(s2) \u0026amp;\u0026amp; resMap.get(s1)) { resMap.put(s1, false); break; } sum++; if (sum == tempMap.size()) { flag = false; } } } String res = resMap.entrySet().stream().filter(Map.Entry::getValue) .map(Map.Entry::getKey).collect(Collectors.joining(\u0026#34;,\u0026#34;)); res = res.isBlank() ? \u0026#34;,\u0026#34; : res; System.out.println(res); } 10. 图像物体的边界\r#\r描述\n给定一个二维数组M行N列，二维数组里的数字代表图片的像素， 为了简化问题，仅包含像素1和5两种像素，每种像素代表一个物体，2个物体相邻的格子为边界，求像素1代表的物体的边界个数。 像素1代表的物体的边界指与像素5相邻的像素1的格子，边界相邻的属于同一个边界， 相邻需要考虑8个方向(上，下，左，右，左上，左下，右上，右下)。 输入描述： 第一行包含两个正整数 M 和 N，表示二维数组的行数和列数。 接下来的 M 行，每行包含 N 个数字，表示二维数组的像素。 输出描述： 输出像素1代表的物体的边界数目。如果没有边界，输出0（例如只存在像素1，或者只存在像素5）。 输入： 6 6 1 1 1 1 1 1 1 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5 1 1 1 1 1 1 1 输出：1 题解\nprivate static int m; private static int n; private static int[] dx = {0, 0, -1, 1, -1, 1, -1, 1}; private static int[] dy = {-1, 1, 0, 0, -1, 1, 1, -1}; public static void main(String[] args) { Scanner in = new Scanner(System.in); m = in.nextInt(); n = in.nextInt(); int[][] grid = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { grid[i][j] = in.nextInt(); } } in.close(); // 标记边界 int[][] border = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == 5) { for (int k = 0; k \u0026lt; 8; k++) { int newI = i + dx[k]; int newJ = j + dy[k]; if (0 \u0026lt;= newI \u0026amp;\u0026amp; newI \u0026lt; m \u0026amp;\u0026amp; 0 \u0026lt;= newJ \u0026amp;\u0026amp; newJ \u0026lt; n \u0026amp;\u0026amp; grid[newI][newJ] == 1) { border[newI][newJ] = 1; } } } } } // 计算边界数量 int count = 0; boolean[][] visited = new boolean[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (border[i][j] == 1 \u0026amp;\u0026amp; !visited[i][j]) { count++; dfs(i, j, border, visited); } } } System.out.println(count); } public static void dfs(int x, int y, int[][] border, boolean[][] visited) { if (x \u0026lt; 0 || x \u0026gt;= n || y \u0026lt; 0 || y \u0026gt;= m || border[x][y] == 0 || visited[x][y]) { return; } visited[x][y] = true; for (int i = 0; i \u0026lt; 8; i++) { dfs(x + dx[i], y + dy[i], border, visited); } } 11. 跳格子游戏\r#\r描述\n小明和朋友们一起玩跳格子游戏，每个格子上有特定的分数 score = [1, -1, -6, 7, -17, 7]， 从起点score[0]开始，每次最大的步长为k，请你返回小明跳到终点 score[n-1] 时，能得到的最大得分。 输入描述： 第一行输入总的格子数量 n 第二行输入每个格子的分数 score[i] 第三行输入最大跳的步长 k 输出描述： 输出最大得分 输入：6 1 -1 -6 7 -17 7 2 输出：14 说明：输出最大得分数，小明从起点score[0]开始跳，第一次跳score[1],第二次跳到score[3],第三次跳到score[5]， 因此得到的最大的得分是score[0] + score[1] + score[3] + score[5] = 14 题解\n// 动态规划： // 创建一个数组 dp，其中 dp[i] 表示跳到 score[i] 时能得到的最大得分。 // 状态转移方程：dp[i] = max(dp[i-1],dp[i-2],...,dp[i-k]) + score[i]; // // 单调队列优化： // 使用双向队列从尾部添加dp[i]的下标i，添加之前判断队列尾部的下标last对应的元素dp[last]是否比dp[i]小 // dp[last]比dp[i]小，则将dp[last]取出丢弃。因为在dp[i]前面的比dp[i]还小的值不会被后面使用到，后面要的是最大值。 // 这样队列里保存的下标对应的dp元素是单调递减的。较小的元素直接淘汰，无需多次排序。 public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = Integer.parseInt(in.nextLine()); int[] arr = Arrays.stream(in.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int k = Integer.parseInt(in.nextLine()); in.close(); int[] dp = new int[arr.length]; // 使用一个双端队列来维护单调递减的索引 Deque\u0026lt;Integer\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; arr.length; i++) { // 移除队列中超出步长限制的索引 if (!deque.isEmpty() \u0026amp;\u0026amp; i - deque.peekFirst() \u0026gt; k) { deque.pollFirst(); } // 更新当前位置的最大得分 dp[i] = (deque.isEmpty() ? 0 : dp[deque.peekFirst()]) + arr[i]; // 保持单调递减性质，比当前dp[i]还小的dp[i-x]已经没有用了，要取也是取当前dp[i]或前面更大的值 while (!deque.isEmpty() \u0026amp;\u0026amp; dp[i] \u0026gt;= dp[deque.peekLast()]) { // 队列中无用的索引移除 deque.pollLast(); } // 将当前索引加入队列 deque.offerLast(i); // 对于dp数组 8 5 4 3 7 0 0，假如步长k=4，arr[4]=-1 // i=4时队列里存的dp的索引index为 0 1 2 3，其对应的dp元素是递减的 // 计算dp[4] = 8 + arr[4] = 7 // 此时，dp数组中dp[1] dp[2] dp[3]都比dp[4] 小，将队列中的对应index移除 // 最后添加当前索引i=4到队列末尾，此时队列中的index对应的dp元素还是递减的 } System.out.println(dp[dp.length-1]); } 12. 最小叶子节点\r#\r描述\n二叉树也可以用数组来存储，给定一个数组，树的根节点的值储存在下标1， 对于储存在下标n的节点，他的左子节点和右子节点分别储存在下标 2*n 和 2*n+1，并且我们用-1代表一个节点为空。 给定一个数组存储的二叉树，试求从根节点到最小的叶子节点的路径，路径由节点的值组成。 输入描述： 输入一行为数组的内容，数组的每个元素都是正整数，元素间用空格分割。 注意第一个元素即为根节点的值，即数组的第n元素对应下标 n。下标0在树的表示中没有使用，所以我们省略了。 输入的树最多为7层。 输出描述： 输出从根节点到最小叶子节点的路径上各个节点的值由空格分割 用例保证最小叶子节点只有一个 输入：3 5 7 -1 -1 2 4 输出：3 7 2 输入：5 9 8 -1 -1 7 -1 -1 -1 -1 -1 6 输出：5 8 7 6 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); String str = in.nextLine(); String[] arr = (\u0026#34;0 \u0026#34; + str).split(\u0026#34; \u0026#34;); // 获取最小叶子节点的位置 int minPos = 0; int min = Integer.MAX_VALUE; for (int i = 2; i \u0026lt; arr.length; i++) { int tmp = Integer.parseInt(arr[i]); if (tmp != 0 \u0026amp;\u0026amp; tmp != -1 \u0026amp;\u0026amp; tmp \u0026lt; min \u0026amp;\u0026amp; i * 2 \u0026gt; arr.length) { min = tmp; minPos = i; } } // 向上回溯 List\u0026lt;String\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); back(arr, minPos, path); Collections.reverse(path); System.out.println(String.join(\u0026#34; \u0026#34;, path)); } private static void back(String[] split, int minPos, List\u0026lt;String\u0026gt; path) { path.add(split[minPos]); if (minPos == 1) { return; } if (minPos % 2 == 0) { back(split, minPos / 2, path); } else { back(split, (minPos - 1) / 2, path); } } 13. 考古学家\r#\r描述\n有一个考古学家发现一个石碑，但是很可惜发现时其已经断成多段。 有N个断口整齐的石碑碎片，为了破解石碑内容，考古学家希望有程序能帮忙计算复原后的石碑文字组合数 输入描述： 第一行输入N，N表示石碑碎片的个数 第二行依次输入石碑碎片上的文字内容S共有N组 输出描述： 输出石碑文字的组合(按照升序排列)，行尾无多余空格 输入：3 a b ab 输出：aabb abab abba baab baba 题解\nprivate static int num; private static int len; private static String[] arr; public static void main(String[] args) { Scanner in = new Scanner(System.in); num = Integer.parseInt(in.nextLine()); String line = in.nextLine(); len = line.replaceAll(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;).length(); arr = line.split(\u0026#34; \u0026#34;); Arrays.sort(arr); boolean[] used = new boolean[num]; TreeSet\u0026lt;String\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); dfs(used, \u0026#34;\u0026#34;, set); set.forEach(System.out::println); } public static void dfs(boolean[] used, String path, TreeSet\u0026lt;String\u0026gt; set) { if (path.length() == len) { set.add(path); return; } // 记录上一次访问的索引 int lastIndex = -1; for (int i = 0; i \u0026lt; num; i++) { if (used[i] || i == lastIndex) { continue; } used[i] = true; dfs(used, path + arr[i], set); used[i] = false; // 更新上一次访问的索引 lastIndex = i; } } 14. 解压报文\r#\r描述\n为了提升数据传输的效率，会对传输的报文进行压缩处理。输入一个压缩后的报文，请返回它解压后的原始报文。 压缩规则：n[str]，表示方括号内部的 str 正好重复 n 次。 注意 n 为正整数（0 ＜ n ≤ 100），str只包含小写英文字母，不考虑异常情况。 输入压缩后的报文： 1）不考虑无效的输入，报文没有额外的空格，方括号总是符合格式要求的； 2）原始报文不包含数字，所有的数字只表示重复的次数 n,例如不会出现像 5b 或 3[8] 的输入； 输出描述: 解压后的原始报文 输入：3[k]2[mn] 输出：kkkmnmn 输入：3[m2[c]] 输出：mccmccmcc 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); char[] chars = in.nextLine().toCharArray(); Stack\u0026lt;Object\u0026gt; stack1 = new Stack\u0026lt;\u0026gt;(); Stack\u0026lt;Object\u0026gt; stack2 = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; chars.length; i++) { //如果是数字，需要判断接下来的字符是不是数字，如果是，要进行拼接 if (chars[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; chars[i] \u0026lt;= \u0026#39;9\u0026#39;) { StringBuilder temp = new StringBuilder(\u0026#34;\u0026#34; + chars[i]); for (int j = i + 1; j \u0026lt; chars.length; j++) { if (chars[j] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; chars[j] \u0026lt;= \u0026#39;9\u0026#39;) { temp.append(chars[j]); } else { i = j - 1; stack1.add(Integer.parseInt(temp.toString())); break; } } } else if (chars[i] != \u0026#39;]\u0026#39;) { stack1.add(chars[i]); } else { //遇到]，形成闭环，将 [ ] 之间的字符拼串，然后按 [ 前方的数字拼接 while (!stack1.peek().equals(\u0026#39;[\u0026#39;)) { stack2.add(stack1.pop()); } stack1.pop(); int nums = Integer.parseInt(\u0026#34;\u0026#34; + stack1.pop()); StringBuilder temp = new StringBuilder(); while (!stack2.isEmpty()) { temp.append(stack2.pop()); } String paste = temp.toString(); while (nums-- \u0026gt; 1) { temp.append(paste); } stack1.push(temp); } } //拼串 StringBuilder result = new StringBuilder(); while (!stack1.isEmpty()) { stack2.push(stack1.pop()); } while (!stack2.isEmpty()) { result.append(stack2.pop()); } System.out.println(result); } 15. 最长的指定瑕疵度的元音子串\r#\r描述\n如果一个字符串的开头和结尾都是元音字母（a、e、i、o、u、A、E、I、O、U），那么它就被称为元音字符串。 元音字符串中非元音字母的数量定义为该字符串的瑕疵度 现在，给定一个字符串和一个目标瑕疵度，请你找出具有指定瑕疵度的最长元音子串，并输出其长度。如果不存在则输出0 注意：字符串中任意连续的字符组成的子序列称为该字符串的子串。 a 和 aa 都是元音字符串，它们的瑕疵度为 0。 aiur 不是元音字符串，因为它的结尾不是元音字母。 abira 是一个元音字符串，它的瑕疵度为2 输入描述： 第一行包含一个整数flaw，表示目标瑕疵度，满足0≤flaw≤65535。 第二行包含一个字符串str，仅由小写字母和大写字母组成，满足1≤str≤65535。 输出描述： 输出一个整数，表示满足条件的最长元音子串的长度。如果不存在满足条件的元音子串，则输出0 输入：1 aabeebuu 输出：5 题解\nprivate static final char[] YAUN = {\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;U\u0026#39;}; public static void main(String[] args) { Scanner in = new Scanner(System.in); int num = Integer.parseInt(in.nextLine()); char[] chars = in.nextLine().toCharArray(); boolean[] arr = new boolean[chars.length]; for (int i = 0; i \u0026lt; chars.length; i++) { arr[i] = isYuan(chars[i]); } int maxLen = 0; for (int i = 0; i \u0026lt; arr.length; i++) { if (!arr[i]) { continue; } int sum = 0; for (int j = i + 1; j \u0026lt; arr.length; j++) { if (arr[j]) { if (sum == num) { maxLen = Math.max(maxLen, j - i + 1); } } else { sum++; } } } System.out.println(maxLen); } private static boolean isYuan(char ch) { for (char c : YAUN) { if (ch == c) { return true; } } return false; } 16. 目录删除\r#\r描述\n某文件系统中有N个目录，每个目录都一个独一无二的ID。 每个目录只有一个父目录，但每个父目录下可以有零个或者多个子目录，目录结构呈树状结构。 假设，根目录的ID为0，且根目录没有父目录，其他所有目录的ID用唯一的正整数表示，并统一编号。 现给定目录ID和其父目录ID的对应父子关系表[子目录ID，父目录ID]，以及一个待删除的目录ID， 请计算并返回一个ID序列，表示因为删除指定目录后剩下的所有目录，返回的ID序列以递增序输出。 注意: 1、被删除的目录或文件编号一定在输入的ID序列中 2、当一个目录删除时，它所有的子目录都会被删除 输入描述： 输入的第一行为父子关系表的长度m; 接下来的行为m个父子关系对; 最后一行为待删除的ID。序列中的元素以空格分割，参见样例。 输出描述： 输出一个序列，表示因为删除指定目录后，剩余的目录ID. 输入：5 8 6 10 8 6 0 20 8 2 6 8 输出：2 6 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); int num = Integer.parseInt(in.nextLine()); int[][] arr = new int[num][2]; for (int i = 0; i \u0026lt; num; i++) { String[] strings = in.nextLine().split(\u0026#34; \u0026#34;); arr[i][0] = Integer.parseInt(strings[0]); arr[i][1] = Integer.parseInt(strings[1]); } List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); String[] strings = in.nextLine().split(\u0026#34; \u0026#34;); for (String str : strings) { list.add(Integer.parseInt(str)); } Map\u0026lt;Integer, Boolean\u0026gt; ansMap = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Integer, Integer\u0026gt; tmpMap = new HashMap\u0026lt;\u0026gt;(); for (int[] subArr : arr) { ansMap.put(subArr[0], true); ansMap.put(subArr[1], true); tmpMap.put(subArr[0], subArr[1]); } for (Integer i : list) { ansMap.put(i, false); } boolean flag = true; while (flag) { int sum = 0; for (Map.Entry\u0026lt;Integer, Integer\u0026gt; entry : tmpMap.entrySet()) { Integer parent = entry.getValue(); Integer sub = entry.getKey(); if (!ansMap.get(parent) \u0026amp;\u0026amp; ansMap.get(sub)) { ansMap.put(sub, false); break; } sum++; if (sum == tmpMap.size()) { flag = false; } } } String ans = ansMap.entrySet().stream() .filter(Map.Entry::getValue).map(Map.Entry::getKey).filter(key -\u0026gt; key != 0) .sorted().map(String::valueOf).collect(Collectors.joining(\u0026#34; \u0026#34;)); System.out.println(ans); } 17. 吃火锅\r#\r描述\n火锅里会在不同时间下很多菜，不同食材要煮不同时间，才能变得刚好合适，你希望吃到最多的刚好合适的菜， 但是你的手速不够快用m代替手速，每次下手捞菜后至少要过m秒，才能再捞（每次只能捞一个） 那么用最合理的策略，最多能吃到多少，刚好合适的菜 输入描述： 第一行两个整数n、m，其中n代表往锅里下菜的个数，m代表手速 接下来有n行，每行有两个数x、y，代表第x秒下的菜过y秒才能变得刚好合适（1 ＜ mn ＜ 1000），（1 ＜ xy ＜ 1000） 输出描述： 输出一个整数代表用最合理的策略，最多能吃到刚好合适的菜的数量 输入：3 2 1 2 2 1 3 2 输出：2 往锅里下的菜的个数3，手速2； 第1秒的时候下入菜品1，2秒后熟了； 第2秒的时候下入菜品2，1秒后熟了； 第3秒的时候下入菜品3，2秒后熟了； 第一种菜品和第二种菜品只能吃到一种，第三种菜品可以吃到； 题解\n// 遍历每一种菜，若当前与上一次捞菜的时间差\u0026gt;=m，则当前可以进行捞菜 public static void main(String[] args) { Scanner in = new Scanner(System.in); String[] split = in.nextLine().split(\u0026#34; \u0026#34;); int n = Integer.parseInt(split[0]); int m = Integer.parseInt(split[1]); int[] arr = new int[n]; for (int i = 0; i \u0026lt; n; i++) { String[] tmp = in.nextLine().split(\u0026#34; \u0026#34;); // 每种菜刚好合适的时间点 arr[i] = Integer.parseInt(tmp[0]) + Integer.parseInt(tmp[1]); } Arrays.sort(arr); // 第1个合适的菜 int count = 1; int pre = 0; for (int i = 1; i \u0026lt; arr.length; i++) { if (arr[i] \u0026gt;= arr[pre] + m) { // 当前与上次捞菜的时间差大于等于m，则可以进行捞菜 count++; // 更新本次捞菜时间点 pre = i; } } System.out.println(count); } 18. 服务器广播\r#\r描述\n服务器连接方式包括直接相连，间接连接。 A 和 B 直接连接， B 和 C 直接连接，则 A 和 C 间接连接。直接连接和间接连接都可以发送广播。 给出一个 N * N 数组，代表 N 个服务器， matrix[i][j] == 1 ，则代表 i 和 j 直接连接； 不等于 1 时，代表 i 和 j 不直接连接。 matrix[i][i]== 1 ，即自己和自己直接连接。matrix[i][j]==matrix[j][i] 。 计算初始需要给几台服务器广播，才可以使每个服务器都收到广播。 输入描述：输入为N行，每行有N个数字，为0或1，由空格分隔，构成N*N的数组，N的范围为 1 ≤ N ≤ 40 输出描述：输出一个数字，为需要广播的服务器的数量 输入：1 0 0 0 1 0 0 0 1 输出：3 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); String[] str = in.nextLine().split(\u0026#34; \u0026#34;); int n = str.length; int[][] arr = new int[n][n]; for (int i = 0; i \u0026lt; n; i++) { arr[0][i] = Integer.parseInt(str[i]); } for (int i = 1; i \u0026lt; n; i++) { String[] s = in.nextLine().split(\u0026#34; \u0026#34;); for (int j = 0; j \u0026lt; n; j++) { arr[i][j] = Integer.parseInt(s[j]); } } int count = 0; List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { if (!list.contains(i)) { dfs(arr, list, i); count++; } } System.out.println(count); } public static void dfs(int[][] arr, List\u0026lt;Integer\u0026gt; list, int index) { list.add(index); for (int i = index + 1; i \u0026lt; arr.length; i++) { if (arr[index][i] == 1 \u0026amp;\u0026amp; !list.contains(i)) { dfs(arr, list, i); } } } 19. 二叉树的广度优先遍历\r#\r描述\n有一棵二叉树，每个节点由一个大写字母标识(最多26个节点）。 现有两组字母，分别表示前序遍历（父节点-\u0026gt;左孩子-\u0026gt;右孩子）和中序遍历（左孩子-\u0026gt;父节点-\u0026gt;右孩子）的结果， 请你输出后序遍历（左孩子-\u0026gt;右孩子-\u0026gt;父节点）的结果。 输入描述： 每个输入文件包含两串字母，各占一行。（每串只包含大写字母） 第一行字母表示前序遍历结果，第二行字母表示中序遍历结果。 输出描述： 输出仅一行，表示后序遍历的结果，结尾换行。 输入：DBACEGF ABCDEFG 输出：ACBFGED 思路：先从先序遍历中找到根节点，然后从中序遍历中找到左子树和右子树，递归，构建二叉树，最后再进行后序遍历。 例如：已知前序遍历是DBACEGF，中序遍历是ABCDEFG，那么由前序遍历先根，可知道D是树的根，再看在中序遍历中D左边是ABC，所以可知道ABC一定在D的左子树上，而EFG在D的右子树上。那么前序遍历为BAC,中序遍历为ABC 题解\npublic static class TreeNode { char val; TreeNode left; TreeNode right; TreeNode(char val) { this.val = val; } } public static void lastOrder(StringBuilder sb, TreeNode node) { if (node == null) { return; } lastOrder(sb, node.left); lastOrder(sb, node.right); sb.append(node.val); } private static TreeNode build(String preOrder, String inOrder) { if (preOrder.isEmpty()) { return null; } char midVal = preOrder.charAt(0); TreeNode root = new TreeNode(midVal); if (preOrder.length() == 1) { return root; } int midIndex = inOrder.indexOf(midVal); String preLeft = preOrder.substring(1, midIndex + 1); String preRight = preOrder.substring(midIndex + 1); String inLeft = inOrder.substring(0, midIndex); String inRight = inOrder.substring(midIndex + 1); root.left = build(preLeft, inLeft); root.right = build(preRight, inRight); return root; } public static void main(String[] args) { Scanner in = new Scanner(System.in); String preOrder = in.nextLine(); String inOrder = in.nextLine(); TreeNode root = build(preOrder, inOrder); StringBuilder sb = new StringBuilder(); lastOrder(sb, root); System.out.println(sb); } 20. 单词搜索\r#\r描述\n给一个字符串和一个二维字符数组，如果该字符串存在于该数组中，则按字符串的字符顺序输出字符串每个字符所在单元格的位置下标字符串，如果找不到返回字符串N。 1.需要按照字符串的字符组成顺序搜索，且搜索到的位置必须是相邻单元格，其中“相邻单元格”是指那些水平相邻或垂直相邻的单元格。 2.同一个单元格内的字母不允许被重复使用。 3.假定在数组中最多只存在一个可能的匹配。 输入描述： 第1行为一个数字N指示二维数组在后续输入所占的行数。 第2行到第N+1行输入为一个二维大写字符数组，每行字符用半角,分割。二维数组的大小为N*N，小于等于 100。 第N+2行为待查找的字符串，由大写字符组成。单词长度K，小于 1000。 输出描述： 输出一个位置下标字符串，拼接格式为：第1个字符行下标+\u0026#34;,\u0026#34;+第1个字符列下标+\u0026#34;,\u0026#34;+第2个字符行下标+\u0026#34;,\u0026#34;+第2个字符列下标...+\u0026#34;,\u0026#34;+第N个字符行下标+\u0026#34;,\u0026#34;+第N个字符列下标示例1 输入：4 A,C,C,F C,D,E,D B,E,S,S F,E,C,A ACCESS 输出：0,0,0,1,0,2,1,2,2,2,2,3 说明：ACCESS分别对应二维数组的[0,0] [0,1] [0,2] [1,2] [2,2] [2,3]下标位置 题解\nprivate static final List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); public static void main(String[] args) { Scanner in = new Scanner(System.in); int N = Integer.parseInt(in.nextLine()); char[][] arr = new char[N][N]; for (int i = 0; i \u0026lt; N; i++) { arr[i] = in.nextLine().replaceAll(\u0026#34;,\u0026#34;, \u0026#34;\u0026#34;).toCharArray(); } String word = in.nextLine(); in.close(); if (exist(arr, word)) { for (int i = list.size() - 1; i \u0026gt;= 0; i--) { System.out.print(list.get(i)); if (i != 0) { System.out.print(\u0026#34;,\u0026#34;); } } } else { System.out.println(\u0026#34;N\u0026#34;); } } private static boolean exist(char[][] board, String word) { char[] words = word.toCharArray(); for (int i = 0; i \u0026lt; board.length; i++) { for (int j = 0; j \u0026lt; board[0].length; j++) { if (dfs(board, words, i, j, 0)) { list.add(i + \u0026#34;,\u0026#34; + j); return true; } } } return false; } private static boolean dfs(char[][] arr, char[] word, int i, int j, int k) { if (i \u0026gt;= arr.length || i \u0026lt; 0 || j \u0026gt;= arr[0].length || j \u0026lt; 0 || arr[i][j] != word[k]) { return false; } if (k == word.length - 1) { return true; } int newI = i; int newJ = j; boolean flag = false; if (dfs(arr, word, i + 1, j, k + 1)) { flag = true; newI = i + 1; } if (dfs(arr, word, i - 1, j, k + 1)) { flag = true; newI = i - 1; } if (dfs(arr, word, i, j + 1, k + 1)) { flag = true; newJ = j + 1; } if (dfs(arr, word, i, j - 1, k + 1)) { flag = true; newJ = j - 1; } if (flag) { list.add(newI + \u0026#34;,\u0026#34; + newJ); } return flag; } 21. 最少面试官数\r#\r描述\n某公司组织一场公开招聘活动，假设由于人数和场地的限制，每人每次面试的时长不等，并已经安排给定， 用(S1,E1)、(S2,E2)、(Sj,Ej)...(Si 小于 Ei，均为非负整数)表示每场面试的开始和结束时间。 面试采用一对一的方式，即一名面试官同时只能面试一名应试者， 一名面试官完成一次面试后可以立即进行下一场面试，且每个面试官的面试人次不超过m。 为了支撑招聘活动高效顺利进行，请你计算至少需要多少名面试官。 输入描述： 输入的第一行为面试官的最多面试人次m，第二行为当天总的面试场次n， 接下来的n行为每场面试的起始时间和结束时间，起始时间和结束时间用空格分隔。其中，1 ≤ n, m ≤ 500 输出描述： 输出一个整数，表示至少需要的面试官数量。 输入：2 5 1 2 2 3 3 4 4 5 5 6 输出：3 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); int m = in.nextInt(); int n = in.nextInt(); int[][] arr = new int[n][2]; for (int i = 0; i \u0026lt; n; i++) { arr[i][0] = in.nextInt(); arr[i][1] = in.nextInt(); } solution(m, n, arr); } private static void solution(int m, int n, int[][] arr) { Arrays.sort(arr, Comparator.comparing(c1 -\u0026gt; c1[0])); List\u0026lt;int[]\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(new int[]{arr[0][1], 1}); for (int i = 1; i \u0026lt; n; i++) { boolean flag = false; for (int[] p : list) { if (p[0] \u0026lt;= arr[i][0] \u0026amp;\u0026amp; p[1] \u0026lt; m) { p[1]++; p[0] = arr[i][1]; flag = true; break; } } if (!flag) { list.add(new int[]{arr[i][1], 1}); } } System.out.print(list.size()); } 22. 斗地主之顺子\r#\r描述\n在斗地主扑克牌游戏中， 扑克牌由小到大的顺序为：3,4,5,6,7,8,9,10,J,Q,K,A,2，玩家可以出的扑克牌阵型有：单张、对子、顺子、飞机、炸弹等。 其中顺子的出牌规则为：由至少5张由小到大连续递增的扑克牌组成，且不能包含2。 例如：{3,4,5,6,7}{3,4,5,6,7,8,9,10,J,Q,K,A}都是有效的顺子；而{J,Q,K,A,2}{3,4,5,6}{3,4,5,6,8}等都不是顺子。 给定一个包含13张牌的数组，如果有满足出牌规则的顺子，请输出顺子。 如果存在多个顺子，请每行输出一个顺子，且需要按顺子的第一张牌的大小（必须从小到大）依次输出。 如果没有满足出牌规则的顺子，请输出No。 输入描述：13张任意顺序的扑克牌，每张扑克牌数字用空格隔开，每张扑克牌的数字都是合法的，并且不包括大小王： 输出描述：组成的顺子，每张扑克牌数字用空格隔开： 输入：2 9 J 10 3 4 K A 7 Q A 5 6 输出：3 4 5 6 7 9 10 J Q K A 输入：3 3 4 4 5 5 6 6 7 7 8 8 9 输出：3 4 5 6 7 8 3 4 5 6 7 8 9 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); String[] strings = in.nextLine().split(\u0026#34; \u0026#34;); int[] arr = new int[15]; int index; for (String str : strings) { index = getIndex(str); arr[index]++; } solution(arr); } private static void solution(int[] arr) { List\u0026lt;String\u0026gt; ansList = new ArrayList\u0026lt;\u0026gt;(); for (int left = 3; left \u0026lt;= 10; left++) { if (arr[left] \u0026lt;= 0) { continue; } int right = left + 1; for (; right \u0026lt;= 14; right++) { if (arr[right] \u0026lt;= 0) { break; } } right--; if (right - left \u0026gt;= 4) { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int k = left; k \u0026lt;= right; k++) { arr[k]--; list.add(getString(k)); } ansList.add(String.join(\u0026#34; \u0026#34;, list)); left--; } } ansList.stream().sorted().forEach(System.out::println); } private static int getIndex(String str) { return switch (str) { case \u0026#34;J\u0026#34; -\u0026gt; 11; case \u0026#34;Q\u0026#34; -\u0026gt; 12; case \u0026#34;K\u0026#34; -\u0026gt; 13; case \u0026#34;A\u0026#34; -\u0026gt; 14; default -\u0026gt; Integer.parseInt(str); }; } private static String getString(int index) { return switch (index) { case 11 -\u0026gt; \u0026#34;J\u0026#34;; case 12 -\u0026gt; \u0026#34;Q\u0026#34;; case 13 -\u0026gt; \u0026#34;K\u0026#34;; case 14 -\u0026gt; \u0026#34;A\u0026#34;; default -\u0026gt; String.valueOf(index); }; } "},{"id":22,"href":"/interview/framework/mybatis/","title":"MyBatis","section":"开源框架","content":"\r\u0026ndash; MyBatis\r#\rMyBatis\n是一个基于java的持久层框架 它内部封装了JDBC，使开发者只需要专注于sql语句本身 特点\n1. 与JDBC相比，减少了50%以上的代码量 2. 基于SQL语句编程，相当灵活。 3. SQL写在XML里，降低了耦合度，便于统一管理和优化，且可重用 4. 提供XML标签，支持编写动态SQL语句 5. 提供映射标签，支持对象与数据库的ORM字段关系映射 6. 兼容各种数据库，能够与Spring很好的集成 \u0026ndash; MyBatis 缓存机制\r#\r1. mybatis提供查询缓存，用于减轻数据压力，提高数据库性能 2. 缓存失效：查询条件不相同，或两次查询之间出现了增删改操作 缓存 级别 开启 缓存范围 一级缓存 SqlSession 级别 默认开启 同一个SqlSession，即数据库会话 二级缓存 Mapper 级别 配置开启 同一个Mapper，即同一个 namespace 的 mapper.xml \u0026ndash; JDBC 编程步骤\r#\r加载驱动\nClass.forName(\u0026#34;com.mysql.jdbc.Driver\u0026#34;); 建立连接\nString user = \u0026#34;xxx\u0026#34;; String password = \u0026#34;xxx\u0026#34;; String url = \u0026#34;jdbc:mysql://127.0.0.1:3306/xxx?useUnicode=true\u0026#34;; Connection conn = DriverManager.getConnection(url, user, password); 创建 Statement\nString sql =\u0026#34;SELECT * FROM catalog_info WHERE catalog_name=?\u0026#34;; PreparedStatement prs = conn.prepareStatement(sql); prs.setString(1, \u0026#34;JavaSE\u0026#34;); 执行sql语句，获取结果集\nResultSet res = prs.executeQuery(); while (res.next()) { System.out.println(res.getLong(\u0026#34;catalog_id\u0026#34;) + \u0026#34; - \u0026#34; + res.getString(\u0026#34;catalog_name\u0026#34;)); } 关闭资源\nres.close(); prs.close(); conn.close(); \u0026ndash; #{}、${}\r#\r含义 Mybatis 处理过程 防止SQL注入 #{} 预编译处理 将 #{} 替换为 ? 号，再调用PreparedStatement的set方法来赋值 可以 ${} 字符串替换 将 ${} 替换成变量的值 不能 "},{"id":23,"href":"/interview/program-lang/java-base/p3/","title":"Part.3","section":"Java基础","content":"\r\u0026ndash; HashMap 的工作原理\r#\r底层数据结构\nHashMap 底层是由数组和单向链表实现，数组中的每个元素都是链表，由 Node 内部类实现 HashMap 通过 put \u0026amp; get 方法存储和获取元素对象 存储对象时，将 K/V 键值传给 put() 方法\n1、调用 hash(K)方法计算 K的 hash值，然后结合数组长度，计算得数组下标； 2、判断数组该下标节点是否存在： A. 如果不存在，则新增节点，直接执行插入 B. 如果已存在，即为发生哈希碰撞，则遍历该位置的链表，对比判断 K值、hash值，是否在链表节点中已经存在： a. 如果已存在，则更新链表节点的键值对； b. 如果不存在，则新增节点，插入链表的尾部（尾插法）或者红黑树中（树的添加方式） 3、判断是否需要扩容，调整数组大小； 获取对象时，将 K 传给 get() 方法\n1、调用 hash(K)方法计算 K的 hash值，然后结合数组长度，计算得数组下标，即找到了该 K所在的链表 2、顺序遍历链表，对比查找 K值、hash值两者相同的链表节点 3、如果找到，则返回链表节点的 V值，否则返回空 \u0026ndash; HashMap 的数据结构\r#\rJDK1.7及其之前，是数组+链表\nJDK1.8及其之后，是数组+链表/红黑树\n\u0026ndash; HashMap 的数组的初始化长度\r#\r默认的初始容量值是16，也可以手动指定 \u0026ndash; HashMap 的容量\r#\r1、容量capacity，决定着table 数组的大小，默认是16，也可以构造时传入 2、装载因子loadFactor，主要目的是用来确认table 数组是否需要动态扩展，默认值是0.75(概率泊松分布) 3、阈值threshold，等于capacity * loadFactor，当超过阈值时 table 就需要动态扩容 \u0026ndash; HashMap 的数组什么时候扩容\r#\rJDK1.7及其之前，以下两个条件同时满足时会扩容： 1、size 达到 threshold 2、table[index]!=null JDK1.8及其之后，以下两个条件满足其一时会扩容： 1、size达到threshold 2、当table[index]下的结点个数达到8个但是table.length又没有达到64 \u0026ndash; HashMap 什么时候会转红黑树\r#\r当table[index]下的结点个数达到8个，但是table.length已经达到64 \u0026ndash; HashMap 的数组长度为什么是2的幂次方数\r#\r为了效率更快： 1、在HashMap中，先得到key的hashcode，然后通过hashcode \u0026amp; (table.length - 1) 运算得到一个数组下标index 2、用与运算计算数组下标，相比于取余运算速度更快，但这有个前提条件，就是数组的长度得是一个2的幂次方数。 \u0026ndash; HashMap、HashTable\r#\rHashMap HashTable 非线程安全，效率相对较高 线程安全，效率相对较低 key/value 都允许为 null key/value 都不允许为 null 默认初始容量16，按 2n 进行扩容 默认初始容量11，按 2n+1 进行扩容 重新计算hash值 直接使用对象的 hashCode \u0026ndash; HashMap、ConcurrentHashMap\r#\r区别\nHashMap： 1. key/value 都允许为 null值 2. 非线程安全 ConcurrentHashMap： 1. key/value 都不允许为 null值 2. 线程安全 ConcurrentHashMap 线程锁：\nJDK 1.7中 1、使用分段锁，相当于把一个 HashMap 分成多个段，每段分配一把锁。 2、锁粒度：基于 Segment，包含多个 HashEntry。 JDK 1.8中 1、使用 CAS + synchronized + Node + 红黑树 2、锁粒度：Node（首结点） \u0026ndash; HashMap、LinkedHashMap、TreeMap\r#\rHashMap\n1、底层是基于哈希表（散列表/数组）的数据结构 2、key是无序的 TreeMap\n1、底层是基于红黑树的数据结构 2、key是有序的 3、使用场景：在需要按自然顺序或自定义顺序遍历键的情况下 LinkedHashMap\n1、继承自HashMap，其内部多维护了一个双向链表 2、key是有序的 3、使用场景：在需要输出的顺序和输入的顺序相同的情况下 "},{"id":24,"href":"/interview/dev-tool/tomcat/","title":"Tomcat","section":"开发工具","content":"\r\u0026ndash; Tomcat\r#\r是一个免费开源的轻量级Web应用服务器 默认端口：8080 \u0026ndash; Tomcat 部署方式\r#\r使用 Tomcat 的自动部署\n将web应用拷贝到webapps目录。 当Tomcat启动时，会自动部署应用。 使用 Manager 应用部署\n进入Tomcat主页的Manager App控制台，可以指定一个web应用的路径或war文件 修改 conf/server.xml 文件部署\n在server.xml文件的\u0026lt;Host\u0026gt;标签内添加\u0026lt;Context\u0026gt;标签，可以指定应用路径和文件位置 \u0026ndash; Tomcat 目录结构\r#\rbin -- 脚本文件 conf -- 配置文件 lib -- 公共类库 logs -- 日志文件 temp -- 临时文件 webapps -- web应用目录 work -- 编译后的文件 "},{"id":25,"href":"/interview/program-design/structure-algorithm/huawei-od/%E5%8F%82%E8%80%83%E9%A2%981/","title":"参考题 - 1","section":"华为OD","content":"\r01. 字符串反转\r#\r描述\n接受一个只包含小写字母的字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000） 输入描述：输入一行，为一个只包含小写字母的字符串。 输出描述：输出该字符串反转后的字符串。 输入：abcd 输出：dcba 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); String str = in.nextLine(); StringBuilder sb = new StringBuilder(str); sb.reverse(); System.out.println(sb); } 02. 数字颠倒\r#\r描述\n输入一个整数，将这个整数以字符串的形式逆序输出 程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001 数据范围：0≤n≤2^30−1 输入描述：输入一个int整数 输出描述：将这个整数以字符串的形式逆序输出 输入：1516000 输出：0006151 题解\n同01题 03. 表达式求值\r#\r描述\n给定一个字符串描述的算术表达式，计算出结果值。 输入字符串长度不超过 100 ，合法的字符包括 +, -, *, /, (, ),0-9 数据范围：运算过程中和最终结果均满足∣val∣≤2^31 −1 ，即只进行整型运算，确保输入的表达式合法 输入描述：输入算术表达式 输出描述：计算出结果值 输入：400+5 输出：405 题解\npublic static void main(String[] args) throws ScriptException { Scanner in = new Scanner(System.in); String line = in.nextLine(); ScriptEngine engine = new ScriptEngineManager().getEngineByName(\u0026#34;js\u0026#34;); System.out.println(engine.eval(line)); } 04. 字符逆序\r#\r描述\n将一个字符串str的内容颠倒过来，并输出。 数据范围：1≤len(str)≤10000 输入描述：输入一个字符串，可以有空格 输出描述：输出逆序的字符串 输入：I am a student 输出：tneduts a ma I 题解\npublic static void main(String[] args){ Scanner in = new Scanner(System.in); String line = in.nextLine(); StringBuilder res = new StringBuilder(line); System.out.println(res.reverse()); } 05. 尼科彻斯定力\r#\r描述\n验证尼科彻斯定理，即：任何一个整数m的立方都可以写成m个连续奇数之和。 例如： 1^3=1 2^3=3+5 3^3=7+9+11 4^3=13+15+17+19 输入一个正整数m（m≤100），将m的立方写成m个连续奇数之和的形式输出。 数据范围：1≤m≤100 输入描述：输入一个int整数 输出描述：输出分解后的string 输入：6 输出：31+33+35+37+39+41 题解\n// 由等差数列公式，公差d=2 // 可得a1=m(m-1)+1 public static void main(String[] args){ Scanner in = new Scanner(System.in); int m = in.nextInt(); int a1 = m * (m - 1) + 1; StringBuilder sb = new StringBuilder(Integer.toString(a1)); for(int i = 1; i \u0026lt; m; i++){ a1 = a1 + 2; sb.append(\u0026#34;+\u0026#34;); sb.append(a1); } System.out.println(sb); } 06. 公共子串计算\r#\r描述\n给定两个只包含小写字母的字符串，计算两个字符串的最大公共子串的长度。 注：子串的定义指一个字符串删掉其部分前缀和后缀（也可以不删）后形成的字符串。 数据范围：字符串长度：1≤s≤150 输入描述：输入两个只包含小写字母的字符串 输出描述：输出一个整数，代表最大公共子串的长度 输入：asdfas werasdfaswer 输出：6 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); char[] chs1 = in.nextLine().toCharArray(); char[] chs2 = in.nextLine().toCharArray(); int maxLen = 0; for (int i = 0; i \u0026lt; chs1.length; i++) { for (int j = 0; j \u0026lt; chs2.length; j++) { int t1 = i; int t2 = j; int count = 0; while (chs1[t1] == chs2[t2]) { t1++; t2++; count++; maxLen = Math.max(count, maxLen); if (t1 == chs1.length || t2 == chs2.length) { break; } } } } System.out.println(maxLen); } 07. 求最大连续bit数\r#\r描述\n求一个int类型数字对应的二进制数字中1的最大连续数，例如3的二进制为00000011，最大连续2个1 数据范围：数据组数：1≤t≤5 ，1≤n≤500000 输入描述：输入一个int类型数字 输出描述：输出转成二进制之后连续1的个数 输入：200 输出：2 题解\npublic static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String input = null; while ((input = br.readLine()) != null) { char[] binary = Integer.toBinaryString(Integer.parseInt(input)).toCharArray(); int max = 0; // 最大连续数 int count = 0; // 当前连续数 for (char b : binary) { if (b == \u0026#39;1\u0026#39;) { count++; if (count \u0026gt; max) { max = count; } } else { count = 0; } } System.out.println(max); } } 08. 最长回文子串\r#\r描述\n给定一个仅包含小写字母的字符串，求它的最长回文子串的长度。所谓回文串，指左右对称的字符串。 所谓子串，指一个字符串删掉其部分前缀和后缀（也可以不删）的字符串 数据范围：字符串长度1≤s≤350 输入描述：输入一个仅包含小写字母的字符串 输出描述：返回最长回文子串的长度 输入：cdabbacc 输出：4 说明：abba为最长的回文子串 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); String line = in.nextLine(); int maxLen = 0; for (int i = 0; i \u0026lt; line.length(); i++) { for (int j = i + 1; j \u0026lt;= line.length(); j++) { // 回文字符串 反转后与其自身相等 String sub = line.substring(i, j); String subRev = new StringBuilder(sub).reverse().toString(); if (sub.equals(subRev)) { maxLen = Math.max(maxLen, sub.length()); } } } System.out.println(maxLen); } 09. 等差数列\r#\r描述\n等差数列 2，5，8，11，14。。。。（从 2 开始的 3 为公差的等差数列） 输出求等差数列前n项和 数据范围：1≤n≤1000 输入描述：输入一个正整数n。 输出描述：输出一个相加后的整数。 输入：2 输出：7 说明：2+5=7 输入：275 输出：113575 题解\n// 等差数列求和公式 public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = in.nextInt(); int sum = 2 * n + (n * (n - 1) * 3) / 2; System.out.println(sum); } 10. 密码强度等级\r#\r描述\n密码按如下规则进行计分，并根据不同的得分为密码进行安全等级划分。 一、密码长度: 5 分: 小于等于4 个字符 10 分: 5 到7 字符 25 分: 大于等于8 个字符 二、字母: 0 分: 没有字母 10 分: 密码里的字母全都是小（大）写字母 20 分: 密码里的字母符合”大小写混合“ 三、数字: 0 分: 没有数字 10 分: 1 个数字 20 分: 大于1 个数字 四、符号: 0 分: 没有符号 10 分: 1 个符号 25 分: 大于1 个符号 五、奖励（只能选符合最多的那一种奖励）: 2 分: 字母和数字 3 分: 字母、数字和符号 5 分: 大小写字母、数字和符号 最后的评分标准: \u0026gt;= 90: 非常安全 \u0026gt;= 80: 安全（Secure） \u0026gt;= 70: 非常强 \u0026gt;= 60: 强（Strong） \u0026gt;= 50: 一般（Average） \u0026gt;= 25: 弱（Weak） \u0026gt;= 0: 非常弱（Very_Weak） 对应输出为：VERY_SECURE、SECURE、VERY_STRONG、STRONG、AVERAGE、WEAK、VERY_WEAK 请根据输入的密码字符串，进行安全评定。 注： 字母：a-z, A-Z 数字：0-9 符号包含如下： (ASCII码表可以在UltraEdit的菜单view-\u0026gt;ASCII Table查看) !\u0026#34;#$%\u0026amp;\u0026#39;()*+,-./ (ASCII码：0x21~0x2F) :;\u0026lt;=\u0026gt;?@ (ASCII码：0x3A~0x40) [\\]^_` (ASCII码：0x5B~0x60) {|}~ (ASCII码：0x7B~0x7E) 提示：1≤字符串的长度≤300 输入描述：输入一个string的密码 输出描述：输出密码等级 输入：38$@NoNoN 输出：VERY_SECURE 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); char[] chs = in.nextLine().toCharArray(); int score = 0; //统计长度 int len = chs.length; if (len \u0026lt;= 4) score += 5; else if (len \u0026lt; 8) score += 10; else score += 25; //遍历获取大小写字母、数字、符号数目 int upCount = 0; int lowCount = 0; int numCount = 0; int sigCount = 0; for (char ch : chs) { if (Character.isUpperCase(ch)) ++upCount; else if (Character.isLowerCase(ch)) ++lowCount; else if (Character.isDigit(ch)) ++numCount; else ++sigCount; } //字母分数 if ((upCount \u0026gt; 0 \u0026amp;\u0026amp; lowCount == 0) || (upCount == 0 \u0026amp;\u0026amp; lowCount \u0026gt; 0)) score += 10; else if (upCount \u0026gt; 0 \u0026amp;\u0026amp; lowCount \u0026gt; 0) score += 20; //数字分数 if (numCount == 1) score += 10; else if (numCount \u0026gt; 1) score += 20; //符号分数 if (sigCount == 1) score += 10; else if (sigCount \u0026gt; 1) score += 25; //奖励分数 if (numCount \u0026gt; 0 \u0026amp;\u0026amp; upCount \u0026gt; 0 \u0026amp;\u0026amp; lowCount \u0026gt; 0 \u0026amp;\u0026amp; sigCount \u0026gt; 0) score += 5; else if (numCount \u0026gt; 0 \u0026amp;\u0026amp; sigCount \u0026gt; 0 \u0026amp;\u0026amp; (upCount \u0026gt; 0 || lowCount \u0026gt; 0)) score += 3; else if (numCount \u0026gt; 0 \u0026amp;\u0026amp; (upCount \u0026gt; 0 || lowCount \u0026gt; 0)) score += 2; //评分 if (score \u0026gt;= 90) System.out.println(\u0026#34;VERY_SECURE\u0026#34;); else if (score \u0026gt;= 80) System.out.println(\u0026#34;SECURE\u0026#34;); else if (score \u0026gt;= 70) System.out.println(\u0026#34;VERY_STRONG\u0026#34;); else if (score \u0026gt;= 60) System.out.println(\u0026#34;STRONG\u0026#34;); else if (score \u0026gt;= 50) System.out.println(\u0026#34;AVERAGE\u0026#34;); else if (score \u0026gt;= 25) System.out.println(\u0026#34;WEAK\u0026#34;); else System.out.println(\u0026#34;VERY_WEAK\u0026#34;); } 11. 字符个数统计\r#\r描述\n编写一个函数，计算字符串中含有的不同字符的个数。字符在 ASCII 码范围内( 0~127 ，包括 0 和 127 )，换行表示结束符，不算在字符里。不在范围内的不作统计。多个相同的字符只计算一次 例如，对于字符串 abaca 而言，有 a、b、c 三种不同的字符，因此输出 3 。 数据范围：1≤n≤500 输入描述：输入一行没有空格的字符串。 输出描述：输出 输入字符串 中范围在(0~127，包括0和127)字符的种数。 输入：abc 输出：3 题解\n// 数组下标不重复，且有序 public static void main(String[] args) { Scanner in = new Scanner(System.in); char[] chs = in.nextLine().toCharArray(); int[] temArr = new int[128]; int count = 0; for (char ch : chs) { if (temArr[ch] == 0) { count++; temArr[ch] = 1; } } System.out.println(count); } 12. 截取字符串\r#\r描述\n输入一个字符串和一个整数 k ，截取字符串的前k个字符并输出 数据范围：字符串长度满足 1≤n≤1000，1≤k≤n 输入描述：1.输入待截取的字符串。2.输入一个正整数k，代表截取的长度 输出描述：截取后的字符串 输入：abABCcDEF 6 输出：abABCc 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); String str = in.nextLine(); int k = Integer.parseInt(in.nextLine()); System.out.println(str.substring(0, k)); } 13. 查找组成一个偶数最接近的两个素数\r#\r描述\n任意一个偶数（大于2）都可以由2个素数组成，组成偶数的2个素数有很多种情况，本题目要求输出组成指定偶数的两个素数差值最小的素数对。 数据范围：输入的数据满足 4≤n≤1000 输入描述：输入一个大于2的偶数 输出描述：从小到大输出两个素数 输入：20 输出：7 13 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); int n = in.nextInt(); int m1 = n / 2; int m2 = n / 2; while (!isPrime(m1) || !isPrime(m2)) { m1--; m2++; } System.out.println(m1); System.out.println(m2); } public static boolean isPrime(int n) { for (int i = 2; i \u0026lt;= n / 2; i++) { if (n % i == 0) { return false; } } return true; } 14. 统计字符\r#\r描述\n输入一行字符，分别统计出包含英文字母、空格、数字和其它字符的个数。 数据范围：输入的字符串长度满足 1≤n≤1000 输入描述：输入一行字符串，可以有空格 输出描述：统计其中英文字符，空格字符，数字字符，其他字符的个数 输入：1qazxsw23 edcvfr45tgbn hy67uj m,ki89ol.\\\\/;p0-=\\\\][ 输出：26 3 10 12 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); String str = in.nextLine(); String str1 = str.replaceAll(\u0026#34;[^a-zA-Z]\u0026#34;, \u0026#34;\u0026#34;); String str2 = str.replaceAll(\u0026#34;[^ ]\u0026#34;, \u0026#34;\u0026#34;); String str3 = str.replaceAll(\u0026#34;[^0-9]\u0026#34;, \u0026#34;\u0026#34;); String str4 = str.replaceAll(\u0026#34;[a-zA-Z0-9 ]\u0026#34;, \u0026#34;\u0026#34;); System.out.println(str1.length()); System.out.println(str2.length()); System.out.println(str3.length()); System.out.println(str4.length()); } 15. 字符串排序\r#\r描述\n给定 n 个字符串，请对 n 个字符串按照字典序排列。 数据范围：1≤n≤1000，字符串长度满足 1≤len≤100 输入描述：输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。 输出描述：数据输出n行，输出结果为按照字典序排列的字符串。 输入：5 cap to cat boat boot 输出：boat boot cap cat to 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); int sum = Integer.parseInt(in.nextLine()); String[] arr = new String[sum]; for (int i = 0; i \u0026lt; sum; i++) { arr[i] = in.nextLine(); } Arrays.sort(arr); Arrays.stream(arr).forEach(System.out::println); } 16. 进制转换\r#\r描述\n写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。 数据范围：保证结果在1≤n≤2^31−1 输入描述：输入一个十六进制的数值字符串。 输出描述：输出该数值的十进制字符串。不同组的测试用例用\\n隔开。 输入：0xAA 输出：170 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); String str = in.nextLine().substring(2); int val = Integer.parseInt(str, 16); System.out.println(val); } 17. 找出字符串中第一个只出现一次的字符\r#\r描述\n找出字符串中第一个只出现一次的字符 数据范围：输入的字符串长度满足1≤n≤1000 输入描述：输入一个非空字符串 输出描述：输出第一个只出现一次的字符，如果不存在输出-1 输入：asdfasdfo 输出：o 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); String str = in.nextLine(); for (int i = 0; i \u0026lt; str.length(); i++) { char ch = str.charAt(i); if (str.indexOf(ch) == str.lastIndexOf(ch)) { System.out.println(ch); return; } } System.out.println(-1); } 18. 输入n个整数，输出其中最小的K个\r#\r描述\n输入n个整数，找出其中最小的k个整数并按升序输出 本题有多组输入样例 数据范围：1≤n≤1000，输入的整数满足 1≤val≤10000 输入描述：第一行输入两个整数n和k，第二行输入一个整数数组 输出描述：从小到大输出最小的k个整数，用空格分开。 输入：5 2 1 3 5 7 2 输出：1 2 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); while (in.hasNext()) { int n = in.nextInt(); int k = in.nextInt(); int[] arr = new int[n]; for (int i = 0; i \u0026lt; n; i++) { arr[i] = in.nextInt(); } Arrays.sort(arr); StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; k; i++) { sb.append(arr[i]).append(\u0026#34; \u0026#34;); } System.out.println(sb.toString().trim()); } } 19. 字符串字符匹配\r#\r描述\n判断短字符串S中的所有字符是否在长字符串T中全部出现。 请注意本题有多组样例输入。 数据范围：1≤len(S),len(T)≤200 输入描述：输入两个字符串。第一个为短字符串，第二个为长字符串。两个字符串均由小写字母组成。 输出描述：如果短字符串的所有字符均在长字符串中出现过，则输出字符串\u0026#34;true\u0026#34;。否则输出字符串\u0026#34;false\u0026#34;。 输入：bc abc 输出：true 说明：其中abc含有bc，输出\u0026#34;true\u0026#34; 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); while (in.hasNext()) { String shortStr = in.nextLine(); String longStr = in.nextLine(); Set\u0026lt;Character\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; shortStr.length(); ++i) { set.add(shortStr.charAt(i)); } for (int i = 0; i \u0026lt; longStr.length(); ++i) { set.remove(longStr.charAt(i)); } System.out.println(set.isEmpty()); } } "},{"id":26,"href":"/interview/program-design/structure-algorithm/leetcode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","title":"滑动窗口","section":"leetcode","content":"\r滑动窗口\r#\r滑动窗口\r#\r使用两个指针划出一个窗口，并维护窗口数据的有效性 无重复字符的最长子串\r#\r原题\n给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。 输入: s = \u0026#34;abcabcbb\u0026#34; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026#34;abc\u0026#34;，所以其长度为 3。 题解\n1、窗口内是无重复子串 2、在窗口右端追加一个字符，则要判断窗口内是否已经存在该字符 3、如果存在，则要去除窗口内重复字符位置左端的所有字符 // 滑动窗口 public class Main { public int lengthOfLongestSubstring(String s) { // 窗口 Set\u0026lt;Character\u0026gt; occ = new HashSet\u0026lt;\u0026gt;(); int ans = 0; int left = 0; for (int right = 0; right \u0026lt; s.length(); right++) { while (occ.contains(s.charAt(right))) { occ.remove(s.charAt(left++)); } occ.add(s.charAt(right)); ans = Math.max(ans, right - left + 1); } return ans; } } // 加入哈希 public class Main { public int lengthOfLongestSubstringHash(String s) { HashMap\u0026lt;Character, Integer\u0026gt; keyIndex = new HashMap\u0026lt;\u0026gt;(); int length = s.length(); int maxLength = 0; int lashIndex = 0; for (int i = 0; i \u0026lt; length ; i++) { final char c = s.charAt(i); if (keyIndex.containsKey(c)) { lashIndex = Math.max(keyIndex.get(c) + 1, lashIndex); } keyIndex.put(c, i); int currLength = i - lashIndex + 1; if (maxLength \u0026lt; currLength) { maxLength = currLength; } } return maxLength; } } 找到字符串中所有字母异位词\r#\r原题\n给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。 输入: s = \u0026#34;cbaebabacd\u0026#34;, p = \u0026#34;abc\u0026#34; 输出: [0,6] 解释: 起始索引等于 0 的子串是 \u0026#34;cba\u0026#34;, 它是 \u0026#34;abc\u0026#34; 的异位词。 起始索引等于 6 的子串是 \u0026#34;bac\u0026#34;, 它是 \u0026#34;abc\u0026#34; 的异位词。 题解\npublic class Main { public List\u0026lt;Integer\u0026gt; findAnagrams(String s, String p) { List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); if (s.length() \u0026lt; p.length()) { return ans; } // 窗口 int[] sCount = count(s, p.length() - 1); int[] target = count(p, p.length()); for (int i = 0; i \u0026lt; s.length() - p.length() + 1; i++) { sCount[s.charAt(i + p.length() - 1) - \u0026#39;a\u0026#39;]++; if (Arrays.equals(target, sCount)) { ans.add(i); } sCount[s.charAt(i) - \u0026#39;a\u0026#39;]--; } return ans; } private int[] count(String s, int end) { int[] ans = new int[26]; for (int i = 0; i \u0026lt; end; i++) { final int c = s.charAt(i) - \u0026#39;a\u0026#39;; ans[c]++; } return ans; } } "},{"id":27,"href":"/interview/program-design/structure-algorithm/dir/","title":"目录","section":"数据结构与算法","content":" 必会 1. 数组 2. 字符串 3. 排序 4. 贪心 5. 递归 6. 循环 7. 滑窗 8. 栈 9. 进制转换 10. 位运算 11. 队列 12. 哈希表 13. 链表 14. 线性表 15. 二分查找 进阶 1. 图 2. 树 3. DFS搜索 4. BFS搜索 5. 动态规划 6. 前缀和 7. 排列组合 8. 矩阵 9. 双指针 10. 回溯 11. 状态机 12. 并查集 13. 正则表达式 14. 分治 15. 枚举 16. 统计 建议 必会部分知识点倾向于出现在100分题中，进阶知识点倾向于出现在200分题中。 建议必会部分优先掌握1-10知识点， 进阶部分优先掌握1-4知识点，这部分出现频次高，短时间内刷题性价比高。 import java.util.Scanner; // 注意类名必须为 Main, 不要有任何 package xxx 信息 public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 注意 hasNext 和 hasNextLine 的区别 while (in.hasNext()) { // 注意 while 处理多个 case Long a = in.nextLong(); Long b = in.nextLong(); System.out.println(a + b); } } } ASCII 48-57：0-9\r65-90：A-Z\r97-122：a-z 输入 //1. Scanner in = new Scanner(System.in); // InputStream is = System.in; // BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); ## 1\r- 原题\r```html\r```\r- 题解\r```html\r```\r```java\rpublic class Main {\r}\r```\r"},{"id":28,"href":"/interview/program-design/structure-algorithm/leetcode/%E5%AD%90%E4%B8%B2/","title":"子串","section":"leetcode","content":"\r子串\r#\r子串\r#\r长串数据中一段连续的数据 和为 K 的子数组\r#\r原题\n给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。 子数组是数组中元素的连续非空序列。 输入：nums = [1,1,1], k = 2 输出：2 题解\n1、遍历数组，计算nums[0]到nums[i]的和pre 2、使用哈希表存储键值对，键为pre，值为次数 3、如果哈希表存在键pre-k，则代表存在一个子数组，该子数组末端到nums[i]之间的数字之和等于k 问题转为：pre[i]−pre[j−1]==k （前缀和之差为k，代表这两个前缀之间的数字相加就是K） public class Main { public int subarraySum(int[] nums, int k) { HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(0, 1); int pre = 0; int count = 0; for (int i = 0; i \u0026lt; nums.length; i++) { pre += nums[i]; if (map.containsKey(pre - k)) { count += map.get(pre - k); } map.put(pre, map.getOrDefault(pre, 0) + 1); } return count; } } 1\r#\r原题\n题解\npublic class Main { } 1\r#\r原题\n题解\npublic class Main { } "},{"id":29,"href":"/interview/service-manage/nginx/","title":"Nginx","section":"服务治理","content":"\r\u0026ndash; Nginx\r#\r是一个开源的高性能 HTTP 服务器和反向代理服务器\n优点： 1. 高并发、高可靠性、低内存消耗 2. 配置简单、支持热部署 3. 良好的负载均衡和缓存功能 \u0026ndash; Nginx 处理HTTP请求\r#\rNginx 是一个高性能的 Web 服务器，能够同时处理大量的并发请求\n1. 多进程机制 Nginx包含一个主进程和多个工作进程。 主进程主要负责调度管理工作进程，工作进程则负责处理用户的请求 2. 异步非阻塞机制 工作进程接收到客户端的请求以后，会调用IO进行处理， 当发生等待时，工作线程会注册一个事件，转而去处理其他的请求 当IO返回时，就会触发该事件，工作线程会继续执行该未完成的请求 \u0026ndash; 正向代理、反向代理\r#\r正向代理\n1. 是一个代理服务器，它代表客户端向目标服务器发起请求。 2. 代理的对象是客户端，对外隐藏了真实的客户端 反向代理\n1. 是一个代理服务器，它代表服务端向客户端提供服务 2. 代理的对象是服务端，对外隐藏了真实的服务端 "},{"id":30,"href":"/interview/service-manage/dubbo/","title":"Dubbo","section":"服务治理","content":"\r\u0026ndash; Dubbo\r#\r是一款高性能、轻量级的开源Java RPC框架 \u0026ndash; Dubbo 工作原理\r#\r0. 服务容器负责启动、加载、运行服务提供者。 1. 服务提供者向注册中心注册自己提供的服务 2. 服务消费者向注册中心订阅自己消费的服务 3. 注册中心通知服务消费者，服务节点的变更 4. 服务消费者基于负载均衡算法，从服务列表中选一台进行调用 5. 服务消费者/提供者，将调用信息发送到监控中心 \u0026ndash; Dubbo 负载均衡策略\r#\r策略 策略 说明 随机策略 random 随机选择一个可用的服务节点 轮询策略 roundrobin 按公平轮询的方式选择服务节点 最少活跃数策略 leastactive 优先选择活跃调用数最少的服务节点 一致性哈希策略 consistenthash 通过哈希算法将相同参数的请求发送到同一个服务节点 \u0026ndash; Dubbo、Spring Cloud\r#\rDubbo Spring Cloud 所属厂商 阿里系的分布式服务治理框架 Apache 旗下的 Spring 体系下的微服务解决方案 通信机制 RPC 通信 基于 HTTP 的 REST 方式 技术维度 只是实现了服务治理 覆盖了微服务架构下的方方面面 \u0026ndash; Dubbo、Zookeeper\r#\rDubbo推荐使用Zookeeper作为服务的注册中心\n1. Dubbo是管理中间层的工具，在业务层到数据仓库间，有很多服务需要接入和调度，dubbo提供一个框架解决这个问题 2. Dubbo有多种注册中心供选择，使用Zookeeper，是为了引入Zookeeper特性 \u0026ndash; RPC、REST\r#\rRPC\n1. RPC，远程过程调用，是一种进程间通信方式 2. 优点：调用简单、性能高、低延迟、自带负载均衡 3. 缺点：耦合性强、无法跨语言，平台敏感 REST\n1. REST，即RESTful ，是一种架构风格，指的是一组架构约束条件和原则。 2. 优点：耦合性低，兼容性好，通用性好，跨语言支持 3. 缺点：性能不如 RPC 高 RPC、REST\nRPC适用于内网服务调用，对外提供服务请走REST。 IO密集的服务调用用RPC，低频服务用REST 服务调用过于密集与复杂，RPC就比较适用 "},{"id":31,"href":"/interview/service-manage/zookeeper/","title":"Zookeeper","section":"服务治理","content":"\r\u0026ndash; Zookeeper\r#\r是一个开源的分布式的服务协调框架 特点 说明 数据一致性 每个server都保存了一份相同的数据副本，client无论连接到哪个server，数据都是一致的 请求顺序性 来自同一个client的更新请求，其发送顺序和最后的执行顺序是一致的 可靠性 当一个消息被成功更新后，不会因为网络波动或其他原因而回滚 原子性 更新要不成功要不失败，没有第三个状态 独立性 不同的client之间互不影响 实时性 在一定时间范围内，client能读到最新数据 \u0026ndash; Zookeeper 角色\r#\r角色 角色 说明 Leader 领导者 为客户端提供读服务和写服务。管理集群内的所有事务的顺序，以及维护集群状态的同步 Follower 跟随者 为客户端提供读服务，参与Leader选举过程 Observer 观察者 为客户端提供读服务，不参与Leader选举过程 \u0026ndash; Zookeeper 应用场景\r#\r1. 数据发布与订阅 2. 命名服务 3. 配置管理 4. 集群管理 5. 分布式通知与协调 6. 分布式锁 7. 分布式队列 \u0026ndash; Zookeeper 工作原理\r#\r1. Zookeeper是基于观察者模式设计，接受观察者的注册 2. Zookeeper上存储和管理着大家都关心的数据 3. 当这些数据发生变化时，Zookeeper将会通知已注册的观察者做出相应的回应 \u0026ndash; Zookeeper 通知机制\r#\r1. Zookeeper允许客户端向服务端的某个znode注册一个Watcher监听 2. 当服务端的一些指定事件触发了这个Watcher，服务端会向指定客户端发送一个事件通知 3. 客户端根据Watcher通知状态和事件类型做出业务上的改变 \u0026ndash; Zookeeper 选举原则\r#\r1. Zookeeper 集群中只有超过半数以上的服务器启动，集群才能正常工作； 2. 在集群正常工作之前，myid 小的服务器给 myid 大的服务器投票，直到集群正常工作，选出 Leader； 3. 选出Leader之后，之前的服务器状态由 Looking 改变为 Following，以后的服务器都是 Follower。 \u0026ndash; Zookeeper 选举过程\r#\r假设：有五台服务器，从S1-S5 依序启动\nS1启动，发起选举\nS1投自己一票 此时S1为1票，不够半数以上，选举无法完成； S2启动，发起选举\nS2投自己一票，然后与S1交换选票，因为S2的ServerID大于S1，S1更改投S2 此时S1为0票，S2为2票，不够半数以上，选举无法完成； S3启动，发起选举\nS3投自己一票，然后与S1、S2交换选票，因为S3的ServerID最大，S1、S2更改投S3 此时S1、S2为0票，S3为3票，S3票数已经超过半数当选Leader； S4启动，发起选举\nS4投自己一票，然后相互交换选票，因为S1、S2、S3已经不是LOOKING状态，不会更改选票信息。 此时S3为3票，S4为1票，S4服从多数改投S3 S5启动，发起选举\n同4一样，S5改投S3， 最终S3是Leader，状态为LEADING； 其余服务器是Follower，状态为FOLLOWING。 \u0026ndash; Zookeeper 监听原理\r#\r1. 在Main()主线程中创建zkClient客户端。 2. zkClient会创建两个线程，一个负责网络连接通信（connet），一个负责监听（listener）。 3. zkClient通过connet线程，将监听事件注册到Zookeeper的监听列表。 4. 当数据或路径发生改变时，Zookeeper会将消息发送给listener线程。 5. listener线程调用process()方法，执行相应的操作。 "},{"id":32,"href":"/interview/program-design/structure-algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%931/","title":"机试题库 - 1","section":"华为OD","content":"\r01.\r#\r描述\n题解\n02.\r#\r描述\n题解\n03.\r#\r描述\n题解\n04.\r#\r描述\n题解\n05.\r#\r描述\n题解\n06.\r#\r描述\n题解\n07.\r#\r描述\n题解\n08.\r#\r描述\n题解\n09.\r#\r描述\n题解\n10.\r#\r描述\n题解\n11.\r#\r描述\n题解\n12.\r#\r描述\n题解\n13.\r#\r描述\n题解\n14.\r#\r描述\n题解\n15.\r#\r描述\n题解\n16.\r#\r描述\n题解\n17.\r#\r描述\n题解\n18.\r#\r描述\n题解\n19.\r#\r描述\n题解\n20.\r#\r描述\n题解\n21.\r#\r描述\n题解\n22.\r#\r描述\n题解\n23.\r#\r描述\n题解\n24.\r#\r描述\n题解\n25.\r#\r描述\n题解\n"},{"id":33,"href":"/interview/program-design/structure-algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%932/","title":"机试题库 - 2","section":"华为OD","content":"\r01.\r#\r描述\n题解\n02.\r#\r描述\n题解\n03.\r#\r描述\n题解\n04.\r#\r描述\n题解\n05.\r#\r描述\n题解\n06.\r#\r描述\n题解\n07.\r#\r描述\n题解\n08.\r#\r描述\n题解\n09.\r#\r描述\n题解\n10.\r#\r描述\n题解\n11.\r#\r描述\n题解\n12.\r#\r描述\n题解\n13.\r#\r描述\n题解\n14.\r#\r描述\n题解\n15.\r#\r描述\n题解\n16.\r#\r描述\n题解\n17.\r#\r描述\n题解\n18.\r#\r描述\n题解\n19.\r#\r描述\n题解\n20.\r#\r描述\n题解\n21.\r#\r描述\n题解\n22.\r#\r描述\n题解\n23.\r#\r描述\n题解\n24.\r#\r描述\n题解\n25.\r#\r描述\n题解\n"},{"id":34,"href":"/interview/program-design/structure-algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%933/","title":"机试题库 - 3","section":"华为OD","content":"\r01.\r#\r描述\n题解\n02.\r#\r描述\n题解\n03.\r#\r描述\n题解\n04.\r#\r描述\n题解\n05.\r#\r描述\n题解\n06.\r#\r描述\n题解\n07.\r#\r描述\n题解\n08.\r#\r描述\n题解\n09.\r#\r描述\n题解\n10.\r#\r描述\n题解\n11.\r#\r描述\n题解\n12.\r#\r描述\n题解\n13.\r#\r描述\n题解\n14.\r#\r描述\n题解\n15.\r#\r描述\n题解\n16.\r#\r描述\n题解\n17.\r#\r描述\n题解\n18.\r#\r描述\n题解\n19.\r#\r描述\n题解\n20.\r#\r描述\n题解\n21.\r#\r描述\n题解\n22.\r#\r描述\n题解\n23.\r#\r描述\n题解\n24.\r#\r描述\n题解\n25.\r#\r描述\n题解\n"},{"id":35,"href":"/interview/program-design/structure-algorithm/huawei-od/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/","title":"华为机试","section":"华为OD","content":"\rHJ1：字符串最后一个单词的长度\r#\r描述\n计算字符串最后一个单词的长度，单词以空格隔开，字符串长度小于5000。（注：字符串末尾不以空格为结尾） 输入描述：输入一行，代表要计算的字符串，非空，长度小于5000。 输出描述：输出一个整数，表示输入字符串最后一个单词的长度。 输入：hello nowcoder 输出：8 题解\n// 遍历字符串，每遍历一个字符，length++ // 如果遇到空格，则length归零 public static void main(String[] args) throws Exception{ InputStream InputStream = System.in; int length = 0; char c; while (\u0026#39;\\n\u0026#39; != (c=(char)InputStream.read())) { length++; if (c == \u0026#39; \u0026#39;) { length = 0; } } System.out.println(length); } HJ2：计算某字符出现次数\r#\r描述\n写出一个程序，接受一个由字母、数字和空格组成的字符串，和一个字符，然后输出输入字符串中该字符的出现次数。（不区分大小写字母） 数据范围：1 ≤ n ≤ 1000 输入描述：第一行输入一个由字母、数字和空格组成的字符串，第二行输入一个字符（保证该字符不为空格）。 输出描述：输出输入字符串中含有该字符的个数。（不区分大小写字母） 输入：ABCabc A 输出：2 题解\n// 字符串转为小写 // 遍历字符串数组，判断字符相等，累加count++ public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); char[] chars1 = br.readLine().toLowerCase().toCharArray(); char[] chars2 = br.readLine().toLowerCase().toCharArray(); int count = 0; for (int i = 0; i \u0026lt; chars1.length; i++) { if (chars1[i] == chars2[0]) { count++; } } System.out.println(count); } HJ3：明明的随机数\r#\r描述\n明明生成了个1到500之间的随机整数。请你删去其中重复的数字， 即相同的数字只保留一个，把其余相同的数去掉，然后再把这些数从小到大排序，按照排好的顺序输出。 数据范围：1≤n≤1000 ，输入的数字大小满足 1≤val≤500 输入描述：第一行先输入随机整数的个数 N 。 接下来的 N 行每行输入一个整数，代表明明生成的随机数。 输出描述：输出多行，表示输入数据处理后的结果 输入：3 2 2 1 输出：1 2 题解\n// 数组下标不重复，且有序 public static void main(String[] args)throws IOException { BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); String str; while((str=bf.readLine())!=null) { boolean[] stu = new boolean[1001]; StringBuilder sb=new StringBuilder(); int n = Integer.parseInt(str); for(int i=0;i\u0026lt;n;i++) { stu[Integer.parseInt(bf.readLine())] = true; } for(int i=1;i\u0026lt;1001;i++) { if(stu[i]) { sb.append(i).append(\u0026#34;\\n\u0026#34;); } } sb.deleteCharAt(sb.length()-1); System.out.println(sb.toString()); } } HJ4：字符串分隔\r#\r描述\n输入一个字符串，请按长度为8拆分每个输入字符串并进行输出； 长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。 输入描述：连续输入字符串(每个字符串长度小于等于100) 输出描述：依次输出所有分割后的长度为8的新字符串 输入：abc 输出：abc00000 题解\n// 足够8的部分：直接打印输出，记录字符位置 // 不足8的部分：构造零值数组，再放入字符，最后打印输出 public static void main(String[] args) throws IOException{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str; while((str = br.readLine())!=null){ int len = str.length(); int start = 0; while (len \u0026gt;= 8){ System.out.println(str.substring(start, start + 8)); start += 8; len -= 8; } if (len \u0026gt; 0) { char[] tmp = new char[8]; for(int i = 0;i\u0026lt;8;i++){ tmp[i]=\u0026#39;0\u0026#39;; } for(int i = 0; start \u0026lt; str.length(); i++) { tmp[i] = str.charAt(start++); } System.out.println(String.valueOf(tmp)); } } } HJ5：进制转换\r#\r描述\n写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。 数据范围：保证结果在1≤n≤2^31−1 输入描述：输入一个十六进制的数值字符串。 输出描述：输出该数值的十进制字符串。不同组的测试用例用\\n隔开。 示例： 输入：0xAA 输出：170 题解\n// 判断字符：ASCII码值大于等于65 // 字符代表的值：charNum-65+10 // 数字代表的值：charNum-48 public static void main(String[] args) throws IOException{ BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); String input; while((input = bf.readLine())!=null){ String temp = input.substring(2,input.length()); int sum = 0; int length = temp.length(); for(int i= length-1;i\u0026gt;=0;i--){ char c = temp.charAt(i); int tempNum = (int)c; if(tempNum\u0026gt;=65){ tempNum = tempNum - 65 + 10; }else{ tempNum = tempNum - 48; } sum = sum + (int) Math.pow(16, length-i-1)*tempNum; } System.out.println(sum); } } HJ6：质数因子\r#\r描述\n功能:输入一个正整数，按照从小到大的顺序输出它的所有质因子（重复的也要列举）（如180的质因子为2 2 3 3 5 ） 数据范围：1≤n≤2×10^9+14 输入描述：输入一个整数 输出描述：按照从小到大的顺序输出它的所有质数的因子，以空格隔开。 输入：180 输出：2 2 3 3 5 题解\n// 质数：又叫素数，指的是在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数 // 质数因子：能整除给定正整数的质数 public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str; while ((str = br.readLine()) != null) { int num = Integer.parseInt(str); StringBuilder sb = new StringBuilder(); for (int i = 2; i \u0026lt;= Math.sqrt(num); i++) { if (num % i == 0) { sb.append(i).append(\u0026#34; \u0026#34;); num = num / i; i--; } } sb.append(num).append(\u0026#34; \u0026#34;); System.out.println(sb.toString()); } } HJ7：取近似值\r#\r描述\n写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于 0.5 ,向上取整；小于 0.5 ，则向下取整。 数据范围：保证输入的数字在 32 位浮点数范围内 输入描述：输入一个正浮点数值 输出描述：输出该数值的近似整数值 输入：5.5 输出：6 题解\n// 判断小数点位置，及小数点后一位是否大于等于5 public static void main(String args[])throws Exception{ BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); String str = bf.readLine(); int index = str.indexOf(\u0026#34;.\u0026#34;); int a = Integer.parseInt(str.substring(0, index)); int b = Integer.parseInt(str.substring(index + 1, index + 2)); if(b \u0026gt;= 5){ a++; System.out.println(a); }else{ System.out.println(a); } } HJ8：合并表记录\r#\r描述\n数据表记录包含表索引index和数值value（int范围的正整数），请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照index值升序进行输出。 提示：0≤index≤11111111、1≤value≤100000 输入描述：先输入键值对的个数n（1≤n≤500），接下来n行每行输入成对的index和value值，以空格隔开 输出描述：输出合并后的键值对（多行） 输入：4 0 1 0 2 1 2 3 4 输出：0 3 1 2 3 4 题解\n// 使用HashMap // 使用jdk8流排序 public static void main(String[] args){ Scanner input = new Scanner(System.in); int size = input.nextInt(); Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; size; i++) { int key = input.nextInt(); int value = input.nextInt(); if (map.containsKey(key)) { map.put(key, map.get(key) + value); } else { map.put(key, value); } } List\u0026lt;Integer\u0026gt; list = map.keySet().stream().sorted().collect( Collectors.toList()); for (Integer key : list) { System.out.println( key + \u0026#34; \u0026#34; + map.get(key)); } } HJ9：提取不重复的整数\r#\r描述\n输入一个 int 型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。 保证输入的整数最后一位不是 0 。 数据范围：1≤n≤10^8 输入描述：输入一个int型整数 输出描述：按照从右向左的阅读顺序，返回一个不含重复数字的新的整数 输入：9876673 输出：37689 题解\n// String.charAt() // 去重判断：String.contains() public static void main(String[] args) { Scanner in = new Scanner(System.in); while (in.hasNextLine()) { String str1=in.nextLine(); String str2=\u0026#34;\u0026#34;; for(int i=str1.length()-1;i\u0026gt;=0;i--){ String c=String.valueOf(str1.charAt(i)); if(!str2.contains(c)){ str2=str2+c; } } System.out.println(str2); } } HJ10：字符个数统计\r#\r描述\n编写一个函数，计算字符串中含有的不同字符的个数。字符在 ASCII 码范围内( 0~127 ，包括 0 和 127 )，换行表示结束符，不算在字符里。不在范围内的不作统计。多个相同的字符只计算一次 例如，对于字符串 abaca 而言，有 a、b、c 三种不同的字符，因此输出 3 。 数据范围：1≤n≤500 输入描述：输入一行没有空格的字符串。 输出描述：输出 输入字符串 中范围在(0~127，包括0和127)字符的种数。 输入：abc 输出：3 题解\n// String.charAt() // 数组下标不重复，且有序 public static void main(String[] args) { Scanner in = new Scanner(System.in); while (in.hasNextLine()) { String s = in.nextLine(); int[] a = new int[128]; int count = 0; for (int i = 0; i \u0026lt; s.length(); i++) { char b = s.charAt(i); if (a[b] == 0) { count++; a[b] = 1; } } System.out.println(count); } } HJ11：数字颠倒\r#\r描述\n输入一个整数，将这个整数以字符串的形式逆序输出 程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001 数据范围：0≤n≤2^30−1 输入描述：输入一个int整数 输出描述：将这个整数以字符串的形式逆序输出 输入：1516000 输出：0006151 题解\n// 反转StringBuilder.reverse() public static void main(String[] args) { Scanner in = new Scanner(System.in); while (in.hasNextLine()) { String input=in.nextLine(); StringBuilder sb=new StringBuilder(input); sb.reverse(); System.out.println(sb.toString()); } } HJ12：字符串反转\r#\r描述\n接受一个只包含小写字母的字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000） 输入描述：输入一行，为一个只包含小写字母的字符串。 输出描述：输出该字符串反转后的字符串。 输入：abcd 输出：dcba 题解\n同HJ11 HJ13：句子逆序\r#\r描述\n将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I” 所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符 数据范围：输入的字符串长度满足1≤n≤1000，注意本题有多组输入 输入描述：输入一个英文语句，每个单词用空格隔开。保证输入只包含空格和字母。 输出描述：得到逆序的句子 输入：I am a boy 输出：boy a am I 题解\n// 字符串分割String.split() public static void main(String[] args) { Scanner in = new Scanner(System.in); while (in.hasNextLine()) { String line=in.nextLine(); String[] arr=line.split(\u0026#34; \u0026#34;); List\u0026lt;String\u0026gt; list=new ArrayList\u0026lt;\u0026gt;(); for(int i=arr.length-1;i\u0026gt;=0;i--){ list.add(arr[i]); } System.out.println(String.join(\u0026#34; \u0026#34;,list)); } } HJ14：字符串排序\r#\r描述\n给定 n 个字符串，请对 n 个字符串按照字典序排列。 数据范围：1≤n≤1000，字符串长度满足 1≤len≤100 输入描述：输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。 输出描述：数据输出n行，输出结果为按照字典序排列的字符串。 输入：5 cap to cat boat boot 输出：boat boot cap cat to 题解\n// 排序Arrays.sort() public static void main(String[] args) { Scanner in = new Scanner(System.in); while (in.hasNextLine()) { int sum = Integer.valueOf(in.nextLine()); String[] arr = new String[sum]; for (int i = 0; i \u0026lt; sum; i++) { arr[i] = in.nextLine(); } Arrays.sort(arr); for (int j = 0; j \u0026lt; sum; j++) { System.out.println(arr[j]); } } } HJ15：求int型正整数在内存中存储时1的个数\r#\r描述\n输入一个 int 型的正整数，计算出该 int 型数据在内存中存储时 1 的个数。 数据范围：保证在 32 位整型数字范围内 输入描述：输入一个整数（int类型） 输出描述：这个数转换成2进制后，输出1的个数 输入：5 输出：2 题解\n// 十进制转二进制Integer.toBinaryString() public static void main(String[] args) { Scanner in = new Scanner(System.in); while (in.hasNextLine()) { int num=Integer.valueOf(in.nextLine()); char[] arr=Integer.toBinaryString(num).toCharArray(); int count=0; for (int i = 0; i \u0026lt; arr.length; i++) { if(arr[i]==\u0026#39;1\u0026#39;){ count++; } } System.out.println(count); } } \u0026ndash;HJ16：购物单\r#\r王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的 如果要买归类为附件的物品，必须先买该附件所属的主件，且每件物品只能购买一次。 每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。 王强查到了每件物品的价格（都是 10 元的整数倍），而他只有 N 元的预算。除此之外，他给每件物品规定了一个重要度，用整数 1 ~ 5 表示。他希望在花费不超过 N 元的前提下，使自己的满意度达到最大。 满意度是指所购买的每件物品的价格与重要度的乘积的总和，假设设第i件物品的价格为v[i]，重要度为w[i]，共选中了k件物品， 编号依次为j1、j2、...、jk，则满意度为：v[j1]*w[j1]+v[j2]*w[j2]+...+v[jk]*w[jk]。（其中 * 为乘号） 请你帮助王强计算可获得的最大的满意度。 输入描述： 输入的第 1 行，为两个正整数N，m，用一个空格隔开：（其中 N （ N\u0026lt;32000 ）表示总钱数， m （m \u0026lt;60 ）为可购买的物品的个数。） 从第 2 行到第 m+1 行，第 j 行给出了编号为 j-1 的物品的基本数据，每行有 3 个非负整数 v p q （其中 v 表示该物品的价格（ v\u0026lt;10000 ）， p 表示该物品的重要度（ 1 ~ 5 ）， q 表示该物品是主件还是附件。如果 q=0 ，表示该物品为主件，如果 q\u0026gt;0 ，表示该物品为附件， q 是所属主件的编号） 输出描述： 输出一个正整数，为张强可以获得的最大的满意度。 输入：1000 5 800 2 0 400 5 1 300 5 1 400 3 0 500 2 0 输出：2200 题解\nHJ17：坐标移动\r#\r描述\n开发一个坐标计算工具， A表示向左移动，D表示向右移动，W表示向上移动，S表示向下移动。从（0,0）点开始移动，从输入字符串里面读取一些坐标，并将最终输入结果输出到输出文件里面。 输入：合法坐标为A(或者D或者W或者S) + 数字（两位以内），坐标之间以;分隔。非法坐标点需要进行丢弃。 数据范围：每组输入的字符串长度满足1≤n≤10000，坐标保证满足-2^31 ≤ x,y ≤ 2^31-1，且数字部分仅含正数 输入描述：一行字符串 输出描述：最终坐标，以逗号分隔 输入：A10;S20;W10;D30;X;A1A;B10A11;;A10; 输出：10,-10 题解\npublic static void main(String[] args) throws IOException { BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); String[] in = bf.readLine().split(\u0026#34;;\u0026#34;); int x = 0; int y = 0; for(String s : in){ if(!s.matches(\u0026#34;[WASD][0-9]{1,2}\u0026#34;)){ continue; } int val = Integer.valueOf(s.substring(1)); switch(s.charAt(0)){ case \u0026#39;W\u0026#39;: y += val; break; case \u0026#39;S\u0026#39;: y -= val; break; case \u0026#39;A\u0026#39;: x -= val; break; case \u0026#39;D\u0026#39;: x += val; break; } } System.out.println(x+\u0026#34;,\u0026#34;+y); } HJ18：识别有效的IP地址和掩码并进行分类统计\r#\r描述\n请解析IP地址和对应的掩码，进行分类识别。要求按照A/B/C/D/E类地址归类，不合法的地址和掩码单独归类。 所有的IP地址划分为 A,B,C,D,E五类 A类地址从1.0.0.0到126.255.255.255 B类地址从128.0.0.0到191.255.255.255 C类地址从192.0.0.0到223.255.255.255 D类地址从224.0.0.0到239.255.255.255 E类地址从240.0.0.0到255.255.255.255 私网IP范围是： 从10.0.0.0到10.255.255.255 从172.16.0.0到172.31.255.255 从192.168.0.0到192.168.255.255 子网掩码为二进制下前面是连续的1，然后全是0。 例如：255.255.255.32就是一个非法的掩码，注意二进制下全是1或者全是0均为非法子网掩码 注意： 1. 类似于【0.*.*.*】和【127.*.*.*】的IP地址不属于上述输入的任意一类，也不属于不合法ip地址，计数时请忽略 2. 私有IP地址和A,B,C,D,E类地址是不冲突的 输入描述：多行字符串。每行一个IP地址和掩码，用~隔开。 输出描述：统计A、B、C、D、E、错误IP地址或错误掩码、私有IP的个数，之间以空格隔开。 输入：10.70.44.68~255.254.255.0 1.0.0.1~255.0.0.0 192.168.0.2~255.255.255.0 19..0.~255.255.255.0 输出：1 0 1 0 0 2 1 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int aNum = 0; int bNum = 0; int cNum = 0; int dNum = 0; int eNum = 0; int errNum = 0; int pNum = 0; while (sc.hasNextLine()) { String str = sc.nextLine(); String[] strArr = str.split(\u0026#34;~\u0026#34;); int ipFirst = getIpSeg(strArr[0], 0); if (ipFirst == 0 || ipFirst == 127) { continue; } if (maskIsInvaild(strArr[1])) { errNum++; continue; } if (ipIsInvaild(strArr[0])) { errNum++; continue; } if (ipFirst \u0026gt;= 1 \u0026amp;\u0026amp; ipFirst \u0026lt;= 126) { aNum++; } if (ipFirst \u0026gt;= 128 \u0026amp;\u0026amp; ipFirst \u0026lt;= 191) { bNum++; } if (ipFirst \u0026gt;= 192 \u0026amp;\u0026amp; ipFirst \u0026lt;= 223) { cNum++; } if (ipFirst \u0026gt;= 224 \u0026amp;\u0026amp; ipFirst \u0026lt;= 239) { dNum++; } if (ipFirst \u0026gt;= 240 \u0026amp;\u0026amp; ipFirst \u0026lt;= 255) { eNum++; } int ipSecond = getIpSeg(strArr[0], 1); if (ipFirst == 10 || (ipFirst == 172 \u0026amp;\u0026amp; ipSecond \u0026gt;= 16 \u0026amp;\u0026amp; ipSecond \u0026lt;= 31) || (ipFirst == 192 \u0026amp;\u0026amp; ipSecond == 168)) { pNum++; } } System.out.println(aNum + \u0026#34; \u0026#34; + bNum + \u0026#34; \u0026#34; + cNum + \u0026#34; \u0026#34; + dNum + \u0026#34; \u0026#34; + eNum + \u0026#34; \u0026#34; + errNum + \u0026#34; \u0026#34; + pNum); } public static boolean maskIsInvaild(String mask) { String[] maskArr = mask.split(\u0026#34;\\\\.\u0026#34;); if (maskArr.length != 4) { return true; } String maskBinary = toBinary(maskArr[0]) + toBinary(maskArr[1]) + toBinary(maskArr[2]) + toBinary(maskArr[3]); if (!maskBinary.matches(\u0026#34;[1]{1,}[0]{1,}\u0026#34;)) { return true; } return false; } public static String toBinary(String num) { String numBinary = Integer.toBinaryString(Integer.valueOf(num)); while (numBinary.length() \u0026lt; 8) { numBinary = \u0026#34;0\u0026#34; + numBinary; } return numBinary; } public static boolean ipIsInvaild(String ip) { String[] ipArr = ip.split(\u0026#34;\\\\.\u0026#34;); if (ipArr.length != 4) { return true; } if (Integer.valueOf(ipArr[0]) \u0026gt; 255 || Integer.valueOf(ipArr[1]) \u0026gt; 255 || Integer.valueOf(ipArr[2]) \u0026gt; 255 || Integer.valueOf(ipArr[3]) \u0026gt; 255) { return true; } return false; } public static int getIpSeg(String ip, int index) { String[] ipArr = ip.split(\u0026#34;\\\\.\u0026#34;); return Integer.valueOf(ipArr[index]); } HJ19：简单错误记录\r#\r描述\n开发一个简单错误记录功能小模块，能够记录出错的代码所在的文件名称和行号。 处理： 1、 记录最多8条错误记录，循环记录，最后只用输出最后出现的八条错误记录。对相同的错误记录只记录一条，但是错误计数增加。最后一个斜杠后面的带后缀名的部分（保留最后16位）和行号完全匹配的记录才做算是“相同”的错误记录。 2、 超过16个字符的文件名称，只记录文件的最后有效16个字符； 3、 输入的文件可能带路径，记录文件名称不能带路径。也就是说，哪怕不同路径下的文件，如果它们的名字的后16个字符相同，也被视为相同的错误记录 4、循环记录时，只以第一次出现的顺序为准，后面重复的不会更新它的出现时间，仍以第一次为准 数据范围：错误记录数量满足1≤n≤100，每条记录长度满足1≤len≤100 输入描述：每组只包含一个测试用例。一个测试用例包含一行或多行字符串。每行包括带路径文件名称，行号，以空格隔开。 输出描述：将所有的记录统计并将结果输出，格式：文件名 代码行数 数目，一个空格隔开 输入：D:\\zwtymj\\xccb\\ljj\\cqzlyaszjvlsjmkwoqijggmybr 645 E:\\je\\rzuwnjvnuz 633 C:\\km\\tgjwpb\\gy\\atl 637 F:\\weioj\\hadd\\connsh\\rwyfvzsopsuiqjnr 647 E:\\ns\\mfwj\\wqkoki\\eez 648 D:\\cfmwafhhgeyawnool 649 E:\\czt\\opwip\\osnll\\c 637 G:\\nt\\f 633 F:\\fop\\ywzqaop 631 F:\\yay\\jc\\ywzqaop 631 D:\\zwtymj\\xccb\\ljj\\cqzlyaszjvlsjmkwoqijggmybr 645 输出：rzuwnjvnuz 633 1 atl 637 1 rwyfvzsopsuiqjnr 647 1 eez 648 1 fmwafhhgeyawnool 649 1 c 637 1 f 633 1 ywzqaop 631 2 题解\npublic static void main(String[] args) throws Exception { BufferedReader buffer = new BufferedReader(new InputStreamReader(System.in)); String str; LinkedHashMap\u0026lt;String, Integer\u0026gt; data = new LinkedHashMap\u0026lt;String, Integer\u0026gt;(); while ((str = buffer.readLine()) != null) { int idx1 = str.lastIndexOf(\u0026#34; \u0026#34;); int idx2 = str.lastIndexOf(\u0026#34;\\\\\u0026#34;); String key = (idx1 - idx2) \u0026gt; 16 ? str.substring(idx1 - 16) : str.substring(idx2 + 1); data.put(key, data.getOrDefault(key, 0) + 1); } int count = 0; for (String key : data.keySet()) { count++; if (count \u0026gt; (data.size() - 8)) { System.out.println(key + \u0026#34; \u0026#34; + data.get(key)); } } } HJ20：密码验证合格程序\r#\r描述\n密码要求: 1.长度超过8位 2.包括大小写字母、数字、其它符号，以上四种至少三种 3.不能有长度大于2的包含公共元素的子串重复 （注：其他符号不含空格或换行） 数据范围：输入的字符串长度满足1≤n≤100 输入描述：一组字符串。 输出描述：如果符合要求输出：OK，否则输出NG 输入：021Abc9000 021Abc9Abc1 021ABC9000 021$bc9000 输出：OK NG NG OK 题解\npublic static void main(String[] args) throws IOException { BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); String input = null; while (null != (input = reader.readLine())) { char[] chars = input.toCharArray(); // 条件1：长度超过8位 if (chars.length \u0026lt; 9) { System.out.println(\u0026#34;NG\u0026#34;); continue; } // 条件2：包括大小写字母、数字、其它符号，以上四种至少三种 int flag1 = 0; int flag2 = 0; int flag3 = 0; int flag4 = 0; for (char ch : chars) { if (\u0026#39;A\u0026#39; \u0026lt;= ch \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;Z\u0026#39;) { flag1 = 1; } else if (\u0026#39;a\u0026#39; \u0026lt;= ch \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;z\u0026#39;) { flag2 = 1; } else if (\u0026#39;0\u0026#39; \u0026lt;= ch \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { flag3 = 1; } else { flag4 = 1; } } if ((flag1 + flag2 + flag3 + flag4) \u0026lt; 3) { System.out.println(\u0026#34;NG\u0026#34;); continue; } // 条件3：不存在两个大于2的子串相同 String msg = \u0026#34;OK\u0026#34;; Map\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; chars.length - 2; i++) { String key = input.substring(i, i + 3); if (map.containsKey(key)) { msg = \u0026#34;NG\u0026#34;; break; } map.put(key, \u0026#34;1\u0026#34;); } System.out.println(msg); } } HJ21：简单密码\r#\r描述\n现在有一种密码变换算法。 九键手机键盘上的数字与字母的对应： 1--1， abc--2, def--3, ghi--4, jkl--5, mno--6, pqrs--7, tuv--8 wxyz--9, 0--0，把密码中出现的小写字母都变成九键键盘对应的数字，如：a 变成 2，x 变成 9. 而密码中出现的大写字母则变成小写之后往后移一位，如：X ，先变成小写，再往后移一位，变成了 y ，例外：Z 往后移是 a 。 数字和其它的符号都不做变换。 数据范围：输入的字符串长度满足1≤n≤100 输入描述：输入一组密码，长度不超过100个字符。 输出描述：输出密码变换后的字符串 输入：YUANzhi1987 输出：zvbo9441987 题解\npublic static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str = br.readLine(); StringBuffer sb = new StringBuffer(); for (int i = 0; i \u0026lt; str.length(); i++) { //获取第i个字符 char c = str.charAt(i); //判断，处理 if (c \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c \u0026lt; \u0026#39;Z\u0026#39;) { c = (char) (c + \u0026#39;b\u0026#39; - \u0026#39;A\u0026#39;); } else if (c == \u0026#39;Z\u0026#39;) { c = \u0026#39;a\u0026#39;; } else if (c\u0026gt;=\u0026#39;a\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;c\u0026#39;) { c = \u0026#39;2\u0026#39;; } else if (c\u0026gt;=\u0026#39;d\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;f\u0026#39;) { c = \u0026#39;3\u0026#39;; } else if (c\u0026gt;=\u0026#39;g\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;i\u0026#39;) { c = \u0026#39;4\u0026#39;; } else if (c\u0026gt;=\u0026#39;j\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;l\u0026#39;) { c = \u0026#39;5\u0026#39;; } else if (c\u0026gt;=\u0026#39;m\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;o\u0026#39;) { c = \u0026#39;6\u0026#39;; } else if (c\u0026gt;=\u0026#39;p\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;s\u0026#39;) { c = \u0026#39;7\u0026#39;; } else if (c\u0026gt;=\u0026#39;t\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;v\u0026#39;) { c = \u0026#39;8\u0026#39;; } else if (c\u0026gt;=\u0026#39;w\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;z\u0026#39;) { c = \u0026#39;9\u0026#39;; } sb.append(c); } System.out.println(sb.toString().trim()); } HJ22：汽水瓶\r#\r描述\n某商店规定：三个空汽水瓶可以换一瓶汽水，允许向老板借空汽水瓶（但是必须要归还）。 小张手上有n个空汽水瓶，她想知道自己最多可以喝到多少瓶汽水。 数据范围：输入的正整数满足1≤n≤100 注意：本题存在多组输入。输入的 0 表示输入结束，并不用输出结果。 输入描述：输入文件最多包含 10 组测试数据，每一行仅包含一个正整数 n（1≤n≤100），表示小张手上的空汽水瓶数。n=0表示输入结束 输出描述：对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出0。 输入：3 10 81 0 输出：1 5 40 题解\n// 每两个空瓶可以喝一瓶：2空瓶加上借的1空瓶，兑换1瓶汽水，喝掉后将空瓶还回给老板 public static void main(String[] args){ Scanner sc = new Scanner(System.in); while(sc.hasNextInt()){ int bottle = sc.nextInt(); if(bottle==0){ break; } System.out.println(bottle/2); } } HJ23：删除字符串中出现次数最少的字符\r#\r描述\n实现删除字符串中出现次数最少的字符，若出现次数最少的字符有多个，则把出现次数最少的字符都删除。 输出删除这些单词后的字符串，字符串中其它字符保持原来的顺序。 数据范围：输入的字符串长度满足1≤n≤20，保证输入的字符串中仅出现小写字母 输入描述：字符串只包含小写英文字母, 不考虑非法输入，输入的字符串长度小于等于20个字节。 输出描述：删除字符串中出现次数最少的字符后的字符串。 输入：aabcddd 输出：aaddd 题解\npublic static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { String s = scanner.nextLine(); char[] chars = s.toCharArray(); //统计每个字母的数量 HashMap\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (char aChar : chars) { map.put(aChar, (map.getOrDefault(aChar, 0) + 1)); } //找到数量最少的字符数量 Collection\u0026lt;Integer\u0026gt; values = map.values(); Integer min = Collections.min(values); //用空字符串替换该字母 for (Character character : map.keySet()) { if (map.get(character) == min){ s = s.replaceAll(String.valueOf(character), \u0026#34;\u0026#34;); } } System.out.println(s); } } HJ26：字符串排序\r#\r描述\n编写一个程序，将输入字符串中的字符按如下规则排序。 规则1：英文字母从 A 到 Z 排列，不区分大小写。如，输入： Type 输出： epTy 规则2：同一个英文字母的大小写同时存在时，按照输入顺序排列。如，输入： BabA 输出： aABb 规则3：非英文字母的其它字符保持原来的位置。如，输入： By?e 输出： Be?y 数据范围：输入的字符串长度满足1≤n≤1000 输入描述：输入字符串 输出描述：输出字符串 输入：A Famous Saying: Much Ado About Nothing (2012/8). 输出：A aaAAbc dFgghh: iimM nNn oooos Sttuuuy (2012/8). 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); while (in.hasNextLine()) { String str = in.nextLine(); String res = sort(str); System.out.println(res); } } public static String sort(String str) { // 先将英文字母收集起来 List\u0026lt;Character\u0026gt; letters = new ArrayList\u0026lt;\u0026gt;(); char[] chars = str.toCharArray(); for (char ch : chars) { if (Character.isLetter(ch)) { letters.add(ch); } } // 将英文字母先排序好 letters.sort(Comparator.comparingInt(Character::toLowerCase)); // 若是非英文字母则直接添加 StringBuilder result = new StringBuilder(); for (int i = 0, j = 0; i \u0026lt; str.length(); i++) { if (Character.isLetter(str.charAt(i))) { result.append(letters.get(j++)); } else { result.append(str.charAt(i)); } } return result.toString(); } HJ27：查找兄弟单词\r#\r定义一个单词的“兄弟单词”为：交换该单词字母顺序（注：可以交换任意次），而不添加、删除、修改原有的字母就能生成的单词。 兄弟单词要求和原来的单词不同。例如： ab 和 ba 是兄弟单词。 ab 和 ab 则不是兄弟单词。 现在给定你 n 个单词，另外再给你一个单词 x ，让你寻找 x 的兄弟单词里，按字典序排列后的第 k 个单词是什么？ 注意：字典中可能有重复单词。 数据范围：1≤n≤1000 ，输入的字符串长度满足1≤len(str)≤10，1≤k\u0026lt;n 输入描述：输入只有一行。 先输入字典中单词的个数n，再输入n个单词作为字典单词。 然后输入一个单词x最后后输入一个整数k 输出描述：第一行输出查找到x的兄弟单词的个数m，第二行输出查找到的按照字典顺序排序后的第k个兄弟单词，没有符合则不用输出。 输入：3 abc bca cab abc 1 输出：2 bca 题解\npublic static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { String[] arr = scanner.nextLine().split(\u0026#34; \u0026#34;); int num = Integer.parseInt(arr[0]); String x = arr[arr.length - 2]; int k = Integer.parseInt(arr[arr.length - 1]); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt;= num; i++) { if (isBrother(x, arr[i])) { list.add(arr[i]); } } int size = list.size(); System.out.println(size); if (size \u0026gt;= k) { Collections.sort(list); System.out.println(list.get(k - 1)); } } } public static boolean isBrother(String str1, String str2) { if (str1.length() != str2.length() || str2.equals(str1)) { return false; } char[] chars1 = str1.toCharArray(); char[] chars2 = str2.toCharArray(); Arrays.sort(chars1); Arrays.sort(chars2); return new String(chars1).equals(new String(chars2)); } HJ28：素数伴侣\r#\r描述\n若两个正整数的和为素数，则这两个正整数称之为“素数伴侣”，如2和5、6和13 从已有的N（N为偶数）个正整数中挑选出若干对组成“素数伴侣”，能组成“素数伴侣”最多的方案称为“最佳方案” 例如有4个正整数：2，5，6，13，如果将5和6分为一组中只能得到一组“素数伴侣”，而将2和5、6和13编组将得到两组“素数伴侣”，能组成“素数伴侣”最多的方案称为“最佳方案” 输入：有一个正偶数 n ，表示待挑选的自然数的个数。后面给出 n 个具体的数字。 输出：输出一个整数 K ，表示你求得的“最佳方案”组成“素数伴侣”的对数。 数据范围：1≤n≤100，输入的数据大小满足2≤val≤30000 输入描述：输入一个正偶数 n，输入 n 个整数 输出描述：求得的“最佳方案”组成“素数伴侣”的对数。 输入：4 2 5 6 13 输出：2 题解\n// 素数一定是奇数，因此素数伴侣一定是奇数+偶数 public static void main(String[] args) { //标准输入 Scanner sc = new Scanner(System.in); while (sc.hasNext()) { //输入正偶数 int n = sc.nextInt(); //用于记录输入的n个整数 int[] arr = new int[n]; //用于存储所有的奇数 ArrayList\u0026lt;Integer\u0026gt; odds = new ArrayList\u0026lt;\u0026gt;(); //用于存储所有的偶数 ArrayList\u0026lt;Integer\u0026gt; evens = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { arr[i] = sc.nextInt(); //将奇数添加到odds if (arr[i] % 2 == 1) { odds.add(arr[i]); } //将偶数添加到evens if (arr[i] % 2 == 0) { evens.add(arr[i]); } } //下标对应已经匹配的偶数的下标，值对应这个偶数的伴侣 int[] matcheven = new int[evens.size()]; //记录伴侣的对数 int count = 0; for (int j = 0; j \u0026lt; odds.size(); j++) { //用于标记对应的偶数是否查找过 boolean[] v = new boolean[evens.size()]; //如果匹配上，则计数加1 if (find(odds.get(j), matcheven, evens, v)) { count++; } } System.out.println(count); } } //判断奇数x能否找到伴侣 private static boolean find(int x, int[] matcheven, ArrayList\u0026lt;Integer\u0026gt; evens, boolean[] v) { for (int i = 0; i \u0026lt; evens.size(); i++) { //该位置偶数没被访问过，并且能与x组成素数伴侣 if (isPrime(x + evens.get(i)) \u0026amp;\u0026amp; v[i] == false) { v[i] = true; // 如果i位置偶数还没有伴侣，则与x组成伴侣 // 如果已经有伴侣，并且这个伴侣能重新找到新伴侣，则把原来伴侣让给别人，自己与x组成伴侣 if (matcheven[i] == 0 || find(matcheven[i], matcheven, evens, v)) { matcheven[i] = x; return true; } } } return false; } //判断x是否是素数 private static boolean isPrime(int x) { if (x == 1) return false; //如果能被2到根号x整除，则一定不是素数 for (int i = 2; i \u0026lt;= (int) Math.sqrt(x); i++) { if (x % i == 0) { return false; } } return true; } HJ29：字符串加解密\r#\r描述\n对输入的字符串进行加解密，并输出。 加密方法为： 当内容是英文字母时则用该英文字母的后一个字母替换，同时字母变换大小写,如字母a时则替换为B；字母Z时则替换为a； 当内容是数字时则把该数字加1，如0替换1，1替换2，9替换0； 其他字符不做变化。 解密方法为加密的逆过程。 数据范围：输入的两个字符串长度满足 1≤n≤1000，保证输入的字符串都是只由大小写字母或者数字组成 输入描述： 第一行输入一串要加密的密码 第二行输入一串加过密的密码 输出描述： 第一行输出加密后的字符 第二行输出解密后的字符 输入：abcdefg BCDEFGH 输出：BCDEFGH abcdefg 题解\npublic static void main(String[] args) { Scanner in = new Scanner(System.in); while (in.hasNext()) { System.out.println(encode(in.nextLine())); System.out.println(decode(in.nextLine())); } } //加密函数 private static String encode(String code) { char[] t = code.toCharArray(); for (int i = 0; i \u0026lt; t.length; i++) { if (t[i] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; t[i] \u0026lt; \u0026#39;z\u0026#39;) { t[i] = (char) (t[i] - \u0026#39;a\u0026#39; + \u0026#39;A\u0026#39; + 1); } else if (t[i] == \u0026#39;z\u0026#39;) { t[i] = \u0026#39;A\u0026#39;; } else if (t[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; t[i] \u0026lt; \u0026#39;Z\u0026#39;) { t[i] = (char) (t[i] - \u0026#39;A\u0026#39; + \u0026#39;a\u0026#39; + 1); } else if (t[i] == \u0026#39;Z\u0026#39;) { t[i] = \u0026#39;a\u0026#39;; } else if (t[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; t[i] \u0026lt; \u0026#39;9\u0026#39;) { t[i] = (char) (t[i] + 1); } else if (t[i] == \u0026#39;9\u0026#39;) { t[i] = \u0026#39;0\u0026#39;; } } return String.valueOf(t); } //解密函数 private static String decode(String password) { char[] t = password.toCharArray(); for (int i = 0; i \u0026lt; t.length; i++) { if (t[i] \u0026gt; \u0026#39;a\u0026#39; \u0026amp;\u0026amp; t[i] \u0026lt;= \u0026#39;z\u0026#39;) { t[i] = (char) (t[i] - \u0026#39;a\u0026#39; + \u0026#39;A\u0026#39; - 1); } else if (t[i] == \u0026#39;a\u0026#39;) { t[i] = \u0026#39;Z\u0026#39;; } else if (t[i] \u0026gt; \u0026#39;A\u0026#39; \u0026amp;\u0026amp; t[i] \u0026lt;= \u0026#39;Z\u0026#39;) { t[i] = (char) (t[i] - \u0026#39;A\u0026#39; + \u0026#39;a\u0026#39; - 1); } else if (t[i] == \u0026#39;A\u0026#39;) { t[i] = \u0026#39;z\u0026#39;; } else if (t[i] \u0026gt; \u0026#39;0\u0026#39; \u0026amp;\u0026amp; t[i] \u0026lt;= \u0026#39;9\u0026#39;) { t[i] = (char) (t[i] - 1); } else if (t[i] == \u0026#39;0\u0026#39;) { t[i] = \u0026#39;9\u0026#39;; } } return String.valueOf(t); } "}]