[{"id":0,"href":"/framework/spring/ioc/bean/","title":"Bean","section":"IoC","content":"\rBean\r#\rBean\r#\r是指由Spring IoC容器实例化、组装和管理的对象 可以把 Spring IoC 容器看作是一个大工厂，Bean 就相当于工厂的产品 Bean 作用域\r#\r对于 prototype 作用域的 Bean 来说，Spring IoC 容器只负责创建 作用域 描述 singleton 默认值，在 spring IoC 容器仅存在一个 Bean 实例 prototype 每次通过 Spring 容器获取 Bean 时，容器都会创建一个新的 Bean 实例 request 每次 HTTP 请求，容器都会创建一个 Bean 实例， 仅在当前 HTTP Request 内有效 session 同一个 HTTP Session 共享一个 Bean 实例，仅在当前 HTTP Session 内有效 application 同一个 Web 应用共享一个 Bean 实例，在当前 ServletContext 内有效 Bean 生命周期\r#\r实例化 Spring 启动，加载类路径下配置文件，解析为 BeanDefinition 并装配到对应容器中 查找并加载 Spring 管理的 Bean，进行 Bean 的实例化 对于 prototype 作用域的 Bean 来说，Spring IoC 容器只负责创建，不会再跟踪其生命周期 初始化 Spring 对 bean 进行依赖注入 若 Bean 实现接口 BeanNameAware，则执行 setBeanName()，获取 bean 的名字 若 Bean 实现接口 BeanFactoryAware，则执行 setBeanFactory()，获取 BeanFactory 若 Bean 实现接口 ApplicationContextAware，则执行 setApplicationContext()，获取应用上下文； 若 Bean 实现接口 BeanPostProcessor，则先执行 postProcessBeforeInitialization()； 若 Bean 实现接口 InitializingBean，则执行 afterPropertiesSet()； 在 xml 文件中，若 Bean 配置了 init-method，则执行自定义方法； 若 Bean 实现接口 BeanPostProcessor，则先执行 postProcessAfterInitialization()； 使用 此时 Bean 已经准备就绪，可以被使用了 销毁\n如 Bean 实现接口 DisposableBean，则容器销毁时则执行 destory()； 在 xml 文件中，若 Bean 配置了destory-method，则容器销毁时则执行自定义方法。 "},{"id":1,"href":"/program-lang/java/container/Queue/BlockingQueue/","title":"BlockingQueue","section":"Queue","content":"\rBlockingQueue\r#\r阻塞队列\r#\r队列，Queue，是一种先进先出（first in first out：FIFO）的抽象的数据结构 BlockingQueue，是一个支持两个附加操作的队列 当阻塞队列是空时，从队列中获取元素的操作将会被阻塞 当阻塞队列是满时，往队列中添加元素的操作将会被阻塞 核心方法\r#\r抛出异常 返回特殊值 超时退出 一直阻塞 插入 add(e) offer(e) offer(e,time,unit) put(e) 移除 remove() poll() poll(time,unit) take() 检查 element() peek() / / 说明 抛出异常 当阻塞队列满时，再往队列 add 元素会抛 IllegalStateException:Queuefull当阻塞队列空时，再往队列 Remove 元素时候会抛出 NoSuchElementException 返回特殊值 插入方法，成功返回 true，失败返回 false移除方法，成功返回元素，队列里面没有就返回null 超时退出 当阻塞队列满时，队列会阻塞生产者线程一定时间，超过时限后生产者线程就会退出当阻塞队列空时，队列会阻塞消费者线程一定时间，超过时限后消费者线程就会退出 一直阻塞 当阻塞队列满时，生产者继续往队列里面 put 元素，队列会一直阻塞直到 put 数据 or 响应中断退出当阻塞队列空时，消费者试图从队列 take 元素，队列会一直阻塞消费者线程，直到队列可用 常用队列\r#\r队列 说明 实现 ArrayBlockingQueue 有界阻塞队列 由数组实现 LinkedBlockingQueue 有界阻塞队列 由链表实现 LinkedTransferQueue 无界阻塞队列 由链表实现 LinkedBlockingDeque 双端有界阻塞队列 由链表实现 DelayQueue 延迟无界阻塞队列 SynchronousQueue 单元素的阻塞队列 PriorityBlockingQueue 支持优先级的无界阻塞队列 应用\r#\r线程池、消息中间件、生产者消费者模式 // 生产者消费者模式-传统版 public class ShareData { private int num = 0; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void increment() throws Exception { lock.lock(); try { while (num != 0) { condition.await(); } num++; System.out.println(Thread.currentThread().getName() + \u0026#34;\\t\u0026#34; + num); condition.signalAll(); } finally { lock.unlock(); } } public void deIncrement() throws Exception { lock.lock(); try { while (num == 0) { condition.await(); } num--; System.out.println(Thread.currentThread().getName() + \u0026#34;\\t\u0026#34; + num); condition.signalAll(); } finally { lock.unlock(); } } } public class ProdConsumerTraditionDemo { public static void main(String[] args) { ShareData shareData = new ShareData(); new Thread(() -\u0026gt; { for (int i = 1; i \u0026lt;= 5; i++) { try { shareData.increment(); } catch (Exception e) { e.printStackTrace(); } } }, \u0026#34;AA\u0026#34;).start(); new Thread(() -\u0026gt; { for (int i = 1; i \u0026lt;= 5; i++) { try { shareData.deIncrement(); } catch (Exception e) { e.printStackTrace(); } } }, \u0026#34;BB\u0026#34;).start(); } } // 生产者消费者模式-阻塞队列版 public class MyResource { /** * 默认开启 进行生产消费的交互 */ private volatile boolean flag = true; /** * 默认值是0 */ private AtomicInteger atomicInteger = new AtomicInteger(); private BlockingQueue\u0026lt;String\u0026gt; blockingQueue = null; public MyResource(BlockingQueue\u0026lt;String\u0026gt; blockingQueue) { this.blockingQueue = blockingQueue; System.out.println(blockingQueue.getClass().getName()); } public void produce() throws Exception { String data = null; boolean returnValue; String threadName = Thread.currentThread().getName(); while (flag) { data = atomicInteger.incrementAndGet() + \u0026#34;\u0026#34;; returnValue = blockingQueue.offer(data, 2L, TimeUnit.SECONDS); if (returnValue) { System.out.println(threadName + \u0026#34; 插入队列数据\u0026#34; + data + \u0026#34;成功\u0026#34;); } else { System.out.println(threadName + \u0026#34; 插入队列数据\u0026#34; + data + \u0026#34;失败\u0026#34;); } TimeUnit.SECONDS.sleep(1); } System.out.println(threadName + \u0026#34; 停止 表示 flag=\u0026#34; + flag); } public void consume() throws Exception { String result = null; String threadName = Thread.currentThread().getName(); while (flag) { result = blockingQueue.poll(2L, TimeUnit.SECONDS); if (null == result || \u0026#34;\u0026#34;.equalsIgnoreCase(result)) { flag = false; System.out.println(threadName + \u0026#34; 超过2s没有取到 消费退出\u0026#34;); System.out.println(); System.out.println(); return; } System.out.println(threadName + \u0026#34; 消费队列\u0026#34; + result + \u0026#34;成功\u0026#34;); } } public void stop() throws Exception { flag = false; } } public class ProdConsumerBlockQueueDemo { public static void main(String[] args) throws Exception { MyResource myResource = new MyResource(new ArrayBlockingQueue\u0026lt;\u0026gt;(10)); new Thread(() -\u0026gt; { System.out.println(Thread.currentThread().getName() + \u0026#34;\\t启动\u0026#34;); try { myResource.produce(); } catch (Exception e) { e.printStackTrace(); } }, \u0026#34;producer\u0026#34;).start(); new Thread(() -\u0026gt; { System.out.println(Thread.currentThread().getName() + \u0026#34;\\t启动\u0026#34;); try { myResource.consume(); } catch (Exception e) { e.printStackTrace(); } }, \u0026#34;consumer\u0026#34;).start(); try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(); System.out.println(); System.out.println(\u0026#34;时间到,停止活动\u0026#34;); myResource.stop(); } } "},{"id":2,"href":"/program-lang/java/thread/tool/CountDownLatch/","title":"CountDownLatch","section":"并发工具","content":"\rCountDownLatch\r#\r功能\r#\r倒计时器 一个或多个线程一直等待，直到其他线程完成某件事情之后再执行 原理\r#\r通过一个计数器进行实现。计数器初始值为线程的数量。 每当一个线程执行完毕后，计数器的值就减 1。 当计数器的值为 0 时，表示所有线程都执行完毕，然后在 CountDownLatch 上等待的线程就可以恢复执行了。 方法\r#\r// 构造方法：设定计数器初始值 public CountDownLatch(int count) // 计数器值减1 public void countDown() // 获取当前计数器值 public long getCount() // 非定时等待 public void await() // 定时等待 public boolean await(long timeout, TimeUnit unit) 示例\r#\r// 自习室锁门 public class Test { public static void main(String[] args) throws Exception { CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 1; i \u0026lt;= 6; i++) { new Thread(() -\u0026gt; { System.out.println(Thread.currentThread().getName() + \u0026#34;\\t上完自习\u0026#34;); countDownLatch.countDown(); }, String.valueOf(i)).start(); } countDownLatch.await(); System.out.println(Thread.currentThread().getName() + \u0026#34;\\t班长锁门离开教室\u0026#34;); } } "},{"id":3,"href":"/program-lang/web/css/basic/","title":"CSS 基础","section":"CSS","content":"\rCSS 基础\r#\rCSS\r#\rCascading Style Sheets，层叠样式表 使网页内容与表现相分离，简化网页代码，提高页面浏览速度 层叠样式\r#\rHTML 同一元素，可以定义多个样式 HTML 子元素，会继承其父元素的CSS样式 样式不冲突时，多个样式效果可叠加；样式冲突时，按样式的优先级来显示 语法规则\r#\rCSS规则，由选择器、声明组成 注释：/*注释语句*/ 引入方式\r#\r外部样式表 内部样式表 内联样式 //外部样式表：在网页头部引入 \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;XXX.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; //内部样式表：在网页头部，定义样式表 \u0026lt;head\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; p {color:red;} ... \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; //内联颜色表：在相关标签内，定义style属性 \u0026lt;p style=\u0026#34;color:red;\u0026#34;\u0026gt;这是一个段落。\u0026lt;/p\u0026gt; 基础单位\r#\r尺寸：size\r#\r值 说明 备注 % 百分比 in 英寸 25.4 mm cm 厘米 10 mm mm 毫米 1 mm pt 磅/点，Point 0.35 mm pc 派卡，Pica 4.23 mm px 像素，Pixel em 当前字体尺寸的倍数 1em = 16px（默认） ex x-height 1ex = 0.5em 颜色：color\r#\r值 说明 备注 (颜色名) 颜色名称 red rgb(x,x,x) RGB 值 rgb(255,0,0) rgb(x%, x%, x%) RGB 百分比值 rgb(100%,0%,0%) #rrggbb 十六进制数 #ff0000 盒模型\r#\r垂直方向，相邻元素的外边距会合并，实际高度为较大值 盒模型各属性，默认不继承父元素样式 命名\r#\r规范\n以小写字母开头 英文字母、数字、\u0026quot;_\u0026quot;、\u0026quot;-\u0026quot; 使用有意义的命名 命名形式：单个单词、连字符、驼峰命名 示例\n页头 header 页体 main 页尾 footer 内容 content 容器 container 条 bar 导航 nav 侧栏 sidebar 栏目 column 广告 banner 能区 shop 外围 wrapper "},{"id":4,"href":"/service-manage/deprecated-frame/eureka/","title":"Eureka","section":"日落组件","content":"\rEureka\r#\rEureka\r#\r服务注册中心\n一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。\n工作原理\r#\rEureka 采用了 C-S 的设计架构。 Eureka Server 作为服务注册功能的服务器，是服务注册中心。 而系统中的其他微服务，使用 Eureka Client 连接到 Eureka Server 并维持心跳连接。 这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。 SpringCloud 的其他模块（比如Zuul）就可以通过 Eureka Server 来发现系统中的其他微服务，并执行相关的逻辑。 核心组件\r#\rEureka Server\n提供服务注册服务 各个节点启动后，会在 Eureka Server 中进行注册，这样 Eureka Server 中将会存储所有可用服务的节点信息。 Eureka Client\n是一个 Java 客户端，用于简化与 Eureka Server 的交互。 作为轮询负载均衡器，并提供服务的故障切换支持。 在应用启动后，将会向 Eureka Server 周期性发送心跳。 角色\r#\rEureka Server：提供服务注册和发现 Service Provider：服务提供方，将自身服务注册到 Eureka，从而使服务消费方能够找到 Service Consumer：服务消费方，从 Eureka 获取注册服务列表，从而能够消费服务 自我保护模式\r#\r当 EurekaServer 节点在短时间内丢失过多客户端时，那么这个节点就会进入自我保护模式。 自我保护模式下，EurekaServer 就会保护服务注册表中的信息，即不会注销任何微服务。 当网络故障恢复后，该 EurekaServer 节点会自动退出自我保护模式。 Eureka 保证 AP\r#\rEureka 优先保证高可用性，其各个节点都是平等的。 只要有一台 EurekaServer 在，就能保证注册服务可用，只不过查到的信息可能不是最新的 "},{"id":5,"href":"/framework/spring/ioc/","title":"IoC","section":"Spring","content":"\rIoC\r#\rInversion of Control，即“控制反转”，是一种设计思想，用于解决对象之间的耦合问题。 以前对象的创建及依赖关系是由开发人员自己维护，现在反转交给 spring 来完成创建及注入 控制：指的是对象创建（实例化、管理）的权利 反转：控制权交给外部环境了（spring框架、IoC容器） IoC \u0026amp; DI\r#\rDI，Dependency Injection，即“依赖注入”，由容器动态的将某个依赖关系注入到组件之中。 IOC 是一种软件设计思想，DI 是这种软件设计思想的一个实现。 IoC 和 DI 是同一个概念的不同角度描述。 IoC 容器\r#\r具有依赖注入功能的容器，它可以创建对象，负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖 IoC 容器底层其实就是一个 Bean 工厂，Spring 提供了两种 IoC 容器，即BeanFactory、ApplicationContext BeanFactory：最简单的 IoC 容器，它提供了 IoC 容器最基本的功能 ApplicationContext：BeanFactory 的子接口，并添加了更多的企业特定的功能 "},{"id":6,"href":"/program-lang/java/thread/theory/JMM/","title":"Java 内存模型","section":"并发理论","content":"\rJava 内存模型\r#\rJMM\r#\rJava Memory Model，是一种抽象的概念。 描述的是一组规则或规范，规定了程序中各个变量的访问方式。 内存\r#\r主内存：共享的内存区域，所有线程都可访问。代表：内存条 工作内存：每个线程的私有数据区域。代表：CPU缓存 规则\r#\r线程解锁前，必须把共享变量的值刷新回主内存 线程加锁前，必须读取主内存的最新值到自己的工作内存 加锁解锁是同一把锁 访问过程\r#\r线程对变量的操作(读取赋值等)，必须在工作内存中进行 首先要将变量从主内存拷贝到自己的工作空间，然后对变量进行操作，操作完成再将变量写回主内存 并发三特性\r#\r原子性 不可分割，是一个整体。即一个操作或者多个操作，要么全部执行并且不被打断，要么就都不执行 可见性 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值 有序性 程序执行的顺序按照代码的先后顺序执行 指令重排\r#\r为了优化程序性能，编译器和处理器重新对指令序列进行排序的一种手段 内存屏障\r#\rMemory Barrier 作用： 阻止屏障两侧的指令重排序 强制将缓存数据刷新到主内存 类型： Load指令：读屏障，将内存存储的数据拷贝到处理器的缓存中。 Store指令：写屏障，让当前线程写入高速缓存中的最新数据更新写入到内存，让其他线程也可见。 分为四类：LoadLoad、StoreStore、LoadStore、 StoreLoad 数据依赖性\r#\r如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性 语义：as-if-serial\r#\r不管怎么指令重排，单线程程序的执行结果不会改变 为了遵循此语义，编译器不会对存在数据依赖关系的操作做重排序，因为会改变执行结果。 编译器、runtime和处理器都遵守as-if-serial语义 规则：happens-before\r#\r如果A Happens-Before B，则A操作的结果对B操作可见，且A操作在B操作之前执行 JMM承诺保证happens-before规则 as-if-serial \u0026amp; happens-before\r#\r两者目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度 as-if-serial 保证结果：单线程程序的执行结果不被改变 as-if-serial 创造环境：单线程程序是按程序的顺序来执行的 happens-before 保证结果：正确同步的多线程程序的执行结果不被改变 happens-before 创造环境：正确同步的多线程程序是按happens-before指定的顺序来执行的 "},{"id":7,"href":"/program-lang/java/library/java.io/","title":"java.io","section":"基础类库","content":"\rIO 流\r#\r概述\r#\rI/O 即输入Input/ 输出Output的缩写，就是计算机调度把各个存储中的数据写入写出的过程； Java中用“流（stream）”来抽象表示这么一个写入写出的功能，并封装成一个“类” I/O 体系\r#\rI/O 体系基类：以程序自身为参照基准，判断输入输出\n字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer I/O 体系分类\nInputStream OutputStream Reader Writer 文件流 File\u0026ndash; File\u0026ndash; File\u0026ndash; File\u0026ndash; 管道流 Piped\u0026ndash; Piped\u0026ndash; Piped\u0026ndash; Piped\u0026ndash; 缓冲流 Buffered\u0026ndash; Buffered\u0026ndash; Buffered\u0026ndash; Buffered\u0026ndash; 数据流 Data\u0026ndash; Data\u0026ndash; 字符流 String\u0026ndash; String\u0026ndash; 对象流 Object\u0026ndash; Object\u0026ndash; 转换流 InputStream\u0026ndash; OutputStream\u0026ndash; 字节数组流 ByteArray\u0026ndash; ByteArray\u0026ndash; 字符数组流 CharArray\u0026ndash; CharArray\u0026ndash; 打印流 Print\u0026ndash; Print\u0026ndash; I/O 示例\r#\r文件流\r#\r// FileInputStream、FileOutputStream try (FileInputStream fis = new FileInputStream(\u0026#34;E:\\\\test1.txt\u0026#34;); FileOutputStream fos = new FileOutputStream(\u0026#34;E:\\\\test2.txt\u0026#34;)) { int len; byte[] buff = new byte[1024]; while ((len = fis.read(buff)) \u0026gt; 0) { fos.write(buff, 0, len); } } catch (IOException e) { e.printStackTrace(); } // FileReader、FileWriter try (FileReader fr = new FileReader(\u0026#34;E:\\\\test1.txt\u0026#34;); FileWriter fw = new FileWriter(\u0026#34;E:\\\\test2.txt\u0026#34;)) { int len; char[] buff = new char[1024]; while ((len = fr.read(buff)) \u0026gt; 0) { fw.write(new String(buff, 0, len)); } } catch (IOException e) { e.printStackTrace(); } 缓冲流\r#\r// BufferedInputStream、BufferedOutputStream try (FileInputStream fis = new FileInputStream(\u0026#34;E:\\\\test1.txt\u0026#34;); FileOutputStream fos = new FileOutputStream(\u0026#34;E:\\\\test2.txt\u0026#34;); BufferedInputStream bis = new BufferedInputStream(fis); BufferedOutputStream bos = new BufferedOutputStream(fos)) { int len; byte[] buff = new byte[1024]; while ((len = bis.read(buff)) \u0026gt; 0) { bos.write(buff, 0, len); } } catch (IOException e) { e.printStackTrace(); } 转换流\r#\rInputStreamReader：将字节输入流转换为字符输入流 OutputStreamWriter：将字节输出流转换为字符输出流 // InputStreamReader、OutputStreamWriter try (FileInputStream fis = new FileInputStream(\u0026#34;E:\\\\file_gbk.txt\u0026#34;); FileOutputStream fos = new FileOutputStream(\u0026#34;E:\\\\file_utf8.txt\u0026#34;); InputStreamReader isr = new InputStreamReader(fis, \u0026#34;GBK\u0026#34;); OutputStreamWriter osw = new OutputStreamWriter(fos, \u0026#34;UTF-8\u0026#34;)) { int len; char[] buff = new char[1024]; while ((len = isr.read(buff)) != -1) { osw.write(buff, 0, len); } } catch (IOException e) { e.printStackTrace(); } 对象流\r#\r// ObjectInputStream、ObjectOutputStream public class Test { public static void main(String[] args) { try (FileInputStream fis = new FileInputStream(\u0026#34;E:\\\\test1.txt\u0026#34;); FileOutputStream fos = new FileOutputStream(\u0026#34;E:\\\\test2.txt\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); ObjectOutputStream oos = new ObjectOutputStream(fos)) { // 对象序列化存储 oos.writeObject(new Animal(\u0026#34;dog\u0026#34;)); // 对象反序列化读取 Animal dog = (Animal) ois.readObject(); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } } // 输出对象的类必须实现Serializable接口 public class Animal implements Serializable { private String name; public Animal(String name) { this.name = name; } } "},{"id":8,"href":"/program-lang/java/jvm/tuning/parameter/","title":"JVM 参数","section":"JVM 调优","content":"\rJVM 参数\r#\rJVM 参数\r#\r标配参数、X参数（了解）\r#\r-version 版本信息 -help 帮助 -showversion 版本详情 -Xint 解释模式，强制 JVM 执行所有的字节码 -Xcomp 编译模式，第一次使用就把所有的字节码编译成本地代码 -Xmixed 混合模式，将解释模式和编译模式进行混合使用 XX 参数（重点）\r#\r布尔类型：-XX:+或-某个属性（+ 表示开启，- 表示关闭） 键值类型：-XX:属性键=属性值 示例 说明 -XX:-PrintGCDetails 关闭：打印GC收集细节 -XX:+PrintGCDetails 开启：打印GC收集细节 -XX:-UseSerialGC 关闭：使用串行垃圾回收器 -XX:+UseSerialGC 开启：使用串行垃圾回收器 -XX:MetaspaceSize=128m 设置元空间的内存大小，默认21m -XX:MaxTenuringThreshold=15 设置GC垃圾年龄阈值，默认15 常用 JVM 参数\r#\r-Xms、-Xmx、-Xss、-Xmn\r#\r参数 说明 备注 -Xms 初始分配内存，默认是物理内存的1/64 -Xms 等价于 -XX:InitialHeapSize -Xmx 最大分配内存，默认是物理内存的1/4 -Xmx 等价于 -XX:MaxHeapSize -Xss 设置单个线程栈的内存大小，一般默认512K ~ 1024K -Xss 等价于 -XX:ThreadStackSize -Xmn 设置年轻代的内存大小，一般使用默认值 -XX:MetaspaceSize\r#\r设置元空间的内存大小，默认21m 元空间（Java8）和老年代（Java7）类似，但元空间并不在虚拟机中，而是使用本地内存 -XX:SurvivorRatio\r#\r配置新生代中 eden 和 S0/S1 空间比例\n# eden:S0:S1=8:1:1 (默认) -XX:SurvivorRatio=8 # eden:S0:S1=4:1:1 -XX:SurvivorRatio=4 -XX:NewRatio\r#\r配置新生代与老年代在堆中的比例\n# 新生代:老年代=1:2(默认) -XX:NewRatio=2 # 新生代:老年代=1:4 -XX:NewRatio=4 -XX:MaxTenuringThreshold\r#\r设置新生代中对象最大存活次数 在新生代中对象存活次数（经过Minor GC的次数）后仍然存活，就会晋升到老年代 -XX:+PrintGCDetails\r#\r输出 GC 收集的日志信息 GC 日志分析 查看 JVM 参数\r#\rjps、jinfo\r#\r查询进程号：jps 查看具体参数：jinfo -XX:+PrintFlagsInitial\r#\r查看全部初始默认参数 -XX:+PrintFlagsFinal\r#\r查看全部最终参数 -XX:+PrintCommandLineFlags\r#\r查看特定参数 "},{"id":9,"href":"/program-lang/java/library/java.util.stream/lambda/","title":"Lambda","section":"java.util.stream","content":"\rLambda 表达式\r#\rLambda\r#\r允许把函数作为一个方法的参数，即函数作为参数传递到方法中 也可称为闭包，能使代码更加简洁 基本语法\r#\r参数列表：() 操作符：-\u0026gt; 方法体：{} (参数1,参数2,...) -\u0026gt; { // 方法体 }; 简写规则\r#\r特征 说明 可选类型声明 不需要声明参数类型，编译器可以统一识别参数值。 可选的参数圆括号 一个参数无需定义圆括号，但多个参数需要定义圆括号。 可选的大括号 如果主体包含了一个语句，就不需要使用大括号。 可选的返回关键字 如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。 变量作用域\r#\rLambda 表达式只能引用标记了 final 的外层局部变量，否则会编译错误。 Lambda 表达式的局部变量隐性的具有 final 的语义。 public class Test { public static void main(String[] args) { // 隐性 final int num = 1; Converter s = (param) -\u0026gt; System.out.println(String.valueOf(param + num)); s.convert(2); //编译会出错 num = 5; } public interface Converter { void convert(int i); } } 示例\r#\rpublic static void main(String[] args) { // 匿名内部类 Runnable r1 = new Runnable() { @Override public void run() { System.out.println(\u0026#34;r1：线程执行了...\u0026#34;); } }; new Thread(r1).start(); // Lambda表达式 Runnable r2 = () -\u0026gt; System.out.println(\u0026#34;r2：线程执行了...\u0026#34;); new Thread(r2).start(); } public static void main(String[] args) { // 匿名内部类 Comparator\u0026lt;String\u0026gt; c1 = new Comparator\u0026lt;String\u0026gt;() { @Override public int compare(String o1, String o2) { return o1.length() - o2.length(); } }; // Lambda表达式 Comparator\u0026lt;String\u0026gt; c2 = (o1, o2) -\u0026gt; o1.length() - o2.length(); } public class Test { public static void main(String args[]) { Test tester = new Test(); // 类型声明 MathOperation addition = (int a, int b) -\u0026gt; a + b; // 不用类型声明 MathOperation subtraction = (a, b) -\u0026gt; a - b; // 大括号中的返回语句 MathOperation multiplication = (int a, int b) -\u0026gt; { return a * b; }; // 没有大括号及返回语句 MathOperation division = (int a, int b) -\u0026gt; a / b; System.out.println(\u0026#34;10 + 5 = \u0026#34; + tester.operate(10, 5, addition)); System.out.println(\u0026#34;10 - 5 = \u0026#34; + tester.operate(10, 5, subtraction)); System.out.println(\u0026#34;10 x 5 = \u0026#34; + tester.operate(10, 5, multiplication)); System.out.println(\u0026#34;10 / 5 = \u0026#34; + tester.operate(10, 5, division)); // 不用括号 GreetingService greetService1 = message -\u0026gt; System.out.println(\u0026#34;Hello \u0026#34; + message); // 用括号 GreetingService greetService2 = (message) -\u0026gt; System.out.println(\u0026#34;Hello \u0026#34; + message); greetService1.sayMessage(\u0026#34;Runoob\u0026#34;); greetService2.sayMessage(\u0026#34;Google\u0026#34;); } interface MathOperation { int operation(int a, int b); } interface GreetingService { void sayMessage(String message); } private int operate(int a, int b, MathOperation mathOperation) { return mathOperation.operation(a, b); } } "},{"id":10,"href":"/program-lang/java/container/Map/","title":"Map","section":"集合容器","content":"\r"},{"id":11,"href":"/framework/kafka/mq/","title":"MQ","section":"Kafka","content":"\r消息队列\r#\rMQ\r#\rMessage Queue，消息队列 是基础数据结构中“先进先出”的一种数据结构。 原理\r#\r点对点模式：一对一，消费者主动拉取数据，消息收到后消息清除 发布/订阅模式：一对多，数据生产后，推送给所有订阅者 优点\r#\r解耦：解耦消息处理过程，使得扩展变得容易 异步：允许异步处理消息 削峰：提高峰值处理能力 缓冲：控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况 保证数据安全：消息队列把数据进行持久化直到它们已经被完全处理。这规避了数据丢失风险。 保证消息的有序性：保证数据会按照特定的顺序来处理 缺点\r#\r系统可用性降低 系统复杂性提高 一致性问题 消息中间件\r#\r单机吞吐量 时效性 可用性 消息可靠性 ActiveMQ 万级 ms 级 高，主从架构 有较低的概率丢失数据 RabbitMQ 万级 μs 级 高，主从架构 RocketMQ 10万级 ms 级 非常高，分布式架构 可零丢失 Kafka 10万级 ms 级 非常高，分布式架构 可零丢失 ActiveMQ\r#\r非常成熟，功能强大，在业内大量的公司以及项目中都有应用 偶尔会有较低概率丢失消息 社区活跃度低，官方对其维护也越来越少 而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用 RabbitMQ\r#\rerlang语言开发，性能极其好，延时很低； 吞吐量到万级，MQ功能比较完备 而且开源提供的管理界面非常棒，用起来很好用 社区相对比较活跃，几乎每个月都发布几个版本 RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重 erlang语言本身带来的问题。很难读源码，很难定制和掌控 RocketMQ\r#\r接口简单易用，有阿里品牌保障 日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便 社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景 java系的，可以自己阅读源码，定制自己公司的MQ，可以掌控 Kafka\r#\r仅仅提供较少的核心功能 但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展 kafka最好是支撑较少的topic数量即可，保证其超高吞吐量 kafka唯一的一点劣势是有可能消息重复消费，在大数据领域中以及日志采集中，这点轻微影响可以忽略。 "},{"id":12,"href":"/database/redis/persistence/RDB/","title":"RDB","section":"持久化","content":"\rRDB\r#\rRDB\r#\rRedis DataBase，在指定的时间间隔内将内存中的数据集快照写入磁盘。 持久化文件：dump.rdb 过程\r#\rRedis 调用 fork() ，创建一个子进程。 主进程继续处理client请求，且不进行任何IO操作，以保证性能。 子进程会先将数据写入到一个临时文件中，待持久化过程都结束了， 再用这个临时文件替换上次持久化好的文件。 触发\r#\r自动触发\n根据 save m n 配置规则自动触发； 从节点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点会触发 bgsave； 执行 debug reload 时； 执行 shutdown时，如果没有开启aof，也会触发。 手动触发\nsave：会阻塞当前Redis服务器，直到持久化完成，线上应该禁止使用。 bgsave：该触发方式会fork一个子进程，由子进程负责持久化过程，因此阻塞只会发生在fork子进程的时候。 优点\r#\r只有一个文件 dump.rdb，方便持久化。 容灾性好，一个文件可以保存到安全的磁盘。 性能最大化，保证了 redis的高性能 相对于数据集大时，比 AOF 的启动效率更高。 缺点\r#\r数据安全性低。如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改 每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程。这可能会非常耗时，造成服务器暂时停止处理客户端。 "},{"id":13,"href":"/framework/springmvc/RESTful/","title":"RESTful","section":"Spring MVC","content":"\rRESTful 风格\r#\rRESTful\r#\r是一种互联网软件架构，是一种设计风格 即 REST，是 REST 的形容词形式 RESTful 原则\r#\r网络上的所有事物都被抽象为资源 每个资源都有唯一的标识，对资源的操作不会改变标识 同一个资源具有多种表现形式(xml,json等) 所有的操作都是无状态的 RESTful 规范\r#\r使用 URL 标识资源，URL中原则上不使用“动词”。 使用标准方法（GET、POST、PUT、PATCH、DELETE）操作资源。 使用 Json 格式返回结果，并用HTTP状态码进行标识。 RESTful 示例\r#\r//如果占位符中的名称和形参名一致，在@PathVariable可以不指定名称 @RequestMapping(\u0026#34;/item/{id}\u0026#34;) public @ResponseBody Item item(@PathVariable(\u0026#34;id\u0026#34;) Integer itemId){ //.... } "},{"id":14,"href":"/service-manage/dubbo/rpc/","title":"RPC","section":"Dubbo","content":"\rRPC\r#\rRPC\r#\rRemote Procedure Call，远程过程调用，是一种进程间通信方式 允许程序调用另一个地址空间的过程或函数，而不用程序员显式编码这个远程调用的细节。 优点：调用简单、性能高、低延迟、自带负载均衡 缺点：耦合性强、无法跨语言，平台敏感 REST\r#\rREST，即 RESTful ，是一种架构风格，指的是一组架构约束条件和原则。 优点：耦合性低，兼容性好，通用性好，跨语言支持 缺点：性能不如 RPC 高 RPC \u0026amp; REST\r#\rRPC ：服务提供方与调用方接口依赖方式太强、服务对平台敏感，难以简单复用。 REST ：牺牲了服务调用的性能，但避免了RPC带来的问题。 RPC or REST\r#\rRPC 适用于内网服务调用，对外提供服务请走 REST。 IO 密集的服务调用用 RPC，低频服务用 REST 服务调用过于密集与复杂，RPC 就比较适用 "},{"id":15,"href":"/framework/spring/","title":"Spring","section":"开源框架","content":"\rSpring\r#\rSpring 是一个开源的轻量级 Java 开发框架 Spring 的核心是控制反转（IoC）和面向切面（AOP） Spring 特点\r#\r方便解耦，简化开发 用户可以将所有对象的创建和依赖关系的维护，交给Spring管理 支持AOP编程 Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能 支持声明式事务 只需要通过配置就可以完成对事务的管理，而无需手动编程 方便程序测试 Spring对Junit4支持，可以通过注解方便的测试Spring程序 集成各种优秀框架 Spring内部提供了对各种优秀框架的直接支持 简化JavaEE的使用 Spring对JavaEE开发中非常难用的一些API，都提供了封装，降低了使用难度 Spring 体系结构\r#\r"},{"id":16,"href":"/program-base/network/tcp-ip/tcp/","title":"TCP","section":"TCP/IP","content":"\rTCP 协议\r#\rTCP 协议\r#\rTransmission Control Protocol，传输控制协议 是面向连接的协议，在收发数据前，必须和对方建立可靠的连接。 一个TCP连接必须有三次握手、四次挥手 报文首部\r#\rseq：报文序号 ask：确认序号 标志位 描述 说明 URG 紧急 当URG=1时，表明报文段有紧急数据，应当尽快传送。 ACK 确认 当ACK=1时，上面的确认号才管用。 PSH 推送 当PSH=1时，接收端应当将缓冲区中的数据尽快交付上层。 RST 重连 当RST=1时，表示TCP连接出现严重差错，必须释放连接，再重新建立连接。 SYN 新建 当SYN=1时，表示请求建立连接。 FIN 终止 当FIN=1时，表示要求释放连接。 建立连接：三次握手\r#\r三次握手（Three-way Handshake），是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包 第一次握手：客户端发出报文（SYN），请求建立连接 第二次握手：服务器收到报文（ SYN ），如果同意连接，则发出确认报文（SYN+ASK） 第三次握手：客户端收到确认报文（SYN+ASK）后，再发出确认报文（ASK） 握手过程简述\n第一次握手 A请求建立连接 A：你听清楚么？ 第二次握手 A发送正常，B接收正常 B：能听清楚，你呢？ 第三次握手 B发送正常，A接收正常 A：也能听清楚。 断开连接：四次挥手\r#\r四次挥手（Four-way handshake），即TCP 的连接的拆除需要发送四个包 第一次挥手：客户端发出报文（FIN），请求释放连接，停止发送数据 第二次挥手：服务器收到报文（FIN），发出确认报文（ASK），停止接收数据 第三次挥手：服务器发出报文（FIN），停止发送数据 第四次挥手：客户端收到报文（FIN），发出确认报文（ASK），停止接收数据 挥手过程简述 第一次挥手 A请求断开连接 A：我要挂电话了？ 第二次挥手 B收到请求，同意断开连接 B：收到，挂吧。 第三次挥手 B确认断开连接 B：我也没有话要说了。 第四次挥手 A收到确认，断开连接 A：挂断电话。 UDP 协议\r#\rUser Data Protocol，用户数据报协议 是一个非连接的协议，传输数据之前源端和终端不建立连接 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上 报文首部\r#\rTCP vs UDP\r#\rTCP UDP 连接性 面向字节流，需要建立连接 面向报文，不需建立连接 可靠性 可靠，不丢包 不可靠，会丢包 传输效率 传输效率低，速度慢 传输效率高，速度快 流量控制 滑动窗口 无 拥塞控制 慢开始、拥塞避免、快重传、快恢复 无 应用场合 对效率要求低，对准确性要求高或要求有连接的场景 对效率要求高，对准确性要求低 连接方式 只支持点到点 支持一对一、一对多、多对多 首部开销 开销20字节 开销8字节 "},{"id":17,"href":"/program-lang/java/thread/container/ThreadLocal/","title":"ThreadLocal","section":"并发容器","content":"\rThreadLocal\r#\r概述\r#\r线程本地变量 变量在每个线程中都有独立拷贝，线程对变量的访问都是基于它自己的变量，就避免了线程不安全问题 数据隔离\r#\rThreadLocal 类操作的是 Thread 的成员变量 threadLocals。 每个线程 Thread 都有自己的 threadLocals，从而互相不影响。 实现\r#\r每个 Thread 对象都有一个 ThreadLocalMap 映射表 ThreadLocalMap 的 key 是 ThreadLocal 实例本身，value 则存储 Object 数据 通过 ThreadLocal 对象的 get()/set() 方法进行取值/设值 方法\r#\r// 构造方法 public ThreadLocal() // 设值 public void set(T value) // 取值 public T get() 示例\r#\rpublic class Test { private static ThreadLocal\u0026lt;String\u0026gt; local = new ThreadLocal\u0026lt;\u0026gt;(); public static void main(String[] args) { String[] values = {\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;}; for (String value : values) { new Thread(() -\u0026gt; { String thread = Thread.currentThread().getName(); Test.local.set(value); System.out.println(thread + \u0026#34; set(\u0026#34; + value + \u0026#34;)\u0026#34;); System.out.println(thread + \u0026#34; get()=\u0026#34; + local.get()); local.remove(); }).start(); } } } "},{"id":18,"href":"/program-lang/java/container/Map/TreeMap/","title":"TreeMap","section":"Map","content":"\rTreeMap\r#\r概述\r#\rTreeMap 是有序集合，通过红黑树实现 特点\r#\r键 不允许为null，不允许重复 值 允许为null，允许重复 顺序 有序 多线程 线程不安全 继承关系\r#\rpublic class TreeMap\u0026lt;K,V\u0026gt; extends AbstractMap\u0026lt;K,V\u0026gt; implements NavigableMap\u0026lt;K,V\u0026gt;, Cloneable, java.io.Serializable AbstractMap接口 提供了Map骨干功能 NavigableMap接口 SortedMap 的扩展接口，提供了一系列的导航方法 Cloneable接口 支持克隆 Serializable接口 支持序列化 成员变量\r#\r// 比较器 private final Comparator\u0026lt;? super K\u0026gt; comparator; // 红黑树的根节点 private transient Entry\u0026lt;K,V\u0026gt; root; // 元素的个数 private transient int size = 0; // 修改的次数 private transient int modCount = 0; // 节点结构 static final class Entry\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { K key; V value; Entry\u0026lt;K,V\u0026gt; left; Entry\u0026lt;K,V\u0026gt; right; Entry\u0026lt;K,V\u0026gt; parent; boolean color = BLACK; Entry(K key, V value, Entry\u0026lt;K,V\u0026gt; parent) { this.key = key; this.value = value; this.parent = parent; } //... } 构造方法\r#\r// 默认 public TreeMap() { comparator = null; } // 指定比较器 public TreeMap(Comparator\u0026lt;? super K\u0026gt; comparator) { this.comparator = comparator; } // 指定集合，转化为TreeMap public TreeMap(Map\u0026lt;? extends K, ? extends V\u0026gt; m) { comparator = null; putAll(m); } // 指定集合，转化为TreeMap public TreeMap(SortedMap\u0026lt;K, ? extends V\u0026gt; m) { //... } "},{"id":19,"href":"/program-lang/java/container/Set/TreeSet/","title":"TreeSet","section":"Set","content":"\rTreeSet\r#\r概述\r#\rTreeSet 基于 TreeMap 实现，是 TreeMap 的缩水版本 特点\r#\r顺序 有序 元素 不允许为null，不允许重复 多线程 线程不安全 继承关系\r#\rpublic class TreeSet\u0026lt;E\u0026gt; extends AbstractSet\u0026lt;E\u0026gt; implements NavigableSet\u0026lt;E\u0026gt;, Cloneable, java.io.Serializable AbstractSet接口 提供了 Set 接口的骨干功能 NavigableSet接口 SortedSet 的扩展接口，提供了一系列的导航方法 Cloneable接口 支持克隆 Serializable接口 支持序列化 成员变量\r#\r// 使用Map的key保存元素 private transient NavigableMap\u0026lt;E,Object\u0026gt; m; // 使用PRESENT作为Map所有key的value private static final Object PRESENT = new Object(); 构造方法\r#\r// 默认 public TreeSet() { this(new TreeMap\u0026lt;E,Object\u0026gt;()); } // 指定比较器 public TreeSet(Comparator\u0026lt;? super E\u0026gt; comparator) { this(new TreeMap\u0026lt;\u0026gt;(comparator)); } // 指定集合，转化为TreeSet public TreeSet(Collection\u0026lt;? extends E\u0026gt; c) { this(); //... } // 指定集合，转化为TreeSet public TreeSet(SortedSet\u0026lt;E\u0026gt; s) { this(s.comparator()); //... } "},{"id":20,"href":"/program-lang/java/container/List/Vector/","title":"Vector","section":"List","content":"\rVector\r#\r概述\r#\r是一个动态数组，其容量能够动态增长 和 ArrayList 很相似，不同的是，Vector 是线程安全的，且包含了许多非集合框架方法 不推荐使用 特点\r#\r顺序 有序 元素 允许为 null，允许重复 效率 比 ArrayList 效率低 多线程 线程安全 继承关系\r#\rpublic class Vector\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable AbstractList、List接口 提供了列表的骨干功能 RandomAccess接口 提供了随机访问功能 Cloneable接口 支持克隆 Serializable接口 支持序列化 成员变量\r#\r// 保存元素的数组 protected Object[] elementData; // 元素的个数 protected int elementCount; // 扩容因子 protected int capacityIncrement; 构造方法\r#\r// 默认 public Vector() { this(10); } // 指定初始容量 public Vector(int initialCapacity) { this(initialCapacity, 0); } // 指定初始容量、扩容因子 public Vector(int initialCapacity, int capacityIncrement) { //... } // 指定集合，转化为Vector public Vector(Collection\u0026lt;? extends E\u0026gt; c) { //... } 扩容机制\r#\r如果扩容因子大于0，就设置新容量为：旧容量 + 增长因子 如果扩容因子不大于0，设置新容量为：旧容量 * 2 private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement \u0026gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); } "},{"id":21,"href":"/program-design/data-algorithm/sort/bubble/","title":"冒泡排序","section":"排序算法","content":"\r冒泡排序\r#\r算法步骤\r#\r相邻元素两两比较，大的往后放。第一轮完毕后，最后的元素会是最大的数 去除最后的元素，重复以上的步骤。 直到所有元素均排序完毕 动图演示\r#\r代码实现\r#\rpublic class BubbleSort implements IArraySort { @Override public int[] sort(int[] arr) throws Exception { for (int i = 1; i \u0026lt; arr.length; i++) { // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。 boolean flag = true; for (int j = 0; j \u0026lt; arr.length - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; flag = false; } } if (flag) { break; } } return arr; } } "},{"id":22,"href":"/service-manage/distributed/","title":"分布式","section":"服务治理","content":"\r分布式系统\r#\r网络上相互连接的多个组件，通过通信协作而形成的软件系统 CAP 理论\r#\r一个分布式系统，最多只能同时实现 CAP 三要素中的两点，不能三者兼顾。 一致性 Consistency 所有节点上的数据时刻保持同步 可用性 Availability 每个请求都能接收到一个响应，无论响应成功或失败 分区容错 Partition tolerance 系统应该持续提供服务，即使系统内部某个节点有消息丢失 BASE 理论\r#\r基本可用 Basically Available 分布式系统在出现不可预知故障的时候，允许损失部分可用性 响应时间上的损失、系统功能上的损失 软状态 Soft-state 允许系统中的数据存在中间状态，前提是该中间状态的存在不会影响系统的整体可用性 即允许系统在不同节点的数据副本之间数据同步的过程存在延时 最终一致性 Eventually Consistent 系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态 "},{"id":23,"href":"/framework/spring/aop/AspectJ/","title":"切面编程","section":"AOP","content":"\r切面编程\r#\r启用\r#\rJava 配置类 // 在 Java 配置类中，使用 @EnableAspectJAutoProxy 和 @ComponentScan @Configuration @ComponentScan(basePackages = \u0026#34;xxx.xxx.xxx\u0026#34;) //注解扫描 @EnableAspectJAutoProxy //开启 AspectJ 的自动代理 public class AppConfig { } XML 配置文件 \u0026lt;!-- 开启注解扫描 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;xxx.xxx.xxx\u0026#34;/\u0026gt; \u0026lt;!--开启AspectJ 自动代理--\u0026gt; \u0026lt;aop:aspectj-autoproxy/\u0026gt; 示例\r#\r// 定义切面 @Aspect public class TestAnnotationAspect { // 定义切点 @Pointcut(\u0026#34;execution(* com.spring.service.*.*(..))\u0026#34;) private void pointCutMethod() { } // 定义环绕通知 @Around(\u0026#34;pointCutMethod()\u0026#34;) public Object doAround(ProceedingJoinPoint pjp) throws Throwable { System.out.println(\u0026#34;进入方法......\u0026#34;); Object o = pjp.proceed(); System.out.println(\u0026#34;退出方法......\u0026#34;); return o; } // 定义前置通知 @Before(\u0026#34;pointCutMethod()\u0026#34;) public void doBefore() { System.out.println(\u0026#34;......\u0026#34;); } // 定义后置通知 @After(\u0026#34;pointCutMethod()\u0026#34;) public void doAfter() { System.out.println(\u0026#34;......\u0026#34;); } // 定义正常返回通知 @AfterReturning(pointcut = \u0026#34;pointCutMethod()\u0026#34;, returning = \u0026#34;result\u0026#34;) public void doAfterReturning(String result) { System.out.println(\u0026#34;......\u0026#34;); } // 定义异常返回通知 @AfterThrowing(pointcut = \u0026#34;pointCutMethod()\u0026#34;, throwing = \u0026#34;e\u0026#34;) public void doAfterThrowing(Exception e) { System.out.println(\u0026#34;......\u0026#34;); } } "},{"id":24,"href":"/program-design/design-pattern/creational/","title":"创建型","section":"设计模式","content":" 常用 不常用 创造型 单例、工厂、建造者 原型 "},{"id":25,"href":"/program-lang/java/thread/thread/thread-create/","title":"创建线程","section":"线程基础","content":"\r创建线程\r#\r继承Thread类\r#\rpublic class MyThread extends Thread { @Override public void run() { // 执行体... } } public class Test { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.start(); } } 实现 Runnable 接口\r#\rpublic class MyRunnable implements Runnable { @Override public void run() { // 执行体... } } public class Test { public static void main(String[] args) { MyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable); thread.start(); } } 使用 Callable、Future\r#\rpublic class MyCallable implements Callable\u0026lt;String\u0026gt;{ @Override public String call(){ // 执行体... return \u0026#34;\u0026#34;; } } public class Test { public static void main(String[] args) { Callable\u0026lt;String\u0026gt; myCallable = new MyCallable(); FutureTask\u0026lt;String\u0026gt; futureTask = new FutureTask\u0026lt;\u0026gt;(myCallable); Thread thread = new Thread(futureTask); thread.start(); } } 使用 Executor 框架\r#\rpublic class MyRunnable implements Runnable { @Override public void run() { // 执行体... } } public class Test { public static void main(String[] args) { ExecutorService executor = Executors.newSingleThreadExecutor(); MyRunnable myRunnable = new MyRunnable(); for (int i = 0; i \u0026lt; 5; i++) { executor.execute(myRunnable); } System.out.println(\u0026#34;线程任务开始执行\u0026#34;); executor.shutdown(); } } "},{"id":26,"href":"/program-lang/java/jvm/class-load/loader/","title":"加载器","section":"类加载","content":"\r加载器\r#\r类加载\r#\r虚拟机加载class文件到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的Class对象 类加载器\r#\r实现 “通过一个类的全限定名来获取描述此类的二进制字节流” 动作的代码模块，称为类加载器。 相同的字节码被不同的类加载器加载的类不相等。 类加载器类型\r#\r启动类加载器\nBootstrapClassLoader C++ 编写，负责加载 jre/lib 下面的核心类库（java.lang.*等） 扩展类加载器\nExtClassLoader Java 编写，负责加载 jre/lib/ext 目录下的一些扩展类库， 只有一个实例。 应用程序类加载器\nAppClassLoader Java 编写，负责加载应用程序的主函数类 ， 只有一个实例。 用户自定义类加载器\nCustomClassLoader Java 编写，负责加载指定路径的 class 文件 双亲委派机制\r#\r当类加载器需要加载某一个 .class 字节码文件时，它会首先将这个任务委托给其父类加载器。 递归这个操作，直至传递到顶层的启动类加载器。 只有当父类加载器无法完成此加载任务时，子类加载器才会自己去加载。 双亲委派的作用\r#\r防止类的重复加载。通过委派的方式，判断上级是否已经加载过该 .class 文件，如果加载过了，则不需要重新加载 保证核心 .class 不被篡改，即使被篡改也不会被加载，即使被加载也不会是同一个 class 对象。 Java类随着类加载器一起具备了带有优先级的层级关系 "},{"id":27,"href":"/program-design/design-pattern/creational/01-singleton/","title":"单例模式","section":"创建型","content":"\r单例模式\r#\r概述\r#\r英文：Singleton Pattern 简述：保证一个类仅有一个实例，并且提供一个全局访问点 归纳：世上只有一个我 目的：保证独一无二 案例：CEO 示例\r#\r饿汉式\r#\r一般情况下，推荐使用 // 在类初始化时，已经自行实例化 public class Singleton { private static final Singleton instance = new Singleton(); private Singleton(){} public static Singleton getInstance(){ return instance; } } 懒汉式\r#\r一般情况下，不建议使用 // 在第一次调用的时候实例化自己 public class Singleton { private static volatile Singleton instance = null; private Singleton(){} public static Singleton getInstance(){ //双重判定：效率、同步 if(instance == null){ synchronized(Singleton.class){ if(instance == null){ return new Singleton(); } } } return instance; } } 登记式\r#\r内部静态类，只有在要明确实现 lazy loading 效果时，才会使用 public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } } 枚举式\r#\r如果涉及到反序列化创建对象时，可以尝试使用 public enum Singleton { INSTANCE; public void whateverMethod() { } } 应用\r#\r主要解决： 一个全局使用的类频繁的创建与销毁 应用场景： 要求生产唯一序列号。 WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 注意事项： 防止多线程情况下，实例被多次创建 单例类不要实现 Cloneable 接口 "},{"id":28,"href":"/database/oracle/plsql/basic-syntax/","title":"基本语法","section":"PL/SQL","content":"\r基本语法\r#\rPL/SQL\r#\r是块结构语言，其最基本的单元是语句块。 每一条语句以逗号结尾，不区分大小写。 语句块\r#\r块的结构 关键字 是否必备 声明部分 DECLARE 可选 可执行命令部分 BEGIN、END 必备 异常处理部分 EXCEPTION 可选 -- 基本结构 DECLARE -- declarations section BEGIN -- executable command(s) EXCEPTION -- exception handling END; -- 示例 DECLARE message varchar2(20):= \u0026#39;Hello, World!\u0026#39;; BEGIN dbms_output.put_line(message); END; 标识符\r#\r由字母，数字，美元符号，下划线和数字符号组成 不能使用保留关键字作为标识符 不得超过30个字符 分隔符\r#\r分隔符 ' 字符串分隔符 \u0026quot; 引用标识符分隔符 , 项目分隔符 ( ) 表达式或列表分隔符 \u0026lt;\u0026lt; \u0026gt;\u0026gt; 标签分隔符 运算符 := 赋值运算符 =\u0026gt; 关联运算符 .. 范围运算符 ΙΙ 连接运算符 其他 % 属性绑定 . 组件选择符 : 主机变量指示符 @ 远程访问指示符 ; 声明或语句终止符 -- 单行注释 /* */ 多行注释 运算符\r#\r算术运算符 + - * / 加减乘除 ** 幂运算 关系运算符 \u0026lt; \u0026lt;= 小于、小于等于 \u0026gt; \u0026gt;= 大于、大于等于 = 等于 \u0026lt;\u0026gt; '= ~= ^= 不等于 比较运算符 LIKE 通配符比较 BETWEEN 范围比较 IN 判断值是否在结果集中 IS [NOT] NULL 是否为空 逻辑运算符 NOT 逻辑否 AND 逻辑与 OR 逻辑或 常量变量\r#\r常量\r#\r:= 赋初始值，也可以使用 DEFAULT 代替 -- 语法 constant_name CONSTANT datatype := value; -- 示例 pi CONSTANT NUMBER := 3.141592654; hello CONSTANT VARCHAR2(20) DEFAULT \u0026#39;Hello world\u0026#39;; 变量\r#\rNOT NULL 约束变量值不能为null -- 语法 variable_name datatype [NOT NULL] [:= value]; -- 示例 sales NUMBER(10, 2); name VARCHAR2(25) := \u0026#39;zhangsan\u0026#39;; DECLARE v_counter INTEGER; BEGIN v_counter := 0; v_counter := v_counter+1; DBMS_OUTPUT.put_line(\u0026#39;变量结果=\u0026#39; || v_counter); END; 变量作用域\r#\r局部变量：内部块中声明的变量，外部块不可访问。 全局变量：在最外部块或包中声明的变量。 DECLARE -- Global variables num1 number := 95; num2 number := 85; BEGIN DBMS_OUTPUT.put_line(\u0026#39;Outer Variable num1: \u0026#39; || num1); DBMS_OUTPUT.put_line(\u0026#39;Outer Variable num2: \u0026#39; || num2); DECLARE -- Local variables num1 number := 195; num2 number := 185; BEGIN DBMS_OUTPUT.put_line(\u0026#39;Inner Variable num1: \u0026#39; || num1); DBMS_OUTPUT.put_line(\u0026#39;Inner Variable num2: \u0026#39; || num2); END; END; /* Outer Variable num1: 95 Outer Variable num2: 85 Inner Variable num1: 195 Inner Variable num2: 185 */ 编码风格\r#\r大小写风格：关键字、内置函数、预定义类型使用大写字母。 标识符命名：v_变量名、con_常量名、cur_游标名、type_类型名 缩进风格：2空格缩进 "},{"id":29,"href":"/program-lang/web/css/style/font/","title":"字体样式","section":"CSS 样式","content":"\r字体样式\r#\r属性\r属性说明\r属性值\r属性值说明\rcolor\r字体颜色\rcolor\r颜色值\rfont-style\r字体风格\rnormal\r正常\ritalic\r斜体\roblique\r斜体\rfont-weight\r字体粗细\r100 - 900\r数值：400=normal，700=bold\rlighter\r更细\rnormal\r标准\rbold\r粗体\rbolder\r更粗\rfont-size\r字体尺寸\rsize\r数值\rxx-small\r\u0026nbsp;\u0026nbsp;9px\r\u0026nbsp;x-small\r11px\r\u0026nbsp;\u0026nbsp; small\r13px\r\u0026nbsp; medium\r16px\r\u0026nbsp;\u0026nbsp; large\r19px\r\u0026nbsp;x-large\r23px\rxx-large\r28px\rfont-family\r字体系列\r字体名\rTimes、\"Times New Roman\"、...\r字体集\r\"serif\"、\"sans-serif\"、...\r简写\r#\r顺序：font-style | font-weight | font-size/line-height | font-family 至少需设定 font-size 和 font-family 示例\r#\rdiv{ font-style:italic; font-weight:bold; font-size:12px; line-height:1.5em; font-family:arial,verdana; color:red; } div{ font:italic bold 12px/1.5em arial,verdana; color:red; } "},{"id":30,"href":"/database/mysql/grammar/character-datatype/","title":"字符集、数据类型","section":"基本语法","content":"\r字符集\r#\rMySQL使用变量来存储字符集\n客户端传入数据给服务端：character_set_client\n服务端返回数据给客户端：character_set_results\n客户端服务端之间的连接：character_set_connection\n-- 查询数据库字符集 show variables like \u0026#39;character_set_%\u0026#39;; -- 设置字符集 set character_set_client = utf8; 设置字符集：修改my.ini文件\n[mysqld] character-set-server=utf8 [client] default-character-set=utf8 [mysql] default-character-set=utf8 数据类型\r#\r整数类型\r#\r类型 描述 大小 范围（有符号） 范围（无符号） TINYINT 迷你整形 1 字节 (-128，127) (0，255) SMALLINT 小整形 2 字节 (-32 768，32 767) (0，65 535) MEDIUMINT 中整形 3 字节 INT或INTEGER 标准整形 4 字节 BIGINT 大整形 8 字节 小数类型\r#\r语法：如Float(M,D)，M表示数值总位数，D代表小数部分位数 类型 描述 大小 FLOAT 单精度浮点型 4 字节 DOUBLE 双精度浮点型 8 字节 DECIMAL 数值型 16 字节 日期时间类型\r#\r类型 描述 大小 格式 范围 YEAR 年 1 字节 YYYY 1901 ~ 2155 DATE 日期 3 字节 YYYY-MM-DD 1000-01-01 ~ 9999-12-31 TIME 时间 3 字节 HH:MM:SS \u0026lsquo;-838:59:59\u0026rsquo; ~ \u0026lsquo;838:59:59\u0026rsquo; TIMESTAMP 时间戳 4 字节 YYYYMMDD HHMMSS 1970-01-01 00:00:00 ~ 2038-1-19 11:14:07 DATETIME 日期时间 8 字节 YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 ~9999-12-31 23:59:59 字符串类型\r#\r类型 描述 大小 CHAR 定长字符 0-255字节 VARCHAR 变长字符 0-65535 字节 TINYTEXT 短文本 0-255字节 TEXT 文本 0-65 535字节 MEDIUMTEXT 长文本 0-16 777 215字节 LONGTEXT 极大文本 0-4 294 967 295字节 TINYBLOB 二进制，短文本 0-255字节 BLOB 二进制，文本 0-65 535字节 MEDIUMBLOB 二进制，长文本 0-16 777 215字节 LONGBLOB 二进制，极大文本 0-4 294 967 295字节 "},{"id":31,"href":"/service-manage/springboot/work-principle/","title":"工作原理","section":"Spring Boot","content":"\r工作原理\r#\r核心注解\r#\r@SpringBootApplication，组合以下注解 @SpringBootConfiguration：Spring Boot 项目的配置注解 @EnableAutoConfiguration：启用自动配置 @ComponentScan：默认扫描 @SpringBootApplication 所在类的同级目录以及它的子目录 自动配置原理\r#\r在 spring 程序 main 方法中，添加 @SpringBootApplication 或者 @EnableAutoConfiguration 后， 框架会自动去 maven 中读取每个 starter 中的 spring.factories 文件。 该文件里配置了所有需要被创建的 spring bean。 "},{"id":32,"href":"/service-manage/zookeeper/work-principle/","title":"工作原理","section":"Zookeeper","content":"\r工作原理\r#\r工作机制\r#\r基于观察者模式设计，接受观察者的注册 负责存储和管理大家都关心的数据 当这些数据发现变化时，将会通知到已注册的观察者。 监听原理\r#\r在 main() 主线程中创建 zkClient 客户端。 zkClient 会创建两个线程，一个负责网络连接通信（connet），一个负责监听（listener）。 zkClient 通过 connet 线程，将监听事件注册到 Zookeeper 的监听列表。 当数据或路径发生改变时，Zookeeper 会将消息发送给 listener 线程。 listener 线程调用 process() 方法，执行相应的操作。 "},{"id":33,"href":"/program-lang/java/jvm/gc/reference-type/","title":"引用类型","section":"垃圾回收","content":"\r引用类型\r#\r强引用\r#\r指普通的对象引用 // 对于具有强引用的对象，就算出现OOM，垃圾回收器也不会对该对象进行回收。 Object strongReference = new Object(); // 只有当强引用和对象之间的关联被中断时，对象才会被回收 strongReference = null; 软引用\r#\r对于只有软引用的对象，当内存空间不充足时，它会被回收；当空间充足时，它不会被回收； 应用场景：高速缓存、读取大量本地图片 // 强引用 String str = new String(\u0026#34;abc\u0026#34;); // 软引用 SoftReference\u0026lt;String\u0026gt; softReference = new SoftReference\u0026lt;\u0026gt;(str); System.out.println(softReference.get()); 弱引用\r#\r对于只有弱引用的对象，不管内存空间是否充足，它都会被回收 应用场景：读取大量本地图片 // 强引用 String str = new String(\u0026#34;abc\u0026#34;); // 弱引用 WeakReference\u0026lt;String\u0026gt; weakReference = new WeakReference\u0026lt;\u0026gt;(str); System.out.println(weakReference.get()); // WeakHashMap：键是\u0026#34;弱键\u0026#34;，通过弱引用来管理 entry Map\u0026lt;Integer, String\u0026gt; weakMap = new WeakHashMap\u0026lt;\u0026gt;(); Integer key = new Integer(1); weakMap.put(key, \u0026#34;value\u0026#34;); System.out.println(weakMap); key = null; System.gc(); System.out.println(weakMap); // {1=value} // {} 虚引用\r#\r即形同虚设， 对于只有虚引用的对象，它就和没有引用一样，在任何时候都可能被回收 它必须与 ReferenceQueue 配合使用，垃圾回收之后，它会被放入引用队列中 // 强引用 String str = new String(\u0026#34;abc\u0026#34;); // 虚引用 ReferenceQueue queue = new ReferenceQueue(); PhantomReference pr = new PhantomReference(str, queue); 总结\r#\r引用类型 被垃圾回收时间 用途 生存时间 强引用 从来不会 对象的一般状态 JVM停止运行时终止 软引用 当内存不足时 对象缓存 内存不足时终止 弱引用 正常垃圾回收时 对象缓存 垃圾回收后终止 虚引用 正常垃圾回收时 跟踪对象的垃圾回收 垃圾回收后终止 "},{"id":34,"href":"/program-base/network/http/message/","title":"报文","section":"HTTP","content":"\rHTTP 报文\r#\r报文格式\r#\r请求方式\r#\rGET 返回请求路径所对应的资源。 POST 向请求路径提交数据，创建新的资源。 PUT 更新请求路径所对应的资源。 DELETE 删除请求路径所对应的资源。 HEAD 不需要返回资源，仅返回响应行和响应头即可。 PATCH 更新请求路径所对应的部分资源。 OPTIONS 获取请求路径对应资源的信息（是否可可跨域获取，可以支持哪些请求方式等）。 TRACE 直接返回请求，主要用于测试。 媒体类型\r#\rContent-Type，用于定义请求和响应中的媒体类型信息 类型 描述 类型 描述 text/html HTML格式 application/xhtml+xml XHTML格式 text/plain 纯文本格式 application/xml XML数据格式 text/xml XML格式 application/json JSON数据格式 image/gif gif图片格式 application/pdf pdf格式 image/jpeg jpg图片格式 application/msword Word文档格式 image/png png图片格式 application/octet-stream 二进制流数据 multipart/form-data 表单文件上传 application/x-www-form-urlencoded 表单key/value格式 "},{"id":35,"href":"/database/redis/persistence/","title":"持久化","section":"Redis","content":"\r持久化\r#\r持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。 RDB方式\r#\r能够在指定的时间间隔能对你的数据进行快照存储 AOF方式\r#\r记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据， AOF命令以redis协议追加保存每次写的操作到文件末尾。 Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大 "},{"id":36,"href":"/database/intro/","title":"数据库","section":"数据存储","content":"\r数据库\r#\r数据库\r#\rDatabase，是按照数据结构来组织、存储和管理数据的仓库 非关系型数据库\r#\r主要指非关系型的、分布式的，且一般不保证ACID的数据存储系统 优点：善于处理海量数据、支持分布式集群，负载均衡，性能高 缺点：事务处理能力弱、数据间没有关系、对于复杂业务场景支持较差 代表：Redis、MongoDB、CouchDB 关系型数据库\r#\r采用了关系模型来组织数据的数据库。 优点：容易理解、使用方便、易于维护 缺点：海量数据的读写效率低、难以横向扩展 代表：MySQL、Oracle、PostgreSQL、DB2、SQL Server、Microsoft Access 三大范式\r#\r第一范式（1NF）：字段是最小单元，不可再进行拆分\n第一范式要求字段中的值已经是无法再分割的值。 例如：员工表，姓名字段仅包含员工的正式名称，就符合第一范式， 反之包含中文名、英文名、别名等，则意味着姓名字段是再拆分的 第二范式（2NF）：表要具有唯一性的主键列\n第二范式是在第一范式的基础上的增强，要求数据库表中的行必须可以被唯一的区分。 例如：员工表，定义工号作为主键 第三范式（3NF）：表中的字段不能包含在其他表中已经出现的非主键字段\n第二范式是在前两个范式的基础上的增强，主要用来降低数据的冗余。 例如：员工表包含了部门编码，它引用到部门表中的部门编号这个主键，此时符合第三范式 如果在员工表中又包含一个部门名称，则造成了数据的冗余，不符合第三范式 SQL\r#\rStructured Query Language，结构化查询语言 是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。 语句分类 说明 DDL 数据定义语句，Data Definition Language DML 数据操纵语句，Data Manipulation Language DQL 数据查询语句，Data Query Language DCL 数据控制语句，Data Control Language "},{"id":37,"href":"/database/mysql/advanced-feature/database-engine/","title":"数据库引擎","section":"高级特性","content":"\r数据库引擎\r#\rInnoDB\r#\r是一个事务型的存储引擎，支持行级锁、外键约束、自动增长列。 它的设计目标是处理大容量数据库系统，运行时，InnoDB会在内存中建立缓冲池，用于缓冲数据和索引。 索引结构\r#\rInnoDB是B+Tree索引结构，其将主键组织到一棵B+Tree中，而行数据储存在叶节点上（即聚集索引） 检索算法\r#\r若对主键列进行条件搜索，则按B+Tree的检索算法即可查找到对应的叶节点，获得行数据。\n若对非主键列进行条件搜索，则先在辅助索引B+Tree中检索对应列，到达其叶节点获取对应的主键，\n再进行“对主键列进行条件搜索”\n适用场景\r#\r更新密集的表 事务 自动灾难恢复 外键约束 支持自动增加列属性 MyISAM\r#\r极度强调快速读取操作，不支持数据库事务、行级锁、外键约束 存储格式\r#\r存储格式 特点 优点 缺点 静态表 表中字段均固定长度 存储快，容易缓存 空间占用多 动态表 表中字段均长度可变 空间占用少 容易产生磁盘碎片 压缩表 单独压缩每个记录 访问开支小 需解压 索引结构\r#\rMyISAM 是B+Tree索引结构，其B+Tree的数据域存储的内容为实际数据的地址（即非聚集索引）。 检索算法\r#\r先按B+Tree的检索算法搜索索引，取出其数据域的值， 再以这个值为地址，去读取相应的数据记录。 适用场景\r#\r查询密集型表。MyISAM 存储引擎在筛选大量数据时非常快； 插入密集型表。MyISAM 的并发插入特性允许同时选择、插入数据。 InnoDB \u0026amp; MyISAM\r#\r对比\r#\r区别 InnoDB MyISAM 锁级别 行级锁 表级锁 事务、外键、自增列 支持 不支持 全文索引 不支持 支持 主键 必须有 可以没有 存储空间 占用较多 占用较少 表的具体行数 不保存 保存 使用建议\r#\rInnoDB：可靠性高或者要求事务处理的、表更新和查询都相当频繁的 MyISAM：做很多count的计算的、插入修改不频繁而查询非常频繁的 "},{"id":38,"href":"/database/mysql/mysql-command/database/","title":"数据库管理","section":"基础命令","content":"\r数据库管理\r#\r# 创建 create database 库名 [charset = 字符集] [collate = 校对集]; # 选择 use 库名; # 显示库结构 show create database 库名; # 显示库名 show databases [like \u0026#39;...\u0026#39;]; # 显示当前库名 select database(); # 修改 alter database 库名 [charset = 字符集]/[collate = 校对集]; # 删除 drop database 库名; "},{"id":39,"href":"/program-design/data-structure/","title":"数据结构","section":"程序设计","content":"\r数据\r#\r所有能输入到计算机中并能被程序识别和处理的符号集合 数据结构\r#\r是计算机存储、组织数据的方式 逻辑结构：集合结构、线性结构、树形结构、图形结构 物理结构：顺序存储结构、链式存储结构 "},{"id":40,"href":"/program-design/data-structure/array/","title":"数组","section":"数据结构","content":"\r数组\r#\r数组\r#\rArray 是一种线性结构，在物理内存中占据着一块连续空间。 数组为每个存储的元素都分配了一个下标（索引） ，下标从0开始且自增连续 查询速度快，新增/删除速度慢 特点\r#\r查询速度快 新增、删除速度慢 查询元素\r#\r根据索引直接定位 新增元素\r#\r根据索引找到位置 把后面的所有元素往后移动 插入元素 删除元素\r#\r根据索引找到位置 删除元素 再把后面的所有元素往前移动 "},{"id":41,"href":"/program-base/linux/cmd/flie-manage/","title":"文件管理","section":"常用命令","content":"\r文件管理\r#\rls - 列出目录内容\ncd - 改变目录\ncp - 复制文件或目录\nmv - 移动或重命名文件或目录\nrm - 删除文件或目录\ncat - 连接文件并打印到标准输出\nmore / less - 分页显示文件内容\nhead / tail - 显示文件开头或结尾的内容\n"},{"id":42,"href":"/program-lang/web/html/document/","title":"文档标签","section":"HTML","content":"\r文档标签\r#\r标签 说明 \u0026lt;!DOCTYPE\u0026gt; 定义文档类型 \u0026lt;html\u0026gt; 定义 HTML 文档 \u0026lt;head\u0026gt; 定义网页的头部 \u0026lt;body\u0026gt; 定义网页的主体 头部标签\r#\r标签 说明 \u0026lt;title\u0026gt; 定义网页的标题 \u0026lt;meta\u0026gt; 定义网页的元数据 \u0026lt;base\u0026gt; 定义页面链接标签的默认链接地址 \u0026lt;link\u0026gt; 定义外部资源 \u0026lt;script\u0026gt; 定义脚本文件 \u0026lt;style\u0026gt; 定义样式文件 "},{"id":43,"href":"/framework/quartz/core-class/","title":"核心类","section":"Quartz","content":"\r核心类\r#\rJob\r#\r任务接口\n承载着要被执行的具体业务逻辑\n该接口中定义了 execute 方法，我们需要在里面编写任务执行的业务逻辑。\nJobDetail\r#\r任务实例 负责定义任务数据，为 Job 实例提供了许多属性，存储着 Job 实例的状态信息 调度器每次执行 Job 时，都会根据 JobDetail 创建一个新的 Job 实例，以规避并发访问的问题。 // 重要属性 JobDataMap jobDataMap = jobDetail.getJobDataMap(); String name = jobDetail.getKey().getName(); String group = jobDetail.getKey().getGroup(); String jobName = jobDetail.getJobClass().getName(); Trigger\r#\r触发器 描述触发任务执行的时间规则 // 按简单时间规则执行调度 SimpleTrigger // 按Cron表达式定义的时间规则执行调度 CronTrigger： Scheduler\r#\r调度器 相当于一个容器，装载着任务和触发器。基于 Trigger 触发器，来执行 Job 任务 Trigger 和 JobDetail 可以注册到 Scheduler 中，两者在 Scheduler 中拥有各自的组及名称。 Listener\r#\r监听器 // 监听任务执行前事件、任务执行后事件； JobListener： // 监听触发前事件，出发后事件； TriggerListener： JobDataMap\r#\r可以存储不限量的数据对象，在job实例执行的时候，可以使用其中的数据 // 将job加入到scheduler之前，在构建JobDetail时，可以将数据放入JobDataMap JobDetail job = newJob(DumbJob.class) .withIdentity(\u0026#34;myJob\u0026#34;, \u0026#34;group1\u0026#34;) // name \u0026#34;myJob\u0026#34;, group \u0026#34;group1\u0026#34; .usingJobData(\u0026#34;jobSays\u0026#34;, \u0026#34;Hello World!\u0026#34;) .usingJobData(\u0026#34;myFloatValue\u0026#34;, 3.141f) .build(); // 在job的执行过程中，可以从JobDataMap中取出数据 public class DumbJob implements Job { public DumbJob() { } public void execute(JobExecutionContext context)throws JobExecutionException{ JobKey key = context.getJobDetail().getKey(); JobDataMap dataMap = context.getJobDetail().getJobDataMap(); String jobSays = dataMap.getString(\u0026#34;jobSays\u0026#34;); float myFloatValue = dataMap.getFloat(\u0026#34;myFloatValue\u0026#34;); // ..... } } 两个注解\r#\r// 禁止并发地执行同一个JobDetail实例 @DisallowConcurrentExecution // 当正常执行完Job后，JobDataMap中的数据会保留下来，继续给下一次调用使用 @PersistJobDataAfterExecution "},{"id":44,"href":"/program-design/expression/regular/","title":"正则表达式","section":"表达式","content":"\r正则表达式\r#\r简介\r#\rRegular Expression 是一种字符串匹配的描述模式，用来检索、替换那些符合某个规则的字符串 语法\r#\r转义字符\r#\r特殊字符：( ) [ ] { } 、? * + 、^ $、 . \\ | 构造 匹配 x 字符 x \\ 反斜线字符 \\t 水平制表符 \\v 垂直制表符 \\r 回车符 \\n 换行符 \\f 换页符 普通字符类\r#\r构造 匹配 [abc] 包含：a、b 或 c [^abc] 排除：任何字符，除了 a、b 或 c [a-z] 区间：a 到 z [a-zA-Z] 并集：a 到 z 或 A 到 Z [a-z\u0026amp;\u0026amp;[^bc]] 交集：a 到 z，除了 b 和 c 预定义字符类\r#\r构造 匹配 构造 匹配 . 任何字符 \\d 数字：[0-9] \\D 非数字： [^\\d] \\s 空白字符：[ \\t\\n\\x0B\\f\\r] \\S 非空白字符：[^\\s] \\w 单词字符：[a-zA-Z_0-9] \\W 非单词字符：[^\\w] 边界定位符\r#\r构造 匹配 ^ 行的开头 $ 行的结尾 \\b 单词边界 \\B 非单词边界 数量符\r#\r构造 匹配 X? X，零次或一次 X* X，零次或多次 X+ X，一次或多次 X{n} X，恰好 n 次 X{n,} X，至少 n 次 X{n,m} X，至少 n 次，但是不超过 m 次 运算符\r#\r构造 匹配 XY X 后跟 Y X|Y X 或 Y (X) X，作为捕获组 \\n 引用第n个捕获组 贪婪\r#\r限定符 * + 是贪婪的，它们会尽可能多的匹配文字\n限定符 ? 是非贪婪的，它可以实现最小匹配。\n匹配字符串：\u0026lt;h1\u0026gt;RUNOOB-菜鸟教程\u0026lt;/h1\u0026gt; 正则表达式：/\u0026lt;.*\u0026gt;/\t匹配结果： \u0026lt;h1\u0026gt;RUNOOB-菜鸟教程\u0026lt;/h1\u0026gt; 正则表达式：/\u0026lt;.*?\u0026gt;/\t匹配结果： \u0026lt;h1\u0026gt; 捕获组\r#\r捕获组就是把正则表达式中子表达式匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用 使用( )表示捕获分组 普通捕获组\r#\r格式：(Expression)\n从左到右计算表达式的(，从 1 开始进行编号，0 代表整个表达式\n正则表达式：(\\d{4})-(\\d{2}-(\\d\\d)) 编号 命名 捕获组 匹配内容 0 (\\d{4})-(\\d{2}-(\\d\\d)) 2008-12-31 1 (\\d{4}) 2008 2 (\\d{2}-(\\d\\d)) 12-31 3 (\\d\\d) 31 命名捕获组\r#\r格式：(?\u0026lt;name\u0026gt;Expression) 正则表达式：(?\u0026lt;year\u0026gt;\\d{4})-(?\u0026lt;date\u0026gt;\\d{2}-(?\u0026lt;day\u0026gt;\\d\\d)) 编号 命名 捕获组 匹配内容 0 0 (?\\d{4})-(?\\d{2}-(?\\d\\d)) 2008-12-31 1 year (?\\d{4}) 2008 2 date (?\\d{2}-(?\\d\\d)) 12-31 3 day (?\\d\\d) 31 选择\r#\r?=、?\u0026lt;=、?!、?\u0026lt;! 构造 匹配 \\n 引用捕获组 n X(?=Y) 查找 Y 前面的 X (?\u0026lt;=Y)X 查找 Y 后面的 X X(?!Y) 查找后面不是 Y 的 X (?\u0026lt;!Y)X 查找前面不是 Y 的 X JDK正则\r#\rjava.util.regex String input = \u0026#34;ABC\u0026#34;; String regex = \u0026#34;[a-z]{4}\u0026#34;; // String类 input.matches(regex); // Pattern类 Pattern.matches(regex, input) // Matcher类 Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(input); matcher.matches();\t// 整个字符串是否匹配 matcher.find();\t// 是否有下一个匹配的子串 matcher.group(1);\t// 获取1号捕获组匹配到的子串 ... 常用正则\r#\r\u0026hellip;\n"},{"id":45,"href":"/program-lang/java/thread/problem/deadlock/","title":"死锁","section":"并发问题","content":"\r死锁\r#\r概述\r#\r两个或两个以上的线程，在执行过程中，因争夺资源而造成的一种相互等待的现象 产生条件\r#\r互斥使用 即当资源被一个线程使用(占有)时，别的线程不能使用 不可抢占 资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放 请求和保持 即当资源请求者在请求其他的资源的同时保持对原有资源的占有 循环等待 即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路 图示\r#\r示例\r#\rpublic class HoldThread implements Runnable { private String lockA; private String lockB; public HoldThread(String lockA, String lockB) { this.lockA = lockA; this.lockB = lockB; } @Override public void run() { String threadName = Thread.currentThread().getName(); synchronized (lockA) { System.out.println(threadName + \u0026#34;\\t 持有锁\u0026#34; + lockA + \u0026#34;尝试获得\u0026#34; + lockB); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (lockB) { System.out.println(threadName + \u0026#34;\\t 持有锁\u0026#34; + lockB + \u0026#34;尝试获得\u0026#34; + lockA); } } } } public class DeadLockDemo { public static void main(String[] args) { String lockA = \u0026#34;lockA\u0026#34;; String lockB = \u0026#34;lockB\u0026#34;; new Thread(new HoldThread(lockA, lockB), \u0026#34;AAA\u0026#34;).start(); new Thread(new HoldThread(lockB, lockA), \u0026#34;BBB\u0026#34;).start(); } } 解决办法\r#\rjps：定位进程编号 jstack：找到死锁查看 "},{"id":46,"href":"/dev-tool/git/version-control/","title":"版本控制","section":"Git","content":"\r版本控制\r#\r概述\r#\r版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统\n功能：\n协同修改：多人并行不悖的修改服务器端的同一个文件。 数据备份：不仅保存目录和文件的当前状态， 还能够保存每一个提交过的历史状态。 版本管理：在保存每一个版本的文件信息的时候要做到不保存重复数据， 以节约存储空间， 提高运行效率。 权限控制：对参与开发的人员进行权限控制及代码审核 历史记录：查看修改人、 修改时间、 修改内容、 日志信息。将本地文件恢复到某一个历史状态。 分支管理：允许开发团队在工作过程中多条生产线同时推进任务， 进一步提高效率 分类\r#\r本地式\r#\r用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别 好处就是简单，但是特别容易犯错 集中式\r#\r使用一个单一的集中管理的服务器，保存所有文件的修订版本 而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新 增量维护，特点： 数据不安全：存在单点故障、黑客攻击的问题，需做好数据备份 服务器压力大：所有操作都需要与服务器交互，受限于宽带 强调集中管理：适合人数不多的项目 分布式\r#\r客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 全量维护，特点： 数据安全完整：所有节点都是服务器，无带宽和性能瓶颈；提交全部使用SHA1哈希 效率高：提交为本地操作，全离线操作；编码不会被冲突打断 强调个体：适合分布式开发 SVN\r#\r是基于差异的版本控制，存储的是一组基本文件和每个文件随时间逐步累积的差异 优缺点：节省磁盘空间，耗时、效率低。 不适合的领域：跨地域的协同开发、追求高质量代码和代码门禁 Git\r#\r是基于快照的版本控制，存储的是文件的一系列快照 优缺点：版本切换时非常快，占用磁盘空间较大 不适合的领域：目录级别的读授权、word等二进制文档的版本控制 "},{"id":47,"href":"/program-base/linux/dir/","title":"目录结构","section":"Linux","content":"\rLinux 目录结构\r#\r"},{"id":48,"href":"/program-lang/java/oop/class/","title":"类和对象","section":"面向对象","content":"\r类和对象\r#\r概述\r#\r类：是一个模板，它描述一类对象的状态和行为。 对象：是类的一个实例，有状态和行为。 构造方法\r#\r每个类都有构造方法。 如果没有显式定义，Java编译器将会为该类提供一个默认构造方法。 在创建一个对象的时候，至少要调用一个构造方法。 构造方法的名称必须与类同名。 一个类可以有多个构造方法。 public class Puppy{ public Puppy(){ } public Puppy(String name){ // 这个构造器仅有一个参数：name } } 创建对象\r#\r// 创建类 class 类名{ // 成员变量定义... // 方法定义... } // 创建对象，调用类构造方法 className myObject = new className(); 对象操作\r#\rpublic class Puppy { private String name; public Puppy(String name) { this.name = name; } public String getName() { return this.name; } public static void main(String[] args) { Puppy myPuppy = new Puppy(\u0026#34;tommy\u0026#34;); //创建对象 System.out.println(myPuppy.name); //访问对象属性 System.out.println(myPuppy.getName()); //访问对象方法 } } 内部类\r#\r将一个类定义在另一个类的里面，称里面那个类为内部类 内部类的作用就是为了访问外部类中的成员变量（包括私有） 必须先有外部类对象才能生成内部类对象 //外部类 class Out { private int age = 12; //内部类 class In { public void print() { System.out.println(age); } } } public class Demo { public static void main(String[] args) { // 访问方式一 Out.In in = new Out().new In(); in.print(); // 访问方式二 // Out out = new Out(); // Out.In in = out.new In(); // in.print(); } } 枚举类\r#\r是一种特殊形式的Java类 每一个枚举值，代表一个实例对象 构造函数必须为私有 //格式 enum 枚举类名{ 枚举对象实例1, 枚举对象实例2, ...; } //示例 public enum Color{ RED(\u0026#34;red\u0026#34;,\u0026#34;红色\u0026#34;),GREEN(\u0026#34;green\u0026#34;,\u0026#34;绿色\u0026#34;),BLUE(\u0026#34;blue\u0026#34;,\u0026#34;蓝色\u0026#34;); private final String key; private final String value; //... } 初始化顺序\r#\r静态属性 \u0026ndash;\u0026gt; 静态代码块 \u0026ndash;\u0026gt; 成员属性 \u0026ndash;\u0026gt; 构造代码块 \u0026ndash;\u0026gt; 构造函数 先静态后非静态、先父类后子类 public class Test{ // 静态属性：只初始化一次 private static float PI = 3.14f; // 静态代码块：只初始化一次 static { //... } // 成员属性 private int id = 1; // 构造代码块：提取构造方法中的相同部分，减少重复代码 { // 每次对象实例化，都执行一次 } // 构造函数 public Test() { //... } } "},{"id":49,"href":"/database/oracle/system-function/","title":"系统函数","section":"Oracle","content":"\r系统函数\r#\r转换函数\r#\r函数 说明 示例 TO_CHAR 日期 ==\u0026gt; 字符串数值 ==\u0026gt; 字符串 TO_CHAR(SYSDATE, \u0026lsquo;YYYY-MM-DD HH24:MI:SS\u0026rsquo;)TO_CHAR(123.45678, \u0026lsquo;$9999,999\u0026rsquo;) TO_DATE 字符串 ==\u0026gt; 日期 TO_DATE(\u0026lsquo;2000/01/01\u0026rsquo;, \u0026lsquo;YYYY/MM/DD\u0026rsquo;) TO_NUMBER 字符串 ==\u0026gt; 数值 TO_NUMBER(\u0026rsquo;-$12,345.67\u0026rsquo;, \u0026lsquo;$99,999.99\u0026rsquo;) 字符函数\r#\r函数 说明 LOWER(x) 全部转换为小写 UPPER(x) 全部转换为大写 INITCAP(x) 首字母转换为大写 CONCAT(x, y) 连接字符串 x 和 y ，可以用 || 代替 LENGTH(x) 返回字符串的长度 SUBSTR(x, start[, len]) 截取子字符串，从 start 处开始，截取 len 个字符，缺省 len 截到结尾 INSTR(x, str [, start] [, n) 在 x 中查找 str ，可指定从 start 开始、从第 n 次开始 LPAD(x, n, str) 使用 str 进行左填充，直到长度到达 n RPAD(x, n, str) 使用 str 进行右填充，直到长度到达 n TRIM([str FROM] x) 去除 x 两边的 str ，缺省去除空格 LTRIM(x [, str]) 去除 x 左边的 str ，缺省去除空格 RTRIM(x [, str]) 去除 x 右边的 str ，缺省去除空格 REPLACE(x, old, new) 在 x 中查找 old ，并替换为 new 数值函数\r#\r函数 说明 示例 CEIL(x) 向上取整 CEIL(5.4)=6 FLOOR(x) 向下取整 FLOOR(5.8)=5 ROUND(x [, n]) 四舍五入到小数点后的第 n 位 ROUND(3.456, 2)=3.46 TRUNC(x [, n]) 截取到小数点后的第 n 位 TRUNC(3.456, 2)=3.45 ABS(x) x 绝对值 ABS(-3)=3 MOD(x, y) x 除以 y 的余数 MOD(8, 3)=2 POWER(x, y) x 的 y 次幂 POWER(2, 3)=8 SQRT(x) x 的平方根 SQRT(4)=2 日期函数\r#\r函数 说明 SYSDATE 返回系统当前日期 ADD_MONTHS(date, n) 在 date 上加 n 个月 MONTHS_BETWEEN(date1, date2) date1、date2间相差的月份 LAST_DAY(date) date所在月的最后一天 NEXT_DAY(date, \u0026lsquo;星期六\u0026rsquo;) date后的下个星期六 EXTRACT(year from date) 单独取日期里面的年 分组函数\r#\r函数 说明 sum() 求总和 max() 求最大值 min() 求最小值 avg() 求平均数 count() 求总个数 通用函数\r#\r函数 说明 NVL (expr1, expr2) 如果 expr1 不是 null，返回 expr1，否则返回 expr2 NVL2(expr1, expr2, expr3) 如果 expr1 不是 null，返回 expr2，否则返回 expr3 NULLIF(expr1, expr2) 比较 expr1、expr2，如果相等，返回null，否则返回 expr1 COALESCE(expr1, expr2, \u0026hellip;, exprn) 返回第一个不为空的参数 DECODE(col | expression, search1, result1 [, search2, result2, …, ][, default]) 多条件判断 附录：日期转换格式\r#\r格式元素 描述 格式元素 描述 YYYY 年（4位） W 周数（1-5） MM 月份（01-12） Q 季度 DD 一个月里的天数（01-31） TZ 时区 HH、HH12、HH24 一天的小时数 （01-12、01-12、00-23） MI 分钟 （00-59） SS 秒 （00-59） MS 毫秒 (000-999) 附录：数值转换格式\r#\r格式元素 描述 示例 结果 9 每个9代表一个有效位 999999 1234 0 前导0或后继0 099999 001234 . 小数点 99999.99 1234.00 , 分组（千）分隔符 999,999 1,234 EEEE 科学记数 99.999EEEE 1.234E+03 V 10的n次方 9999V99 123400 $ 货币符号 $99999 $1234 L 本地货币符号 L99999 ￥1234 "},{"id":50,"href":"/program-lang/java/thread/thread/","title":"线程基础","section":"多线程","content":"\r程序 \u0026amp; 进程 \u0026amp; 线程\r#\r程序 是为完成特定任务，用某种语言编写的一组指令的集合是静态的实体 进程 是程序执行时的一个实例，即运行中的程序是操作系统资源分配的基本单位是动态的过程 线程 是在进程中独立运行的子任务，代表一个单一顺序的执行流是任务调度和执行的基本单位 临界区\r#\r临界资源：是一次仅允许一个进程使用的共享资源 临界区：各个进程中，操作临界资源的代码片段 相关临界区：多个进程涉及到同一个临界资源的临界区 线程互斥：多个线程之间竞争使用临界资源的现象 "},{"id":51,"href":"/program-lang/java/thread/threadpool/threadpool-theory/","title":"线程池 - 原理","section":"线程池","content":"\r线程池原理\r#\r核心参数\r#\r创建线程池主要是 ThreadPoolExecutor 类来完成 corePoolSize\r#\r核心线程数 如果线程池中的线程数小于 corePoolSize，则会创建新线程来执行新提交的任务 如果线程池中的线程数到达 corePoolSize，则不会创建新线程，而是把新任务放入到缓存队列当中 类比：银行网点中，当值业务窗口数 maximumPoolSize\r#\r最大线程数量 如果阻塞队列已满，且线程池中线程数量未超过 maximumPoolSize，就会创建新线程来执行新提交的任务 类比：银行网点中，最大业务窗口数 keepAliveTime、unit\r#\r空闲线程的存活时间 如果线程数量超过 corePoolSize，且多余空闲线程的存活时间超过 keepAliveTime 时，会销毁空闲的线程 类比：银行网点中，加开的业务窗口，如果其空闲时间超过一定时限，则撤除 workQueue\r#\r阻塞队列 用于保存被提交但尚未被执行的任务 类比：银行网点中，等候区 threadFactory\r#\r创建线程的工厂类 可定制线程，一般使用默认即可 handler\r#\r饱和策略 如果阻塞队列满了，并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。 策略 说明 AbortPolicy 默认策略， 直接拒绝所提交的任务，并抛出RejectedExecutionException异常 CallerRunPolicy 用调用者所在的线程来执行任务 DiscardOldestPolicy 丢弃掉阻塞队列中存放时间最久的任务，执行当前任务 DiscardPolicy 不处理直接丢弃掉任务 工作过程\r#\r创建线程池后，等待提交过来的任务请求 当调用 execute() 添加一个新任务时，线程池会做如下判断： 如果当前运行的线程数量还小于 corePoolSize，则会创建新线程来执行新任务 如果当前运行的线程数量不小于 corePoolSize，则会将提交的任务放入阻塞队列中 如果当前阻塞队列满了，且当前运行的线程数量还小于 maximumPoolSize，则创建线程运行这个任务 如果当前阻塞队列满了，且当前运行的线程数量不小于 maximumPoolSize，则启动拒绝策略 当一个线程完成任务时，它会从队列中取下一个任务来执行 当一个线程空闲超过一定时间，并且此时当前运行的线程大于 corePoolSize 时，这个线程会被销毁 "},{"id":52,"href":"/program-base/network/network-model/","title":"网络模型","section":"网络","content":"\r网络模型\r#\r网络协议\r#\r是指双方实体完成通信或服务所必须遵循的规则和约定 网络协议分层\r#\r"},{"id":53,"href":"/database/mysql/mysql-tuning/table-tuning/","title":"表结构优化","section":"性能调优","content":"\r表结构优化\r#\r合理设计表结构\r#\r尽量将表字段定义为 NOT NULL 约束 单表不要有太多字段，建议在20以内 VARCHAR 类型只分配真正需要的空间 选取最适用的字段属性，优先最简单的数据类型\r#\r尽量使用数字型字段 尽量使用 VARCHAR 代替 CHAR 尽量使用 TIMESTAMP 代替 DATETIME 尽量使用 TINYINT、SMALLINT、MEDIUMINT 代替 INT 对于特定类型字段，可用enum、set 等符合的数据类型 将字段多的表分解成多个表，增加中间表。\r#\r混用范式与反范式，适当冗余\r#\r第一范式：数据表中每个字段都必须是不可拆分的最小单元 第二范式：满足一范式后，要求每条记录由主键唯一区分，记录中所有属性都依赖于主键。 第三范式：满足二范式后，要求所有属性必须直接依赖主键，不允许间接依赖。 分库分表，读写分离\r#\r垂直分表（按列） 水平分表（按行）：按时间分表、按区间分表、按hash分表 "},{"id":54,"href":"/program-lang/java/grammar/syntax-element/","title":"语法元素","section":"基本语法","content":"\r语法元素\r#\rHello World\r#\rpublic class HelloWorld { public static void main(String []args) { System.out.println(\u0026#34;Hello World\u0026#34;); } } 将以上代码，保存为文件HelloWorld.java 进入cmd 命令窗口，进入目标文件所在的位置 编译代码： javac HelloWorld.java 运行：java HelloWorld 标识符\r#\r大小写敏感 命名规则 由字母、数字、美元符$、下划线_组成 不可以数字开头 不可以使用关键字 包名 xxxyyyzzz 类名、接口名、枚举名 XxxYyyZzz 方法名、变量名 xxxYyyZzz 常量名 XXX_YYY_ZZZ 关键字\r#\rJava语言里事先定义的、有特别意义的标识符，即保留字，均为小写\n访问控制修饰符\n修饰符 当前类 同包 子类 其他包 public OK OK OK OK protected OK OK OK default OK OK private OK 其他修饰符 修饰符 含义 修饰 备注 static 静态的 类方法、类变量 final 最终的 类、方法、变量 abstract 抽象的 类、方法 用来创建抽象类和抽象方法 synchronized 同步的 方法、代码块 其修饰的方法，同一时间只能被一个线程访问 volatile 易变的 成员变量 1、线程每次访问该变量，都强制从共享内存中重新读取值2、当变量发生改变时，都强制线程将变化值回写到共享内存 操作符\r#\r算术运算符 +、-、*、/ 加、减、乘、除 ％ 取余：左操作数除以右操作数的余数 ++ 自增：操作数的值增加1 -- 自减：操作数的值减少1 关系运算符 \u0026lt;、\u0026gt; 小于、大于 \u0026lt;=、\u0026gt;= 小于等于、大于等于 ==、!= 相等、不相等 按位运算符 \u0026amp;、` 、〜` ^ 按位异或，二进制比较，相同为0，不同为1. \u0026lt;\u0026lt; 、\u0026gt;\u0026gt;、\u0026gt;\u0026gt;\u0026gt; 按位左移、按位右移、按位右移补零 逻辑运算符 \u0026amp;\u0026amp; 短路与 ` ! 非 赋值运算符 = 赋值 +=、-=、*=、/= 加赋值、减赋值、乘赋值、除赋值 三元运算符 // 格式 variable x = (expression) ? value if true : value if false // 示例 int a , b; a = 10; b = (a == 1) ? 20 : 30; // 如果 a 等于 1 成立，则设置 b 为 20，否则为 30 instanceof // 格式：检查该对象是否是一个特定类型 ( Object reference variable ) instanceof (class/interface type) // 示例 String name = \u0026#34;James\u0026#34;; boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真 注释\r#\r// 单行注释\t/*\t多行注释 多行注释 */ /** * 文档注释 * 能被javadoc解析 */ 常量\r#\r常量在程序运行时是不能被修改的。 // 常量用 final 来修饰 final double PI = 3.1415927; 变量\r#\r定义：代表内存中的一个存储区域 注意：须先声明并初始化，才能使用 作用域：从定义位置开始，到变量所在{}结束 //变量类型 public class Variable { // 静态变量（类变量） static int allClicks = 0; // 实例变量 String str = \u0026#34;hello world\u0026#34;; public void method() { // 局部变量 int i = 0; } } "},{"id":55,"href":"/program-lang/web/css/position/border/","title":"边","section":"CSS 位置","content":"\r边框\r#\r属性\r属性说明\r属性值\r属性值说明\rborder\r简写属性\rborder: \\[宽度]\\[样式][颜色]\rborder-width | style | color\r简写属性\r\u0026nbsp;\rborder-left | right | top | bottom\r简写属性\r\u0026nbsp;\rborder-[ left | right | top | bottom ]-width\r边框宽度\rthin\r细边框\rmedium\r中边框，默认\rthick\r粗边框\rsize\r数值\rborder-[ left | right | top | bottom ]-style\r边框样式\rnone\r无边框\rhidden\r无边框，用于解决边框冲突\rdotted\r点状边框\rdashed\r虚线边框\rsolid\r实线边框\rdouble\r双线边框\rgroove\r3D 凹槽边框\rridge\r3D 垄状边框\rinset\r3D inset 边框\routset\r3D outset 边框\rborder-[ left | right | top | bottom ]-color\r边框颜色\rtransparent\r透明色，默认\rcolor\r颜色值\r边距\r#\rpadding\rpadding-left | right | top | bottom\r内边距\rmargin\rmargin-left | right | top | bottom\r外边距\r值\rauto\r浏览器自动计算\rsize\r数值\r简写\u0026nbsp;\n助记：顺时针\rmargin:值1\r上下左右 = 值1\rmargin:值1 值2\r上下=值1，左右=值2\rmargin:值1 值2 值3\r上=值1，左右=值2，下=值3\rmargin:值1 值2 值3 值4\r上=值1，右=值2，下=值3，左=值4\r"},{"id":56,"href":"/dev-tool/gradle/config/","title":"配置","section":"Gradle","content":"\r工作原理\r#\rAndroid 配置\r#\rAndroid Studio打开一个工程时，首先会读取gradle-wrapper.properties 文件，获知gradle版本\n然后去 GRADLE_USER_HOME 文件夹，查看是否存在对应版本的gradle\n如果不存在，则会去 distributionUrl 去下载gradle\n配置文件：gradle-wrapper.properties\n# 下载的Gradle压缩包解压后存储的主目录 distributionBase=GRADLE_USER_HOME # 相对于distributionBase的解压缩后的Gradle压缩包的路径 distributionPath=wrapper/dists # 同distributionBase，只不过是存放zip压缩包的 zipStoreBase=GRADLE_USER_HOME # 同distributionPath，只不过是存放zip压缩包的 zipStorePath=wrapper/dists # Gradle发行版压缩包的下载地址 distributionUrl=https\\://services.gradle.org/distributions/gradle-6.5-bin.zip "},{"id":57,"href":"/program-lang/java/thread/lock/concurrency-lock/","title":"锁","section":"锁体系","content":"\r锁\r#\r并发锁\r#\r锁是用来控制多个线程访问共享资源的方式 一个锁能够防止多个线程同时访问共享资源 实现方案\r#\rsynchronized\r#\r存在层次 是一个Java关键字，基于JVM层面实现 锁的获取 假设A线程持有锁，B线程等待。如果A线程阻塞，B线程会一直等待 锁的释放 自动释放：当持有锁的线程执行完同步代码，释放锁；当线程执行发生异常，jvm会让线程释放锁 锁的状态 无法判断 锁的类型 可重入、不可中断、非公平 锁的机制 悲观锁机制 Lock\r#\r存在层次 是一个Java接口，基于JDK层面实现 锁的获取 有多种方式获取锁，线程可以不用一直等待 锁的释放 手动释放：需要在finally中释放锁，不然容易造成线程死锁 锁的状态 可以判断 锁的类型 可重入、可中断、可公平/可非公平 锁的机制 乐观锁机制 性能\r#\r推荐优先使用synchronized，而不是Lock synchronized：少量同步 Lock：大量同步 调度\r#\rsynchronized：使用Object对象本身的wait 、notify、notifyAll调度机制 Lock：可以使用Condition进行线程之间的调度 锁的类型\r#\r偏向锁 / 轻量级锁 / 重量级锁\r#\r详情 乐观锁 \u0026amp; 悲观锁\r#\r乐观锁\n总是假设最好的情况。每次去拿数据的时候都认为别人不会修改，所以不会上锁。但是在更新的时候会判断一下在此期间别人有没有去更新这个数据 实现：版本号机制、CAS 算法 缺点：ABA问题、循环时间长开销大、只能保证单个共享变量的原子操作 例如：原子变量类 悲观锁\n总是假设最坏的情况。每次去拿数据的时候都认为别人会修改，所以会上锁。别人想拿这个数据就会阻塞直到它拿到锁 例如：synchronized、ReentrantLock、关系型数据库中的行锁、表锁等。 公平锁 \u0026amp; 非公平锁\r#\r公平锁\n是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。 优点：避免了线程的“饥饿” 缺点：性能相对于非公平锁会差很多 例如：ReentrantLock(指定) 非公平锁\n是指多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待 优点：效率高 缺点：容易导致线程”饥饿” 例如：synchronized、ReentrantLock(默认) 独占锁 \u0026amp; 共享锁\r#\r独享锁 （互斥锁）\n定义：每次只能有一个线程能持有锁 示例：ReentrantLock、Synchronized都是独占锁 共享锁\n定义：允许多个线程同时获取锁，并发访问共享资源 示例：ReentrantReadWriteLock，其读锁是共享锁，其写锁是独占锁 可重入锁\r#\r即递归锁，线程可以进入任何一个它已经拥有的锁所同步着的代码块 同一线程，在外层方法获取锁的时候，进入内层方法会自动获取锁 避免死锁 自旋锁\r#\r是一种锁机制，是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁 优点：减少线程上下文切换的消耗 缺点：循环会消耗CPU资源 分段锁\r#\r是一种锁的设计，即分段加锁。其目的是细化锁的粒度。 ConcurrentHashMap 运用的就是分段锁 "},{"id":58,"href":"/database/redis/persistence/AOF/","title":"AOF","section":"持久化","content":"\rAOF\r#\rAOF\r#\rAppend Only File，以日志的形式来记录每个写操作，并追加到文件中。 当Redis重启时，会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。 持久化文件：appendonly.aof 过程\r#\rRedis 调用 fork() ，创建一个子进程。 主进程处理client请求，把写命令写入到aof文件中，并把写命令缓存起来。 子进程往临时文件中写入重建数据库状态的命令，之后通知主进程。 主进程把缓存的写命令也写入到临时文件，然后用临时文件替换老aof文件。 触发\r#\r自动触发：根据配置规则自动触发； 手动触发：bgrewriteaof 优点\r#\r数据安全 解决了数据一致性问题 AOF 机制的 rewrite 模式 缺点\r#\rAOF 文件比 RDB 文件大，且恢复速度慢。 数据集大的时候，比 rdb 启动效率低。 "},{"id":59,"href":"/framework/spring/aop/","title":"AOP","section":"Spring","content":"\rAOP\r#\rAspect Oriented Programming，面向切面编程，是一种编程思想 是通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术 在面向对象编程(OOP)中，基本单元是类(class)，而 AOP 中的基本单元是切面(aspect) OOP是解决了纵向的代码复用问题，AOP是解决了横向的代码复用问题 术语\r#\r术语 名称 描述 Jointpoint 连接点 程序类中，允许插入通知（Advice）的位置点 Pointcut 切入点 程序类中，已经插入通知（Advice）的位置点 Advice 通知、增强 在切入点（Pointcut）上要执行的代码 Aspect 切面 是切入点（Pointcut）和通知（Advice）的结合 Target 目标 被织入通知（Advice）的目标对象，这个对象永远是一个被代理对象 Weaving 织入 将通知（Advice）添加到目标类具体连接点上的过程 通知类型\r#\r通知 说明 备注 around 环绕通知 在建议方法调用之前和之后，执行通知。 before 前置通知 在一个方法执行之前，执行通知。 after 后置通知 在一个方法执行之后，不考虑其结果，执行通知。 after-returning 正常返回通知 在一个方法执行之后，只有在方法成功完成时，才能执行通知。 after-throwing 异常返回通知 在一个方法执行之后，只有在方法退出抛出异常时，才能执行通知。 "},{"id":60,"href":"/program-lang/java/thread/lock/aqs/","title":"AQS","section":"锁体系","content":"\rAQS 原理\r#\rAQS\r#\r抽象的队列同步器，AbstarctQueuedSynchronizer，简称AQS AQS 定义了一套多线程访问共享资源的同步器基础框架，许多同步类实现都依赖于它，如ReentrantLock、Semaphore\u0026hellip; CLH 队列\r#\r是一个FIFO双向队列。 （FIFO：First in First out，先入先出） AQS 原理\r#\rAQS 维护了一个共享变量 state 和一个 CLH 队列。 线程通过 CAS 去改变 state 状态，成功则获取锁成功，失败则进入等待队列，等待被唤醒。 AQS 实现\r#\rAQS的设计是基于模板模式。 AQS已实现了对等待队列的维护，自定义同步器只需要实现共享资源state的获取与释放方式即可。 AQS 定义了两种资源共享方式： Exclusive：独占方式，只有一个线程能执行，如ReentrantLock Share：共享方式，多个线程可以同时执行，如Semaphore、CountDownLatch 同步状态\r#\rstate用来表示当前的同步状态，根据当前state的值，来判断当前处于锁定状态还是其他状态 // 同步状态 private volatile int state; // 获取当前同步状态 int getState() // 设置当前同步状态 void setState(int newState) // 使用CAS设置当前同步状态，该方法能够保证设置同步状态时的原子性； // 参数expect为state的预期旧值，而update是需要修改的新值，若设置成功，方法返回true，否则false boolean compareAndSetState(int expect, int update) 需重写的方法\r#\r// 独占方式。尝试获取共享资源，成功则返回true，失败则返回false protected boolean tryAcquire(int arg) // 独占方式。尝试释放共享资源，成功则返回true，失败则返回false protected boolean tryRelease(int arg) // 共享方式。尝试获取共享资源，成功则返回正数，失败则返回负数，0表示无可用资源 protected int tryAcquireShared(int arg) // 共享方式。尝试释放共享资源，成功则返回true，失败则返回false protected boolean tryReleaseShared(int arg) // 当前同步器是否在独占模式下被线程占用。只有用到condition才需要去实现它 protected boolean isHeldExclusively() 提供的模板方法\r#\r// 独占方式，获取同步状态 public final void acquire(int arg) // 与acquire()相同，该方法响应中断 public final void acquireInterruptibly(int arg) // 在acquireInteruptibly()上增加了超时限制 public final boolean tryAcquireNanos(int arg, long nanosTimeout) // 独占方式，释放同步状态 public final boolean release(int arg) // 共享方式，获取同步状态 public final void acquireShared(int arg) // 与acquireShared()相同，该方法响应中断 public final void acquireSharedInterruptibly(int arg) // 在acquireSharedInterruptibly()基础上增加了超时限制。 public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout) // 共享方式，释放同步状态 public final boolean releaseShared(int arg) // 获取等待在同步队列上的线程集合 public final Collection\u0026lt;Thread\u0026gt; getQueuedThreads() "},{"id":61,"href":"/program-lang/java/container/List/ArrayList/","title":"ArrayList","section":"List","content":"\rArrayList\r#\r概述\r#\r是一个动态数组，其容量能够动态增长 特点\r#\r顺序 有序 元素 允许为 null，允许重复 效率 修改和查询元素效率高，插入和移除元素效率不高 多线程 线程不安全 继承关系\r#\rpublic class ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable AbstractList、List接口 提供了列表的骨干功能 RandomAccess接口 提供了随机访问功能 Cloneable接口 支持克隆 Serializable接口 支持序列化 成员变量\r#\r// 默认的初始化容量 private static final int DEFAULT_CAPACITY = 10; // 指定容量为0时，返回该空数组 private static final Object[] EMPTY_ELEMENTDATA = {}; // 当调用无参构造方法，返回的是该空数组 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; // 保存元素的数组 transient Object[] elementData; // 元素的个数 private int size; // 最大数组容量 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 构造方法\r#\r// 默认 public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } // 指定初始容量 public ArrayList(int initialCapacity) { //... } // 指定集合，转化为ArrayList public ArrayList(Collection\u0026lt;? extends E\u0026gt; c) { //... } 扩容机制\r#\r每次新增元素都会检查是否需要扩容 默认初始容量10，扩容的新容量为：旧容量的1.5 倍 private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } "},{"id":62,"href":"/framework/spring/ioc/bean-definition/","title":"Bean 定义","section":"IoC","content":"\rBean 定义\r#\r开启组件扫描\r#\rapplication.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!-- 开启组件扫描，指定了 base-package 扫描的包 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;xxx.xxx.xxx\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 组件类注解\r#\r这四个注解实现的功能基本一样，只是为了明确的标识类的层次及意图 注解 说明 @Component 将一般的类标识为 Bean 组件，并委托给 Spring 容器进行管理 @Controller 将控制层的类标识为 Bean 组件，是 @Component 的特化 @Service 将业务层的类标识为 Bean 组件，是 @Component 的特化 @Repository 将数据访问层的类标识为 Bean 组件，是 @Component 的特化 配置类注解\r#\r注解 说明 @Configuration 定义配置类，配置类本身也会被注册为 Bean @Bean 标注在配置类的方法上，将方法返回的实例注册为 Bean "},{"id":63,"href":"/program-lang/java/thread/container/BlockingQueue/","title":"BlockingQueue","section":"并发容器","content":"\rBlockingQueue\r#\rBlockingQueue\n"},{"id":64,"href":"/program-design/expression/cron/","title":"Cron表达式","section":"表达式","content":"\rCron表达式\r#\r简介\r#\r是一个具有时间含义的字符串 格式\r#\r{秒数} {分钟} {小时} {日期} {月份} {星期} {年份(可为空)} 分为 6~7 个域 ，以空格隔开。每个域可以是确定的取值，也可以是具有逻辑意义的特殊字符。 域取值\r#\r下表为各个域的取值范围及支持的特殊字符 域 允许的取值范围 允许的特殊符号 是否必填 秒 0-59 , - * / 是 分钟 0-59 , - * / 是 小时 0-23 , - * / 是 日期 1-31 , - * / ? L W 是 月份 1-12 或 JAN-DEC , - * / 是 星期 1-7 或 SUN-SAT , - * / ? L # 是 年 1970-2099 , - * / 否 特殊字符\r#\r字符不区分大小写，MON、mon相同 字符 含义 示例 * 所有可能的值 在月份域中，*表示每个月 ? 任意可能的值 在月份域中，?表示任意某个月 , 列出枚举值 在分钟域中，5,20表示分别在5分钟和20分钟触发一次 - 范围 在分钟域中，5-20表示从5分钟到20分钟之间每一分钟触发一次 / 数值的增量 在分钟域中，0/15表示从第0分钟开始，每15分钟触发一次 # 每个月的第几个星期几 在星期域中，4#2表示某月的第二个星期四。 L Last，最后一天 在日期域中，L表示某个月的最后一天 W 离指定某日最近的工作日 在日期域中，5W表示如果5号是星期六，则在4号触发；如果5号是星期天，则在6日触发；如果5号是工作日，则就在5号触发。 取值示例\r#\r示例 说明 0 15 10 ? * * 每天 10:15 执行任务 0 15 10 * * ? 每天 10:15 执行任务 0 0 12 * * ? 每天 12:00 执行任务 0 0 10,14,16 * * ? 每天 10:00 点、14:00、16:00 执行任务 0 0/30 9-17 * * ? 每天 09:00 到 17:00 时间段内，每隔半小时执行任务 0 * 14 * * ? 每天 14:00 到 14:59 时间段内，每隔1分钟执行任务 0 0-5 14 * * ? 每天 14:00 到 14:05 时间段内，每隔1分钟执行任务 0 0/5 14 * * ? 每天 14:00 到 14:55 时间段内，每隔5分钟执行任务 0 0/5 14,18 * * ? 每天 14:00 到 14:55、18:00 到 18:55时间段内，每隔5分钟执行任务 0 0 12 ? * WED 每个星期三 12:00 执行任务 0 15 10 15 * ? 每月 15 日 10:15 执行任务 0 15 10 L * ? 每月最后一日 10:15 执行任务 0 15 10 ? * 6L 每月最后一个星期六 10:15 执行任务 0 15 10 ? * 6#3 每月第三个星期六 10:15 执行任务 0 10,44 14 ? 3 WED 每年 3 月的每个星期三 14:10 和 14:44 执行任务 0 15 10 ? * * 2022 2022 年每天 10:15 执行任务 0 15 10 ? * * * 每年每天 10:15 执行任务 0 0/5 14,18 * * ? 2022 2022 年每天 14:00 到 14:55、18:00 到 18:55 时间段内，每隔5分钟执行任务 0 15 10 ? * 6#3 2022,2023 2022 年至 2023 年每月第三个星期六 10:15 执行任务 0 0/30 9-17 * * ? 2022-2025 2022 年至 2025 年每天 09:00 到 17:30 时间段内，每隔半小时执行任务 0 10,44 14 ? 3 WED 2022/2 从 2022 年开始，每隔两年 3 月的每个星期三 14:10 和 14:44 执行任务 "},{"id":65,"href":"/program-lang/java/thread/tool/CyclicBarrier/","title":"CyclicBarrier","section":"并发工具","content":"\rCyclicBarrier\r#\r功能\r#\r循环栅栏 多个线程互相等待，直到全部都到达同一个同步点，再继续一起执行 原理\r#\r在CyclicBarrier类的内部有一个计数器 每个线程在到达屏障点的时候都会调用 await() 将自己阻塞，此时计数器会减 1 当计数器减为 0 的时候，所有因调用 await() 而被阻塞的线程将被唤醒 方法\r#\r// 构造方法：设置要拦截的线程数，及安全栅跳闸时无预定义的动作 public CyclicBarrier(int parties) // 构造方法：设置要拦截的线程数，及安全栅跳闸时执行的预定义动作 public CyclicBarrier(int parties, Runnable barrierAction) // 非定时等待 public int await() // 定时等待 public int await(long timeout, TimeUnit unit) // 定时等待 public void reset() 示例\r#\r// 集齐七龙珠 public static void main(String[] args) { CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -\u0026gt; { System.out.println(\u0026#34;召唤神龙\u0026#34;); }); for (int i = 1; i \u0026lt;= 7; i++) { final int temp = i; new Thread(() -\u0026gt; { System.out.println(\u0026#34;收集到第\u0026#34; + temp + \u0026#34;颗龙珠\u0026#34;); try { cyclicBarrier.await(); } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } }, String.valueOf(i)).start(); } } CyclicBarrier \u0026amp; CountDownLatch\r#\r他们内部都有一个计数器，当计数器的值不断的减为 0 的时候，所有阻塞的线程将会被唤醒 CyclicBarrier的计数器由自己控制，而CountDownLatch的计数器则由使用者来控制 CyclicBarrier可以实现循环拦截，而CountDownLatch只能拦截一轮 "},{"id":66,"href":"/program-lang/java/container/Map/HashMap/","title":"HashMap","section":"Map","content":"\rHashMap\r#\r概述\r#\r是一个哈希表，存储的是键值对 (key-value) 映射。 特点\r#\r键 允许为null（放在第一位），不允许重复 值 允许为null，允许重复 顺序 无序 效率 插入、获取的时间复杂度基本是 O(1)。遍历整个 Map 需要的时间与数组的长度成正比 多线程 线程不安全 继承关系\r#\rpublic class HashMap\u0026lt;K,V\u0026gt; extends AbstractMap\u0026lt;K,V\u0026gt; implements Map\u0026lt;K,V\u0026gt;, Cloneable, Serializable { AbstractMap、Map接口 提供了Map接口的骨干功能 Cloneable接口 支持克隆 Serializable接口 支持序列化 成员变量\r#\r// 默认初始容量为16 static final int DEFAULT_INITIAL_CAPACITY = 1 \u0026lt;\u0026lt; 4; // 默认负载因子为0.75 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 临界值 = 容量 * 负载因子 int threshold; // 负载因子 final float loadFactor; // 最大容量为int的最大值除2 static final int MAXIMUM_CAPACITY = 1 \u0026lt;\u0026lt; 30; // 如果主干数组上的链表的长度大于8，链表转化为红黑树 static final int TREEIFY_THRESHOLD = 8; // 如果发现某一个红黑树的长度小于6，则会重新退化为链表 static final int UNTREEIFY_THRESHOLD = 6; // 当hashmap容量大于64时，链表才能转成红黑树 static final int MIN_TREEIFY_CAPACITY = 64; // 存储元素的数组 transient Node\u0026lt;k,v\u0026gt;[] table; transient Set\u0026lt;map.entry\u0026lt;k,v\u0026gt;\u0026gt; entrySet; // 元素的个数 transient int size; // HashMap改变的次数 transient int modCount; 构造方法\r#\r// 默认 public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; } // 指定初始容量 public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } // 指定初始容量、负载因子 public HashMap(int initialCapacity, float loadFactor) { //... } // 指定集合，转化为HashMap public HashMap(Map\u0026lt;? extends K, ? extends V\u0026gt; m) { this.loadFactor = DEFAULT_LOAD_FACTOR; //... } 底层结构\r#\rJDK1.7：数组 + 链表\nJDK1.8：数组 + 链表 + 红黑树\n​\n内部类\n// 用来实现数组及链表 static class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { final int hash; final K key; V value; Node\u0026lt;K,V\u0026gt; next; Node(int hash, K key, V value, Node\u0026lt;K,V\u0026gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } //... } // 用来实现红黑树 static final class TreeNode\u0026lt;K,V\u0026gt; extends LinkedHashMap.Entry\u0026lt;K,V\u0026gt; { TreeNode\u0026lt;K,V\u0026gt; parent; // red-black tree links TreeNode\u0026lt;K,V\u0026gt; left; TreeNode\u0026lt;K,V\u0026gt; right; TreeNode\u0026lt;K,V\u0026gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node\u0026lt;K,V\u0026gt; next) { super(hash, key, val, next); } //... } 重要函数\r#\r新增：put()\r#\r调用 hash()，计算 key 的 hash 值 再通过哈希算法，将 hash 值转换成数组的下标 如果下标位置为空，则新增一个节点 如果下标位置上为红黑树，则就调用树方法插入节点 如果下标位置上有链表或单个节点（即发生哈希碰撞），则将 key 和链表每个节点上的 key 依次进行 equals() 对比 如果有节点返回 true，则覆盖该节点 如果所有节点都返回 false，则将新节点添加到链表的末尾。并判断是否需要转换为红黑树。 如果数组长度大于阀值，则 resize() 进行扩容 public V put(K key, V value) { // 调用hash(key)计算key的hashcode值 return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, i; // 如果table为空，初始化哈希表 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 计算出索引位置 if ((p = tab[i = (n - 1) \u0026amp; hash]) == null) // 节点若不存在，则新增一个节点 tab[i] = newNode(hash, key, value, null); else { // 节点若已经存在，执行赋值操作 Node\u0026lt;K,V\u0026gt; e; K k; // 如果节点的key、hash值与传入的相等 if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) e = p; // 如果是红黑树 else if (p instanceof TreeNode) e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); // 如果是链表 else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { // 如果找不到目标节点，则在链表尾部新增一个节点， p.next = newNode(hash, key, value, null); //链表长度8，将链表转化为红黑树存储 if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } // 如果目标节点存在 if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) break; p = e; } } // 如果目标节点存在，则覆盖该节点的value if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } // 记录修改次数 ++modCount; //判断是否需要扩容 if (++size \u0026gt; threshold) resize(); afterNodeInsertion(evict); return null; } 查找：get()\r#\r调用 hash()，计算 key 的 hash 值 再通过哈希算法，将 hash 值转换成数组的下标 判断索引处第一个key与传入key是否相等，如果相等直接返回 如果不相等，判断链表是否是红黑二叉树，如果是，直接从树中取值 如果不是树，就遍历链表查找 public V get(Object key) { Node\u0026lt;K,V\u0026gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node\u0026lt;K,V\u0026gt; getNode(int hash, Object key) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; first, e; int n; K k; if ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (first = tab[(n - 1) \u0026amp; hash]) != null) { if (first.hash == hash \u0026amp;\u0026amp; // always check first node ((k = first.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode\u0026lt;K,V\u0026gt;)first).getTreeNode(hash, key); do { if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } 扩容：resize()\r#\r当元素的个数大于临界值时，会进行扩容。扩容很耗时 扩容的新容量为：旧容量 * 2 扩容机制： 新表是旧表的两倍容量，以(e.hash \u0026amp; oldCap) == 0把单链表拆分为两队， 如果等于0，则将元素迁移到新数组 “原位置”的位置上 如果不等于0，则将元素迁移到新数组 “原位置+oldCap”的位置上 final Node\u0026lt;K,V\u0026gt;[] resize() { Node\u0026lt;K,V\u0026gt;[] oldTab = table; // 原容量 int oldCap = (oldTab == null) ? 0 : oldTab.length; // 原临界值 int oldThr = threshold; // 新容量，新临界值 int newCap, newThr = 0; // 初始化newCap, newThr if (oldCap \u0026gt; 0) { if (oldCap \u0026gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 设新临界值为旧临界值的2倍 else if ((newCap = oldCap \u0026lt;\u0026lt; 1) \u0026lt; MAXIMUM_CAPACITY \u0026amp;\u0026amp; oldCap \u0026gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr \u0026lt;\u0026lt; 1; // double threshold } else if (oldThr \u0026gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap \u0026lt; MAXIMUM_CAPACITY \u0026amp;\u0026amp; ft \u0026lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; // 下面开始构造新表，初始化表中的数据 @SuppressWarnings({\u0026#34;rawtypes\u0026#34;,\u0026#34;unchecked\u0026#34;}) Node\u0026lt;K,V\u0026gt;[] newTab = (Node\u0026lt;K,V\u0026gt;[])new Node[newCap]; table = newTab; // 遍历所有节点，将节点赋值到新表 if (oldTab != null) { for (int j = 0; j \u0026lt; oldCap; ++j) { Node\u0026lt;K,V\u0026gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash \u0026amp; (newCap - 1)] = e; // 如果是红黑树节点，则进行红黑树的重新hash分布 else if (e instanceof TreeNode) ((TreeNode\u0026lt;K,V\u0026gt;)e).split(this, newTab, j, oldCap); // 如果是普通的链表节点，则进行普通的重新hash分布 else { // preserve order // 存储索引位置为：“原索引位置”，即低位链 Node\u0026lt;K,V\u0026gt; loHead = null, loTail = null; // 存储索引位置为：“原索引位置+oldCap”，即高位链 Node\u0026lt;K,V\u0026gt; hiHead = null, hiTail = null; Node\u0026lt;K,V\u0026gt; next; do { next = e.next; if ((e.hash \u0026amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); // 尾插法（低位链） if (loTail != null) { loTail.next = null; newTab[j] = loHead; } // 尾插法（高位链） if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } 哈希算法\r#\rHash，一般称“散列”，也译为“哈希” 哈希函数：将任意长度的数据，通过散列算法，变换成固定长度的数据摘要（哈希值） 哈希碰撞：两个不同的输入值，根据同一散列函数计算出的哈希值相同的现象 基本特性：根据同一散列函数计算出的散列值， 如果不同，那么输入值肯定也不同。 如果相同，输入值不一定相同。 应用：密码学\r#\r在密码学中，哈希算法主要用于对整个消息的完整性进行校验，对于抗碰撞和抗篡改能力要求极高 抗碰撞能力： 对于任意两个不同的数据块，其hash值相同的可能性极小； 对于一个给定的数据块，找到和它hash值相同的数据块极为困难。 抗篡改能力： 对于一个数据块，哪怕只改动其一个比特位，其hash值的改动也会非常大。 应用：数据结构\r#\r比如HashMap中，哈希算法是为了加速键值对的查找，并将元素均匀地放在各个桶里 这时候，对于抗碰撞的要求就没有那么高，哈希值的产生速度更为重要。 // java.lang.String public int hashCode() { int h = hash; if (h == 0 \u0026amp;\u0026amp; value.length \u0026gt; 0) { char val[] = value; for (int i = 0; i \u0026lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; } 单链表创建\r#\r头插法\r#\r尾插法\r#\r因为每次都是将新节点插入到链表尾部，所以需要增加一个始终指向表尾节点的指针R "},{"id":67,"href":"/program-lang/java/container/Set/HashSet/","title":"HashSet","section":"Set","content":"\rHashSet\r#\r概述\r#\rHashSet 基于 HashMap 实现，是 HashMap 的缩水版本 特点\r#\r顺序 无序 元素 允许为 null，不允许重复 多线程 线程不安全 继承关系\r#\rpublic class HashSet\u0026lt;E\u0026gt; extends AbstractSet\u0026lt;E\u0026gt; implements Set\u0026lt;E\u0026gt;, Cloneable, java.io.Serializable AbstractSet、Set接口 提供了 Set 接口的骨干功能 Cloneable接口 支持克隆 Serializable接口 支持序列化 成员变量\r#\r// 使用Map的key保存元素 private transient HashMap\u0026lt;E,Object\u0026gt; map; // 使用PRESENT作为Map所有key的value private static final Object PRESENT = new Object(); 构造方法\r#\r// 默认 public HashSet() { map = new HashMap\u0026lt;\u0026gt;(); } // 指定初始容量 public HashSet(int initialCapacity) { map = new HashMap\u0026lt;\u0026gt;(initialCapacity); } // 指定初始容量、负载因子 public HashSet(int initialCapacity, float loadFactor) { map = new HashMap\u0026lt;\u0026gt;(initialCapacity, loadFactor); } // 指定集合，转化为HashSet public HashSet(Collection\u0026lt;? extends E\u0026gt; c) { map = new HashMap\u0026lt;\u0026gt;(Math.max((int) (c.size()/.75f) + 1, 16)); //... } "},{"id":68,"href":"/program-lang/web/html/","title":"HTML","section":"Web","content":"\rHTML\r#\r超文本标记语言，Hyper Text Markup Language 是一种描述网页的语言，由标签组成 不需编译，直接由浏览器执行 HTML 不区分大小写 HTML 结构\r#\r声明：\u0026lt;!DOCTYPE html\u0026gt;，必须放在HTML文档第一行 标签：由尖括号包围关键词构成，如\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;、\u0026lt;br/\u0026gt; 元素：从 开始标签 到 结束标签 的所有代码 属性：在 开始标签 中规定，以键/值对的形式出现，例如：\u0026lt;p name=\u0026ldquo;value\u0026rdquo;\u0026gt;xxx\u0026lt;/p\u0026gt; 注释：\u0026lt;!\u0026ndash; 注释内容 \u0026ndash;\u0026gt; HTML 文档\r#\r即网页，包含 HTML 标签和纯文本 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Hello world!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; HTML 转义\r#\r转义字符 字符 转义字符 字符 \u0026amp;nbsp; Space \u0026amp;quot; \u0026quot; \u0026amp;lt; \u0026lt; \u0026amp;trade; ™ 商标 \u0026amp;gt; \u0026gt; \u0026amp;reg; ® 注册 \u0026amp;amp; \u0026amp; \u0026amp;copy; © 版权 "},{"id":69,"href":"/program-base/network/tcp-ip/ip/","title":"IP","section":"TCP/IP","content":"\rIP 协议\r#\rIP 协议\r#\rInternet Protocol，网际互连协议 IP 地址\r#\r是指互联网协议地址，规定网络上所有的设备都必须有独一无二的标识 IPV4：使用 32 个比特或者 4 组 0 到 255 之间的数字来为计算机编址，如192.168.1.60，分为ABCDE五类 起始地址 终止地址 A类 0.0.0.0 127.255.255.255 B类 128.0.0.0 191.255.255.255 C类 192.0.0.0 223.255.255.255 D类 224.0.0.0 239.255.255.255 E类 240.0.0.0 255.255.255.255 子网掩码\r#\rIP 地址由网络号和主机号两部分组成 子网掩码是一个32位地址，结合IP地址进行计算，可以得到IP地址的网络号、主机号 A:\t202.194.128.9 B:\t202.194.128.14 子网掩码: 255.255.255.0 转二进制： A:\t1100 1010.1100 0010.1000 0000.0000 1001 B:\t1100 1010.1100 0010.1000 0000.0000 1101 子网掩码: 1111 1111.1111 1111.1111 1111.0000 0000 掩码取反: 0000 0000.0000 0000.0000 0000.1111 1111 获取网络号：对IP和掩码，作与运算 A:\t1100 1010.1100 0010.1000 0000.0000 0000 B:\t1100 1010.1100 0010.1000 0000.0000 0000 即： A:\t202.194.128.0 B:\t202.194.128.0 获取主机号：对IP和反掩码，作与运算\tA:\t0000 0000.0000 0000.0000 0000.0000 1001 B:\t0000 0000.0000 0000.0000 0000.0000 1101 即： A:\t9 B:\t14 "},{"id":70,"href":"/program-lang/java/","title":"Java","section":"程序语言","content":"\rJava\r#\r是一种高级的面向对象的程序设计语言 特点：跨平台、面向对象、简单易学、安全健壮、支持多线程 Java 版本\r#\rJavaSE Java Platform Standard Edition 标准版 是其他版本的基础，主要用于开发桌面应用程序 JavaEE Java Platform Enterprise Edition 企业版 主要用于开发企业级分布式网络程序 JavaME Java Platform Micro Edition 小型版 主要用于嵌入式系统开发 Java 概念\r#\rJVM Java Virtual Machine Java 虚拟机 JRE Java Runtime Environment Java 运行环境 JDK Java Development Kit Java 开发工具包 "},{"id":71,"href":"/program-lang/java/library/java.sql/","title":"java.sql","section":"基础类库","content":"\rJDBC\r#\r概述\r#\rJava Data Base Connectivity，java 数据库连接 是一种用于执行 sql 语句的 java API，可以为多种关系数据库提供统一访问。 相关API\r#\rjava.sql.Driver 数据库驱动，由数据库厂商提供具体实现 java.sql.DriverManager 数据库驱动管理器 java.sql.Connection 数据库连接 java.sql.Statement SQL语句对象 java.sql.ResultSet 数据库结果集 连接步骤\r#\r加载驱动\nClass.forName(\u0026#34;com.mysql.jdbc.Driver\u0026#34;); 建立连接\nString user = \u0026#34;xxx\u0026#34;; String password = \u0026#34;xxx\u0026#34;; String url = \u0026#34;jdbc:mysql://127.0.0.1:3306/xxx?useUnicode=true\u0026#34;; Connection conn = DriverManager.getConnection(url, user, password); 创建 Statement\nString sql =\u0026#34;SELECT * FROM catalog_info WHERE catalog_name=?\u0026#34;; PreparedStatement prs = conn.prepareStatement(sql); prs.setString(1, \u0026#34;JavaSE\u0026#34;); 执行sql语句，获取结果集\nResultSet res = prs.executeQuery(); while (res.next()) { System.out.println(res.getLong(\u0026#34;catalog_id\u0026#34;) + \u0026#34; - \u0026#34; + res.getString(\u0026#34;catalog_name\u0026#34;)); } 关闭资源\nres.close(); prs.close(); conn.close(); "},{"id":72,"href":"/program-base/linux/","title":"Linux","section":"编程基础","content":"\rLinux\r#\r是一套免费使用和自由传播的类Unix操作系统 Linux 思想\r#\r一切都是文件 每个文件都有确定的用途 Linux 特点\r#\r开源、开放性 多用户、多任务 良好的界面 设备独立性 丰富的网络功能 可靠的安全系统 良好的可移植性 "},{"id":73,"href":"/program-lang/java/container/List/","title":"List","section":"集合容器","content":"\r"},{"id":74,"href":"/database/mysql/","title":"MySQL","section":"数据存储","content":"\rMySQL\r#\r是一个关系型数据库管理系统。\n属于 Oracle 旗下产品，开源免费。\n# 开/关服务 net start mysql net stop mysql # 登录/退出 mysql -h主机地址 -P端口 -u用户名 -p密码 exit \\q quit "},{"id":75,"href":"/program-lang/java/jvm/tuning/oom/","title":"OOM 问题","section":"JVM 调优","content":"\rOOM 问题\r#\r内存溢出\r#\rOut Of Memory，内存溢出 java.lang.OutOfMemoryError OOM 异常信息 栈内存溢出 java.lang.StackOverflowError 堆内存溢出 java.lang.OutOfMemoryError：Java heap space 元空间内存溢出 java.lang.OutOfMemoryError：MetaSpace 直接内存溢出 java.lang.OutOfMemoryError：Direct buffer memory GC 回收时间过长\r#\rjava.lang.OutOfMemoryError：GC overhead limit exceeded 超过 98% 的时间都在用来做 GC，且回收了不到 2% 的堆内存 不能再创建新的线程\r#\rjava.lang.OutOfMemoryError：unable to create new native thread 原因：创建了太多的线程，超过系统承载极限 解决：想办法减少应用程序创建的线程的数量 "},{"id":76,"href":"/service-manage/deprecated-frame/ribbon/","title":"Ribbon","section":"日落组件","content":"\rRibbon\r#\rRibbon\r#\r负载均衡 是一个基于 HTTP 和 TCP 的客户端负载均衡工具 工作原理\r#\r先访问注册中心，获取可用的服务列表 再根据用户指定的策略，再从服务列表中选择一个地址。 Ribbon 自带 LB 策略\r#\rLoad Balance，即负载均衡 "},{"id":77,"href":"/framework/springmvc/","title":"Spring MVC","section":"开源框架","content":"\rSpring MVC\r#\r一种基于 Java 的、实现了 MVC 设计模式的、请求驱动类型的轻量级 Web 框架。 MVC\r#\rModel、View、Controller 是一种软件设计典范，通过分离业务逻辑、数据、界面显示的方式来组织代码。 使程序分层、分工合作，既相互独立，又协同合作。 Model 模型 负责数据封装及业务逻辑处理 View 视图 负责渲染模型数据，进行可视化展示 Controller 控制器 负责居中调度。将接收的用户请求，指派给模型进行处理，并将结果传递给视图进行展示 "},{"id":78,"href":"/program-lang/java/thread/theory/synchronized/","title":"synchronized","section":"并发理论","content":"\rsynchronized\r#\r特性\r#\r并发三特性：原子性、可见性、有序性 可重入性：是可重入锁 基本用法\r#\rsynchronized 内置锁，是一种“对象锁”，锁的是对象而非引用变量，作用粒度是对象 同步原理\r#\r对象头\r#\r实例数据：存放类的属性数据信息，包括父类的属性信息 对齐填充：非必须，仅仅是为了字节对齐 对象头：Mark Word、Class Metadata Address、Array Length Mark Word 存储对象自身的运行时数据，如 hashCode、锁信息或分代年龄或GC标志等 Class Metadata Address 存储指向对象类型数据的指针 Array Length 存储数组长度（如果当前对象是数组） 锁记录\r#\rLock Record，是线程私有的数据结构。 当线程进入同步代码块时，如果此同步对象没有被锁定，JVM会在当前线程的栈中创建Lock Record空间，用于存储锁对象的Mark Word的拷贝。 每一个被锁住的对象Mark Word都会和一个Lock Record关联，同时Lock Record中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。 监视器\r#\rMonitor，可以理解为一种同步机制、一个对象。任何一个对象都有一个Monitor与之关联。 Monitor只能被一个线程持有，此时当前对象就处于锁定状态，其它线程只能阻塞等待。 在JVM中，Synchronized是基于进入和退出Monitor对象，来实现方法同步和代码块同步。 MonitorEnter指令 插入在同步代码块的开始位置。当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁； MonitorExit指令 插入在方法结束处和异常处。JVM保证每个MonitorEnter必须有对应的MonitorExit； 同步优化\r#\r为优化synchronized性能，在JDK1.6后增加了自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁等策略 锁的信息存储在对象头的MarkWord里，不同的锁状态对应的存储内容如下图 锁膨胀：无锁——\u0026gt;偏向锁——\u0026gt;轻量级锁——\u0026gt;重量级锁，并且膨胀方向不可逆 偏向锁\r#\r减少同一线程获取锁的代价 当持有锁的线程再次请求该锁时，无需再做任何同步操作，即获取锁 轻量级锁\r#\r轻量级锁是由偏向锁升级而来 当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁 重量级锁\r#\r重量级锁是由轻量级锁升级而来 当同一时间有多个线程竞争锁时，锁就会被升级成重量级锁，此时其申请锁带来的开销也就变大 其他策略\r#\r锁消除 当检测到不可能存在共享数据的竞争时，JVM会对这些同步锁进行消除 锁粗化 将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁 自旋锁 是一种锁机制，尝试获取锁的线程不会立即阻塞，而是采用循环的方式去多次尝试 自适应自旋锁 自旋的次数不是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定 "},{"id":79,"href":"/program-base/network/tcp-ip/","title":"TCP/IP","section":"网络","content":"\rTCP/IP 协议\r#\rTransmission Control Protocol / Internet Protocol，传输控制协议/网际协议 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准，是一系列互联网通信协议的统称 "},{"id":80,"href":"/program-lang/java/thread/thread/thread-stop/","title":"停止线程","section":"线程基础","content":"\r停止线程\r#\r正常结束\r#\r程序运行结束，线程自动结束 使用退出标志\r#\r使用一个停止标记，在线程中进行判断该标记的状态然后进行处理 public class MyThread extends Thread { private volatile boolean isShutDown = false; public void run() { while (!isShutDown) { // 执行体... } } public void shutDown() { this.isShutDown = true; } } public class Test { public static void main(String[] args) throws Exception { MyThread thread = new MyThread(); thread.start(); Thread.sleep(5000); thread.shutDown(); } } 使用 interrupt()\r#\r线程处于阻塞状态时，调用 interrupt() 会抛出 InterruptException 异常 线程未处于阻塞状态时，使用 isInterrupted() 判断线程的中断标志来退出循环 public class MyThread extends Thread { public void run() { // 非阻塞状态：通过判断中断标志来退出 while (!isInterrupted()) { try { // 执行体... Thread.sleep(5 * 1000); } catch (InterruptedException e) { // 阻塞状态：通过捕获中断异常来退出 break; } } } } public class Test { public static void main(String[] args) throws Exception { Thread thread = new MyThread(); thread.start(); thread.interrupt(); thread.join(); } } 使用 stop()\r#\r可以直接使用 thread.stop() 来强行终止线程，但不推荐 但是stop()是很危险的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果 "},{"id":81,"href":"/program-lang/java/jvm/memory-structure/","title":"内存结构","section":"虚拟机","content":"\r内存结构\r#\r运行时数据区\r#\rJVM 在执行 Java 程序的过程中，会把它所管理的内存区域划分为若干个不同的数据区域 方法区\r#\r即永久代 用于存储类信息、常量、静态常量、即时编译后的代码 运行时常量池，也是方法区的一部分，用于存放编译期生成的各种字面量和符号引用 堆内存\r#\r用于存储对象实例、数组 是垃圾收集器管理的主要区域 堆内存采用分代收集算法，又细分为：新生代（Eden区、SurvivorFrom区、SurvivorTo区）、老年代 虚拟机栈\r#\r栈内存，是Java方法执行的内存模型 每个方法被执行时，都会创建一个栈帧来存储局部变量表、操作数栈、动态链接、方法出口等信息 方法从被调用到执行完成的过程，就对应着栈帧在虚拟机栈中从入栈到出栈的过程 本地方法栈\r#\r与虚拟机栈相同，区别是虚拟机栈为执行 Java 方法服务，而本地方法栈则为 Native 方法服务 程序计算器\r#\r在 Java 虚拟机中，唯一没有 OOM 的区域 是一小块内存空间，用于存储当前线程正在执行字节码指令的地址值 正在执行 Java 方法时，记录的是当前指令的地址 正在执行 Native 方法时，则为 Undefined 内存区域分代\r#\r新生代\r#\r由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收 分区 说明 Eden 区 Java 新对象的出生地（大对象直接分配到老年代）当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收 ServivorFrom 区ServivorTo 区 存放 MinorGC 过程中的幸存者使用复制算法，From、To区交互配合使用 老年代\r#\r主要存放应用程序中生命周期长的内存对象，老年代的对象比较稳定，所以 MajorGC 不会频繁执行 永久代\r#\r指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息 GC 不会在主程序运行期对永久区域进行清理 在JDK1.8中，永久代被元空间取代，元空间并不在虚拟机中，而是使用本地内存 "},{"id":82,"href":"/program-lang/java/jvm/gc/judge/","title":"判定算法","section":"垃圾回收","content":"\r判定算法\r#\r引用计数法\r#\r原理：通过计算引用的数量，来判断一个对象是否可以回收 缺陷：不能解决对象间循环引用的问题 实现： 给对象添加一个引用计数器，记录引用该对象的次数 当有地方引用该对象时，计数器加 1。当引用失效时，计数器减 1。 当计数器值为 0 时，代表为垃圾对象，就会被 GC 进行回收。 可达性分析法\r#\r原理：通过判断对象是否可到达，来决定对象是否可以被回收\n实现：\n通过一系列的名为GC Roots的对象作为起始点。 从这些节点开始向下搜索，搜索所走过的路径称为引用链。 当从 GC Roots 到一个对象不可达时，则证明此对象是不可用的。 可以作为 GC Roots 的对象\nJava 虚拟机栈中正在引用的对象 本地方法栈中正在引用的对象 方法区常量引用的对象 静态属性引用的对象 "},{"id":83,"href":"/program-lang/java/jvm/class-load/load-process/","title":"加载过程","section":"类加载","content":"\r加载过程\r#\r1、加载\r#\r通过一个类的全限定名，获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构，转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区该类各种数据的访问入口。 2、验证\r#\r目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全 阶段 说明 文件格式验证 验证字节流是否符合 Class 文件格式的规范，确保能被当前虚拟机处理。 元数据验证 对字节码进行语义验证，确保其描述信息符合 Java 语言规范的要求 字节码验证 通过数据流和控制流分析，确保程序语义是合法的、符合逻辑的 符号引用验证 验证符号引用是否为可用的直接引用，确保解析动作能正确执行。 3、准备\r#\r为类变量（静态变量）分配内存，并将其初始化为系统默认值（零值） 如果是 final 修饰的类变量，则会直接初始化设定的值。 4、解析\r#\r将常量池内的符号引用替换为直接引用 解析：类或接口、字段、类方法、接口方法 5、初始化\r#\r初始化阶段是执行类构造器 \u0026lt;clinit\u0026gt;() 方法的过程\n\u0026lt;clinit\u0026gt;() 方法：\n是由编译器自动收集类中的所有类变量的赋值动作和静态语句块 (static{}块) 中的语句合并产生的。 虚拟机保证一个类的 \u0026lt;clinit\u0026gt;() 方法在多线程环境中被正确的加锁、同步 触发初始化：\n当虚拟机启动时，虚拟机会初始化定义了main()方法的主类 当使用 java.lang.reflect 包的方法对类进行反射调用时，会触发类的初始化 当初始化一个类的时候，如果其父类还未初始化，会先触发其父类的初始化 当遇到 new、getstatic、putstatic 或 invokestatic 节码指令时，会触发类的初始化如使用 new 关键字实例化对象、访问类的静态变量、访问类的静态方法 不触发初始化：\n访问类的常量 通过数组定义来引用类 子类访问父类的静态变量，子类不会被初始化 "},{"id":84,"href":"/program-lang/web/css/position/width-height/","title":"宽高","section":"CSS 位置","content":"\r宽高\r#\r属性 属性说明 width 宽度 min-width 最小宽度 max-width 最大宽度 height 高度 min-height 最小高度 max-height 最大高度 属性值 属性值说明 auto 默认 size 数值 inherit 继承 "},{"id":85,"href":"/program-lang/java/oop/encapsulation/","title":"封装","section":"面向对象","content":"\r封装\r#\r概念\r#\r封装：将属性和行为绑定起来，并隐藏部分实现的细节，对外只提供访问接口。 优点：降低耦合、隐藏细节、类内部可自由修改 示例\r#\r设为私有 对外提供公共访问方法 public class Person{ private String name; public String getName(){ return name; } public void setName(String name){ this.name = name; } } "},{"id":86,"href":"/dev-tool/git/principle/","title":"工作原理","section":"Git","content":"\r工作原理\r#\r原理\r#\rGit 把数据看作是微型文件系统的一系列快照， 每次提交更新时，Git 都会对当前的全部文件制作一个快照并保存这个快照的索引（哈希算法）， 为了高效， 如果文件没有修改，Git 不再重新存储该文件， 而是只保留一个链接指向之前存储的文件。 特性\r#\r直接记录快照，而非差异比较 近乎所有操作都是本地执行，不需要联网 时刻保持数据完整性 一般只是添加数据 工程区域\r#\r工作区：日常工作的工程目录 暂存区：又称索引，工程根目录.git/index 文件夹 版本区：又称本地仓库，工程根目录.git文件夹 工作流程\r#\r文件必须一步一步的依次提交 文件可以依次检出，也可以直接从远程仓库检出到工作目录 "},{"id":87,"href":"/framework/kafka/work-principle/","title":"工作原理","section":"Kafka","content":"\r工作原理\r#\r术语\r#\rproducer：生产者，生产 message 发送到 topic consumer：消费者，订阅 topic 消费 message consumer group：消费者组，同组的不同消费者不能同时消费同一个分区的数据 broker：指 Kafka 节点，一个 Kafka 集群由多个 Kafka 节点组成。 topic：指消息类别，每条发布到 kafka 集群的消息都属于某个类别。 partition：指 topic 的分区，每个 topic 多个 partition。 segment：指 partition 的分段，每个 partition 包含多个 segment 段，每个 Segment 存着 message 信息。 offset：指 Message 在 partition 中的偏移量，可理解为消息在 partition 中的索引 存储设计\r#\rpartition 在物理上对应一个 log 文件夹，包含多个 segment 段，每个 segment 大小相等，顺序读写。 segment 在物理上对应一个.log 数据文件和一个 .index 索引文件，文件以该段中最小的 offset 进行命名。 Kafka 并没有为每条 Message 建立索引，而是采用了稀疏存储的方式，每隔一定字节的数据建立一条索引。 这样在查找指定 offset 的 Message 时，用二分查找就可以快速定位到该 Message "},{"id":88,"href":"/service-manage/dubbo/work-principle/","title":"工作原理","section":"Dubbo","content":"\r工作原理\r#\r核心功能\r#\r面向接口的远程方法调用 智能容错和负载均衡 服务自动注册和发现 Dubbo 角色\r#\r服务提供者：Provider 服务消费者：Consumer 注册中心：Registry 监控中心：Monitor Dubbo 工作原理\r#\r服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 "},{"id":89,"href":"/framework/springmvc/workflow/","title":"工作流程","section":"Spring MVC","content":"\r工作流程\r#\r核心组件\r#\r前端控制器：DispatcherServlet 处理器映射器：HandlerMapping 处理器适配器：HandlerAdapter 处理器：Handler 视图解析器：ViewResolver 视图：View 工作流程\r#\r发起请求到前端控制器。 前端控制器请求 HandlerMapping 查找 Handler。 HandlerMapping 向前端控制器返回 Handler。 前端控制器调用 HandlerAdapter 去执行 Handler。 HandlerAdapter 执行 Handler。 Handler 执行完成后，向 HandlerAdapter 返回 ModelAndView。 HandlerAdapter 将 ModelAndView返回给前端控制器。 前端控制器将 ModelAndView 传给 ViewReslover。 ViewReslover 解析后，向前端控制器返回具体 View。 前端控制器根据 View 进行渲染视图。 前端控制器响应用户。 "},{"id":90,"href":"/program-design/design-pattern/creational/02-factory/","title":"工厂模式","section":"创建型","content":"\r工厂模式\r#\r概述\r#\r英文：Factory Pattern 简述：不同条件下创建不同实例 归纳：产品标准化，生产更高效 目的：封装创建细节 案例：实体工厂 示例\r#\r简单工厂\r#\r// 产品 public interface Phone { void function(); } // 类似产品：XiaoMi，Iphone public class HuanWei implements Phone{ @Override public void function() { System.out.println(\u0026#34;华为手机\u0026#34;); } } // 统一工厂 public class PhoneFactory { public static Phone createPhone(String type){ if (\u0026#34;XiaoMi\u0026#34;.equals(type)){ return new XiaoMi(); } if (\u0026#34;HuanWei\u0026#34;.equals(type)){ return new HuanWei(); } if (\u0026#34;Iphone\u0026#34;.equals(type)){ return new Iphone(); } return null; } } 工厂方法\r#\r主要解决： 接口选择的问题 应用场景： 日志记录器（记录到硬盘/系统事件/远程服务器） 数据库访问（多种类型数据库） 连接服务器（多种通讯协议） // 产品 public interface Phone { void function(); } // 类似产品：XiaoMi，Iphone public class HuanWei implements Phone{ @Override public void function() { System.out.println(\u0026#34;华为手机\u0026#34;); } } // 工厂 public interface PhoneFactory { Phone createPhone(); } // 类似工厂：XiaoMiFactory，IphoneFactory public class HuanWeiFactory implements PhoneFactory { @Override public Phone createPhone() { return new HuanWei(); } } 抽象工厂\r#\r主要解决： 接口选择的问题 应用场景： 生成不同操作系统的程序 注意事项： 产品族难扩展，产品等级易扩展 // 类似产品族：Camera、Screen public interface CPU { void name(); } // 类似产品等级：XiaoM、Iphone public class HuanWeiCPU implements CPU { void name(); } public class HuanWeiCamera implements Camera { void name(); } public class HuanWeiScreen implements Screen { void name(); } // 类似工厂：XiaoMiFactory、IphoneFactory public interface PhoneFactory { CPU createCpu(); Camera createCamera(); Screen createScreen(); } public class HuanWeiFactory implements PhoneFactory { @Override public CPU createCpu() { return new HuanWeiCPU(); } @Override public Camera createCamera() { return new HuanWeiCamera(); } @Override public Screen createScreen() { return new HuanWeiScreen(); } } "},{"id":91,"href":"/program-lang/java/thread/problem/ConcurrentModificationException/","title":"并发修改异常","section":"并发问题","content":"\r并发修改异常\r#\r故障现象\r#\rpublic class Test { public static void main(String[] args) { ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;Integer\u0026gt;(); list.add(2); Iterator\u0026lt;Integer\u0026gt; iterator = list.iterator(); while(iterator.hasNext()){ Integer integer = iterator.next(); if(integer==2) list.remove(integer); } } } Exception in thread \u0026#34;main\u0026#34; java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:911) at java.util.ArrayList$Itr.next(ArrayList.java:861) at org.local.Test.main(Test.java:15) 导致原因\r#\r并发争抢修改导致。一个正在写，另一个抢夺，导致数据不一致，并发修改异常 解决方案\r#\rnew Vector\u0026lt;\u0026gt;(); Collections.synchronizedList(new ArrayList\u0026lt;\u0026gt;()); new CopyOnWriteArrayList\u0026lt;\u0026gt;(); "},{"id":92,"href":"/program-lang/java/thread/theory/","title":"并发理论","section":"多线程","content":"\r串行、并行、并发\r#\r串行：顺序执行多个任务；一个任务执行完毕后，再执行下一个任务。 并行：同时执行多个任务；同一时刻，同时有多个任务在执行。 并发：交替执行多个任务；同一时刻，只有一个任务在执行。 阻塞、非阻塞\r#\r指自身状态，是否能去做其他事 阻塞 ：调用在发出去后，在消息返回之前，当前进/线程会被阻塞 非阻塞：调用在发出去后，不会阻塞当前进/线程，而是立即返回 同步、异步\r#\r指处理方式，是否等待结果 同步：执行某个任务，等待结果返回，再执行后续任务 异步：执行某个任务，不等待结果返回，就执行后续任务 "},{"id":93,"href":"/program-lang/java/feature/exception/","title":"异常处理","section":"语言特性","content":"\r异常处理\r#\r异常\r#\r就是程序出现了不正常的情况 异常体系\r#\r编译时异常\nRuntimeException之外的异常，又称受检异常 在编译期间出现的异常，必须处理，否则无法通过编译 比如：FileNotFoundException 运行时异常\nRuntimeException及其子类，又称非受检异常 在运行期间出现的异常，可延后处理 比如：NullPointerException 抛出异常\r#\r默认方式\nJVM会把异常信息输出在了控制台，并停止程序 throw 方式\n用在方法内，后面跟异常对象 thorws 方式\n用在方法声明上，后面跟异常类名 可以跟多个，用逗号隔开 // 在方法内 throw new Exception(); // 在方法声明上 public void method() throws Exception { } 捕获异常\r#\rtry - catch - finally try { // 可能出现异常的语句 } catch (异常类 变量){ // 处理异常的代码，可以有多个 // 出现异常，才会执行 } finally { // 不是必须的 // 无论是否产生异常，一定会执行的语句 } 自定义异常\r#\r自定义类，使之继承 Exception 等异常类 // 用法与内置异常类一样 public class MyException extends Exception { MyException(String message) { super(message); } } finally \u0026amp; return\r#\r执行逻辑 finally块前的return语句，记为out-return finally块内的return语句，记为in-return finally块中无return： 执行out-return，保存结果到缓存槽，执行finally块，返回缓存槽的数据 finally块中有return： 执行out-return，保存结果到缓存槽，执行finally块，执行in-return提前退出 场景示例 // finally块中无return，且未操作变量 public static void test() { try { System.out.println(\u0026#34;执行try\u0026#34;); } finally { System.out.println(\u0026#34;执行finally\u0026#34;); } } /** * 打印： * 执行try * 执行finally */ // finally块中无return，且操作了变量（基本类型/String） public static String test() { String result; try { result = \u0026#34;try\u0026#34;; return result; } finally { result = \u0026#34;finally\u0026#34;; } } /** * 返回：try */ // finally块中无return，且操作了变量（引用类型） public static String[] test() { String[] arr = new String[2]; try { arr[0] = \u0026#34;try\u0026#34;; return arr; } finally { arr[1] = \u0026#34;finally\u0026#34;; } } /** * 返回：[try, finally] */ // finally块中有return public static String test() { try { return \u0026#34;try\u0026#34;; } finally { return \u0026#34;finally\u0026#34;; } } /** * 返回：finally */ "},{"id":94,"href":"/program-design/data-algorithm/","title":"数据算法","section":"程序设计","content":"\r时间复杂度\r#\r是一个关于输入数据量 n 的函数，定量描述了该算法所需的最大运行时间\n记作 T(n)=O(f(n))，表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同\nn：问题规模\nf(n)：是 n 的某个函数\nT(n)：时间频度，算法中语句总的执行次数，是 n 的某个函数\n推导时间复杂度： 1. 复杂度与具体的常系数无关 2. 多项式级的复杂度相加的时候，只保留最高阶项 示例：T(n) = 2n²+7n+6 =\u0026gt; T(n) = 2n²+7n+1 =\u0026gt; T(n) = 2n² =\u0026gt; T(n) = n² =\u0026gt; 记为 O(n²) 常见时间复杂度\r#\rO(1) \u0026lt; O(logn) \u0026lt; O(n) \u0026lt; O(nlogn)\u0026lt; O(n²) \u0026lt; O(n³ ) \u0026lt; O(2ⁿ ) \u0026lt; O(n!) \u0026lt; O(nⁿ ) 常数阶：O(1) int i=1; int j=2; ++i; j++; int m=i+j; 对数阶：O(logn) int i=1; while(i\u0026lt;n){ i=i*2; } 线性阶：O(n) for(int i=1;i\u0026lt;=n;i++){ j=i; j++; } 线性对数阶：O(nlogn) for(int m=1;m\u0026lt;=n;m++){ int i=1; while(i\u0026lt;n){ i=i*2; } } 平方阶：O(n²) for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=n;j++){ total+=j; } } "},{"id":95,"href":"/database/oracle/plsql/data-types/","title":"数据类型","section":"PL/SQL","content":"\r数据类型\r#\r标量类型\r#\r数字型\r#\r精度：prec，所有数字位的个数 刻度：scale，小数点右边的数字位的个数，可以是负数 类型 描述 NUMBER(prec, scale) 整型或浮点型，最大精度 38 位。 PLS_INTEGER 带符号整型，以 32 位表示。 BINARY_INTEGER 带符号整型，以 32 位表示。 BINARY_FLOAT 单精度浮点型 BINARY_DOUBLE 双精度浮点型 1. NUMBER 等价子类型，用于兼容ANSI和IBM： 整型：DEC(prec, scale)、DECIMAL(prec, scale)、INT、INTEGER、SMALLINT 浮点型：NUMERIC(pre, secale)、DOUBLE PRECISION、FLOAT、REAL 2. NUMBER：以十进制进行存储，需转换为二进制后才能进行算术运算 PLS_INTEGER、BINARY_INTEGER：以二进制进行存储，可直接进行算术运算，比NUMBER更有效率 3. PLS_INTEGER：数值溢出时，抛出异常 BINARY_INTEGER：数值溢出时，会指派为 NUMBER 类型 字符型\r#\r类型 描述 CHAR 固定长度字符串，最大大小为32,767字节 VARCHAR2 可变长度字符串，最大大小为32,767字节 1. CHAR、VARCHAR2语法：CHAR[(maxSize [CHAR|BYTE])] CHAR|BYTE：以字符/字节为单位 maxSize:字符长度 2. STRING、VARCHAR：VARCHAR2的等价子类型，用于兼容ANSI和IBM 3. LONG、LONG RAW：仅为了保持向后兼容，可用BLOB代替 4. NCHAR、NVARCHAR2：CHAR、VARCHAR2的Unicode版本，用于多语言环境 5. ROWID：物理行标识符，用来标识普通数据表中的一行信息 UROWID：通用行标识符，可以存储物理、逻辑或外部行标识符 日期型\r#\r类型 描述 DATE 表示日期和时间，精度为秒级别，没有时区信息 TIMESTAMP 表示日期和时间，精度为纳秒级别， 可以选择包含时区信息 INTERVAL 表示时间段，可以选择以年，月，日，秒来表示时间区别 布尔型\r#\rBOOLEAN：TRUE、FALSE、NULL 注意：Oracle 数据库中并不包含布尔类型，故不能用布尔值与数据库交互 LOB类型\r#\r即大对象类型，存储大数据项，如文本，图形图像，视频剪辑和声音波形。 LOB数据类型允许对数据进行高效，随机，分段访问。 类型 描述 大小 BFILE 用于在数据库外的操作系统文件中存储大型二进制对象 取决于系统，但不得超过 4GB。 BLOB 用于在数据库中存储大型二进制对象 8TB 至 128TB CLOB 用于在数据库中存储大字符数据 8TB 至 128TB NCLOB 用于在数据库中存储大块 NCHAR 数据 8TB 至 128TB 引用类型\r#\r类型 描述 %TYPE 定义一个变量类型，其类型与数据表中某个列或某个变量的数据类型相同 %ROWTYPE 定义一个记录类型，其结构与数据表的数据结构相一致 --%TYPE 引用表单个字段类型 DECLARE v_name emp.ename%TYPE; -- 引用表的单个字段类型（单值变量） v_sal emp.sal%TYPE; BEGIN SELECT ename, sal INTO v_name, v_sal FROM emp WHERE empno=7369; DBMS_OUTPUT.put_line(\u0026#39;姓名:\u0026#39; || v_name ||\u0026#39; 工资: \u0026#39; ||v_sal); END; -- %ROWTYPE 引用表的所有字段类型 DECLARE v_emp emp%ROWTYPE; -- 引用整个表的字段类型（表变量） BEGIN SELECT * INTO v_emp -- 插入整行数据（所有字段数据） FROM emp WHERE empno=7369; -- 不能直接打印整个表,只能是单个值的拼接 DBMS_OUTPUT.put_line(\u0026#39;姓名:\u0026#39; || v_emp.ename ||\u0026#39; 工资: \u0026#39; ||v_emp.sal); END; 复合类型\r#\r记录：RECORD\r#\rDECLARE TYPE test_record IS RECORD( userName VARCHAR2(30) NOT NULL := \u0026#39;oracle\u0026#39;, userInfo VARCHAR2(100)); record_book test_record; BEGIN record_book.userName :=\u0026#39;oracle\u0026#39;; record_book.userInfo :=\u0026#39;oracle PL/SQL\u0026#39;; DBMS_OUTPUT.PUT_LINE(record_book.userName||\u0026#39; \u0026#39; ||record_book.userInfo); END; 数组：VARRAY\r#\rDECLARE --定义一个最多容纳5个VARCHAR(20)数据类型成员的VARRAY数据类型 TYPE test_varray_type IS VARRAY(5) OF VARCHAR(20); test_varray test_varray_type; BEGIN --用构造函数语法赋予初值 test_varray := test_varray_type(\u0026#39;北京\u0026#39;, \u0026#39;上海\u0026#39;, \u0026#39;重庆\u0026#39;, \u0026#39;成都\u0026#39;, \u0026#39;杭州\u0026#39;); DBMS_OUTPUT.PUT_LINE(\u0026#39;城市名称：\u0026#39;||test_varray (1)||\u0026#39;、\u0026#39; ||test_varray (2)||\u0026#39;、\u0026#39; ||test_varray (3)||\u0026#39;、\u0026#39; ||test_varray (4)); DBMS_OUTPUT.PUT_LINE(\u0026#39;赋予初值NULL的第5个成员的值：\u0026#39;||test_varray (5)); --用构造函数语法赋予初值后就可以这样对成员赋值 test_varray (5) := \u0026#39;深圳\u0026#39;; DBMS_OUTPUT.PUT_LINE(\u0026#39;第5个成员的值：\u0026#39;||test_varray (5)); END; 表：TABLE\r#\rDECLARE --定义记录表数据类型 TYPE emp_table_type IS TABLE OF employees%ROWTYPE INDEX BY BINARY_INTEGER; v_emp_table EMP_TABLE_TYPE; BEGIN SELECT first_name, hire_date, job_id INTO v_emp_table(1).first_name, v_emp_table(1).hire_date, v_emp_table(1).job_id FROM employees WHERE employee_id = 177; SELECT first_name, hire_date, job_id INTO v_emp_table(2).first_name, v_emp_table(2).hire_date, v_emp_table(2).job_id FROM employees WHERE employee_id = 178; DBMS_OUTPUT.PUT_LINE(\u0026#39;177雇员名称：\u0026#39;||v_emp_table(1).first_name ||\u0026#39; 雇佣日期：\u0026#39;||v_emp_table(1).hire_date ||\u0026#39; 岗位：\u0026#39;||v_emp_table(1).job_id); DBMS_OUTPUT.PUT_LINE(\u0026#39;178雇员名称：\u0026#39;||v_emp_table(2).first_name ||\u0026#39; 雇佣日期：\u0026#39;||v_emp_table(2).hire_date ||\u0026#39; 岗位：\u0026#39;||v_emp_table(2).job_id); END; 自定义子类型\r#\r是在标准类型的基础上进一步约束而创建的新类型 与其基类型有着相同的操作条款，属于基类型指定值的子集 DECLARE SUBTYPE type_userName IS char(20); SUBTYPE type_sex IS char(6); uName type_userName; userSex type_sex; BEGIN uName := \u0026#39;ewang\u0026#39;; userSex := \u0026#39;male\u0026#39;; DBMS_OUTPUT.PUT_LINE(\u0026#39;user name:\u0026#39; || uName || \u0026#39; Sex: \u0026#39; || userSex); END; "},{"id":96,"href":"/database/redis/data-type/","title":"数据类型","section":"Redis","content":"\r数据类型\r#\r字符串：String\r#\r是Redis最基本的数据类型，最大能存储512MB。 是二进制安全的，可以包含任何数据。 应用：计数功能 哈希：Hash\r#\r是一个键值对集合。 是一个string类型的field和value的映射表 应用：存储用户信息。 列表：List\r#\r是简单的字符串列表，按照插入顺序排序。 你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 应用：做简单的消息队列的功能 集合：Set\r#\r是string类型的无序集合，通过HashTable实现 应用：全局去重功能 有序集合：Zset\r#\r是string类型元素的集合，且不允许重复的成员。 其每个元素都会关联一个double类型的分数，Redis通过此分数来排序 应用：排行榜 "},{"id":97,"href":"/program-lang/java/grammar/data-type/","title":"数据类型","section":"基本语法","content":"\r数据类型\r#\r计算机容量单位\r#\r1Byte = 8 bit， 1KB = 1024Byte bit：位，比特，是计算机运算的基础，代表二进制数位，取值范围：0或1 Byte：字节，计算机文件大小的基本计算单位，用于表示计算机中的一个字符 基本数据类型\r#\r数据类型 描述 字节 默认值 取值范围 举例说明 byte 位 1 0 -128 ~ 127 byte b = 10; short 短整数 2 0 -32768 ~ 32767 short s = 10; int 整数 4 0 -2^31 - 2^31-1 int i = 10; long 长整数 8 0l -2^63 - 2^63-1 long l = 10l; float 单精度 4 0.0f -2^31 - 2^31-1 float f = 10.0f; double 双精度 8 0.0d -2^63 - 2^63-1 double d = 10.0d; char 字符 2 空 0 - 2^16-1 char c = \u0026lsquo;c\u0026rsquo;; boolean 布尔值 1 false true、false boolean b = true; 引用数据类型\r#\rJava语言中，除了基本类型其他都为引用类型，如对象、接口、数组 类型转换\r#\r基本规则 不能对boolean类型进行类型转换 不能把对象类型转换成不相关类的对象 在把容量大的类型转换为容量小的类型时，必须使用强制类型转换 转换过程中可能导致溢出或损失精度 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入 自动类型转换 整型、浮点型、字符型可以混合运算。 运算中，不同类型的数据先转化为同一类型，然后进行运算 转换从低级到高级 byte,short,char—\u0026gt; int —\u0026gt; long—\u0026gt; float —\u0026gt; double 强制类型转换 条件：转换的数据类型必须是兼容的 格式：(type)value 隐藏强制类型转换 整数的默认类型是 int 浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上 F 或者 f。 "},{"id":98,"href":"/database/mysql/mysql-command/table/","title":"数据表管理","section":"基础命令","content":"\r数据表管理\r#\r创建\r#\r# 创建表 create table 表名(列名 列类型 [长度],...) [engine = 存储引擎] [charset = 字符集] [collate = 校对集]; # 复制表结构 create table 新表名 like [数据库名.]表名; -- 示例 CREATE TABLE IF NOT EXISTS `runoob_tbl`( `runoob_id` INT UNSIGNED AUTO_INCREMENT, `runoob_title` VARCHAR(100) NOT NULL, `runoob_author` VARCHAR(40) NOT NULL, `submission_date` DATE, PRIMARY KEY ( `runoob_id` ) )ENGINE=InnoDB DEFAULT CHARSET=utf8; 查询\r#\rshow create table 表名; show columns from 表名; describe 表名; desc 表名; show tables [like \u0026#39;...\u0026#39;]; 修改\r#\r# 改表名 rename table 旧表名 to 新表名; # 改属性 alter table 表名 [engine=存储引擎]/[charset=字符集]/[collate=校对集]; # 删除列 alter table 表名 drop 列名; # 修改列 alter table 表名 add 列名 列类型 [列属性] [first]/[after 字段名]; # 添加列 alter table 表名 modify 列名 列类型 [列属性] [first]/[after 字段名]; # 改列类型 alter table 表名 change 旧列名 新列名 列类型 [列属性] [first]/[after 字段名]; # 改列名 删除\r#\rdrop table 表名; truncate 表名; delete from 表名; 区别 drop truncate delete 速度 快 中 慢 空间 释放全部空间 恢复到初始大小 不释放空间 表结构 删除 不删 不删 类型 DDL DDL DML 事务 不支持 不支持 支持 trigger 不触发 不触发 触发 生效时机 执行立即生效 执行立即生效 事务提交后生效 "},{"id":99,"href":"/program-base/linux/cmd/flie-view/","title":"文件查看","section":"常用命令","content":"\r文件查看\r#\rgrep - 文本搜索工具\nsed - 流编辑器，用于过滤和转换文本\nawk - 强大的文本分析工具\nvi / vim - 文本编辑器\n"},{"id":100,"href":"/program-lang/web/html/text/","title":"文本标签","section":"HTML","content":"\r文本标签\r#\r标签 说明 \u0026lt;b\u0026gt; 定义粗体文本（无语义） \u0026lt;i\u0026gt; 定义斜体文本（无语义） \u0026lt;u\u0026gt; 定义下划线文本（无语义） \u0026lt;s\u0026gt; 定义删除线文本（无语义） \u0026lt;del\u0026gt; 定义被删除文本（有语义） \u0026lt;ins\u0026gt; 定义被插入文本（有语义） \u0026lt;em\u0026gt; 定义强调文本（有语义） \u0026lt;strong\u0026gt; 定义强调文本（有语义，语气更为强烈） \u0026lt;sup\u0026gt; 定义上标文本 \u0026lt;sub\u0026gt; 定义下标文本 \u0026lt;big\u0026gt; 定义大号字 \u0026lt;small\u0026gt; 定义小号字 \u0026lt;code\u0026gt; 定义计算机代码 \u0026lt;pre\u0026gt; 定义预格式文本 排版标签\r#\r标签 说明 \u0026lt;h1\u0026gt;\u0026hellip;\u0026hellip;\u0026lt;h6\u0026gt; 定义 HTML 标题 \u0026lt;p\u0026gt; 定义一个段落 \u0026lt;br\u0026gt; 定义换行 \u0026lt;hr\u0026gt; 定义水平线 \u0026lt;div\u0026gt; 定义文档中的块 \u0026lt;span\u0026gt; 定义文档中的块 "},{"id":101,"href":"/program-lang/web/css/style/text/","title":"文本样式","section":"CSS 样式","content":"\r文本样式\r#\r属性\r属性说明\r属性值\r属性值说明\rtext-align\r水平对齐\u0026nbsp;\n仅对块级元素有效\rleft\r左对齐\rcenter\r居中\rright\r右对齐\rjustify\r两端对齐\rvertical-align\r垂直对齐\rbaseline\r默认\rsub\r下标\rsuper\r上标\rtop\r最顶端对齐\rtext-top\r顶端对齐\rmiddle\r中部对齐\rbottom\r最底端对齐\rtext-bottom\r底端对齐\rsize\r数值\rline-height\r文本行高\rsize\r数值\rword-spacing\r单词间距\rsize\r数值\rletter-spacing\r字符间距\rsize\r数值\rtext-indent\r首行缩进\rsize\r数值\rtext-transform\r文本大小写\rnone\r默认\rcapitalize\r单词大写字母开头\ruppercase\r字母都大写\rlowercase\r字母都小写\rtext-decoration\r修饰文本\rnone\r默认\runderline\r划线，文本底部\roverline\r划线，文本顶部\rline-through\r划线，穿过文本\r文字基线\r#\r"},{"id":102,"href":"/program-lang/java/library/java.util.stream/method-reference/","title":"方法引用","section":"java.util.stream","content":"\r方法引用\r#\r方法引用\r#\r通过方法的名字来指向一个方法 使用一对冒号 :: 进行引用 引用方式\r#\rpublic class Test { public static void main(String[] args) { // 构造器引用 // Class::new或Class\u0026lt; T \u0026gt;::new final Car car = Car.create(Car::new); final List\u0026lt;Car\u0026gt; cars = Collections.singletonList(car); // 静态方法引用 // Class::static_method cars.forEach(Car::collide); // 特定类的任意对象的方法引用 // Class::method cars.forEach(Car::repair); // 特定对象的方法引用 // instance::method final Car police = Car.create(Car::new); cars.forEach(police::follow); } } @FunctionalInterface public interface Supplier\u0026lt;T\u0026gt; { T get(); } public class Car { public static Car create(final Supplier\u0026lt;Car\u0026gt; supplier) { return supplier.get(); } public static void collide(final Car car) { System.out.println(\u0026#34;Collided \u0026#34; + car.toString()); } public void follow(final Car another) { System.out.println(\u0026#34;Following the \u0026#34; + another.toString()); } public void repair() { System.out.println(\u0026#34;Repaired \u0026#34; + this.toString()); } } "},{"id":103,"href":"/program-base/network/http/status/","title":"状态码","section":"HTTP","content":"\rHTTP 状态码\r#\r状态码\r#\rHTTP Status Code 由三位数字代码组成，用于表示HTTP请求的处理结果和状态 状态码分类\r#\r状态码 含义 描述 1xx 消息响应 服务器收到请求，需要请求者继续执行操作 2xx 成功响应 操作被成功接收并处理 3xx 重定向 需要进一步的操作以完成请求 4xx 客户端错误 请求包含语法错误或无法完成请求 5xx 服务器错误 服务器在处理请求的过程中发生了错误 常见状态码\r#\r消息响应\n100 Continue 继续 101 Switching Protocol 切换协议 成功响应\n200 OK 成功 201 Created 已创建 202 Accepted 已创建 203 Non-Authoritative Information 未授权信息 204 No Content 无内容 205 Reset Content 重置内容 206 Partial Content 部分内容 重定向\n300 Multiple Choice 多种选择 301 Moved Permanently 永久移动 302 Found 临时移动 303 See Other 查看其他位置 304 Not Modified 未修改 305 Use Proxy 使用代理 306 unused 未使用 307 Temporary Redirect 临时重定向 308 Permanent Redirect 永久重定向 客户端错误\n400 Bad Request 错误请求 401 Unauthorized 未授权 402 Payment Required 需要付款 403 Forbidden 禁止访问 404 Not Found 未找到 405 Method Not Allowed 不允许使用该方法 406 Not Acceptable 无法接受 407 Proxy Authentication Required 要求代理身份验证 408 Request Timeout 请求超时 409 Conflict 冲突 410 Gone 已失效 411 Length Required 需要内容长度头 412 Precondition Failed 预处理失败 413 Request Entity Too Large 请求实体过长 414 Request-URI Too Long 请求网址过长 415 Unsupported Media Type 媒体类型不支持 416 Requested Range Not Satisfiable 请求范围不合要求 417 Expectation Failed 预期结果失败 服务器端错误\n500 Internal Server Error 内部服务器错误 501 Implemented 未实现 502 Bad Gateway 网关错误 503 Service Unavailable 服务不可用 504 Gateway Timeout 网关超时 505 HTTP Version Not Supported HTTP 版本不受支持 "},{"id":104,"href":"/database/mysql/advanced-feature/user-auth/","title":"用户权限","section":"高级特性","content":"\r用户权限\r#\r用户管理\r#\r-- 查询用户信息 select * from mysql.user; -- 创建用户 -- @后为主机域，可使用占位符 create user \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;password\u0026#39;; -- 删除用户 drop user \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 修改root用户密码 mysqladmin -u root -h localhost -p password \u0026#34;password\u0026#34; -- root用户修改普通用户密码 set password for \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;=password(\u0026#39;password\u0026#39;); 权限管理\r#\r数据权限：增删改查（select\\update\\delete\\insert） 结构权限：结构操作（create\\drop） 管理权限：权限管理（create user\\grant\\revoke） # 新增 grant 权限列表 on 数据库.表名 to 用户; # 删除 revoke 权限列表 on 数据库.表 from 用户; -- 授予username用户，所有数据库所有表的，增删改查权限 grant select,insert,update,delete on *.* to \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 授予username用户，所有数据库所有表的，所有权限 grant all on *.* to \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 取消username用户，所有库所有表的，插入权限 revoke insert on *.* from \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; -- 刷新权限 flush privileges; "},{"id":105,"href":"/framework/quartz/demo/","title":"示例","section":"Quartz","content":"\r示例\r#\rJob\r#\r@Slf4j @PersistJobDataAfterExecution public class TestJob implements Job { @Override public void execute(JobExecutionContext jobExecutionContext){ System.out.println(\u0026#34;TestJob 执行啦\u0026#34;); } } Scheduler\r#\r@Slf4j public class TestScheduler { public static void main(String[] args) throws Exception { // 获取任务调度的实例 Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); // 定义任务调度实例, 并与TestJob绑定 JobDetail jobDetail = JobBuilder.newJob(TestJob.class) .usingJobData(\u0026#34;executeCount\u0026#34;, 0) .withIdentity(\u0026#34;testJob\u0026#34;, \u0026#34;testJobGroup\u0026#34;) .build(); // 定义触发器, 会马上执行一次, 接着5秒执行一次 Date endTime = new Date(); endTime.setTime(endTime.getTime()+5000); Trigger trigger = TriggerBuilder.newTrigger() .usingJobData(\u0026#34;testInfo\u0026#34;, \u0026#34;trigger数据存放\u0026#34;) .withIdentity(\u0026#34;testTrigger\u0026#34;, \u0026#34;testTriggerGroup\u0026#34;) .startNow() .endAt(endTime) //设置了停止时间 .withSchedule(SimpleScheduleBuilder.repeatSecondlyForever(5)) .build(); // 创建SchedulerListener scheduler.getListenerManager().addSchedulerListener(new MySchedulerListener()); // 使用触发器调度任务的执行 scheduler.scheduleJob(jobDetail, trigger); // 开启任务 scheduler.start(); } } /** OUTPUT: testJobGroup.testJob 添加工作任务 testJob 完成部署 调度器 正在开启时调用 调度器 开启时调用 TestJob 执行啦 触发器被移除 testJob testJobGroup.testJob 删除工作任务 **/ SchedulerListener\r#\rpublic class MySchedulerListener implements SchedulerListener { @Override public void jobScheduled(Trigger trigger) { String jobName = trigger.getJobKey().getName(); System.out.println(jobName + \u0026#34; 完成部署\u0026#34;); } @Override public void jobUnscheduled(TriggerKey triggerKey) { System.out.println(triggerKey + \u0026#34; 完成卸载\u0026#34;); } @Override public void triggerFinalized(Trigger trigger) { System.out.println(\u0026#34;触发器被移除 \u0026#34; + trigger.getJobKey().getName()); } @Override public void triggerPaused(TriggerKey triggerKey) { System.out.println(triggerKey + \u0026#34; 正在被暂停\u0026#34;); } @Override public void triggersPaused(String triggerGroup) { System.out.println(\u0026#34;触发器组 \u0026#34; + triggerGroup + \u0026#34; 正在被暂停\u0026#34;); } @Override public void triggerResumed(TriggerKey triggerKey) { System.out.println(triggerKey + \u0026#34; 正在从暂停中恢复\u0026#34;); } @Override public void triggersResumed(String triggerGroup) { System.out.println(\u0026#34;触发器组 \u0026#34; + triggerGroup + \u0026#34; 正在从暂停中恢复\u0026#34;); } @Override public void jobAdded(JobDetail jobDetail) { System.out.println(jobDetail.getKey() + \u0026#34; 添加工作任务\u0026#34;); } @Override public void jobDeleted(JobKey jobKey) { System.out.println(jobKey + \u0026#34; 删除工作任务\u0026#34;); } @Override public void jobPaused(JobKey jobKey) { System.out.println(jobKey + \u0026#34; 工作任务正在被暂停\u0026#34;); } @Override public void jobsPaused(String jobGroup) { System.out.println(\u0026#34;工作任务组 \u0026#34; + jobGroup + \u0026#34; 正在被暂停\u0026#34;); } @Override public void jobResumed(JobKey jobKey) { System.out.println(jobKey + \u0026#34; 正在从暂停中恢复\u0026#34;); } @Override public void jobsResumed(String jobGroup) { System.out.println(\u0026#34;工作任务组 \u0026#34; + jobGroup + \u0026#34; 正在从暂停中恢复\u0026#34;); } @Override public void schedulerError(String msg, SchedulerException cause) { System.out.println(\u0026#34;产生严重错误时调用： \u0026#34; + msg + \u0026#34; \u0026#34; + cause.getUnderlyingException()); } @Override public void schedulerInStandbyMode() { System.out.println(\u0026#34;调度器在挂起模式下调用\u0026#34;); } @Override public void schedulerStarted() { System.out.println(\u0026#34;调度器 开启时调用\u0026#34;); } @Override public void schedulerStarting() { System.out.println(\u0026#34;调度器 正在开启时调用\u0026#34;); } @Override public void schedulerShutdown() { System.out.println(\u0026#34;调度器 已经被关闭 时调用\u0026#34;); } @Override public void schedulerShuttingdown() { System.out.println(\u0026#34;调度器 正在被关闭 时调用\u0026#34;); } @Override public void schedulingDataCleared() { System.out.println(\u0026#34;调度器的数据被清除时调用\u0026#34;); } } "},{"id":106,"href":"/database/oracle/system-table/","title":"系统表","section":"Oracle","content":"\r系统表\r#\r系统表前缀\r#\r前缀 说明 USER_ 记录用户对象的信息 ALL_ 记录用户对象的信息及被授权访问的对象信息 DBA_ 记录数据库实例的所有对象的信息 V$ 当前实例的动态视图 常用查询\r#\r-- 常用表\r#\rdba_ all_ user_ 对象 dba_objects all_objects user_objects 视图 dba_views all_views user_views 表 dba_tables all_tables user_tables 列 dba_tab_columns all_tab_columns user_tab_columns 序列 dba_sequences all_sequences user_sequences 同义词 dba_synonyms all_synonyms user_synonyms 索引 dba_indexs all_indexs user_indexs 列索引 dba_ind_columns all_ind_columns user_ind_columns 约束 dba_constraints all_constraints user_constrainst 列约束 dba_cons_columns all_cons_columns user_cons_columns dual -- 伪表 dba_users -- 用户 dba_roles -- 角色 dba_tablespaces -- 表空间 dba_data_files -- 数据文件 dba_trigers -- 触发器 user_source -- 对象资源 user_procedures -- 存储过程 附录：dba_\r#\rdba_users 数据库用户信息 dba_segments 表段信息 dba_extents 数据区信息 dba_objects 数据库对象信息 dba_tablespaces 数据库表空间信息 dba_data_files 数据文件设置信息 dba_temp_files 临时数据文件信息 dba_rollback_segs 回滚段信息 dba_ts_quotas 用户表空间配额信息 dba_free_space 数据库空闲空间信息 dba_profiles 数据库用户资源限制信息 dba_sys_privs 用户的系统权限信息 dba_tab_privs 用户具有的对象权限信息 dba_col_privs 用户具有的列对象权限信息 dba_role_privs 用户具有的角色信息 dba_audit_trail 审计跟踪记录信息 dba_stmt_audit_opts 审计设置信息 dba_audit_object 对象审计结果信息 dba_audit_session 会话审计结果信息 dba_indexes 用户模式的索引信息 附录：all_\r#\rall_users 数据库所有用户的信息 all_objects 数据库所有的对象的信息 all_def_audit_opts 所有默认的审计设置信息 all_tables 所有的表对象信息 all_indexes 所有的数据库对象索引的信息 附录：user_\r#\ruser_objects 用户对象信息 user_source 用户的所有资源对象信息 user_segments 用户的表段信息 user_tables 用户的表对象信息 user_tab_columns 用户的表列信息 user_constraints 用户的对象约束信息 user_sys_privs 当前用户的系统权限信息 user_tab_privs 当前用户的对象权限信息 user_col_privs 当前用户的表列权限信息 user_role_privs 当前用户的角色权限信息 user_indexes 用户的索引信息 user_ind_columns 用户的索引对应的表列信息 user_cons_columns 用户的约束对应的表列信息 user_clusters 用户的所有簇信息 user_clu_columns 用户的簇所包含的内容信息 user_cluster_hash_expressions 散列簇的信息 user_jobs 用户定时任务信息表 附录：v$\r#\rv$database 数据库信息 v$datafile 数据文件信息 v$controlfile 控制文件信息 v$logfile 重做日志信息 v$instance 数据库实例信息 v$log 日志组信息 v$loghist 日志历史信息 v$sga 数据库SGA信息 v$parameter 初始化参数信息 v$process 数据库服务器进程信息 v$bgprocess 数据库后台进程信息 v$controlfile_record_section 控制文件记载的各部分信息 v$thread 线程信息 v$datafile_header 数据文件头所记载的信息 v$archived_log 归档日志信息 v$archive_dest 归档日志的设置信息 v$logmnr_contents 归档日志分析的DML DDL结果信息 v$logmnr_dictionary 日志分析的字典文件信息 v$logmnr_logs 日志分析的日志列表信息 v$tablespace 表空间信息 v$tempfile 临时文件信息 v$filestat 数据文件的I/O统计信息 v$undostat Undo 数据信息 v$rollname 在线回滚段信息 v$session 会话信息 v$transaction 事务信息 v$rollstat 回滚段统计信息 v$pwfile_users 特权用户信息 v$sqlarea 当前查询过的sql语句访问过的资源及相关的信息 v$sql 与v$sqlarea基本相同的相关信息 v$sysstat 数据库系统状态信息 附录：其他\r#\rsession_roles 会话的角色信息 session_privs 会话的权限信息 index_stats 索引的设置和存储信息 "},{"id":107,"href":"/database/mysql/mysql-tuning/index-tuning/","title":"索引优化","section":"性能调优","content":"\r索引优化\r#\r建立合适的索引\r#\r索引应建立在区分度高、数据量小的字段上 对数字的索引效率要优于字符串 下列情况，应建立索引 外键 经常作为查询条件的字段 经常与其他表进行连接的字段 经常需要排序、分组和联合操作的字段 执行频率高（几千次/每天）的语句 数据量大（超过300万）的表 控制索引的数量\r#\r删除不再使用或者很少使用的索引 频繁进行数据更新操作的表，不要建立太多的索引 充分利用索引查询，避免全表扫描\r#\r全表扫描：读取表所有数据，检查每一行是否满足给定条件的过程。 导致索引失效的情况 使用 null 、not、\u0026lt;\u0026gt;、!=、参数、内置函数 or 拼接非索引字段 like 前模糊匹配，形如‘%abc’ 对索引字段进行操作运算 不符合复合索引的最左前缀匹配原则 查询的数量是大表的大部分（30％以上） 列与列进行比较 数据类型转换，包括显式与隐式 尽量使用前缀来索引 "},{"id":108,"href":"/program-lang/java/thread/threadpool/threadpool-type/","title":"线程池 - 种类","section":"线程池","content":"\r常见线程池\r#\r四种线程池\r#\rnewSingleThreadExecutor\r#\r创建一个单线程化的线程池 它只会用唯一的工作线程来执行任务，保证所有任务都按照指定顺序执行 public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;())); } newFixedThreadPool\r#\r创建一个指定工作线程数量的线程池 可控制线程的最大并发数，超出的线程会在队列中等待。 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;()); } newCachedThreadPool\r#\r创建一个可缓存线程池 如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则创建新线程 public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue\u0026lt;Runnable\u0026gt;()); } newScheduledThreadPool\r#\r创建一个可定期或者延时执行任务的定长线程池，支持定时及周期性任务执行 public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize); } public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue()); } 注意事项\r#\r阿里规约中，禁止使用 Executors 创建线程池。因为有可能导致OOM 方法 弊端 newFixedThreadPoolnewSingleThreadExecutor 主要问题是堆积的请求处理队列可能会耗费非常大的内存甚至OOM newCachedThreadPoolnewScheduledThreadPool 主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建非常多的线程甚至OOM "},{"id":109,"href":"/program-design/design-pattern/structural/","title":"结构型","section":"设计模式","content":" 常用 不常用 结构型 代理、桥接、装饰、适配器 门面、组合、享元 "},{"id":110,"href":"/database/mysql/grammar/operator-attribute/","title":"运算符、列属性","section":"基本语法","content":"\r运算符\r#\r算术运算符\r#\r运算符 描述 + 加法 - 减法 * 乘法 /、DIV 除法 %、MOD 取余 逻辑运算符\r#\r运算符 描述 NOT、! 逻辑非 AND 逻辑与 OR 逻辑或 XOR 逻辑异或 位运算符\r#\r运算符 描述 \u0026amp; 按位与 | 按位或 ^ 按位异或 ! 取反 \u0026lt;\u0026lt;、\u0026gt;\u0026gt; 左移、右移 比较运算符\r#\r运算符 描述 运算符 描述 = 等于 [NOT] BETWEEN 【不】在两值之间 \u0026lt;\u0026gt;、!= 不等于 [NOT] IN 【不】在集合中 \u0026lt;、\u0026gt; 小于、大于 IS [NOT] NULL 【不】为空 \u0026lt;=、\u0026gt;= 小于等于、大于等于 LIKE 模糊匹配，%代表多个字符、_代表单个字符 \u0026lt;=\u0026gt; 含NULL值的比较 RLIK、EREGEXP 正则式匹配 语句结束符\r#\rMysql一旦见到语句结束符，就会开始执行。所以定义函数时，需要修改语句结束符，控制执行时机 语句结束符 描述 ; 默认结束符，列名显示在上边，值显示在下边 \\g 效果与分号一样 \\G 列名显示在左边，值显示在右边 列属性\r#\rnull、notnull\r#\r数据列是否允许NULL值。 在设计表的时候，尽量不要让数据为空。 default\r#\r默认值。 如果没有数据插入，以默认值进行填充，通常是null。 comment\r#\r列的注释说明。 unsigned\r#\r数值型数据，无符号 zerofill\r#\r当存储的数值型数据未达到显示长度时，在左侧补0，适用于正数数值 auto_increment\r#\r自动递增，适用于整数类型\n-- 查询自动递增变量 show variables like \u0026#39;auto_increment%\u0026#39;; -- 修改步长 alter table tableName auto_increment= 2; primary key\r#\r主键，在一张表中，有且只有一个主键。\n不能为空，且具有唯一性。\n-- 修改 alter table tableName add primary key(fieldName); -- 删除 alter table tableName drop primary key; foreign key\r#\r外键，表示两表间的关系。 一般不设外键，影响数据库效率，外键关系一般由业务来实现。 unique\r#\r唯一键，在不为空的情况下，不允许重复。\n-- 修改 alter table tableName add unique key(fieldName); -- 删除 alter table tableName drop index keyName; "},{"id":111,"href":"/service-manage/zookeeper/elect-leader/","title":"选举机制","section":"Zookeeper","content":"\r选举机制\r#\r选举\r#\r在 Zookeeper工作时，有一个节点为 Leader，其他则为 Follower，而 Leader 是通过内部的选举机制临时产生的 节点状态：领导者（LEADING）、竞选者（LOOKING）、跟随者（FOLLOWING）、观察者（OBSERVER） 触发选举时机：集群首次启动、集群在工作时Leader宕机 投票信息：myid（服务器id）、ZXID （事务id）、逻辑时钟、节点状态 选举原则\r#\rZookeeper 集群中只有超过半数以上的服务器启动，集群才能正常工作；\n在集群正常工作之前，myid 小的服务器给 myid 大的服务器投票，直到集群正常工作，选出 Leader；\n选出Leader之后，之前的服务器状态由 Looking 改变为 Following，以后的服务器都是 Follower。\n选举过程\r#\r假设：有五台服务器，从 id1-5 依序启动 服务器1启动，发起一次选举： 服务器1投自己一票。 此时服务器1为1票，不够半数以上（3票），选举无法完成； 服务器1状态保持为LOOKING； 服务器2启动，再发起一次选举： 服务器1和2分别投自己一票，此时服务器1发现服务器2的id比自己大，更改选票投给服务器2； 此时服务器1为0票，服务器2为2票，不够半数以上（3票），选举无法完成； 服务器1、2状态保持LOOKING； 服务器3启动，发起一次选举： 与上面过程一样，服务器1和2先投自己一票，然后因为服务器3id最大，两者更改选票投给为服务器3； 此时服务器1为0票，服务器2为0票，服务器3为3票。服务器3的票数已经超过半数当选Leader。 服务器1，2更改状态为FOLLOWING，服务器3更改状态为LEADING； 服务器4启动，发起一次选举： 此时服务器1、2、3已经不是LOOKING状态，不会更改选票信息。投票结果：服务器3为3票，服务器4为1票。 此时服务器4服从多数，更改选票信息为服务器3； 服务器4并更改状态为FOLLOWING； 服务器5启动，发起一次选举： 同4一样投票给3，此时服务器3一共5票，服务器5为0票； 服务器5并更改状态为FOLLOWING； 最终Leader是服务器3，状态为LEADING；其余服务器是Follower，状态为FOLLOWING。 "},{"id":112,"href":"/program-design/data-algorithm/sort/selection/","title":"选择排序","section":"排序算法","content":"\r选择排序\r#\r算法步骤\r#\r首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 动图演示\r#\r代码实现\r#\rpublic class SelectionSort implements IArraySort { @Override public int[] sort(int[] arr) throws Exception { // 总共要经过 N-1 轮比较 for (int i = 0; i \u0026lt; arr.length - 1; i++) { int min = i; // 每轮需要比较的次数 N-i for (int j = i + 1; j \u0026lt; arr.length; j++) { if (arr[j] \u0026lt; arr[min]) { // 记录目前能找到的最小值元素的下标 min = j; } } // 将找到的最小值和i位置所在的值进行交换 if (i != min) { int tmp = arr[i]; arr[i] = arr[min]; arr[min] = tmp; } } return arr; } } "},{"id":113,"href":"/program-design/data-structure/linked-list/","title":"链表","section":"数据结构","content":"\r链表\r#\r链表\r#\rLinked List 是一种物理存储单元上非连续、非顺序的存储结构 数据元素的逻辑顺序，是通过链表中的指针链接次序实现的 每个数据元素包含两个部分：存储元素的数据域、指向下一个结点地址的指针域 特点\r#\r查询速度慢 新增、删除速度快 查询元素\r#\r因为数据都是分散存储的，所以只能从第一个数据开始，顺着指针的指向逐一往下查找 新增元素\r#\r顺着指针，查找到位置 新增一个元素 删除元素\r#\r顺着指针，查找到位置 删除一个元素 "},{"id":114,"href":"/framework/spring/ioc/bean-injection/","title":"Bean 注入","section":"IoC","content":"\rBean 注入\r#\r自动装配方式\r#\r方式 描述 no 默认模式，没有自动装配 byName 由属性名自动装配。 byType 由属性数据类型自动装配。 constructor 类似于 byType，但该类型适用于构造函数参数类型。 Autodetect 首先尝试通过 constructor 使用自动装配来连接，如果它不执行，再尝试通过 byType 来自动装配。 Bean 注入\r#\r@Resource、@Autowired 两者功能相同，都可以标注在字段和setter方法 @Autowired\r#\rSpring 提供的注解 默认按 byType 方式进行装配 可配合 @Qualifier，改为按 byName 方式进行装配 @Resource\r#\rJ2EE 提供的注解，Spring 做了支持 默认按 byName 方式进行装配 属性 name 和 type，装配顺序： 如果同时指定了 name 和 type，则寻找唯一匹配的 bean 进行装配 如果指定了 name，则按 byName 方式进行装配 如果指定了 type，按 byType 方式进行装配 如果未指定 name 和 type，则按 byName 方式进行装配 "},{"id":115,"href":"/program-lang/java/thread/container/ConcurrentHashMap/","title":"ConcurrentHashMap","section":"并发容器","content":"\rConcurrentHashMap\r#\rConcurrentHashMap\n"},{"id":116,"href":"/service-manage/deprecated-frame/feign/","title":"Feign","section":"日落组件","content":"\rFeign\r#\rFeign\r#\r服务调用 Feign 集成了 Ribbon，是一个声明式的Web服务客户端 使得编写Web服务客户端变得非常容易，只需要创建一个接口，然后在上面添加注解即可。 "},{"id":117,"href":"/program-lang/java/container/Map/HashTable/","title":"HashTable","section":"Map","content":"\rHashTable\r#\r概述\r#\r是一个哈希表，存储的是键值对 (key-value) 映射。 和 HashMap 很相似，不同的是，HashTable 是线程安全的 特点\r#\r键 不允许为null，不允许重复 值 不允许为null，允许重复 顺序 无序 多线程 线程安全 继承关系\r#\rpublic class Hashtable\u0026lt;K,V\u0026gt; extends Dictionary\u0026lt;K,V\u0026gt; implements Map\u0026lt;K,V\u0026gt;, Cloneable, java.io.Serializable Dictionary、Map接口 提供了键值对的骨干功能 Cloneable接口 支持克隆 Serializable接口 支持序列化 成员变量\r#\r// 保存key-value的数组。 private transient Entry\u0026lt;?,?\u0026gt;[] table; // 元素的个数 private transient int count; // 阈值，用于判断是否需要调整Hashtable的容量（threshold = 容量*加载因子） private int threshold; // 加载因子 private float loadFactor; // Hashtable被改变的次数 private transient int modCount = 0; // 内部类，每一个Entry本质上是一个单向链表 private static class Entry\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { final int hash; final K key; V value; Entry\u0026lt;K,V\u0026gt; next; //... } 构造方法\r#\r// 默认 public Hashtable() { this(11, 0.75f); } // 指定初始容量 public Hashtable(int initialCapacity) { this(initialCapacity, 0.75f); } // 指定初始容量、加载因子 public Hashtable(int initialCapacity, float loadFactor) { //... } // 指定集合，转化为Hashtable public Hashtable(Map\u0026lt;? extends K, ? extends V\u0026gt; t) { this(Math.max(2*t.size(), 11), 0.75f); //... } 扩容机制\r#\r当元素的个数大于阈值时，会进行扩容 扩容的新容量为：旧容量 * 2 + 1 protected void rehash() { int oldCapacity = table.length; Entry\u0026lt;?,?\u0026gt;[] oldMap = table; // 新数组的容量=旧数组长度*2+1 int newCapacity = (oldCapacity \u0026lt;\u0026lt; 1) + 1; // 保证新数组的大小永远小于等于MAX_ARRAY_SIZE if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) { if (oldCapacity == MAX_ARRAY_SIZE) return; newCapacity = MAX_ARRAY_SIZE; } // 创建新数组 Entry\u0026lt;?,?\u0026gt;[] newMap = new Entry\u0026lt;?,?\u0026gt;[newCapacity]; modCount++; // 计算新的临界值 threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1); table = newMap; // 将旧数组中的元素迁移到新数组中 for (int i = oldCapacity ; i-- \u0026gt; 0 ;) { for (Entry\u0026lt;K,V\u0026gt; old = (Entry\u0026lt;K,V\u0026gt;)oldMap[i] ; old != null ; ) { Entry\u0026lt;K,V\u0026gt; e = old; old = old.next; //计算新数组下标 int index = (e.hash \u0026amp; 0x7FFFFFFF) % newCapacity; // 头插法的方式迁移旧数组的元素 e.next = (Entry\u0026lt;K,V\u0026gt;)newMap[index]; newMap[index] = e; } } } "},{"id":118,"href":"/program-base/network/http/","title":"HTTP","section":"网络","content":"\rHTTP 协议\r#\rHyper Text Transfer Protocol，超文本传输协议，是一种网络通信协议 用于将超文本标记语言（HTML）文档从Web服务器传送到本地浏览器 基于客户端/服务端（C/S）模型，将浏览器为客户端，通过URL向服务端发送所有请求 工作过程\r#\r客户与服务器建立连接 客户向服务器提出请求 服务器接受请求，并根据请求返回相应的文件作为应答 客户与服务器关闭连接 其他\r#\rHTTP 的默认端口号为80 HTTP 是无连接的，每次连接只处理一个请求 HTTP 是媒体独立的，可以发送任何类型的数据 HTTP 是无状态的，对于事务处理没有记忆能力 "},{"id":119,"href":"/program-base/network/http/https/","title":"HTTPS","section":"HTTP","content":"\rHTTPS 协议\r#\rHTTPS\r#\rHypertext Transfer Protocol Secure，超文本传输安全协议 是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议 主要作用：数据保密性、数据完整性、身份校验安全性 默认端口：443 工作原理\r#\rHTTPS 优点\r#\r使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； HTTPS 要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 谷歌曾称“比起同等 HTTP 网站，采用 HTTPS 加密的网站在搜索结果中的排名将会更高”。 HTTPS 缺点\r#\rHTTPS 协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电； HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响； SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。 SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。 HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。 "},{"id":120,"href":"/program-lang/java/library/java.time/","title":"java.time","section":"基础类库","content":"\r日期时间\r#\rJava8 Time API\r#\r新增的日期时间类都是不可变的 Instant 时间戳 LocalDateTime 年月日时分秒毫秒 LocalDate 年月日 LocalTime 时分秒毫秒 转换：新旧日期时间\r#\rDate \u0026lt;\u0026mdash;\u0026gt; Instant\n// 新旧日期类，都是通过Instant进行互转 Date now = new Date(); Instant instant = now.toInstant(); Date date = Date.from(instant); Instant \u0026lt;\u0026mdash;\u0026gt; ZonedDateTime、LocalDateTime、LocalDate、LocalTime\nInstant now = Instant.now(); // Instant \u0026lt;=\u0026gt; ZonedDateTime ZonedDateTime zonedDateTime = now.atZone(ZoneId.systemDefault()); Instant instant = zonedDateTime.toInstant(); // Instant \u0026lt;=\u0026gt; LocalDateTime LocalDateTime localDateTime = now.atZone(ZoneId.systemDefault()).toLocalDateTime(); Instant instant = localDateTime.atZone(ZoneId.systemDefault()).toInstant(); // Instant \u0026lt;=\u0026gt; LocalDate LocalDate localDate = now.atZone(ZoneId.systemDefault()).toLocalDate(); Instant instant = localDate.atStartOfDay(ZoneId.systemDefault()).toInstant(); // Instant =\u0026gt; LocalTime LocalTime localTime = now.atZone(ZoneId.systemDefault()).toLocalTime(); LocalDateTime \u0026lt;\u0026mdash;\u0026gt; LocalDate、LocalTime\nLocalDate now = LocalDate.now(); LocalDateTime localDateTime = localDate.atStartOfDay(); LocalDate localDate = localDateTime.toLocalDate(); LocalTime localTime = localDateTime.toLocalTime(); 转换：字符串与日期时间\r#\rString \u0026lt;\u0026mdash;\u0026gt; Date\nSimpleDateFormat format = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); Date date = format.parse(\u0026#34;2022-01-01 01:01:01\u0026#34;); String dateStr dateStr = format.format(date); // 2022-01-01 01:01:01 dateStr = date.toString(); // Sat Jan 01 01:01:01 CST 2022 String \u0026lt;\u0026mdash;\u0026gt; LocalDateTime\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); LocalDateTime localDateTime = LocalDateTime.parse(\u0026#34;2022-01-01 01:01:01\u0026#34;, formatter); String localDateTimeStr; localDateTimeStr = localDateTime.format(formatter); // 2022-01-01 01:01:01 localDateTimeStr = localDateTime.toString(); // 2022-01-01T01:01:01 String \u0026lt;\u0026mdash;\u0026gt; LocalDate\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd\u0026#34;); LocalDate localDate = LocalDate.parse(\u0026#34;2022-01-01\u0026#34;, formatter); String localDateStr; localDateStr = localDate.format(formatter); // 2022-01-01 localDateStr = localDate.toString(); // 2022-01-01 String \u0026lt;\u0026mdash;\u0026gt; LocalTime\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\u0026#34;HH:mm:ss\u0026#34;); LocalTime localTime = LocalTime.parse(\u0026#34;01:01:01\u0026#34;, formatter); String localTimeStr; localTimeStr = localTime.format(formatter); // 01:01:01 localTimeStr = localTime.toString(); // 01:01:01 获取：当前日期时间\r#\r// 2020-03-25T13:18:51.052775200Z System.out.println(Instant.now()); // 2020-03-25T21:18:51.064769800 System.out.println(LocalDateTime.now()); // 2020-03-25 System.out.println(LocalDate.now()); // 21:18:51.064769800 System.out.println(LocalTime.now()); // 2020 System.out.println(Year.now()); // 2020-03 System.out.println(YearMonth.now()); // --03-25 System.out.println(MonthDay.now()); 获取：指定日期时间\r#\r// 2020-03-25T21:44:32 LocalDateTime.of(2020, 3, 25, 21, 44, 32); // 2020-03-25 LocalDate.of(2020, 3, 25); // 21:44:32 LocalTime.of(21, 44, 32); // 2020 Year.of(2020); // 2020-03 YearMonth.of(2020, 3); // --03-25 MonthDay.of(3, 25); // 指定日期时间 LocalDateTime localDateTime = LocalDateTime.of(2020, 3, 25, 21, 44, 32); // 这一天的开始时间 localDateTime.toLocalDate().atStartOfDay(); // 这一天的开始时间 localDateTime.toLocalDate().atTime(LocalTime.MAX); // 30小时后 localDateTime.plusHours(30); // 30分钟后 localDateTime.plusMinutes(30); 间隔：Period\r#\r时间间隔：年数，月数，天数 只能比较LocalDate LocalDate localDate1 = LocalDate.of(2020, 1, 15); LocalDate localDate2 = LocalDate.now(); Period period = Period.between(localDate1, localDate2); // 10 System.out.println(period.getDays()); // 2 System.out.println(period.getMonths()); 间隔：Duration\r#\r时间间隔：秒数，纳秒数 能比较包含了time的类，如LocalDateTime，LocalTime和Instant等 LocalDateTime localDateTime1 = LocalDateTime.of(2020, 1, 15, 8, 21, 12); LocalDateTime localDateTime2 = LocalDateTime.now(); Duration between = Duration.between(localDateTime1, localDateTime2); // 70 System.out.println(between.toDays()); // 1694 System.out.println(between.toHours()); 间隔：ChronoUnit\r#\r表示时间单位 LocalDateTime localDateTime1 = LocalDateTime.of(2020, 1, 15, 8, 21, 12); LocalDateTime localDateTime2 = LocalDateTime.now(); // 0 localDateTime1.until(localDateTime2, ChronoUnit.YEARS); // 2 localDateTime1.until(localDateTime2, ChronoUnit.MONTHS); // 70 localDateTime1.until(localDateTime2, ChronoUnit.DAYS); // 1694 localDateTime1.until(localDateTime2, ChronoUnit.HOURS); // 101678 localDateTime1.until(localDateTime2, ChronoUnit.MINUTES); // 6100682 localDateTime1.until(localDateTime2, ChronoUnit.SECONDS); // 0 ChronoUnit.YEARS.between(localDateTime1, localDateTime2) ...... 比较\r#\rLocalDateTime localDateTime1 = LocalDateTime.of(2020, 3, 25, 6, 44, 32); LocalDateTime localDateTime2 = LocalDateTime.now(); // 是否为同一天 true localDateTime1.toLocalDate().equals(localDateTime2.toLocalDate()); // localDateTime1是否在localDateTime2之前 true localDateTime1.isBefore(localDateTime2); // localDateTime1是否在localDateTime2之后 false localDateTime1.isAfter(localDateTime2); #\r"},{"id":121,"href":"/program-lang/java/container/Set/LinkedHashSet/","title":"LinkedHashSet","section":"Set","content":"\rLinkedHashSet\r#\r概述\r#\rLinkedHashSet 基于 LinkedHashMap 实现，是 HashSet 的一个扩展版本 特点\r#\r顺序 有序 元素 允许为 null，不允许重复 多线程 线程不安全 继承关系\r#\rpublic class LinkedHashSet\u0026lt;E\u0026gt; extends HashSet\u0026lt;E\u0026gt; implements Set\u0026lt;E\u0026gt;, Cloneable, java.io.Serializable HashSet、Set接口 提供了 Set 接口的骨干功能 Cloneable接口 支持克隆 Serializable接口 支持序列化 构造方法\r#\r// 默认 public LinkedHashSet() { super(16, .75f, true); } // 指定初始容量 public LinkedHashSet(int initialCapacity) { super(initialCapacity, .75f, true); } // 指定初始容量、负载因子 public LinkedHashSet(int initialCapacity, float loadFactor) { super(initialCapacity, loadFactor, true); } // 指定集合，转化为LinkedHashSet public LinkedHashSet(Collection\u0026lt;? extends E\u0026gt; c) { super(Math.max(2*c.size(), 11), .75f, true); //... } // 父类HashSet的构造方法 // 使用 LinkedHashMap 的 key 保存元素 HashSet(int initialCapacity, float loadFactor, boolean dummy) { map = new LinkedHashMap\u0026lt;\u0026gt;(initialCapacity, loadFactor); } "},{"id":122,"href":"/program-lang/java/container/List/LinkedList/","title":"LinkedList","section":"List","content":"\rLinkedList\r#\r概述\r#\r是一种双向链表 特点\r#\r顺序 有序 元素 允许为 null，允许重复 效率 查询慢，增删快 多线程 线程不安全 继承关系\r#\rpublic class LinkedList\u0026lt;E\u0026gt; extends AbstractSequentialList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, Deque\u0026lt;E\u0026gt;, Cloneable, java.io.Serializable AbstractSequentialList、List接口 提供了列表的骨干功能 Deque接口 提供了双端队列的骨干功能 Cloneable接口 支持克隆 Serializable接口 支持序列化 成员变量\r#\r// 元素的个数 transient int size = 0; // 头节点 transient Node\u0026lt;E\u0026gt; first; // 尾节点 transient Node\u0026lt;E\u0026gt; last; // 节点（内部类） private static class Node\u0026lt;E\u0026gt; { E item; Node\u0026lt;E\u0026gt; next; Node\u0026lt;E\u0026gt; prev; Node(Node\u0026lt;E\u0026gt; prev, E element, Node\u0026lt;E\u0026gt; next) { this.item = element; this.next = next; this.prev = prev; } } 构造方法\r#\r// 默认 public LinkedList() { } // 指定集合，转化为LinkedList public LinkedList(Collection\u0026lt;? extends E\u0026gt; c) { //... } "},{"id":123,"href":"/database/oracle/plsql/","title":"PL/SQL","section":"Oracle","content":"\rPL/SQL\r#\rProcedural Language/SQL 是为标准 SQL 语言添加了过程化功能的一门程序设计语言 具有第三代语言特性，第三代程序设计语言是诸如 C、C++、Java 这类语言。 只能在 oracle 数据库中使用 功能特点\r#\r特点 说明 与 SQL 语言整合 PL/SQL 中可以执行 SQL 语句 结构化程序设计 PL/SQL 提供了顺序、分支、循环三种基本控制结构 面向对象开发 PL/SQL 提供了对象类型 模块化开发 PL/SQL 提供了块、子程序、包三种程序单元 显著提高性能 PL/SQL 允许一次性向数据库发送多条 SQL 语句，减小了网络开销 执行环境\r#\r"},{"id":124,"href":"/program-lang/java/thread/lock/ReentrantLock/","title":"ReentrantLock","section":"锁体系","content":"\rReentrantLock\r#\r"},{"id":125,"href":"/program-lang/java/thread/tool/Semaphore/","title":"Semaphore","section":"并发工具","content":"\rSemaphore\r#\r功能\r#\r信号灯 作为一种流量控制手段，用于控制同时访问特定资源的线程数量，保证合理的使用共享资源。 原理\r#\rSemaphore 管理一系列许可（仅维护许可的计数）。 线程通过 acquire() 获取许可。当没有可用的许可的时候，线程阻塞，直到有可用的许可为止。 线程通过 release() 释放许可。 方法\r#\r// 构造方法：设定许可数量 public Semaphore(int permits) // 构造方法：设定许可数量，公平/非公平模式 public Semaphore(int permits, boolean fair) // 获取许可 public void acquire() // 释放许可 public void release() // 获取剩余许可数量 public int drainPermits() 示例\r#\r// 抢车位 public class Test { public static void main(String[] args) { // 模拟3个停车位 Semaphore semaphore = new Semaphore(3); // 模拟6部汽车 for (int i = 1; i \u0026lt;= 6; i++) { new Thread(() -\u0026gt; { try { String thread = Thread.currentThread().getName(); // 抢到资源 semaphore.acquire(); System.out.println(thread + \u0026#34;\\t抢到车位\u0026#34;); sleep(3); System.out.println(thread + \u0026#34;\\t停3秒离开车位\u0026#34;); } catch (InterruptedException e) { e.printStackTrace(); } finally { // 释放资源 semaphore.release(); } }, String.valueOf(i)).start(); } } private static void sleep(long timeout) { try { TimeUnit.SECONDS.sleep(timeout); } catch (InterruptedException e) { e.printStackTrace(); } } } "},{"id":126,"href":"/program-lang/java/container/Set/","title":"Set","section":"集合容器","content":"\r"},{"id":127,"href":"/program-base/linux/shell/","title":"Shell","section":"Linux","content":"\rShell\r#\r是一种命令行解释器，它是用户与操作系统内核之间的接口 提供了一种交互式的方式，使用户可以通过命令来操作计算机，执行各种任务和管理系统资源 "},{"id":128,"href":"/service-manage/springboot/","title":"Spring Boot","section":"服务治理","content":"\rSpring Boot\r#\r是一个用来简化新 Spring 应用的初始搭建以及开发过程的框架 定制 Spring Boot 项目 中文参考文档 核心功能\r#\r可独立运行 Spring 项目 内嵌 servlet 容器 提供 starter 简化 Maven 配置 自动配置 Spring 准生产的应用监控 无代码生成和xml配置 优点\r#\r快速搭建项目 对主流框架无配置集成 项目可独立运行，不依赖 servlet 容器 提供运行时的应用监控 极大提高开发、部署效率 与云计算天然集成 "},{"id":129,"href":"/program-lang/java/thread/theory/volatile/","title":"volatile","section":"并发理论","content":"\rvolatile\r#\r概述\r#\rvolatile：是一种比sychronized关键字更轻量级的同步机制，用来确保将变量的更新操作通知到其他线程。 保证所修饰变量对所有的线程的可见性 禁止指令重排优化 不保证原子性 实现原理\r#\r对于volatile所修饰变量的写操作，在生成汇编代码时，会增加Lock前缀指令 缓存一致性：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期 内存语义\r#\r写volatile变量会重新刷新到主内存中，其他线程读volatile变量，会重新从主内存中读取新值 内存语义的实现\r#\r在生成字节码时，编译器会在指令序列中插入内存屏障，来禁止特定类型的处理器重排序 StoreStore屏障 禁止上面的普通写和下面的volatile写重排序 StoreLoad屏障 防止上面的volatile写与下面可能有的volatile读/写重排序 LoadLoad屏障 禁止下面所有的普通读操作和上面的volatile读重排序 LoadStore屏障 禁止下面所有的普通写操作和上面的volatile读重排序 解决：不保证原子性\r#\r解决办法：使用 synchronized 修饰、使用 AtomicInteger 类型 public class Singleton { //volatile：禁止指令重排 private static volatile Singleton instance = null; private Singleton() { } // 双重检测机制 public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } } "},{"id":130,"href":"/program-lang/web/html/list/","title":"列表标签","section":"HTML","content":"\r列表标签\r#\r标签 说明 \u0026lt;ul\u0026gt; 定义一个无序列表（属性type：disc、square、circle） \u0026lt;ol\u0026gt; 定义一个有序列表（属性type：1、a、A、ⅰ、Ⅰ） \u0026lt;li\u0026gt; 定义一个列表项 \u0026lt;dl\u0026gt; 定义一个定义列表 \u0026lt;dt\u0026gt; 定义一个定义列表项 \u0026lt;dd\u0026gt; 定义一个定义列表项描述 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Coffee\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Milk\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;Coffee\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Milk\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;Coffee\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;Black hot drink\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;Milk\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;White cold drink\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; "},{"id":131,"href":"/program-lang/web/css/style/list/","title":"列表样式","section":"CSS 样式","content":"\r列表样式\r#\r属性\r属性说明\r属性值\r属性值说明\rlist-style\r简写属性\r\u0026nbsp;\r空格分隔各值，不分顺序\rlist-style-image\r列表项标志的图片\rnone\r无图片，默认\rURL\r图片路径\rlist-style-position\r列表项标志的位置\routside\r标记在文本外，文本与文本对齐。默认\rinside\r标记在文本内，文本与标记对齐\rlist-style-type\r列表项标志的类型\rnone\r无标记\rdisc\r实心圆，默认\rcircle\r空心圆\rsquare\r实心方块\rdecimal\r数字\rlower-alpha\r小写英文字母(a、b、c、...)\rupper-alpha\r大写英文字母(A、B、C、...)\rlower-roman\r小写罗马数字(i、ii、iii、...)\rupper-roman\r大写罗马数字(I、II、III、...)\r"},{"id":132,"href":"/framework/springmvc/params-bind/","title":"参数绑定","section":"Spring MVC","content":"\r参数绑定\r#\r默认支持的类型\r#\rHttpServletRequest HttpServletResponse HttpSession Model/ModelMap 简单类型\r#\rrequest入参、处理器方法形参，名称相同，可免注解\nrequest入参、处理器方法形参，名称不同，使用@RequestParam\n// 属性required，否必须传入 // 属性defaultValue，设置默认值 public String editItem(String id, @RequestParam(value = \u0026#34;name\u0026#34;, required = true) String itemName){ //...... } 简单pojo\r#\r前提条件：接收参数的pojo，内部属性为简单类型，且与request入参名称相同\n//pojo类 public class Label{ private String labelId; private String labelName; //... } //处理器类 @Controller @RequestMapping(method=RequestMethod.POST) public class LabelController { @RequestMapping(\u0026#34;/addLabel\u0026#34;) public ActionResult addLabel(Label label) { //... } } 包装类型pojo\r#\r包装类型pojo：指内部属性不止简单类型，还有引用类型\n方式一：通过HttpServletRequest参数，进行接收\n方式二：通过点来绑定，如示例\n//页面参数 \u0026lt;input name=\u0026#34;parent.name\u0026#34; /\u0026gt; //pojo public class Person{ private String id; private String name; //... } public class PersonVo{ private String id; private Person parent; private Person son; //... } //处理器类 @Controller @RequestMapping(method=RequestMethod.POST) public class PersonController { @RequestMapping(\u0026#34;/setPerson\u0026#34;) public ActionResult setPerson(PersonVo vo) { //... } } 数组\r#\r直接传递\n@RequestMapping(\u0026#34;/deleteItems\u0026#34;) public ActionResult deleteItems(Intege[] item_ids) { //... } List、Map\r#\r需要绑定在对象上\n//pojo public class UserForm { private List\u0026lt;User\u0026gt; userList; private Map\u0026lt;String, User\u0026gt; userMap; //... } //处理器类 @Controller @RequestMapping(method=RequestMethod.POST) public class UserController { @RequestMapping(\u0026#34;/userForm\u0026#34;) public ActionResult userForm(UserForm userForm) { //... } } "},{"id":133,"href":"/program-lang/java/feature/reflection/","title":"反射机制","section":"语言特性","content":"\r反射机制\r#\r概述\r#\r是一种动态获取程序信息以及动态调用对象的功能 是Java被视为动态语言的关键 功用\r#\r在运行时，判断任意一个类所具有的成员变量和方法 在运行时，判断任意一个对象所属的类 在运行时，调用任意一个对象的方法 在运行时，构造任意一个类的对象 在运行时，获取泛型信息 在运行时，处理注解 生成动态代理 反射API\r#\rjava.lang.Class：代表一个类 java.lang.reflect.Field：代表类的成员变量 java.lang.reflect.Method：代表类的方法 java.lang.reflect.Constructor：代表类的构造器 java.lang.reflect.Array：提供了动态创建和访问 Java 数组的方法 java.lang.Class\r#\r获取 Class 实例\n// 1 通过类属性 Class clazz1 = Person.class; // 2 通过实例对象 Person person = new Person(); Class clazz2 = person.getClass(); // 3 通过类名（常用） Class clazz3 = Class.forName(\u0026#34;com.test.Person\u0026#34;); // 4 通过了类加载器（不常用） ClassLoader classLoader = Test.class.getClassLoader(); Class clazz4 = classLoader.loadClass(\u0026#34;com.test.Person\u0026#34;); // 注：每个类对应的Class实例在运行过程中都是唯一的 // 即clazz1、clazz2、clazz3、clazz4是同一个实例 方法摘要\n方法 描述 方法 描述 getConstructor() 获取 Constructor 对象 getClassLoader() 获取类加载器 getConstructors() 获取所有Constructor 对象 getSuperclass() getField() 获取指定 Field 对象 getInterfaces() getFields() 获取所有 Field 对象 getAnnotation() getDeclaredField() 获取指定 Field 对象（包括私有） getAnnotations() getDeclaredFields() 获取所有 Field 对象（包括私有） \u0026hellip; getMethod( 获取指定 Method 对象 getMethods() 获取所有 Method 对象 newInstance() 创建Class对象所代表类的实例 示例\r#\r@Data public class Person { private String name; private Integer age; } public class Test { public static void main(String[] args) throws Exception { Class\u0026lt;?\u0026gt; c = Class.forName(\u0026#34;com.test.Person\u0026#34;); Method[] methods = c.getDeclaredMethods(); Method[] methods2 = c.getMethods(); System.out.println(\u0026#34;本类方法：\u0026#34; + Arrays.toString(methods) + \u0026#34;\\n\u0026#34;); System.out.println(\u0026#34;本类及父类方法：\u0026#34; + Arrays.toString(methods2) + \u0026#34;\\n\u0026#34;); for (Method method : methods) { System.out.println(method.toString()); System.out.println(method.toGenericString() + \u0026#34;\\n\u0026#34;); } Person person = (Person) c.getDeclaredConstructor().newInstance(); Method nameMethod = c.getDeclaredMethod(\u0026#34;setName\u0026#34;, String.class); nameMethod.invoke(person, \u0026#34;瓜田李下\u0026#34;); Method ageMethod = c.getDeclaredMethod(\u0026#34;setAge\u0026#34;, Integer.class); ageMethod.invoke(person, 24); System.out.println(person.toString()); } } "},{"id":134,"href":"/database/mysql/grammar/variable-function/","title":"变量、函数","section":"基本语法","content":"\r变量\r#\r局部变量：仅在结构体语句块中有效 会话变量：在当前用户的当次连接有效 全局变量：全局有效 系统变量\r#\rshow variables [like \u0026#39;...\u0026#39;]; -- 查询多个 select @@varName; -- 查询单个 set varName = value; -- 局部修改（会话级别） set global varName = value; -- 全局修改 set @@global.varName = value; -- 全局修改 -- 示例：修改自动编号步长 SET GLOBAL auto_increment_increment = 1; 会话变量\r#\r-- 设置 set @varName = value; set @varName := value; -- 查看 select @varName; -- 示例 SELECT @name := stu_name,@age := stu_age FROM student WHERE stu_id = \u0026#39;1\u0026#39;; SELECT stu_name,stu_age FROM student WHERE stu_id = \u0026#39;1\u0026#39; INTO @name,@age; 局部变量\r#\r-- 设置 declare varName dataType [attribute]; -- 示例 declare age int default 18; 函数\r#\r内置函数\r#\rMySQL 内置函数 自定义函数\r#\r自定义函数是属于用户级别的，只有当前客户端对应的数据库中可以使用\n函数内部不能使用select指令，因为select一旦执行就会立即返回。（例外情况：select 字段 into @变量;）\n# 定义函数 # 修改语句结束符 create function 函数名(形参) returns 返回值类型 begin 函数体 return 返回值数据; end 语句结束符 复原语句结束符 # 查看函数 show function status [like \u0026#39;...\u0026#39;]; show create function 函数名; # 调用函数 select 函数名(实参列表); # 删除函数 drop function 函数名; -- 示例 DELIMITER $$ CREATE FUNCTION hello() RETURNS VARCHAR(255) BEGIN RETURN \u0026#39;Hello world, mysql\u0026#39;; END $$ DELIMITER ; "},{"id":135,"href":"/program-lang/java/jvm/gc/collect/","title":"回收算法","section":"垃圾回收","content":"\r回收算法\r#\r标记 - 清除（Mark-Sweep）\r#\r原理：\n标记：扫描内存空间，对存活的对象进行标记 清除：扫描内存空间，回收未标记的对象。 缺点：\n两次扫描，效率低 会产生内存碎片 标记 - 整理（Mark-Compact）\r#\r原理：\n标记：扫描内存空间，对存活的对象进行标记 压缩：再次扫描，并整理存活的对象 优缺点：\n没有内存碎片 移动对象需要成本 复制算法（Copying）\r#\r原理：\n从 From 区找到存活的对象，复制到 To 区。 From、To区交互身份，进行下一轮垃圾收集。 优缺点：\n没有标记清除过程，效率高。 没有内存碎片，能进行快速内存分配 可用内存被压缩到了原来的一半，内存利用率较低 分代收集\r#\r原理： 根据对象的生命周期的不同将内存划分为几块，然后根据各块的特点采用最适当的收集算法 对于新生代（大批对象死去、只有少量对象存活），一般使用复制算法 对于老年代（对象存活率高、没有额外空间进行分配担保），一般使用标记-整理算法 分区收集\r#\r原理：将整个堆空间划分为连续的不同小区间，每个小区间独立使用，独立回收。 优点：可以控制一次回收多少个小区间，根据目标停顿时间，每次合理地回收若干个小区间(而不是整个堆)，从而减少一次GC所产生的停顿。 "},{"id":136,"href":"/program-lang/java/jvm/gc/","title":"垃圾回收","section":"虚拟机","content":"\rGC\r#\rGarbage Collections 垃圾收集，释放无用对象所占内存空间 作用：可以有效的防止内存泄露，有效的使用空闲的内存 优点：提高编程效率、保护程序的完整性 缺点：影响程序性能 "},{"id":137,"href":"/dev-tool/git/command/","title":"基本命令","section":"Git","content":"\r基本命令\r#\r基本操作\r#\r创建仓库\r#\rgit init\r#\r# 初始化本地库 # git init [dir] $ git init git clone\r#\r# 从现有库中拷贝项目 # git clone \u0026lt;repository\u0026gt; \u0026lt;dir\u0026gt; $ git clone git://github.com/schacon/grit.git myDir 变更修改\r#\rgit add\r#\r# 添加文件/文件夹到暂存区 # git add [file1] [file2] ... $ git add README hello.php # 格式：git add [dir] $ git add . git rm\r#\r# 删除工作区和暂存区的文件 # git rm \u0026lt;file\u0026gt; $ git rm runoob.txt # 选项：-f 强制删除 $ git rm -f runoob.txt # 选项：--cached 仅从暂存区域移除，仍保留在工作区中 $ git rm --cached runoob.txt # 选项：-r 递归删除 $ git rm –r * git mv\r#\r# 移动或重命名一个文件 # git mv [file] [newfile] $ git mv test.log test.txt # 选项：-f 强制 $ git mv -f README README.md git commit\r#\r# 提交暂存区到本地仓库 # git commit -m [message] $ git commit -m \u0026#39;第一次版本提交\u0026#39; # 选项：-m 提交时添加注释信息 # 选项：-a 提交跟踪过的文件 $ git commit -am \u0026#39;第一次版本提交\u0026#39; # 选项：--amend 追加提交（修改最近一次的提交） $ git commit --amend 回退版本\r#\rgit reset\r#\r# 格式：git reset [--soft | --mixed | --hard] [HEAD] # 选项：--soft 在本地库移动 HEAD 指针 # 选项：--mixed 在本地库移动 HEAD 指针、重置暂存区 # 选项：--hard 在本地库移动 HEAD 指针、重置暂存区、重置工作区 $ git reset HEAD^ # 回退所有内容到上一个版本 $ git reset HEAD^ hello.php # 回退 hello.php 文件的版本到上一个版本 $ git reset 052e # 回退到指定版本 # 后退 n 个版本 $ git reset --hard HEAD^^ # n 为 ^ 的个数 $ git reset --hard HEAD~2 # n 为 ~ 后的数字 远程操作\r#\rgit remote\r#\r# 查看远程库 $ git remote -v # 显示所有 $ git remote show [remote] # 显示某个 # 新增远程库 # git remote add [库别名] [远程地址] $ git remote add origin https://github.com/ArdaData/xxx.git # 删除远程库 # git remote add [库别名] [远程地址] $ git remote add origin https://github.com/ArdaData/xxx.git git fetch、git merge\r#\r# 拉取远程代码 # git fetch [库别名] [分支名] $ git fetch origin # 合并到工作区 # git merge [库别名 / 分支名] $ git merge origin/master git pull\r#\r# 拉取远程代码并合并 # git pull \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt; $ git pull origin master # 合并到当前分支 $ git pull origin master:brantest # 合并到brantest分支 git push\r#\r# 推送到远程并合并 # git push \u0026lt;远程主机名\u0026gt; \u0026lt;本地分支名\u0026gt;:\u0026lt;远程分支名\u0026gt; $ git push origin master # 合并到master分支 $ git push origin master:brantest # 合并到brantest分支 # 选项：--force 强制推送 $ git push --force origin master 分支操作\r#\rgit branch\r#\r# 查看分支 $ git branch -v # 创建分支 $ git branch mybranch # 删除分支 $ git branch -d mybranch git checkout\r#\r# 切换分支 $ git checkout mybranch # 创建并切换分支 $ git checkout -b mybranch git merge\r#\r# 合并分支 $ git merge mybranch 查看操作\r#\r查看差异\r#\rgit status\r#\r# 查看仓库当前的状态，显示有变更的文件 $ git status # 选项：-s 精简显示 $ git status -s git diff\r#\r# 对比暂存区和工作区的差异 $ git diff [file] # 对比暂存区和最后一次提交(HEAD)的差异 $ git diff --cached [file] # 对比工作区/暂存区和最后一次提交(HEAD)的差异（~X: 表示前第X个版本） $ git diff HEAD $ git diff HEAD~X # 比较两个分支上最后提交的内容的差别 $ git diff \u0026lt;分支名1\u0026gt; \u0026lt;分支名2\u0026gt; # 选项：--stat 精简显示 $ git diff --stat 查看日志\r#\rgit log\r#\r# 查看历史提交记录 $ git log # 选项：--oneline 精简显示 $ git log --oneline # 选项：--reverse 逆向显示 $ git log --reverse git blame\r#\r# 查看指定文件的提交记录 # git blame \u0026lt;file\u0026gt; $ git blame README.txt 查看命令\r#\rgit help\r#\r# 在网页中，查看帮助文档 $ git help \u0026lt;command\u0026gt; $ git \u0026lt;command\u0026gt; --help "},{"id":138,"href":"/database/mysql/advanced-feature/store-procedure/","title":"存储过程","section":"高级特性","content":"\r存储过程\r#\r定义\r#\rstored procedure，是一组为了完成特定功能的SQL 语句集，存储在数据库中， 经过第一次编译后再次调用不需要再次编译（效率比较高） 存储过程管理\r#\r# 创建 修改语句结束符 create procedure 过程名字([参数列表]) begin 过程体 end 语句结束符 修改语句结束符（改回来） # 查询 show procedure status [like \u0026#39;...\u0026#39;]; show create procedure 过程名; # 使用 call 过程名([实参列表]); # 删除 drop procedure 过程名; -- 示例 DELIMITER $$ CREATE PROCEDURE proc_countUser() BEGIN SELECT COUNT(*) FROM t_user; END $$ DELIMITER ; 存储过程的形参类型\r#\rIN：参数从外部传入，供过程内部使用。默认类型 OUT：参数从过程内部传出，供外部使用。 INOUT：参数从外部传入，过程内部使用后，又传出，供外部使用。 DELIMITER $$ CREATE PROCEDURE set_counter(INOUT count INT(4),IN inc INT(4)) BEGIN SET count = count + inc; END $$ DELIMITER ; 存储过程 vs 函数\r#\r区别 存储过程 函数 标识符 PROCEDURE FUNCTION 返回值 无 有 使用 不能在select语句中使用 可以在select语句中使用 "},{"id":139,"href":"/program-lang/java/thread/thread/thread-daemon/","title":"守护线程","section":"线程基础","content":"\r守护线程\r#\r概述\r#\r在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 守护线程的作用是为其他线程的运行提供便利服务 守护线程最典型的应用就是 GC (垃圾回收器) 创建守护线程\r#\r不能把正在运行的常规线程设置为守护线程，必须在线程启动前设置为守护线程，否则会抛异常。 在Daemon线程中产生的新线程也是Daemon的。 不要认为所有的应用都可以分配给Daemon来进行服务，比如读写操作或者计算逻辑。 Thread daemonTread = new Thread(); // 设定 daemonThread 为 守护线程，default false(非守护线程) daemonThread.setDaemon(true); // 验证当前线程是否为守护线程，返回 true 则为守护线程 daemonThread.isDaemon(); 为什么要用守护线程？\r#\r在JVM实例中，如果存在任何一个未结束的非守护线程，守护线程就全部工作 当非守护线程全部结束后，则JVM 进程即会退出，守护线程会随着JVM一同结束工作 守护线程拥有自动结束自己生命周期的特性，而非守护线程不具备这个特点 "},{"id":140,"href":"/program-lang/web/css/position/position/","title":"定位","section":"CSS 位置","content":"\r定位\r#\r属性\r属性说明\r属性值\r属性值说明\rposition\r定位\rstatic\r没有定位，默认值\rfixed\r绝对定位，相对于浏览器窗口，脱离标准流\rabsolute\r绝对定位，相对于父元素，脱离标准流\rrelative\r相对定位，相对于自身正常位置\rinherit\r继承\rz-index\r层级\rauto\r与父元素相等，默认\rnumber\r层级数值\rinherit\r继承\rtop\u0026nbsp;\nbottom\u0026nbsp;\nleft\u0026nbsp;\nright\r上下左右\rauto\r浏览器计算，默认\rsize\r数值\rinherit\r继承\r"},{"id":141,"href":"/database/mysql/mysql-tuning/engine-tuning/","title":"引擎优化","section":"性能调优","content":"\r引擎优化\r#\rInnoDB\r#\r禁用唯一性检查\n-- 唯一性校验会降低插入记录的速度， -- 可以在插入记录之前禁用唯一性检查，插入数据完成后再开启 -- 禁用唯一性检查 SET UNIQUE_CHECKS = 0; -- 开启唯一性检查 SET UNIQUE_CHECKS = 1; 禁用外键检查\n-- 插入数据之前执行禁止对外键的检查，数据插入完成后再恢复，可以提高插入速度。 -- 禁用外键检查 SET foreign_key_checks = 0; -- 开启外键检查 SET foreign_key_checks = 1; 禁止自动提交\n-- 插入数据之前执行禁止事务的自动提交，数据插入完成后再恢复，可以提高插入速度。 -- 禁用自动提交 SET autocommit = 0; -- 开启自动提交 SET autocommit = 1; MyISAM\r#\r禁用索引\n-- 插入大量数据，建立索引会降低插入数据速度。 -- 可以在批量插入数据之前禁用索引，数据插入完成后再开启 -- 禁用索引 ALTER TABLE table_name DISABLE KEYS -- 开启索引 ALTER TABLE table_name ENABLE KEYS 批量插入数据\n-- 一次性插入多条数据较快 -- 插入单条数据 insert into 表名 values(列值, ....); -- 插入多条数据 insert into 表名 values(列值, ....),(列值, ....),...; 禁用唯一性检查（同InnoDB）\n使用LOAD DATA INFILE\n当需要批量导入数据时，使用LOAD DATA INFILE语句比INSERT语句插入速度快很多。 "},{"id":142,"href":"/database/oracle/plsql/control-sentence/","title":"控制语句","section":"PL/SQL","content":"\r控制语句\r#\r分支语句\r#\rIF-THEN\r#\r-- 语法 IF condition THEN statements; END IF; -- 示例 DECLARE a NUMBER(2) := 10; BEGIN IF a \u0026lt; 20 THEN DBMS_OUTPUT.put_line(\u0026#39;a is less than 20 \u0026#39; ); END IF; END; IF-THEN-ELSE\r#\r-- 语法 IF condition THEN statements1; ELSE statements2; END IF; -- 示例 DECLARE a NUMBER(3) := 100; BEGIN IF a \u0026lt; 20 THEN DBMS_OUTPUT.put_line(\u0026#39;a is less than 20 \u0026#39; ); ELSE DBMS_OUTPUT.put_line(\u0026#39;a is not less than 20 \u0026#39; ); END IF; END; IF-THEN-ELSIF\r#\r-- 语法 IF condition1 THEN statements1; ELSIF condition2 THEN statements2; ELSE statements3; END IF; -- 示例 DECLARE a NUMBER(3) := 100; BEGIN IF a = 10 THEN DBMS_OUTPUT.put_line(\u0026#39;Value of a is 10\u0026#39; ); ELSIF a = 20 THEN DBMS_OUTPUT.put_line(\u0026#39;Value of a is 20\u0026#39; ); ELSIF a = 30 THEN DBMS_OUTPUT.put_line(\u0026#39;Value of a is 30\u0026#39; ); ELSE DBMS_OUTPUT.put_line(\u0026#39;None of the values is matching\u0026#39;); END IF; END; CASE（检测式）\r#\r-- 语法 CASE selector WHEN value1 THEN statements1; WHEN value2 THEN statements2; WHEN value3 THEN statements3; ... ELSE statementsN; -- default case END CASE; -- 示例 DECLARE grade char(1) := \u0026#39;A\u0026#39;; BEGIN CASE grade WHEN \u0026#39;A\u0026#39; THEN DBMS_OUTPUT.put_line(\u0026#39;Excellent\u0026#39;); WHEN \u0026#39;B\u0026#39; THEN DBMS_OUTPUT.put_line(\u0026#39;Very good\u0026#39;); WHEN \u0026#39;C\u0026#39; THEN DBMS_OUTPUT.put_line(\u0026#39;Well done\u0026#39;); WHEN \u0026#39;D\u0026#39; THEN DBMS_OUTPUT.put_line(\u0026#39;You passed\u0026#39;); WHEN \u0026#39;F\u0026#39; THEN DBMS_OUTPUT.put_line(\u0026#39;Better try again\u0026#39;); ELSE DBMS_OUTPUT.put_line(\u0026#39;No such grade\u0026#39;); END CASE; END; CASE（搜索式）\r#\r选择器隐式被设为 True -- 语法 CASE [True | False] WHEN condition1 THEN statements1; WHEN condition2 THEN statements2; WHEN condition3 THEN statements3; ... ELSE statementsN; -- default case END CASE; -- 示例 DECLARE grade char(1) := \u0026#39;B\u0026#39;; BEGIN CASE WHEN grade = \u0026#39;A\u0026#39; THEN DBMS_OUTPUT.put_line(\u0026#39;Excellent\u0026#39;); WHEN grade = \u0026#39;B\u0026#39; THEN DBMS_OUTPUT.put_line(\u0026#39;Very good\u0026#39;); WHEN grade = \u0026#39;C\u0026#39; THEN DBMS_OUTPUT.put_line(\u0026#39;Well done\u0026#39;); WHEN grade = \u0026#39;D\u0026#39; THEN DBMS_OUTPUT.put_line(\u0026#39;You passed\u0026#39;); WHEN grade = \u0026#39;F\u0026#39; THEN DBMS_OUTPUT.put_line(\u0026#39;Better try again\u0026#39;); ELSE DBMS_OUTPUT.put_line(\u0026#39;No such grade\u0026#39;); END CASE; END; 循环语句\r#\rLOOP\r#\rEXIT 、EXIT WHEN 强制退出循环 CONTINUE、CONTINUE WHEN 退出本次循环，进入下次循环 -- 语法 LOOP statements; END LOOP; -- 示例 DECLARE x NUMBER := 10; BEGIN LOOP DBMS_OUTPUT.put_line(x); x := x + 10; IF x \u0026gt; 50 THEN EXIT; -- EXIT WHEN x \u0026gt; 50; END IF; END LOOP; END; WHILE LOOP\r#\r-- 语法 WHILE condition LOOP statements; END LOOP; -- 示例 DECLARE a NUMBER(2) := 10; BEGIN WHILE a \u0026lt; 20 LOOP DBMS_OUTPUT.put_line(\u0026#39;value of a: \u0026#39; || a); a := a + 1; END LOOP; END; FOR LOOP\r#\r-- 语法 FOR counter IN begin_value .. final_value LOOP statements; END LOOP; -- 示例 DECLARE a NUMBER(2); BEGIN FOR a IN 10 .. 20 LOOP DBMS_OUTPUT.put_line(\u0026#39;value of a: \u0026#39; || a); END LOOP; END; 其他语句\r#\rGOTO\r#\r无条件跳转语句，配合标签使用 不建议使用 -- 示例 DECLARE a NUMBER(2) := 10; BEGIN \u0026lt;\u0026lt;loopstart\u0026gt;\u0026gt; WHILE a \u0026lt; 20 LOOP DBMS_OUTPUT.put_line (\u0026#39;value of a: \u0026#39; || a); a := a + 1; IF a = 15 THEN a := a + 1; GOTO loopstart; END IF; END LOOP; END; NULL\r#\r表示不做任何操作 "},{"id":143,"href":"/program-design/data-algorithm/sort/insertion/","title":"插入排序","section":"排序算法","content":"\r插入排序\r#\r算法步骤\r#\r将第一个元素看做一个有序序列，把其余元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。 类似扑克牌 动图演示\r#\r代码实现\r#\rpublic class InsertSort implements IArraySort { @Override public int[] sort(int[] arr) throws Exception { // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的 for (int i = 1; i \u0026lt; arr.length; i++) { // 记录要插入的数据 int tmp = arr[i]; // 从已经排序的序列最右边的开始比较，找到比其小的数 int j = i; while (j \u0026gt; 0 \u0026amp;\u0026amp; tmp \u0026lt; arr[j - 1]) { arr[j] = arr[j - 1]; j--; } // 存在比其小的数，插入 if (j != i) { arr[j] = tmp; } } return arr; } } "},{"id":144,"href":"/database/mysql/mysql-command/line/","title":"数据行管理","section":"基础命令","content":"\r数据行管理\r#\r插入\r#\r# 省略部分列名：列名与列值必须相对应 insert into 表名(列名, ...) values(列值, ...); # 省略全部列名：需提供表所有列的值 insert into 表名 values(列值, ....); -- 示例 INSERT INTO table_name ( field1,field2,...,fieldN )VALUES( value1,value2,...,valueN ); 删除\r#\rdelete from 表名 [where 条件]; -- 示例 DELETE FROM table_name WHERE field1 = value1; 修改\r#\rupdate 表名 set 列名=值, ... [where 条件]; -- 示例 UPDATE table_name a SET a.field1= value1, a.field2= value2, ... , a.fieldN= valueN WHERE field1 = value1; 查询\r#\rselect [*]/[列名，...] from 表名 [where 条件]; -- 示例 SELECT field1, field2, ..., fieldN FROM table_name WHERE field1 = value1; "},{"id":145,"href":"/program-design/data-structure/stack/","title":"栈","section":"数据结构","content":"\r栈\r#\r栈\r#\rStack 是一种特殊的线性表 限制仅允许在线性表的一端，进行插入和删除操作 特点\r#\r后进先出（Last In First Out，简称LIFO） 入栈出栈\r#\r"},{"id":146,"href":"/program-lang/java/grammar/process-control/","title":"流程控制","section":"基本语法","content":"\r流程控制\r#\rif\r#\r// 格式 if (布尔表达式){ // 如果true,执行... } else { // 如果false,执行... } //示例 int i = 30; if (i \u0026lt; 20) { System.out.print(\u0026#34;true\u0026#34;); } else { System.out.print(\u0026#34;false\u0026#34;); } for\r#\r// 格式 for (初始化; 布尔表达式; 步进) { // 循环内容 } // 增强 for 循环 for (变量类型 变量 : 数组或集合){ // 循环内容 } // 示例 for (int i = 0; i \u0026lt; 10; i++) { System.out.println(\u0026#34;value of i : \u0026#34; + i); } while\r#\r// 格式 while (布尔表达式) { // 循环内容 } // 示例 int i = 10; while (i \u0026lt; 20) { i++; System.out.println(\u0026#34;value of i : \u0026#34; + i); } do\u0026hellip;while\r#\r// 格式 do { // 循环内容 } while (布尔表达式); //示例 int i = 10; do { i++; System.out.println(\u0026#34;value of i : \u0026#34; + i); } while (i \u0026lt; 20); switch\r#\r支持的判断类型\nbyte、short、int 、char，JDK1.7 增加 String 可以有多个 case 语句\n先执行 case 语句，无匹配才执行 default 语句\n只有遇到 break，才会跳出 switch 语句，否则会继续执行下去\n// 格式 switch(expression){ case value : // 语句 break; case value : // 语句 break; ... default : // 语句 } // 示例 int i = 5; switch (i) { case 0: System.out.println(\u0026#34;0\u0026#34;); break; case 1: System.out.println(\u0026#34;1\u0026#34;); break; case 2: System.out.println(\u0026#34;2\u0026#34;); break; default: System.out.println(\u0026#34;default\u0026#34;); } break \u0026amp; continue\r#\rbreak：跳出循环体 continue ：跳出本次循环，进入下次循环 "},{"id":147,"href":"/program-base/linux/cmd/sys/","title":"系统管理","section":"常用命令","content":"\r系统管理\r#\rtop / htop - 显示当前运行的进程\nfree - 显示内存和交换区的使用情况\ndf - 报告文件系统磁盘空间使用情况\ndu - 估计文件空间使用量\nps - 报告当前进程状态\nkill - 发送信号到进程\nifconfig / ip - 网络接口配置\nping - 检测主机是否在网络中\nnetstat - 显示网络状态信息\n"},{"id":148,"href":"/program-lang/java/thread/threadpool/threadpool-operate/","title":"线程池 - 操作","section":"线程池","content":"\r线程池操作\r#\rExecutorService\r#\r方法 描述 execute() 向线程池提交新任务，无返回值 submit() 向线程池提交新任务，返回 Future shutdown() 1、停止接收新任务2、线程池中，已经提交的任务会继续执行，执行完毕后关闭线程池 shutdownNow() 1、停止接收新任务2、试图关闭正在执行的任务3、移除线程池队列中等待执行的任务 isShutdown() 线程池是否关闭 isTerminated() 判断线程池关闭后所有的任务是否都执行完了仅当 shutdown()/shutdownNow() 被调用后才有效 awaitTermination() 阻塞，直到以下情况出现：1、超时；2、当前线程中断；3、所有任务已经执行完成 创建线程池\r#\r使用 ThreaPoolExecutor 构造函数，创建线程池，参数自定义\npublic class MyRunnable implements Runnable { @Override public void run() { System.out.println(Thread.currentThread().getName() + \u0026#34; is running...\u0026#34;); } } public class Test { public static void main(String[] args) throws Exception { ExecutorService threadPool = new ThreadPoolExecutor( 2, 5, 1L, TimeUnit.SECONDS, new LinkedBlockingDeque\u0026lt;\u0026gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy() ); MyRunnable myRunnable = new MyRunnable(); try { for (int i = 0; i \u0026lt; 10; i++) { threadPool.execute(myRunnable); } } catch (Exception ex) { System.out.println(ex.getMessage()); } finally { threadPool.shutdown(); } } } 关闭线程池\r#\r首先任务要能够响应中断 关闭流程： 调用shutdown() ： 禁止提交新的任务 调用awaitTermination() ：等待任务执行完成 调用shutdownNow() ：强制关闭那些执行任务过长（可能无法正常停止）的任务 配置线程数量\r#\r最佳线程数量 = （线程等待时间 / 线程CPU时间 + 1）* CPU核心\n比如平均每个线程CPU运行时间为0.5s，而线程等待时间（非CPU运行时间，比如IO）为1.5s， CPU核心数为8，那么根据上面这个公式估算得到：(1.5/0.5+1)*8=32 "},{"id":149,"href":"/program-lang/java/oop/Inheritance/","title":"继承","section":"面向对象","content":"\r继承\r#\r继承\r#\r指继承父类的状态和行为，创建子类的过程。 不支持多继承。 特性\r#\r子类拥有父类非 private 的属性、方法 子类可以对父类进行扩展 子类可以重写父类方法 支持单继承、多重继承 提高类之间的耦合性 格式\r#\rclass 父类 { //... } class 子类 extends 父类 { //... } this \u0026amp; super\r#\rthis 指向自己的引用 this() 调用自己的构造方法 super 指向父类的引用 super() 调用父类的构造方法 class Animal { public void eat() { System.out.println(\u0026#34;animal : eat\u0026#34;); } } class Dog extends Animal { public void eat() { System.out.println(\u0026#34;dog : eat\u0026#34;); } public void eatTest() { this.eat(); // this 调用自己的方法 super.eat(); // super 调用父类方法 } } extends \u0026amp; implements\r#\rpublic class Animal { private String name; public Animal(String myName) { this.name=myName; } public void eat() { //... } } public class Dog extends Animal{ //... } public interface A { public void eat(); } public interface B { public void sleep(); } public class C implements A,B { //.... } "},{"id":150,"href":"/program-design/design-pattern/behavioural/","title":"行为型","section":"设计模式","content":" 常用 不常用 行为型 状态、策略、模板迭代器、观察者、职责链 命令、中介解释器、访问者、备忘录 "},{"id":151,"href":"/program-design/design-pattern/","title":"设计模式","section":"程序设计","content":" 设计原则 描述 重要性 开闭原则 对扩展开放，对修改封闭 ★★★★★ 依赖倒转 面向接口编程，依赖于抽象而不依赖于具体。 ★★★★★ 单一职责 一个类的职责要单一，不能将太多的职责放到一个类中 ★★★★☆ 里式替换 一个可以接受父类对象的地方，必然可以接受其子类对象 ★★★★☆ 合成复用 尽量使用组合而不是继承，来达到软件复用的目的 ★★★★☆ 迪米特法则 一个类对自己依赖的类知道的越少越好 ★★★☆☆ 接口隔离 使用多个专门的接口来取代一个统一的接口 ★★☆☆☆ 类型 设计模式 数量 创造型 单例、工厂、原型、建造者 5 结构型 代理、桥接、外观、组合、享元、适配器、装饰器 7 行为型 状态、策略、模板、命令、迭代器、解释器、观察者、访问者、中介者、备忘录、职责链 11 "},{"id":152,"href":"/program-lang/java/thread/container/CopyOnWriteArrayList/","title":"CopyOnWriteArrayList","section":"并发容器","content":"\rCopyOnWriteArrayList\r#\r设计思想\r#\rCopy-On-Write（COW），是一种读写分离的思想 写线程写入数据的时候，会复制新建一个新容器。当数据更新完成后，再将旧容器引用指向新容器。 读线程感知数据更新是延时的，牺牲了数据实时性而保证数据最终一致性。 由于写线程写数据是在新容器写入的，因此读线程不会被阻塞。 应用场景\r#\r适用于读多写少的场景，比如系统的黑名单白名单设置 代码实现\r#\rarray private transient volatile Object[] array; get public E get(int index) { return get(getArray(), index); } final Object[] getArray() { return array; } private E get(Object[] a, int index) { return (E) a[index]; } add public boolean add(E e) { final ReentrantLock lock = this.lock; //1. 使用Lock,保证写线程在同一时刻只有一个 lock.lock(); try { //2. 获取旧数组引用 Object[] elements = getArray(); int len = elements.length; //3. 创建新的数组，并将旧数组的数据复制到新数组中 Object[] newElements = Arrays.copyOf(elements, len + 1); //4. 往新数组中添加新的数据 newElements[len] = e; //5. 将旧数组引用指向新的数组 setArray(newElements); return true; } finally { lock.unlock(); } } COW 缺点\r#\r内存占用问题：由于在写数据时，会复制数组，因此可能会出现内存使用瞬时增加，导致频繁的 GC 数据一致性问题：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性 COW \u0026amp; 读写锁\r#\r相同点： 两者都采用了读写分离的思想，并且读线程间是互不阻塞的 不同点： 当写线程在写数据时，COW采用延时更新策略不会阻塞读线程，而ReentrantReadWriteLock会阻塞读线程 COW保证数据的最终一致性，而ReentrantReadWriteLock保证数据的实时性 "},{"id":153,"href":"/program-lang/web/css/selector/","title":"CSS 选择器","section":"CSS","content":"\rCSS 选择器\r#\r选择器大全\r#\rCSS 选择器 简单选择器\r#\r选择器 示例 示例说明 * * 选择所有元素 #id #firstname 选择所有id=\u0026ldquo;firstname\u0026quot;的元素 .class .intro 选择所有class=\u0026ldquo;intro\u0026quot;的元素 标签选择器\r#\r选择器 示例 示例说明 element p 选择所有 \u0026lt;p\u0026gt; 元素 element,element div,p 选择所有 \u0026lt;div\u0026gt; 元素和 \u0026lt;p\u0026gt; 元素 element element div p 选择 \u0026lt;div\u0026gt; 元素内的所有 \u0026lt;p\u0026gt; 元素 element\u0026gt;element div\u0026gt;p 选择所有父级是 \u0026lt;div\u0026gt; 元素的 \u0026lt;p\u0026gt; 元素 element+element div+p 选择所有紧跟在 \u0026lt;div\u0026gt; 元素之后的第一个 \u0026lt;p\u0026gt; 元素 element~element div~p 选择 \u0026lt;div\u0026gt; 元素之后的每一个 \u0026lt;p\u0026gt; 元素 属性选择器\r#\r选择器 示例 示例说明 [attribute] [target] 选择带有 target 属性的所有元素 [attribute=value] [target=-blank] 选择使用 target=\u0026quot;-blank\u0026rdquo; 的所有元素 [attribute~=value] [title~=flower] 选择标题属性包含单词 \u0026ldquo;flower\u0026rdquo; 的所有元素 [attribute|=value] [lang|=en] 选择 lang 属性等于 en，或者以 en- 为开头的所有元素 [attribute^=value] a[src^=\u0026ldquo;https\u0026rdquo;] 选择每一个 src 属性的值以 \u0026ldquo;https\u0026rdquo; 开头的 \u0026lt;a\u0026gt; 元素 [attribute$=value] a[src$=\u0026quot;.pdf\u0026rdquo;] 选择每一个 src 属性的值以 \u0026ldquo;.pdf\u0026rdquo; 结尾的 \u0026lt;a\u0026gt; 元素 [attribute*=value] a[src*=\u0026ldquo;abc\u0026rdquo;] 选择每一个 src 属性的值包含子字符串 \u0026ldquo;abc\u0026rdquo; 的 \u0026lt;a\u0026gt; 元素 伪元素选择器\r#\r伪类 说明 :link 未被访问的链接 :visited 已被访问的链接 :hover 鼠标悬浮于上方的元素 :active 被激活的元素 :focus 拥有键盘输入焦点的元素 :first-child 元素的第一个子元素 :lang 带有 lang 属性的元素 :first-letter 文本的第一个字母 :first-line 文本的首行 :before 元素之前 :after 元素之后 \u0026hellip;\u0026hellip; 优先级\r#\r不同样式表 行内样式\u0026gt;内部样式\u0026gt;外部样式 同一样式表 权值相同：就近原则 权值不同：根据权重 选择器 权重值 !important 最高，示例：div{color:red !important} 行内样式 1000 ID选择器 100 类选择器、伪类 10 标签选择器 1 通配符选择器 0 "},{"id":154,"href":"/program-lang/java/thread/tool/Exchanger/","title":"Exchanger","section":"并发工具","content":"\rExchanger\r#\r功能\r#\r交换器 是一个用于线程间协作的工具类，用于两个线程间交换数据。 原理\r#\rExchanger提供了一个交换的同步点，在这个同步点两个线程能够交换数据。 如果一个线程先执行exchange()，那它会阻塞等待另一个线程也执行 exchange()。 当两个线程就都达到了同步点，它们就可以交换数据。 方法\r#\r// 构造方法 public Exchanger() // 交换 public V exchange(V x) // 交换（超时限制） public V exchange(V x, long timeout, TimeUnit unit) 示例\r#\rpublic class Test { public static void main(String[] args) { Exchanger\u0026lt;String\u0026gt; exchanger = new Exchanger\u0026lt;\u0026gt;(); new Thread(() -\u0026gt; { try { String out=\u0026#34;20块钱\u0026#34;; String in = exchanger.exchange(out); System.out.println(\u0026#34;张三：付出了\u0026#34;+out+\u0026#34;，获得了\u0026#34;+in); } catch (InterruptedException e) { e.printStackTrace(); } }).start(); new Thread(() -\u0026gt; { try { String out=\u0026#34;一条鲤鱼\u0026#34;; String in = exchanger.exchange(out); System.out.println(\u0026#34;李四：付出了\u0026#34;+out+\u0026#34;，获得了\u0026#34;+in); } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } } // 李四：付出了一条鲤鱼，获得了20块钱 // 张三：付出了20块钱，获得了一条鲤鱼 "},{"id":155,"href":"/program-lang/java/thread/theory/final/","title":"final","section":"并发理论","content":"\rfinal\r#\r概述\r#\rfinal，即最终、不可变 可以用来修饰类、方法和变量 用法\r#\r修饰类\nfinal 修饰的类，不能被继承 final 类中的方法，都会被隐式地指定为 final 方法 ​\n修饰方法\nfinal 修饰的方法，不能被重写，但可以被重载 private 修饰的方法，都会隐式地指定为 final 方法 ​\n修饰变量\nfinal 修饰的变量，在初始化后，不能被修改 final 变量，如果是引用类型，引用不能再指向其他对象，但对象内容是可以修改的 重排序规则\r#\r编译器和处理器要遵守两个重排序规则：\n在构造函数内对 final 域的写入，与随后把此被构造对象的引用赋值给一个变量，这两个操作之间不能重排序 初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序 通俗理解就是：\n对象构造函数内有final域，必须先用构造函数构造对象，再把对象赋给其他引用 如果对象有final域，必须先读对象的引用，再读final域 "},{"id":156,"href":"/dev-tool/git/operate/","title":"Git 使用","section":"Git","content":"\rGit 使用\r#\rGitHub\r#\r免密提交\r#\r生成 SSH Key 文件\n$ ssh-keygen -t rsa -C \u0026#34;youremail@example.com\u0026#34; 打开 ~/.ssh/id_rsa.pub，复制里面的 key\n回到 github 上，进入Settings，选择 SSH and GPG keys，点击 New SSH key，设置标题，粘贴 key\n验证\n$ ssh -T git@github.com Hi origin! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. TortoiseGit\r#\r与 GitHub 共用密码\r#\r现象：TortoiseGit 不能共用ssh-keygen产生的密钥\n原因：TortoiseGit 使用扩展名为ppk的密钥，而不是ssh-keygen生成的rsa密钥\n方式一：安装 TortoiseGit 安装过程中，选择使用OpenSSH方式\n方式二：设置 TortoiseGit 网络的ssh客户端位置为 Git\\usr\\bin\\ssh.exe 实际问题\r#\rCHERRY_PICK_HEAD exists\r#\r错误日志\n解决方法\n$ git cherry-pick --abort 删除敏感提交记录\r#\r# 回退：前i次的版本，--soft代表只删除服务器记录，不删除本地 git reset --soft HEAD~i # 强制推送，master代表当前分支 git push origin master --force # 再把本地的文件提交一次就行了 "},{"id":157,"href":"/service-manage/deprecated-frame/hystrix/","title":"Hystrix","section":"日落组件","content":"\rHystrix\r#\rHystrix\r#\r服务降级 是一个用于处理分布式系统的延迟和容错的开源库 能保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性 工作原理\r#\r当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝）， 向调用方返回一个符合预期的、可处理的备选响应，而不是长时间的等待或者抛出调用方无法处理的异常， 这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中蔓延乃至雪崩。 扇入、扇出\r#\r扇入：表示一个模块被多个模块调用 扇出：表示一个模块调用多个模块。 雪崩效应\r#\r分布式系统环境下，应用程序有众多依赖关系。某些情况下，许多依赖不可避免的会调用失败。 如果扇出链路上某个微服务不可用，对其的调用就会占用越来越多的系统资源，进而引起系统崩溃。 这种因“服务提供者的不可用”导致“服务调用者不可用”，并将不可用逐渐放大的现象，即“雪崩效应”。 服务熔断\r#\r当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用 服务降级\r#\r从整个系统的负荷情况考虑，对某些负荷会比较高的某些功能（业务场景），当其熔断后将不再被调用。 此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。达到虽服务水平下降但还可用的目的。 服务降级处理是在客户端实现完成的，与服务端没有关系 "},{"id":158,"href":"/program-lang/java/library/java.util.stream/","title":"java.util.stream","section":"基础类库","content":"\rJava8 流\r#\rStream\r#\r是一个来自数据源的元素队列，并支持聚合操作 元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。 数据源流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。 聚合操作类似 SQL 语句一样的操作， 比如 filter, map, reduce, find, match, sorted 等 基础特征 管道：中间操作都会返回流对象本身 内部迭代：通过访问者模式实现 创建流\r#\rString[] array = {\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}; Path pathObj = Paths.get(\u0026#34;filePath\u0026#34;); Collection\u0026lt;String\u0026gt; collection = Lists.newArrayList(); SecureRandom random = SecureRandom.getInstanceStrong(); // 序列 Stream.of(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); // 数组 Arrays.stream(array); // 集合 collection.stream(); // 文件 Files.lines(pathObj); Files.list(pathObj); // 函数 Stream.iterate(0, n -\u0026gt; n + 3).limit(10); Stream.generate(random::nextInt).limit(10); Stream.generate(() -\u0026gt; (int) (System.nanoTime() % 100)).limit(10); 中间操作\r#\rStream\u0026lt;User\u0026gt; stream = Stream.of(new User()); // 排序（反序） stream.sorted(); stream.sorted(Comparator.comparing(User::getAge).reversed()); // 筛选 stream.filter(User::isMale); // 去重 stream.distinct(); // 截断 stream.limit(10); // 跳过 stream.skip(10); // 映射 stream.map(User::getName); // 流扁平化 stream.map(User::getName).map(s -\u0026gt; s.split(\u0026#34;\u0026#34;)).flatMap(Arrays::stream); 终端操作\r#\rStream\u0026lt;Integer\u0026gt; stream = Stream.of(1, 2, 3, 4, 5); // 匹配 stream.anyMatch(n -\u0026gt; n == 5); // 是否有一个元素匹配 stream.allMatch(n -\u0026gt; n == 5); // 是否全部元素都匹配 stream.noneMatch(n -\u0026gt; n == 5); // 是否全部元素都不匹配 // 查找 stream.findAny(); // 查找任意元素 stream.findFirst(); // 查找第一个元素 // 归约 stream.reduce(Integer::sum); // 求和 stream.reduce(Integer::min); // 最小值 stream.reduce(Integer::max); // 最大值 stream.reduce(1, (n1, n2) -\u0026gt; n1 * n2); // 从1开始，连乘元素 // 统计格式 stream.count(); // 遍历 stream.forEach(System.out::println); // 收集 stream.collect(Collectors.toList()); // List\u0026lt;T\u0026gt; stream.collect(Collectors.toSet()); // Set\u0026lt;T\u0026gt; stream.collect(Collectors.toMap(String::valueOf, n -\u0026gt; \u0026#34;\u0026#34;)); // Map\u0026lt;String,String\u0026gt; stream.collect(Collectors.groupingBy(String::valueOf)); // Map\u0026lt;String,List\u0026lt;T\u0026gt;\u0026gt;，分组 数值流\r#\rIntStream stream; Stream\u0026lt;User\u0026gt; objStream = Stream.of(new User()); // 由数值范围创建 stream = IntStream.range(1, 100); // 不包含结束值100 stream = IntStream.rangeClosed(1, 100); // 包含结束值100 // 由对象流映射 stream = objStream.mapToInt(User::getAge); // 聚合函数 stream.sum(); stream.min(); stream.max(); stream.count(); // 转换回对象流 stream.boxed(); "},{"id":159,"href":"/program-lang/java/container/Map/LinkedHashMap/","title":"LinkedHashMap","section":"Map","content":"\rLinkedHashMap\r#\r概述\r#\rLinkedHashMap 是 HashMap 的子类，可以认为是等同于 HashMap+LinkedList，哈希表+双向链表 特点\r#\r键 允许为null（放在第一位），不允许重复 值 允许为null，允许重复 顺序 有序 多线程 线程不安全 继承关系\r#\rpublic class LinkedHashMap\u0026lt;K,V\u0026gt; extends HashMap\u0026lt;K,V\u0026gt; implements Map\u0026lt;K,V\u0026gt; 成员变量\r#\r// 控制访问顺序：false：基于插入顺序；true：基于访问顺序 final boolean accessOrder; // 其他变量从HashMap中继承 构造方法\r#\r// 默认 public LinkedHashMap() { super(); accessOrder = false; } // 指定初始容量 public LinkedHashMap(int initialCapacity) { super(initialCapacity); accessOrder = false; } // 指定初始容量、负载因子 public LinkedHashMap(int initialCapacity, float loadFactor) { super(initialCapacity, loadFactor); accessOrder = false; } // 指定初始容量、负载因子、accessOrder public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) { super(initialCapacity, loadFactor); this.accessOrder = accessOrder; } // 指定集合，转化为LinkedHashMap public LinkedHashMap(Map\u0026lt;? extends K, ? extends V\u0026gt; m) { super(); accessOrder = false; //... } 底层数据结构\r#\r"},{"id":160,"href":"/database/oracle/","title":"Oracle","section":"数据存储","content":"\rOracle\r#\rOracle Database，是一个适合于大中型企业的关系数据库管理系统。 是美国 Oracle 公司的核心产品，其服务是收费的。 物理结构\r#\r文件 作用 后缀 数据文件 存放数据库数据，若干个数据文件组成表空间 .dbf 控制文件 存放数据库的物理结构信息 .ctl 重做日志文件 记录数据库所有修改信息的文件 .log 归档日志文件 对写满的重做日志文件进行保存复制 .log 参数文件 记录Oracle数据库的基本参数信息 告警文件 记录数据库启动后，用户操作上的或数据库本身的问题 逻辑结构\r#\r逻辑结构 说明 块 Block 最小的逻辑存储单元 ，所有数据的存取都是以块为单位进行的 区 Extent 是一组连续的块构成的存储结构，是Oracle存储分配的最小单位 段 Segment 是为特定的数据对象（如表、索引、回滚等）分配的一系列数据区 表空间 Tablespace 是数据库的最大逻辑划分区域，由若干个数据文件组成。所有数据对象都存储在表空间上 块 Block： 1、块头：包含了该数据块一般的属性信息，如数据块的物理地址、所属段类型等 2、表目录：如果数据块中存储的数据是某个表的数据，则这里存放该表的信息 3、行目录：用来存储数据块中有效的行信息 4、空余空间：指数据块还没有使用的存储空间 5、行空间：表或者索引的数据存储在行空间中，所以行空间是数据块中已经使用的存储空间 段 Segment： 1、数据段：用来存储表中所有数据； 2、索引段：用来存储表中索引的所有数据； 3、临时段：用于存储表排序或汇总时产生的临时数据 4、LOB段：LOB 用来存储表中大型数据对象，例如 CLOB 与 BLOB 5、回退段：用于存储用户数据被修改之前的位置和值； 当要对用户的数据进行回退操作时，就要使用回退段。 直观图 "},{"id":161,"href":"/program-lang/java/container/Queue/","title":"Queue","section":"集合容器","content":"\r"},{"id":162,"href":"/program-lang/java/thread/lock/ReentrantReadWriteLock/","title":"ReentrantReadWrite...","section":"锁体系","content":"\rReentrantReadWriteLock\r#\r"},{"id":163,"href":"/program-base/network/rpc/","title":"RPC","section":"网络","content":"\rRPC\r#\rRemote Procedure Call，远程过程调用 是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议 RPC 使得程序能够像访问本地系统资源一样，去访问远端系统资源 主流 RPC 框架：Dubbo/Dubbox、Google gRPC、Spring Boot/Spring Cloud RPC 组件\r#\r客户端(Client)\t服务调用者 客户端存根(Client Stub)\t存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端 服务端存根(Server Stub)\t接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理 服务端(Server)\t服务提供者 RPC 原理\r#\rRPC 架构\r#\r"},{"id":164,"href":"/service-manage/springcloud/","title":"Spring Cloud","section":"服务治理","content":"\rSpring Cloud\r#\r分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务全家桶 中文参考文档 推荐：Nacos、LoadBalancer、OpenFeign、sentienl、gateway 停更：Eureka、Feign、Hystrix、Zuul、Config、Bus Spring Cloud \u0026amp; Spring Boot\r#\rSpringBoot 专注于快速、方便的开发单个微服务个体 SpringCloud 是关注全局的微服务协调治理框架，它将 SpringBoot 开发的一个个单体微服务整合并管理起来。 SpringBoot 可以离开 SpringCloud 独立使用开发项目，但是 SpringCloud 离不开 SpringBoot，属于依赖的关系。 "},{"id":165,"href":"/database/mysql/mysql-tuning/sql-tuning/","title":"SQL优化","section":"性能调优","content":"\rSQL优化\r#\r避免使用双引号，用单引号代替 避免使用 *，用具体列名代替 避免使用 in，用 exist 代替 尽量使用UNION ALL代替UNION 尽量使用预编译：性能更好、防止SQL注入 尽量少做重复的工作 尽量避免耗时操作：DISTINCT、UNION、MINUS、INTERSECT、ORDER BY 尽量避免使用游标 尽量避免使用临时表 尽量避免大事务操作 尽量避免向客户端返回大数据量 分析 sql 语句：分析慢查询日志 利用分析工具：Explain、Profile "},{"id":166,"href":"/program-design/design-pattern/creational/04-prototype/","title":"原型模式","section":"创建型","content":"\r原型模式\r#\r概述\r#\r英文：Prototype Pattern 简述：通过拷贝原型创建新的对象 归纳：拔一根猴毛，吹出千万个 目的：高效创建对象 案例：克隆 示例\r#\r// 原型类：实现Cloneable接口 public class Prototype implements Cloneable { private String name; // setter、getter... // clone方法 public Object clone(){ try { return super.clone(); } catch (Exception e) { e.printStackTrace(); return null; } } } public class Test { public static void main(String[] args) { Prototype pro1=new Prototype(); pro1.setName(\u0026#34;张三\u0026#34;); //以pro1为原型，克隆得到pro2 Prototype pro2=(Prototype)pro1.clone(); System.out.println(pro1.getName()); System.out.println(pro2.getName()); } } 应用\r#\r主要解决: 在运行期建立和删除原型 应用场景： 细胞分裂。 JAVA 中的 Object clone() 方法。 注意事项： 克隆过程中，不会执行被克隆类的构造方法 浅拷贝：Object类的clone()只拷贝类方法、类成员（基本数据类型+String类型） 深拷贝：对引用数据类型的类成员也进行拷贝 "},{"id":167,"href":"/program-lang/java/jvm/gc/collector/","title":"垃圾收集器","section":"垃圾回收","content":"\r垃圾收集器\r#\r回收方式\r#\r串行（Serial）、并行（Parallel）、并发（Concurrent）、STW 七大收集器\r#\r收集器：Serial 、Serial Old\r#\r单个垃圾收集线程串行工作，会暂停所有用户线程，不适合服务器环境 Serial：新生代，复制算法 Serial Old：老年代，标记 - 整理算法 收集器：ParNew\r#\rSerial 收集器的多线程（即并行）版本 ParNew：新生代，复制算法 收集器：Parallel Scavenge / Old\r#\r多个垃圾收集线程并行工作，会暂停所有用户线程，适合科学算/大数据处理等弱交互场景 Parallel Scavenge：新生代，复制算法，可控制吞吐量 Parallel Old：老年代，标记 - 整理算法 收集器：CMS\r#\r概述\r#\r用户线程和垃圾收集线程并发执行，互联网公司多用它，适用对响应时间有要求的场景 Concurrent Mark Sweep：老年代，标记 - 清除算法 优缺点\r#\r并发收集低停顿，但对CPU资源压力大，且会产生大量碎片 步骤\r#\r初始标记（CMS initial mark） 并发标记（CMS concurrent mark） 重新标记（CMS remark） 并发清除（CMS concurrent sweep） 收集器：G1\r#\r概述\r#\r将堆内存分割成不同的区域然后并发的对其进行垃圾回收 面向服务端应用，适用于多处理器和大容量内存环境 G1：整体上采用标记-整理算法，局部是采用复制算法 步骤\r#\r初始标记（Initial Marking） 并发标记（Concurrent Marking） 最终标记（Final Marking） 筛选回收（Live Data Counting and Evacuation） 原理\r#\rGarbage First\n通过把Java堆分成大小相等的多个独立区域 回收时计算出每个区域回收所获得的空间以及所需时间的经验值， 根据记录两个值来判断哪个区域最具有回收价值，所以叫Garbage First（垃圾优先） G1 堆空间划分\n在G1算法中，堆内存被划分为多个大小相等的区域（Region），每个 Region 都可能是 Eden区， Survivor区或者 Old 区。所有的 Eden 区和 Survivor 区合起来就是新生代，所有的 Old 区合起来就是老年代。 特点\r#\r特点 说明 并行且并发 G1 回收过程中，可以有多个Gc线程同时工作，也不会完全阻塞工作线程 分代收集 G1 依旧区分 Eden、Survivor、老年代 空间整合 G1 整体上采用标记-整理算法，局部是采用复制算法，不会产生内存空间碎片 可预测的停顿 G1 能让用户明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。 G1 相关参数\r#\r参数 说明 -XX:+UseG1GC 开启 G1 -XX:G1HeapRegionSize=n 设置Region大小，值是2的幂，范围是1MB到32MB -XX:MaxGCPauseMillis=n 设置最大GC停顿时间，JVM会尽可能让停顿小于这个时间 G1 与 CMS 对比\r#\rG1 基于标记-整理算法，不产生内存碎片 G1 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收 "},{"id":168,"href":"/database/mysql/mysql-command/composite-query/","title":"复合查询","section":"基础命令","content":"\r复合查询\r#\r条件查询\r#\rselect [distinct去重] 字段列表 from数据源 where条件 group by分组 having条件 order by排序 limit分页; where having 原理 一条条从磁盘读取数据，判断条件，放入内存 将所有数据读入内存，在内存内部，逐条判断 使用别名 不能 可以 使用聚合函数 不能 可以 联合查询\r#\r将多个子查询的结果，组合到一个结果集合中。（子查询所查询的列数量须相同） -- 格式 SELECT expression1, expression2, ... expression_n FROM tables [WHERE conditions] UNION [ALL | DISTINCT] SELECT expression1, expression2, ... expression_n FROM tables [WHERE conditions]; -- 示例 SELECT country, name FROM Websites WHERE country=\u0026#39;CN\u0026#39; UNION ALL SELECT country, app_name FROM apps WHERE country=\u0026#39;CN\u0026#39; ORDER BY country; 连接查询\r#\r内连接：INNER JOIN，获取两个表中，符合字段匹配关系的记录 左连接：LEFT JOIN，获取左表所有记录，即使右表没有对应匹配的记录 右连接：RIGHT JOIN，获取右表所有记录，即使左表没有对应匹配的记录 -- 示例 SELECT a.id, a.author, b.book FROM a_tb a INNER JOIN b_tb b ON a.author = b.author; 子查询\r#\r指在一条select语句中，嵌入了另外一条select语句，那么被嵌入的select语句称之为子查询语句。 关键字：IN、ANY、SOME、ALL -- 子查询返回单一值 SELECT * FROM article WHERE user_id = ( SELECT user_id FROM user WHERE user_name=\u0026#39;Jack\u0026#39; LIMIT 1 ); -- 子查询返回列 SELECT * FROM article WHERE user_id IN( SELECT user_id FROM user WHERE status=1 ); -- 子查询返回行 SELECT * FROM article WHERE (title,content,uid) = ( SELECT title,content,uid FROM blog WHERE bid=2 ); -- 子查询返回表 SELECT * FROM article WHERE (title,content,uid) IN ( SELECT title,content,uid FROM blog ); -- 子查询返回值列表 SELECT * FROM table1 WHERE city=\u0026#39;hangzhou\u0026#39; and exists( select * from table2 where table1.customer_id=table2.customer_id ); "},{"id":169,"href":"/program-lang/java/oop/polymorphism/","title":"多态","section":"面向对象","content":"\r多态\r#\r概念\r#\r多态：指允许不同子类对象对同一消息作出不同的响应 前提：继承、重写、父类引用指向子类对象 示例\r#\rabstract class Animal { public abstract void run(); } class Cat extends Animal { public void run() { System.out.println(\u0026#34;猫跑了......\u0026#34;); } } class Dog extends Animal { public void run() { System.out.println(\u0026#34;狗跑了......\u0026#34;); } } class Lady { private Animal pet; Lady(Animal pet) { this.pet = pet; } public void myPetRun(){ pet.run(); } } public class Test { public static void main(String args[]){ Cat c = new Cat(); Dog d = new Dog(); Lady l1 = new Lady(c); Lady l2 = new Lady(d); l1.myPetRun(); l2.myPetRun(); } } // 测试结果 猫跑了...... 狗跑了...... "},{"id":170,"href":"/program-lang/java/thread/threadpool/ScheduledThreadPoolExecutor/","title":"定时线程池","section":"线程池","content":"\rScheduledThreadPoolExecutor\r#\r"},{"id":171,"href":"/database/oracle/plsql/exception/","title":"异常处理","section":"PL/SQL","content":"\r异常处理\r#\r处理异常\r#\r-- 语法 DECLARE \u0026lt;declarations section\u0026gt; BEGIN \u0026lt;executable command(s)\u0026gt; EXCEPTION \u0026lt;exception handling goes here \u0026gt; WHEN exception1 THEN exception1-handling-statements WHEN exception2 THEN exception2-handling-statements WHEN exception3 THEN exception3-handling-statements ........ WHEN others THEN exception3-handling-statements END; -- 示例 DECLARE c_id customers.id%type := \u0026amp;cc_id; c_name customers.name%type; c_addr customers.address%type; -- 声明自定义异常 ex_invalid_id EXCEPTION; BEGIN IF c_id \u0026lt;= 0 THEN -- 触发自定义异常 RAISE ex_invalid_id; ELSE SELECT name, address INTO c_name, c_addr FROM customers WHERE id = c_id; DBMS_OUTPUT.put_line (\u0026#39;姓名: \u0026#39;|| c_name); DBMS_OUTPUT.put_line (\u0026#39;地址: \u0026#39;|| c_addr); END IF; -- 处理异常 EXCEPTION WHEN ex_invalid_id THEN DBMS_OUTPUT.put_line(\u0026#39;编号ID必须要大于0!\u0026#39;); WHEN no_data_found THEN DBMS_OUTPUT.put_line(\u0026#39;未找到指定ID的客户信息!\u0026#39;); WHEN others THEN DBMS_OUTPUT.put_line(\u0026#39;Error!\u0026#39;); END; 自定义异常\r#\r用户自己定义的异常 需使用 RAISE 语句显式的抛出异常 预定义异常\r#\r系统定义的异常 当程序违反特定数据库规则时自动触发 异常 Oracle错误号 描述 DUP_VAL_ON_INDEX ORA-00001 违反唯一约束条件 INVALID_CURSOR ORA-01001 无效的游标 NOT_LOGGED_ON ORA-01012 没有登录 LOGIN_DENIED ORA-01017 用户名/口令无效; 登录被拒绝 NO_DATA_FOUND ORA-01403 未找到任何数据 TOO_MANY_ROWS ORA-01422 实际返回行数超过请求行数 ZERO_DIVIDE ORA-01476 除数为 0 INVALID_NUMBER ORA-01722 无效数字 STORAGE_ERROR ORA-06500 内存溢出 PROGRAM_ERROR ORA-06501 PL/SQL: 内部错误 VALUE_ERROR ORA-06502 PL/SQL: 数字或值错误 ROWTYPE_MISMATCH ORA-06504 PL/SQL：返回结果集变量的类型错误 ACCESS_INTO_NULL ORA-06530 引用未初始化的组合 COLLECTION_IS_NULL ORA-06531 未初始化集合错误的引用 CASE_NOT_FOUND ORA-06592 当执行CASE语句时,没有发现CASE SELF_IS_NULL ORA-30625 不允许空自参数上的方法调度 raise_application_error\r#\r抛出自定义的错误信息：raise_application_error(code错误码, \u0026lsquo;错误信息\u0026rsquo;) -- 示例 DECLARE v_sal emp.sal%type; v_sal_error EXCEPTION; BEGIN SELECT sal INTO v_sal FROM emp WHERE empno = \u0026amp;empno; IF (v_sal \u0026lt; 3000) THEN raise_application_error(-20000, \u0026#39;薪资问题，小伙子注意啦，要开除啦\u0026#39;); END IF; END; "},{"id":172,"href":"/program-design/data-algorithm/sort/merge/","title":"归并排序","section":"排序算法","content":"\r归并排序\r#\r归并操作\r#\r将已有序的子序列合并，得到完全有序的序列 算法步骤\r#\r申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 动图演示\r#\r代码实现\r#\rpublic class MergeSort implements IArraySort { @Override public int[] sort(int[] arr) throws Exception { if (arr.length \u0026lt; 2) { return arr; } int middle = (int) Math.floor(arr.length / 2); int[] left = Arrays.copyOfRange(arr, 0, middle); int[] right = Arrays.copyOfRange(arr, middle, arr.length); return merge(sort(left), sort(right)); } protected int[] merge(int[] left, int[] right) { int[] result = new int[left.length + right.length]; int i = 0; while (left.length \u0026gt; 0 \u0026amp;\u0026amp; right.length \u0026gt; 0) { if (left[0] \u0026lt;= right[0]) { result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); } else { result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); } } while (left.length \u0026gt; 0) { result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); } while (right.length \u0026gt; 0) { result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); } return result; } } "},{"id":173,"href":"/program-lang/java/grammar/array/","title":"数组","section":"基本语法","content":"\r数组\r#\r概述\r#\r数组是相同类型数据的有序集合，代表着一串连续的内存空间 特点\r#\r数组元素必须是相同类型 数组一旦被创建，其长度就是不可变的 数组元素的索引（下标），从 0 开始 数值类型元素的默认值为 0，引用类型元素的默认值为 null 创建数组\r#\r// 一维数组 dataType[] arrayRefVar; dataType[] arrayRefVar = new dataType[arraySize]; dataType[] arrayRefVar = {value0, value1, ..., valuek}; // 示例 int[] arr1; int[] arr2 = new int[2]; int[] arr3 = {1, 2, 3} // 多维数组 dataType[][] arrayRefVar = new dataType[arraySize1][arraySize2]; dataType[][] arrayRefVar = {{value0, value1, ..., valuek},{...},...}; // 示例 int[][] arr1 = new int[2][3]; int[][] arr2 = {{1, 2, 3},{4, 5},{6, 7, 8, 9}}; 操作数组\r#\rint a,b; int[] arr = {0, 1, 2, 3}; a = arr[0]; // 元素引用 b = arr.length; // 数组长度 "},{"id":174,"href":"/program-lang/web/css/position/float/","title":"浮动","section":"CSS 位置","content":"\r浮动\r#\r属性\r属性说明\r属性值\r属性值说明\rfloat\r浮动\rnone\r不浮动，默认\rleft\r左浮动\rright\r右浮动\rinherit\r继承\rclear\r清除浮动\rnone\r两侧元素，允许浮动，默认值。\rleft\r左侧元素，不允许浮动\rright\r右侧元素，不允许浮动\rboth\r两侧元素，不允许浮动\rinherit\r继承\r浮动规则\r#\r浮动元素 不会重叠 不会上下浮动 会脱离标准流 浮动元素的外边距，不会超过父元素内边距 非浮动元素的文本，会环绕浮动元素周围 "},{"id":175,"href":"/program-base/linux/cmd/user/","title":"用户权限","section":"常用命令","content":"\r用户权限\r#\ruseradd - 添加用户\nusermod - 修改用户属性\nuserdel - 删除用户\ngroupadd - 添加用户组\npasswd - 更改用户密码\nsu - 切换用户身份\nchmod - 改变文件或目录权限\nchown - 改变文件或目录的所有者\n"},{"id":176,"href":"/program-lang/java/thread/thread/thread-state/","title":"线程状态","section":"线程基础","content":"\r线程状态\r#\r线程状态\r#\r状态码 状态 说明 NEW 初始状态 线程被构建，但是还没有调用 start() 方法 RUNNABLE 运行状态 线程已经启动，拥有执行资格，如果取得执行资源则执行 BLOCKED 阻塞状态 线程挂起，阻塞于锁 WAITING 等待状态 线程等待中，需要被显式地唤醒，否则会无限期等待 TIMED_WAITING 超时等待 线程等待中，在达到一定时间后，会自动唤醒 TERMINATED 终止状态 线程已经执行完毕 状态转换\r#\r方法 调用者 描述 对象锁 唤醒 Thread.sleep(t) 当前线程 休眠当前线程 不释放 一定时间后自动唤醒 Thread.yield() 当前线程 让出执行资源，休眠当前线程 不释放 由系统进行调度 thread.join()thread.join(t) 其他线程 加入其他线程，休眠当前线程 不释放 其他线程执行完后唤醒一定时间后自动唤醒 object.wait()object.wait(t) 锁对象 使线程进入等待队列 释放 notify()/notifyAll() 唤醒一定时间后自动唤醒 线程方法\r#\rjava.lang.Thread\r#\r成员方法 描述 静态方法 描述 start() 开始执行线程 setName() 修改线程名称 run() 线程体方法 setPriority() 设置线程优先级（1~10） yield() 使当前线程暂停 setDaemon() 标记线程为用户线程 sleep() 使当前线程休眠 currentThread() 获取当前正在执行的线程对象 join() 当前线程中，加入其他线程 holdsLock() 当前线程是否持有指定锁 interrupt() 中断线程 dumpStack() 打印当前线程的堆栈信息 isAlive() 线程是否处于活动状态 java.lang.Object\r#\r方法 描述 notify() 唤醒在此对象监视器上等待的单个线程。 notifyAll() 唤醒在此对象监视器上等待的所有线程。 wait() 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待 sleep() \u0026amp; wait()\r#\rsleep() wait() 所属类 java.lang.Thread java.lang.Object 对象锁 不释放 释放 使用位置 任意地方 只能在同步块中使用 捕获异常 需要 不需要 "},{"id":177,"href":"/program-lang/web/css/style/background/","title":"背景样式","section":"CSS 样式","content":"\r背景样式\r#\r属性\r属性说明\r属性值\r属性值说明\rbackground\r简写\r\u0026nbsp;\r空格分隔各值，不分顺序\rbackground-color\r背景颜色\rtransparent\r透明色，默认\rcolor\r颜色值\rbackground-image\r背景图片\rnone\r无图片，默认\rurl('URL')\r图片路径\rbackground-repeat\r背景图片重复\rrepeat\r默认。垂直方向及水平方向重复\rrepeat-x\r水平方向重复\rrepeat-y\r垂直方向重复\rno-repeat\r不重复\rbackground-attachment\r背景图片滚动\rscroll\r跟随滚动。默认\rfixed\r固定\rbackground-position\r背景图片起始位置\r当只有一个值时，第二个值默认为居中\rx%、y%\r百分比，默认0% 0%\rx、y\r数值\rtop\r上\rbottom\r下\rleft\r左\rright\r右\rcenter\r中\r示例\r#\rbody{ background-image:url(\u0026#39;/i/eg_bg_03.gif\u0026#39;); background-repeat:no-repeat; background-position:66% 33%; } "},{"id":178,"href":"/database/mysql/advanced-feature/trigger/","title":"触发器","section":"高级特性","content":"\r触发器\r#\r定义\r#\r触发器是一种特殊类型的存储过程，通过触发事件而被执行。 优点： 实现相关表的级联更改。 通过触发器进行安全校验，保证数据安全 缺点： 过分依赖触发器，会影响数据库结构，增加了维护难度。 由于执行触发器不可见，很难弄清数据库层情况 对数据库服务器资源的开销较大 建议： 尽量不使用触发器 如果要使用，需确保触发器高效低耗 触发器管理\r#\r触发时机：before/after 触发事件：insert/update/delete # 创建 修改语句结束符 create trigger 触发器名 触发时机 触发事件 on 表名 for each row begin 执行体 end 语句结束符 修改语句结束符 # 查看 show triggers [like \u0026#39;...\u0026#39;]; show create trigger 触发器名; # 删除 drop trigger 触发器名; -- 示例 DELIMITER $$ CREATE TRIGGER demo BEFORE DELETE ON users FOR EACH ROW BEGIN INSERT INTO logs VALUES(NOW()); INSERT INTO logs VALUES(NOW()); END $$ DELIMITER ; 触发器新旧数据\r#\r触发器，针对数据表中的每一行，会记录其操作前后的数据 -- 在触发器中，可通过“old/new.字段名”，来获取对应数据 -- old：记录操作前的数据。 -- new：记录操作后的数据 -- 示例：商品自动扣除库存 DELIMITER $$ CREATE TRIGGER demo AFTER INSERT ON my_orders FOR EACH ROW BEGIN UPDATE my_goods SET inv = inv -NEW.goods_num WHERE id = NEW.goods_id; END $$ DELIMITER ; "},{"id":179,"href":"/database/mysql/grammar/sentence/","title":"语句","section":"基本语法","content":"\r语句\r#\r分支结构\r#\rif 语句\r#\r作为表达式，嵌套在其他语句中使用，可以放在任何地方\n作为独立的语句去使用，只能放在 begin...end 中\n# 格式：作为表达式 if(条件, 判断为ture返回, 判断为false返回) # 格式：作为独立语句 if 条件1 then 语句1; elseif 条件2 then 语句2; else 语句n; end if; -- 示例：判断 5\u0026lt;10，true返回“大”，false返回“小” select if(5\u0026lt;10, \u0026#39;大\u0026#39;, \u0026#39;小\u0026#39;); -- 示例：创建函数，根据传入的成绩来显示等级 drop function if exists testIf; delimiter $ create function testIf(score int) returns char(3) begin if score\u0026gt;=90 then return \u0026#39;优秀\u0026#39;; elseif score\u0026gt;=80 then return \u0026#39;良好\u0026#39;; elseif score\u0026gt;=60 then return \u0026#39;及格\u0026#39;; else return \u0026#39;不及格\u0026#39;; end if; end$ select testIf(66) as \u0026#39;成绩\u0026#39;; case 语句\r#\r作为表达式，嵌套在其他语句中使用，可以放在任何地方\n作为独立的语句去使用，只能放在 begin...end 中\nelse可以省略，没有满足的条件则返回null\n# 格式：作为表达式 case 字段|表达式|变量 when 常量1 then 返回值1 when 常量2 then 返回值2 else 默认返回值 end # 格式：作为独立语句 case when 条件1 then 语句1; when 条件2 then 语句2; else 语句n; end case; -- 示例：查询读者性别 select readerName, sex, case sex when \u0026#39;男\u0026#39; then \u0026#39;是个爷们\u0026#39; when \u0026#39;女\u0026#39; then \u0026#39;是个姑娘\u0026#39; else \u0026#39;未知\u0026#39; end as \u0026#39;gender\u0026#39; from reader; -- 示例：创建存储过程，根据传入的成绩来显示等级 drop procedure if exists testCase; delimiter $ create procedure testCase(in score int) begin case when score\u0026gt;=90 then select \u0026#39;优秀\u0026#39; as \u0026#39;成绩\u0026#39;; when score\u0026gt;=80 then select \u0026#39;良好\u0026#39; as \u0026#39;成绩\u0026#39;; when score\u0026gt;=60 then select \u0026#39;及格\u0026#39; as \u0026#39;成绩\u0026#39;; else select \u0026#39;不及格\u0026#39; as \u0026#39;成绩\u0026#39;; end case; end $ call testCase(95); 循环结构\r#\r只能放在 begin...end 中 while\r#\r先判断，后循环\n# 格式 [标签:] while 循环条件 do 循环体; end while [标签]; -- 示例：批量插入 drop procedure if exists pro_while; delimiter $ create procedure pro_while(in insertCount int) begin declare i int default 1; -- 声明并初始化局部变量 i while i \u0026lt;= insertCount do insert into reader(readerNo, readerName, sex) values(i, concat(i, \u0026#39;号读者\u0026#39;), \u0026#39;男\u0026#39;); set i = i + 1; -- 循环变量更新 end while; end$ call pro_while(5); -- 插入 5 条记录 repeat\r#\r先执行后判断\n# 格式 [标签:] repeat 循环体; until 结束循环的条件 # 注意此处没有分号 end repeat [标签]; -- 示例：批量插入 drop procedure if exists pro_while; delimiter $ create procedure pro_while(in insertCount int) begin declare i int default 1; -- 声明并初始化局部变量 i repeat insert into reader(readerNo, readerName, sex) values(i, concat(i, \u0026#39;号读者\u0026#39;), \u0026#39;男\u0026#39;); set i = i + 1; -- 循环变量更新 until i \u0026gt;= insertCount end repeat; end$ call pro_while(5); -- 插入 4 条记录 loop\r#\r无限循环\n# 格式 [标签:] loop 循环体; end loop [标签]; -- 示例：批量插入 drop procedure if exists pro_while; delimiter $ create procedure pro_while(in insertCount int) begin declare i int default 1; -- 声明并初始化局部变量 i halt: loop insert into reader(readerNo, readerName, sex) values(i, concat(i, \u0026#39;号读者\u0026#39;), \u0026#39;男\u0026#39;); if i \u0026gt;= insertCount then leave halt; -- leave 控制语句 end if; set i = i + 1; -- 循环变量更新 end loop halt; end$ call pro_while(5); -- 插入 5 条记录 标签\r#\r为某些特定的结构进行命名，方便在某些地方使用 在 mysql 中，没有 continue/break，只有 iterate/leave -- 创建存储过程 CREATE PROCEDURE example_iterate(OUT sum INT) BEGIN DECLARE i INT DEFAULT 0; DECLARE s INT DEFAULT 0; loop_label:LOOP SET i = i+1; IF i \u0026gt; 10 THEN LEAVE loop_label; -- leave：退出整个循环 END IF; IF (i mod 2) THEN SET s = s+i; ELSE ITERATE loop_label; -- iterate：退出本次循环，继续下一个循环 END IF; END LOOP; SET sum = s; END; -- 调用存储过程 CALL example_iterate(@sum); SELECT @sum; "},{"id":180,"href":"/program-lang/web/html/link/","title":"链接标签","section":"HTML","content":"\rURL\r#\r.代表当前网页所在目录，可省略 ..代表当前网页所在目录的上一级目录 //绝对路径 \u0026lt;img src=\u0026#34;D:/html/img.png\u0026#34; /\u0026gt; //相对路径 \u0026lt;img src=\u0026#34;../img.png\u0026#34; /\u0026gt; \u0026lt;a\u0026gt;\r#\r定义一个链接 属性： title：链接提示文字 href：链接地址 target：在何处打开链接：_blank、_parent、_self、_top //链接到资源 \u0026lt;a href=\u0026#34;https://www.baidu.com/\u0026#34; /\u0026gt; \u0026lt;a href=\u0026#34;../xxx.html\u0026#34; /\u0026gt; \u0026lt;a href=\u0026#34;../xxx.rar\u0026#34; /\u0026gt; //链接到邮件 \u0026lt;a href=\u0026#34;mailto:xxx@qq.com\u0026#34; /\u0026gt; //定义锚点 \u0026lt;a name=\u0026#34;mark\u0026#34; /\u0026gt; //链接到锚点 \u0026lt;a href=\u0026#34;#mark\u0026#34; /\u0026gt; \u0026lt;a href=\u0026#34;../xxx.html#\u0026gt;mark\u0026#34; /\u0026gt; \u0026lt;img\u0026gt;\r#\r定义一个图像 属性： src：定义图像的URL alt：定义图像的替代文本 width：定义图像的宽 height：定义图像的高 \u0026lt;img src=\u0026#34;xxx.png\u0026#34; alt=\u0026#34;xxx\u0026#34; width=\u0026#34;40\u0026#34; height=\u0026#34;40\u0026#34; /\u0026gt; "},{"id":181,"href":"/program-design/data-structure/queue/","title":"队列","section":"数据结构","content":"\r队列\r#\r队列\r#\rQueue 是一种特殊的线性表 限制仅允许在线性表的一端进行插入，在另一端进行删除 特点\r#\r先进先出（First In First Out，简称FIFO） 入队出队\r#\r"},{"id":182,"href":"/program-lang/java/thread/theory/CAS/","title":"CAS","section":"并发理论","content":"\rCAS 算法\r#\rCAS\r#\r比较并交换，Compare-And-Swap，是一种无锁算法 基于硬件原语实现，能够在不使用锁的情况下实现多线程之间的变量同步 Java CAS硬件底层接口 ：sun.misc.Unsafe CAS 机制\r#\r涉及到三个参数，数据所在的内存地址 V，旧的预期值 A，要修改的更新值 B 从 V 取值，和 A 做比较，如果相等，则更新为 B。如果不相等则重试 一般情况下是一个自旋操作，即不断的重试。 CAS 缺点\r#\r自旋时间长开销很大 只能保证一个共享变量的原子性 存在 ABA 问题 ABA 问题\r#\r在 CAS 操作中，内存中某时刻的值与下一时刻再次读取的值相等，并不意味着数据没有被修改 存在这种情况：在这段时间内，其他线程将 A 值改成 B 值，又改回 A 值。而CAS却误认为数据未被修改 解决方案： 1、加版本号（时间戳）； 2、时间戳原子引用：AtomicStampedReference\u0026lt;V\u0026gt; "},{"id":183,"href":"/program-lang/java/container/Map/ConcurrentHashMap/","title":"ConcurrentHashMap","section":"Map","content":"\rConcurrentHashMap\r#\r概述\r#\rConcurrentHashMap 是 HashMap 的扩展版本，支持并发，是线程安全的 特点\r#\r键 不允许为null，不允许重复 值 不允许为null，允许重复 顺序 无序 多线程 线程安全 继承关系\r#\rpublic class ConcurrentHashMap\u0026lt;K,V\u0026gt; extends AbstractMap\u0026lt;K,V\u0026gt; implements ConcurrentMap\u0026lt;K,V\u0026gt;, Serializable { 构造方法\r#\r// 默认 public ConcurrentHashMap() { } // 指定初始容量 public ConcurrentHashMap(int initialCapacity) { //... } // 指定初始容量、负载因子 public ConcurrentHashMap(int initialCapacity, float loadFactor) { this(initialCapacity, loadFactor, 1); } // 指定初始容量、负载因子、并发级别 public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) { //... } // 指定集合，转化为ConcurrentHashMap public ConcurrentHashMap(Map\u0026lt;? extends K, ? extends V\u0026gt; m) { //... } 线程同步\r#\rJDK1.7\r#\r通过锁分离（分段锁）的思路解决了多线程的安全问题 ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。 JDK1.8\r#\r抛弃了Segment分段锁机制，利用 CAS+Synchronized 来保证并发更新的安全 "},{"id":184,"href":"/program-lang/java/thread/lock/Condition/","title":"Condition","section":"锁体系","content":"\rCondition\r#\r"},{"id":185,"href":"/program-lang/java/thread/threadpool/FutureTask/","title":"FutureTask","section":"线程池","content":"\rFutureTask\r#\r"},{"id":186,"href":"/program-lang/java/library/java.util.function/","title":"java.util.function","section":"基础类库","content":"\r函数式接口\r#\r概述\r#\rFunctional Interface 就是一个有且仅有一个抽象方法，但可以有多个非抽象方法的接口 可以被隐式转换为 lambda 表达式，使用 @FunctionalInterface 进行检测 // JDK 1.8 之前已有的常用函数式接口 @FunctionalInterface public interface Runnable { void run(); } @FunctionalInterface public interface Callable\u0026lt;V\u0026gt; { V call() throws Exception; } @FunctionalInterface public interface Comparator\u0026lt;T\u0026gt; { int compare(T var1, T var2); } java.util.function\r#\rConsumer\r#\r消费型 接受数据，没有返回值 // 消费一个数据 public interface Consumer\u0026lt;T\u0026gt; { void accept(T t); } // 消费两个数据 public interface BiConsumer\u0026lt;T, U\u0026gt; { void accept(T t, U u); } 接口 函数 IntConsumer void accept(int value); LongConsumer void accept(long value); DoubleConsumer void accept(double value); ObjIntConsumer\u0026lt;T\u0026gt; void accept(T t, int value); ObjLongConsumer\u0026lt;T\u0026gt; void accept(T t, long value); ObjDoubleConsumer\u0026lt;T\u0026gt; void accept(T t, double value); Supplier\r#\r供给型 无需接受数据，返回一个结果 // 无参数，返回一个结果 public interface Supplier\u0026lt;T\u0026gt; { T get(); } 接口 函数 IntSupplier int getAsInt(); LongSupplier long getAsLong(); DoubleSupplier double getAsDouble(); BooleanSupplier boolean getAsBoolean(); Predicate\r#\r断言型 接受一个数据，返回布尔值 // 接受一个数据，返回布尔值 public interface Predicate\u0026lt;T\u0026gt; { boolean test(T t); } // 接受两个数据，返回布尔值 public interface BiPredicate\u0026lt;T, U\u0026gt; { boolean test(T t, U u); } 接口 函数 IntPredicate boolean test(int value); LongPredicate boolean test(long value); DoublePredicate boolean test(double value); Function\r#\r函数型 接受数据，返回一个值 // 接受一个数据，返回一个结果 public interface Function\u0026lt;T, R\u0026gt; { R apply(T t); } // 接受两个数据，返回一个结果 public interface BiFunction\u0026lt;T, U, R\u0026gt; { R apply(T t, U u); } 接口 函数 IntFunction\u0026lt;R\u0026gt; R apply(int value); LongFunction\u0026lt;R\u0026gt; R apply(long value); DoubleFunction\u0026lt;R\u0026gt; R apply(double value); ToIntBiFunction\u0026lt;T, U\u0026gt; int applyAsInt(T t, U u); ToIntFunction\u0026lt;T\u0026gt; int applyAsInt(T value); LongToIntFunction int applyAsInt(long value); DoubleToIntFunction int applyAsInt(double value); ToLongBiFunction\u0026lt;T, U\u0026gt; long applyAsLong(T t, U u); ToLongFunction\u0026lt;T\u0026gt; long applyAsLong(T value); IntToLongFunction long applyAsLong(int value); DoubleToLongFunction long applyAsLong(double value); ToDoubleBiFunction\u0026lt;T, U\u0026gt; double applyAsDouble(T t, U u); ToDoubleFunction\u0026lt;T\u0026gt; double applyAsDouble(T value); IntToDoubleFunction double applyAsDouble(int value); LongToDoubleFunction double applyAsDouble(long value); Operator\r#\r操作同类型数据 接口 函数 UnaryOperator\u0026lt;T\u0026gt; T apply(T t); IntUnaryOperator int applyAsInt(int operand); LongUnaryOperator long applyAsLong(long operand); DoubleUnaryOperator double applyAsDouble(double operand); BinaryOperator\u0026lt;T\u0026gt; T apply(T t1, T t2); IntBinaryOperator int applyAsInt(int left, int right); LongBinaryOperator long applyAsLong(long left, long right); DoubleBinaryOperator double applyAsDouble(double left, double right); "},{"id":187,"href":"/service-manage/zookeeper/","title":"Zookeeper","section":"服务治理","content":"\rZookeeper\r#\r是一个开源的，分布式的，为分布式应用提供协调服务的框架 特点\r#\r由一个领导者（leader）和多个跟随者（follower）组成集群 集群只要有半数以上节点存活，就能正常服务 数据一致性：每个server保存一份相同的数据副本，client无论连接到哪个server，数据都是一致的。 请求顺序性：来自同一个client的更新请求按其发送顺序依次执行。 原子性：一次数据更新要么成功，要么失败。 实时性：在一定时间范围内，client能读到最新数据。 应用\r#\r统一命名服务 统一配置管理 统一集群管理 服务器节点动态上下线 软负载均衡等 "},{"id":188,"href":"/service-manage/deprecated-frame/zuul/","title":"Zuul","section":"日落组件","content":"\rZuul\r#\rZuul\r#\r服务网关 路由：将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础 过滤：对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础 "},{"id":189,"href":"/database/oracle/plsql/transaction/","title":"事务处理","section":"PL/SQL","content":"\r事务处理\r#\r数据库事务\r#\r是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。 这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。 ACID：原子性、一致性、隔离性、持久性 开启事务\r#\r连接到数据库后执行第一个SQL语句。 在事务完成后发出的每个新的SQL语句。 结束事务\r#\r发出 COMMIT 或 ROLLBACK 语句时 发出 DDL/ DCL 语句时 执行 DML 语句失败时 退出 Oracle 工具时 提交事务\r#\rINSERT INTO customers (id,name,age,address,salary) VALUES (1, \u0026#39;Ramesh\u0026#39;, 32, \u0026#39;Ahmedabad\u0026#39;, 2000.00 ); -- 提交事务 COMMIT; 回滚事务\r#\rINSERT INTO customers (id,name,age,address,salary) VALUES (7, \u0026#39;Rajnish\u0026#39;, 27, \u0026#39;HP\u0026#39;, 9500.00 ); INSERT INTO customers (id,name,age,address,salary) VALUES (8, \u0026#39;Riddhi\u0026#39;, 21, \u0026#39;WB\u0026#39;, 4500.00 ); -- 保存点 SAVEPOINT sav1; UPDATE customers SET salary = salary + 1000; -- 回滚到保存点 ROLLBACK TO sav1; UPDATE customers SET salary = salary + 1000 WHERE ID = 7; UPDATE customers SET salary = salary + 1000 WHERE ID = 8; COMMIT; 自动事务\r#\r-- 开启事务自动提交 SET AUTOCOMMIT ON; -- 关闭事务自动提交 SET AUTOCOMMIT OFF; "},{"id":190,"href":"/program-base/linux/cmd/file-zip/","title":"压缩","section":"常用命令","content":"\r压缩\r#\rtar - 文件压缩与解压缩\ngzip / gunzip - 压缩或解压缩文件\nbzip2 / bunzip2 - 压缩或解压缩文件\n"},{"id":191,"href":"/program-design/design-pattern/creational/05-builder/","title":"建造者模式","section":"创建型","content":"\r建造者模式\r#\r概述\r#\r英文：Builder Pattern 简述：用来创建复杂的复合对象 归纳：高配中配和低配，想选哪配就哪配 目的：开放个性配置步骤 案例：选配 示例\r#\r// 被建造的复杂对象 public class House { private String baise; private String wall; private String roofed; // getter、setter //... } // 抽象建造者：主要用来指定建造步骤 public abstract class HouseBuilder { protected House house = new House(); //建设房屋的基本方法，建设根基、建设墙、建设屋顶 public abstract void buildBasic(); public abstract void buildWalls(); public abstract void roofed(); public House buildHouse() { return house; } } // 类似产品类：CommonHouse public class HighBuilding extends HouseBuilder{ @Override public void buildBasic() { System.out.println(\u0026#34;高楼地基\u0026#34;); } @Override public void buildWalls() { System.out.println(\u0026#34;高楼墙面\u0026#34;); } @Override public void roofed() { System.out.println(\u0026#34;高楼屋顶\u0026#34;); } } // 指挥类 public class HouseDirector { HouseBuilder houseBuilder = null; // 构造器创建bilder对象 public HouseDirector(HouseBuilder houseBuilder) { this.houseBuilder = houseBuilder; } // 建造房屋的流程交给指挥者 public House constructHouse() { houseBuilder.buildBasic(); houseBuilder.buildWalls(); houseBuilder.roofed(); return houseBuilder.buildHouse(); } } 应用\r#\r主要解决： 软件系统中，一个复杂对象的创建，通常由各个部分的子对象用一定的算法构成。 由于需求的变化，各子部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。 应用场景： 需要生成的对象具有复杂的内部结构 需要生成的对象内部属性本身相互依赖 注意事项： 与工厂模式的区别是：建造者模式更加关注与零件装配的顺序 "},{"id":192,"href":"/program-design/data-algorithm/sort/quick/","title":"快速排序","section":"排序算法","content":"\r快速排序\r#\r算法步骤\r#\r先从数列中取出一个数作为基准数。 分区过程：将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。 再对左右区间重复第二步，直到各区间只有一个数。 动图演示\r#\r代码实现\r#\rpublic class QuickSort implements IArraySort { @Override public int[] sort(int[] arr) throws Exception { return quickSort(arr, 0, arr.length - 1); } private int[] quickSort(int[] arr, int left, int right) { if (left \u0026lt; right) { int partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); } return arr; } private int partition(int[] arr, int left, int right) { // 设定基准值（pivot） int pivot = left; int index = pivot + 1; for (int i = index; i \u0026lt;= right; i++) { if (arr[i] \u0026lt; arr[pivot]) { swap(arr, i, index); index++; } } swap(arr, pivot, index - 1); return index - 1; } private void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } "},{"id":193,"href":"/program-lang/java/oop/abstraction/","title":"抽象","section":"面向对象","content":"\r抽象\r#\r抽象\r#\r是将一类对象的共同特征总结出来构造类的过程 抽象类\r#\r抽象方法：只有方法声明，没有方法实现 抽象类：包含抽象方法的类 特征： 抽象类不能实例化。 抽象类的非抽象子类必须实现父类抽象方法 抽象方法、抽象类必须被abstract修饰 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法 //示例 abstract class Animal{ String name; public abstract void run(); } class Dog extends Animal{ public void run(){ System.out.println(\u0026#34;run\u0026#34;); } } 接口\r#\r接口是一种特殊的抽象类，是抽象方法的集合。用 interface 定义。 特点 隐式抽象 支持多继承 没有构造方法 接口的方法都是公有的、隐式抽象的 接口的成员变量只能是public static final 的。 //示例 interface Animal{ public static final int id = 1; public void run(); public void eat(); } //接口继承接口 interface fish extends Animal{ //... } //类实现接口 public Dog implements Animal{ public void run(){ //具体实现... } public void eat(){ //具体实现... } } "},{"id":194,"href":"/program-design/data-structure/hash/","title":"散列表","section":"数据结构","content":"\r散列表\r#\r散列表\r#\rHash 也叫哈希表，是一种根据键值对 (key和value) 直接进行访问的数据结构 数据存储\r#\r使用哈希函数计算 key 的哈希值 再用哈希值对数组长度取模，得到其余数，即存放位置的数组下标 如果该位置已经存储了元素，则使用链表在已有元素的后面进行存储 数据查询\r#\r使用哈希函数计算 key 的哈希值， 再用哈希值对数组长度取模，得到存放位置的数组下标 对比参数key与节点key是否相同，如果相同则取出节点value 如果不相同，则对指向的链表进行线性查找 哈希冲突\r#\r两个不同的输入值，根据哈希函数计算出的哈希值取模结果相同的现象 "},{"id":195,"href":"/program-lang/java/grammar/method/","title":"方法","section":"基本语法","content":"\r方法\r#\r方法的定义\r#\r方法包含于类中 方法中不能定义方法 若无返回值，用 void 代替 // 格式 修饰符 返回值类型 方法名(参数类型 参数名){ ... 方法体 ... return 返回值; } // 示例 public static int age(int birthday){ //... } 方法的调用\r#\r// 格式 对象名.函数名（实参列表） // 示例 public int max(int a,int b){ if(a\u0026gt;b){ return a; } return b; } public static void main(String []args) { int larger = max(30, 40); //... } 重载 \u0026amp; 重写\r#\r重载 overload\n在一个类里面，方法名字相同，而参数不同 每个重载的方法都必须有独一无二的参数类型列表（参数个数、参数类型、参数顺序） 重写 override 是子类对父类方法的实现进行重新编写 方法名、参数列表均相同 重写方法抛出的异常，需宽于被重写方法 构造方法不能被重写 区别 区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常捕获 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问限制 可以修改 一定不能做更严格的限制（可以降低限制） 可变参数\r#\r在方法声明中，在指定参数类型后加一个省略号(\u0026hellip;)\npublic static void max(double... numbers) { //... } public static void main(String[] args) { int larger = max(30, 40, 50, 60); //... } "},{"id":196,"href":"/database/mysql/advanced-feature/mysql-index/","title":"索引","section":"高级特性","content":"\r索引\r#\r定义\r#\r索引是一种特殊的文件，它们包含着对所有记录的引用指针 优点：类似书的目录，可以极大地提高数据检索速度 缺点：维护索引会增加额外的开销 原则\r#\r最左侧原则：表的最左侧的一列，往往数据不会发生改变，不影响其他列的数据 命名短小原则：索引命名过长会使索引文件变大，损耗内存 分类\r#\r普通索引：最基本的索引，没有任何限制 唯一索引：索引列的值必须唯一 ，允许有空值 主键索引：一种特殊的唯一索引，一张表中只能定义一个，用来标识一条数据，不能为空 全文索引：仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时耗空间 聚合索引：覆盖多个数据列的索引 实现\r#\rB-Tree：比较适合用作\u0026rsquo;\u0026gt;\u0026lsquo;或\u0026rsquo;\u0026lt;\u0026lsquo;这样的范围查询，在MySQL中最为常用 R-Tree：用于处理多维数据的数据结构，可以对地理数据进行空间索引。运用较少 Hash：使用散列表来对数据进行索引。效率高于B-Tree，但是不支持范围查找和排序。运用较少 FullText：全文索引，是一种记录关键字与对应文档关系的倒排索引。 "},{"id":197,"href":"/program-lang/web/html/table/","title":"表格标签","section":"HTML","content":"\r表格标签\r#\r标签 说明 \u0026lt;table\u0026gt; 定义表格 \u0026lt;tr\u0026gt; 定义表格行 \u0026lt;td\u0026gt; 定义表格单元格 \u0026lt;th\u0026gt; 定义表头单元格 \u0026lt;caption\u0026gt; 定义表格标题 \u0026lt;thead\u0026gt; 定义表格页眉 \u0026lt;tbody\u0026gt; 定义表格主体 \u0026lt;tfoot\u0026gt; 定义表格页脚 标签属性\r#\r\u0026lt;table\u0026gt;\nwidth：表格宽度 border：边框宽度 cellspacing：单元格间距 cellpadding：单元格与内容间距 \u0026lt;td\u0026gt;、\u0026lt;th\u0026gt;\ncolspan：单元格横跨几列 rowspan：单元格横跨几行 共同属性\r#\r属性\r属性值\r属性值说明\r水平对齐：align\rleft\r左对齐（默认）\rright\r右对齐\rcenter\r居中对齐\rjustify\r拉伸对齐\rchar\r对齐指定字符\r垂直对齐：valign\rtop\r顶部对齐（默认）\rmiddle\r居中对齐\rbottom\r底部对齐\rbaseline\r基线对齐\r示例\r#\r\u0026lt;table border=\u0026#34;1\u0026#34; width=\u0026#34;70%\u0026#34; cellspacing=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;caption\u0026gt;表格标题\u0026lt;/caption\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;北京\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;上海\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;广州\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;...\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;...\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;...\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; "},{"id":198,"href":"/service-manage/deprecated-frame/config/","title":"Config","section":"日落组件","content":"\rConfig\r#\rConfig\r#\r配置中心 为微服务框架中的微服务提供统一的外部配置支持 工作原理\r#\rConfig Server：分布式配置中心，它是一个独立的微服务，用来连接配置服务器并为客户端提供配置信息 Config Client：通过配置中心，获取对应的配置来管理应用。 "},{"id":199,"href":"/service-manage/dubbo/","title":"Dubbo","section":"服务治理","content":"\rDubbo\r#\r是一款高性能、轻量级的开源Java RPC框架 Dubbo \u0026amp; Spring Cloud\r#\rDubbo Spring Cloud 所属厂商 阿里系的分布式服务治理框架 Apache 旗下的 Spring 体系下的微服务解决方案 通信机制 RPC 通信 基于 HTTP 的 REST 方式 技术维度 只是实现了服务治理 覆盖了微服务架构下的方方面面 "},{"id":200,"href":"/program-lang/java/thread/lock/LockSupport/","title":"LockSupport","section":"锁体系","content":"\rLockSupport\r#\r"},{"id":201,"href":"/program-design/design-pattern/structural/06-proxy/","title":"代理模式","section":"结构型","content":"\r代理模式\r#\r概述\r#\r英文：Proxy Pattern 简述：为其他对象提供一种代理以控制对这个对象的访问 归纳：没有资源没时间，得找别人来帮忙 目的：增强职责 案例：媒婆 示例\r#\r类型 区别 静态代理 手动生成代理类 动态代理 运用反射机制，动态生成代理类 JDK 动态代理 只能代理实现了接口的类 CGLib 动态代理 对目标类生成一个子类，并覆盖其中方法实现增强。 但因为采用的是继承，所以不能对final修饰的类进行代理 静态代理\r#\r// 被代理目标类 public interface Wow { void tbc(); } public class Blizzard implements Wow { @Override public void tbc() { System.out.println(\u0026#34;《魔兽世界》：燃烧的远征\u0026#34;); } } // 代理类 public class NetEasy implements Wow { private Blizzard blizzard; // 传递被代理对象 public NetEasy(Blizzard blizzard) { this.blizzard = blizzard; } // 控制被代理对象的行为 @Override public void tbc() { System.out.println(\u0026#34;网易代理《魔兽世界》开始\u0026#34;); blizzard.tbc(); System.out.println(\u0026#34;网易代理《魔兽世界》结束\u0026#34;); } } public class Test { public static void main(String[] args) { Wow wow = new NetEasy(new Blizzard()); wow.tbc(); } } 动态代理（JDK）\r#\rpublic class ProxyHandler implements InvocationHandler { private Object target; // 获取被代理对象 public Object newProxyInstance(Object target) { this.target = target; return Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); } // 操作被代理对象的行为 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\u0026#34;JDK：动态代理开始\u0026#34;); Object result = method.invoke(target, args); System.out.println(\u0026#34;JDK：动态代理结束\u0026#34;); return result; } } public class Test { public static void main(String[] args) { ProxyHandler handler = new ProxyHandler(new Blizzard()); Wow wow = (Wow) handler.newProxyInstance(); wow.tbc(); } } 动态代理（CGLIB）\r#\rpublic class CglibInterceptor implements MethodInterceptor { private Enhancer enhancer = new Enhancer(); // 获取被代理对象 public Object newProxyInstance(Class\u0026lt;?\u0026gt; clazz) { enhancer.setSuperclass(clazz); enhancer.setCallback(this); return enhancer.create(); } // 操作被代理对象的行为 @Override public Object intercept( Object target, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(\u0026#34;CGLIB：动态代理开始\u0026#34;); Object result = methodProxy.invokeSuper(target, args); System.out.println(\u0026#34;CGLIB：动态代理结束\u0026#34;); return result; } } public class Test { public static void main(String[] args) { CglibInterceptor interceptor = new CglibInterceptor(); Wow wow = (Wow) interceptor.newProxyInstance(Blizzard.class); wow.tbc(); } } 应用\r#\r主要解决： 直接访问对象时带来的问题（安全控制、进程外访问、对象创建开销大） 应用场景： Spring AOP、Windows 快捷方式 注意事项： 适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口 装饰器模式为了增强功能，而代理模式是为了加以控制 "},{"id":202,"href":"/program-base/linux/cmd/other/","title":"其他","section":"常用命令","content":"\r其他\r#\r"},{"id":203,"href":"/program-design/data-algorithm/sort/shell/","title":"希尔排序","section":"排序算法","content":"\r希尔排序\r#\r希尔排序\r#\r是插入排序的改进版本。 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序 待整个序列中的记录\u0026quot;基本有序\u0026quot;时，再对全体记录进行依次直接插入排序。 算法步骤\r#\r选择一个增量序列 t1，t2，……，tk，其中 ti \u0026gt; tj, tk = 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。 仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 动图演示\r#\r代码实现\r#\rpublic class ShellSort implements IArraySort { @Override public int[] sort(int[] arr) throws Exception { int length = arr.length; int temp; for (int step = length / 2; step \u0026gt;= 1; step /= 2) { for (int i = step; i \u0026lt; length; i++) { temp = arr[i]; int j = i - step; while (j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; temp) { arr[j + step] = arr[j]; j -= step; } arr[j + step] = temp; } } } } "},{"id":204,"href":"/program-design/data-structure/tree/","title":"树","section":"数据结构","content":"\r树\r#\r树\r#\rTree 是由结点和边组成的，不存在环的一种数据结构 是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合 特点\r#\r每个结点有零个或多个子结点 没有父结点的结点称为根结点 每一个非根结点有且只有一个父结点 除了根结点外，每个子结点可以分为多个不相交的子树 术语\r#\r度：结点的子树数目，如图：结点B的度为2 树的度：树中结点的最大度数，如图：树的度为3 树的深度：树中结点的最大层数，如图：树的深度为4 相互关系：祖先、后代、父子、兄弟 分支结点：度大于零的结点 叶子结点：度等于零的结点 分类\r#\r二叉树：一个结点最多只有两个子结点 满二叉树：除了最后一层，其它层的结点都有两个子结点 完全二叉树：除了最后一层，其他层的结点个数都要达到最大，且最后一层的结点从左到右排列 平衡二叉树：任意结点都满足：左右子树的高度差不大于1 二叉搜索树：任意结点都满足：左子结点 \u0026lt; 父结点 \u0026lt; 右子结点 树的遍历\r#\r前序遍历：根结点 ==\u0026gt; 左子树 ==\u0026gt; 右子树 中序遍历：左子树 ==\u0026gt; 根结点 ==\u0026gt; 右子树 后序遍历：左子树 ==\u0026gt; 右子树 ==\u0026gt; 根结点 依据【根结点】位置确定前/中/后序 "},{"id":205,"href":"/program-lang/java/thread/threadpool/","title":"线程池","section":"多线程","content":"\r线程池\r#\r一个容纳了多个线程的容器，里面的线程可以反复使用，避免频繁创建销毁线程。 作用\r#\r降低资源消耗 通过重复利用，降低线程创建和销毁造成的消耗 提高响应速度 当任务到达时，任务可以不需要等到线程创建就能立即执行 提高线程的可管理性 线程是稀缺资源，使用线程池可以进行统一分配，调优和监控 "},{"id":206,"href":"/program-lang/web/html/form/","title":"表单标签","section":"HTML","content":"\r\u0026lt;form\u0026gt;\r#\r属性 描述 accept-charset 字符集 action 提交目的地 URL method 提交方式，get、post target 打开方式，_blank 、_self、 _parent 、_top \u0026lt;form action=\u0026#34;xxx.php\u0026#34; method=\u0026#34;get\u0026#34;\u0026gt; 姓名：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; size=\u0026#34;15\u0026#34; placeholder=\u0026#34;请输入姓名\u0026#34; /\u0026gt; 密码：\u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;pwd\u0026#34; maxlength=\u0026#34;8\u0026#34; placeholder=\u0026#34;请输入密码\u0026#34; /\u0026gt; 照片：\u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;pic\u0026#34; /\u0026gt; 性别： \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;man\u0026#34; checked/\u0026gt;男 \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;woman\u0026#34; /\u0026gt;女 爱好： \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;read\u0026#34; checked/\u0026gt;读书 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;dance\u0026#34; /\u0026gt; 跳舞 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;sing\u0026#34; /\u0026gt; 唱歌 城市: \u0026lt;select name=\u0026#34;city\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;0\u0026#34; selected\u0026gt;__请选择__\u0026lt;/option\u0026gt; \u0026lt;optgroup label=\u0026#34;北方\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;bj\u0026#34;\u0026gt;北京\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;tj\u0026#34;\u0026gt;天津\u0026lt;/option\u0026gt; \u0026lt;/optgroup\u0026gt; \u0026lt;optgroup label=\u0026#34;南方\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;gz\u0026#34;\u0026gt;广州\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;sz\u0026#34;\u0026gt;深圳\u0026lt;/option\u0026gt; \u0026lt;/optgroup\u0026gt; \u0026lt;/select\u0026gt; 备注： \u0026lt;textarea name=\u0026#34;tips\u0026#34; cols=\u0026#34;5\u0026#34; rows=\u0026#34;5\u0026#34;\u0026gt; 这是一段多行文字 \u0026lt;/textarea\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;input\u0026gt;\r#\rtype 描述 hidden 隐藏 text 文本域 password 密码域 radio 单选框 checkbox 复选框 file 文件输入框 image 图片输入框 button 按钮 reset 重置按钮 submit 提交按钮 \u0026lt;select\u0026gt;\r#\r定义下拉列表 \u0026lt;select name=\u0026#34;cars\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;volvo\u0026#34;\u0026gt;Volvo\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;saab\u0026#34;\u0026gt;Saab\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;fiat\u0026#34;\u0026gt;Fiat\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;audi\u0026#34;\u0026gt;Audi\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;textarea\u0026gt;\r#\r定义多行文本 \u0026lt;textarea name=\u0026#34;message\u0026#34; rows=\u0026#34;10\u0026#34; cols=\u0026#34;30\u0026#34;\u0026gt; The cat was playing in the garden. \u0026lt;/textarea\u0026gt; \u0026lt;button\u0026gt;\r#\r定义按钮 \u0026lt;button type=\u0026#34;button\u0026#34; onclick=\u0026#34;alert(\u0026#39;Hello World!\u0026#39;)\u0026#34;\u0026gt; Click Me! \u0026lt;/button\u0026gt; \u0026lt;datalist\u0026gt;\r#\r定义选项列表 \u0026lt;input list=\u0026#34;browsers\u0026#34; name=\u0026#34;browser\u0026#34;\u0026gt; \u0026lt;datalist id=\u0026#34;browsers\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;Internet Explorer\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;Firefox\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;Chrome\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;Opera\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;Safari\u0026#34;\u0026gt; \u0026lt;/datalist\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; 其他\r#\rtype 描述 number 数值输入框 date 日期输入框 color 颜色输入框 range 范围输入框 month 年月输入框 week 年周输入框 time 时间输入框，无时区 datetime 时间输入框，有时区 datetime-local 时间输入框，日期和时间 email 邮箱输入框 tel 电话输入框 url url输入框 search 搜索框 \u0026hellip;\u0026hellip; 更多类型 "},{"id":207,"href":"/database/mysql/advanced-feature/view/","title":"视图","section":"高级特性","content":"\r视图\r#\r定义\r#\r视图是一种虚拟存在的表，对于使用视图的用户来说基本上是透明的 视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成 优点\r#\r简单：视图中数据即为目标数据，用户不需要关心对应的表的结构 安全：使用视图，可以限制用户只能访问他们被允许查询的结果集 数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响 视图管理\r#\r# 创建视图 create view 视图名 as select指令; # 使用视图 # 视图是一张虚拟表，可以直接把视图当做“表”来操作。 # 修改视图 alter view 视图名字 as 新select指令; # 删除视图 drop view 视图名; "},{"id":208,"href":"/database/oracle/plsql/object-oriented/","title":"面向对象","section":"PL/SQL","content":"\r面向对象\r#\r"},{"id":209,"href":"/database/mysql/advanced-feature/transaction/","title":"事务","section":"高级特性","content":"\r事务\r#\r定义\r#\rTransaction，一个最小的不可再分的工作单元，通常对应一个完整的业务 由事务开始和事务结束之间执行的全体操作组成 事务特性：ACID\r#\r原子性：Atomicity，事务应该当作一个单独单元的操作，要么成功，要么失败 一致性：Consistency，事务的执行不能破坏数据库数据的完整性和一致性 隔离性：Isolation，并发事务执行之间无影响 持久性：Durability，事务一旦执行成功，它对数据库的数据的改变必须是永久的 事务并发问题\r#\r脏读 一个事务处理过程里读取了另一个未提交的事务中的数据。 不可重复读 在一个事务中，对同一条记录，多次查询到的数据值不一致。（针对 update） 幻读 在一个事务中，对于多条记录，多次查询到的记录条数不一致。（针对 insert） 隔离级别\r#\r级别 隔离级别 描述 脏读 不可重复读 幻读 级别一 读未提交 可以读取到其他事务未提交的内容 √ √ √ 级别二 读已提交 只能读取到其他事务已经提交的数据 × √ √ 级别三 可重复读 整个事务过程中，对同数据的多次读取结果是相同的 × × √ 级别四 串行化 所有事务操作都依次顺序执行，性能最差 × × × 事务管理\r#\r# 开始一个事务 begin # 事务回滚 rollback # 事务确认 commit # 增加回滚点 savepoint 回滚点名; # 回到回滚点 rollback to 回滚点名; -- 创建数据表 create table runoob_transaction_test( id int(5)) engine=innodb; -- 开启事务 begin; -- 事务操作 insert into runoob_transaction_test value(5); insert into runoob_transaction_test value(6); -- 回滚事务 -- rollback; -- 提交事务 commit; "},{"id":210,"href":"/program-design/data-structure/heap/","title":"堆","section":"数据结构","content":"\r堆\r#\r堆\r#\rHeap 堆是一颗用数组实现的完全二叉树 堆中某个结点的值总是不大于或不小于其父结点的值 "},{"id":211,"href":"/program-design/design-pattern/structural/07-bridge/","title":"桥接模式","section":"结构型","content":"\r桥接模式\r#\r概述\r#\r英文：Bridge Pattern 简述：将两个能够独立变化的部分分离开来 归纳：约定优于配置 目的：不允许用继承 案例：桥 示例\r#\r// 品牌 public interface Brand { void sale(); } // 类似品牌：Shenzhou、Huawei public class Dell implements Brand { @Override public void sale() { System.out.println(\u0026#34;出售戴尔\u0026#34;); } } // 电脑 public class Computer { protected Brand brand; public Computer(Brand brand) { this.brand = brand; } public void sale(){ brand.sale(); } } // 类似电脑：Laptop public class Desktop extends Computer { public Desktop(Brand b) { super(b); } @Override public void sale() { super.sale(); System.out.println(\u0026#34;出售台式电脑\u0026#34;); } } public class Test { public static void main(String[] args) { Computer c = new Desktop(new Dell()); c.sale(); } } 应用\r#\r核心要点： 处理多维度变化的场景，将各个维度设计成独立的继承结构，桥接各个维度为一体 主要解决： 在多维度变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活 注意事项： 对于两个独立变化的维度，适合使用桥接模式 "},{"id":212,"href":"/database/oracle/plsql/trigger/","title":"触发器","section":"PL/SQL","content":"\r触发器\r#\r触发器\r#\r是一种特殊类型的存储过程，通过触发数据库特定事件而自动运行。 创建触发器\r#\r-- 语法 CREATE [OR REPLACE ] TRIGGER trigger_name {BEFORE | AFTER | INSTEAD OF } -- 指定何时执行触发器。INSTEAD OF 子句用于视图 {INSERT [OR] | UPDATE [OR] | DELETE} -- 指定 DML 操作类型 [OF col_name] -- 指定将要更新的列 ON tbl_name -- 指定与触发器关联的表 [REFERENCING OLD AS o NEW AS n] -- 允许各种 DML 语句引用新值和旧值 [FOR EACH ROW] -- 行触发器：作用于每一行（否则仅执行一次，即表触发器） WHEN (condition) -- 为触发器触发的行提供一个条件。仅对行级触发器有效 DECLARE Declaration-statements BEGIN Executable-statements EXCEPTION Exception-handling-statements END; -- 示例 CREATE OR REPLACE TRIGGER display_salary_changes BEFORE DELETE OR INSERT OR UPDATE ON customers FOR EACH ROW WHEN (NEW.ID \u0026gt; 0) DECLARE sal_diff number; BEGIN sal_diff := :NEW.salary - :OLD.salary; DBMS_OUTPUT.put_line(\u0026#39;Old salary: \u0026#39; || :OLD.salary); DBMS_OUTPUT.put_line(\u0026#39;New salary: \u0026#39; || :NEW.salary); DBMS_OUTPUT.put_line(\u0026#39;Salary difference: \u0026#39; || sal_diff); END; 删除触发器\r#\r-- 删除触发器 DROP TRIGGER trigger_name; -- 禁用/启用触发器 ALTER TRIGGER trigger_name {DISABLE|ENABLEND}; "},{"id":213,"href":"/program-design/data-algorithm/sort/counting/","title":"计数排序","section":"排序算法","content":"\r计数排序\r#\r计数排序\r#\r要求输入的数据必须是有确定范围的整数 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 算法步骤\r#\r找出待排序的数组中最大和最小的元素 统计数组中每个值为i的元素出现的次数，存入数组C的第i项 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加） 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1 动图演示\r#\r代码实现\r#\rpublic class CountingSort implements IArraySort { @Override public int[] sort(int[] arr) throws Exception { int maxValue = getMaxValue(arr); return countingSort(arr, maxValue); } private int[] countingSort(int[] arr, int maxValue) { int bucketLen = maxValue + 1; int[] bucket = new int[bucketLen]; for (int value : arr) { bucket[value]++; } int sortedIndex = 0; for (int j = 0; j \u0026lt; bucketLen; j++) { while (bucket[j] \u0026gt; 0) { arr[sortedIndex++] = j; bucket[j]--; } } return arr; } private int getMaxValue(int[] arr) { int maxValue = arr[0]; for (int value : arr) { if (maxValue \u0026lt; value) { maxValue = value; } } return maxValue; } } "},{"id":214,"href":"/database/oracle/plsql/function/","title":"函数","section":"PL/SQL","content":"\r函数\r#\r自定义函数\r#\r创建函数\r#\r-- 语法 CREATE [OR REPLACE] FUNCTION function_name [(parameter_name [IN | OUT | IN OUT] type [, ...])] RETURN return_datatype {IS | AS} BEGIN \u0026lt; function_body \u0026gt; END [function_name]; -- 示例 CREATE OR REPLACE FUNCTION fun_max( p_num1 IN NUMBER, p_num2 IN NUMBER DEFAULT 99 ) RETURN NUMBER IS BEGIN IF p_num1\u0026gt;p_num2 THEN RETURN p_num1; ELSE RETURN p_num2; END IF; END; 调用函数\r#\r-- 方式1 SELECT fun_max(20) FROM DUAL; -- 方式2 BEGIN DBMS_OUTPUT.put_line(fun_max(12,20)); END; -- 方式3 DECLARE v_num NUMBER; BEGIN v_num := fun_max(12,20); DBMS_OUTPUT.put_line(v_num); END; 删除函数\r#\rDROP FUNCTION fun_max; "},{"id":215,"href":"/program-design/data-structure/graph/","title":"图","section":"数据结构","content":"\r图\r#\r图\r#\rGraph 是一系列结点的集合，这些顶点通过边进行连接 这些结点称为顶点，边是顶点的有序偶对 分类\r#\r有向图：边不仅连接两个顶点，并且具有方向 无向图：边仅仅连接两个顶点，没有其他含义 "},{"id":216,"href":"/program-design/data-algorithm/sort/radix/","title":"基数排序","section":"排序算法","content":"\r基数排序\r#\r基数排序\r#\r是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。 基数排序 vs 计数排序 vs 桶排序\r#\r都利用了桶的概念\n基数排序：根据键值的每位数字来分配桶；\n计数排序：每个桶只存储单一键值；\n桶排序：每个桶存储一定范围的数值；\n​\n算法步骤\r#\r将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。 然后，从最低位开始，依次进行一次排序。 这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。 动图演示\r#\r代码实现\r#\r/** * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9 */ public class RadixSort implements IArraySort { @Override public int[] sort(int[] arr) throws Exception { int maxDigit = getMaxDigit(arr); return radixSort(arr, maxDigit); } // 获取最高位数 private int getMaxDigit(int[] arr) { int maxValue = getMaxValue(arr); return getNumLenght(maxValue); } private int getMaxValue(int[] arr) { int maxValue = arr[0]; for (int value : arr) { if (maxValue \u0026lt; value) { maxValue = value; } } return maxValue; } protected int getNumLenght(long num) { if (num == 0) { return 1; } int lenght = 0; for (long temp = num; temp != 0; temp /= 10) { lenght++; } return lenght; } private int[] radixSort(int[] arr, int maxDigit) { int mod = 10; int dev = 1; for (int i = 0; i \u0026lt; maxDigit; i++, dev *= 10, mod *= 10) { // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10) int[][] counter = new int[mod * 2][0]; for (int j = 0; j \u0026lt; arr.length; j++) { int bucket = ((arr[j] % mod) / dev) + mod; counter[bucket] = arrayAppend(counter[bucket], arr[j]); } int pos = 0; for (int[] bucket : counter) { for (int value : bucket) { arr[pos++] = value; } } } return arr; } // 自动扩容，并保存数据 private int[] arrayAppend(int[] arr, int value) { arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; } } "},{"id":217,"href":"/program-design/design-pattern/structural/08-facade/","title":"外观模式","section":"结构型","content":"\r外观模式\r#\r概述\r#\r英文：Facade Pattern 简述：对外提供一个统一的接口用来访问子系统 归纳：打开一扇门，通向全世界 目的：统一访问入口 案例：前台 示例\r#\r// 子系统 public interface Shape { void draw(); } // 类似子系统：Rectangle、Square public class Circle implements Shape { @Override public void draw() { System.out.println(\u0026#34;Circle::draw()\u0026#34;); } } // 外观类 public class ShapeMaker { private Shape circle; private Shape rectangle; private Shape square; public ShapeMaker() { circle = new Circle(); rectangle = new Rectangle(); square = new Square(); } public void drawCircle() { circle.draw(); } public void drawRectangle() { rectangle.draw(); } public void drawSquare() { square.draw(); } } public class Test { public static void main(String[] args) { ShapeMaker shapeMaker = new ShapeMaker(); shapeMaker.drawCircle(); shapeMaker.drawRectangle(); shapeMaker.drawSquare(); } } 应用\r#\r主要解决： 降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口 应用场景： JAVA 的三层开发模式 为复杂的模块或子系统提供外界访问的模块 子系统相对独立 预防低水平人员带来的风险 注意事项： 在层次化结构中，可以使用外观模式定义系统中每一层的入口 "},{"id":218,"href":"/program-design/data-algorithm/sort/bucket/","title":"桶排序","section":"排序算法","content":"\r桶排序\r#\r桶排序\r#\r是计数排序的升级版。它利用了函数的映射关系 影响效率的因素\r#\r桶的数量 映射函数将输入的 N 个数据分配到 K 个桶中的均匀程度 桶内的排序算法 示意图\r#\r代码实现\r#\rpublic class BucketSort implements IArraySort { private static final InsertSort insertSort = new InsertSort(); @Override public int[] sort(int[] arr) throws Exception { return bucketSort(arr, 5); } private int[] bucketSort(int[] arr, int bucketSize) throws Exception { if (arr.length == 0) { return arr; } int minValue = arr[0]; int maxValue = arr[0]; for (int value : arr) { if (value \u0026lt; minValue) { minValue = value; } else if (value \u0026gt; maxValue) { maxValue = value; } } int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1; int[][] buckets = new int[bucketCount][0]; // 利用映射函数将数据分配到各个桶中 for (int i = 0; i \u0026lt; arr.length; i++) { int index = (int) Math.floor((arr[i] - minValue) / bucketSize); buckets[index] = arrAppend(buckets[index], arr[i]); } int arrIndex = 0; for (int[] bucket : buckets) { if (bucket.length \u0026lt;= 0) { continue; } // 对每个桶进行排序，这里使用了插入排序 bucket = insertSort.sort(bucket); for (int value : bucket) { arr[arrIndex++] = value; } } return arr; } // 自动扩容，并保存数据 private int[] arrAppend(int[] arr, int value) { arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; } } "},{"id":219,"href":"/program-design/design-pattern/structural/09-composite/","title":"组合模式","section":"结构型","content":"\r组合模式\r#\r概述\r#\r英文：Composite Pattern 简述：将整体与局部（树形结构）进行递归组合，让客户端能够以一致的方式对其进行处理 归纳：人在一起叫团伙，心在一起叫团队 目的：统一整体和个体 案例：组织架构树 示例\r#\r// 节点 public class Employee { // 节点属性 private String name; private String dept; public Employee(String name, String dept) { this.name = name; this.dept = dept; subEmployees = new ArrayList\u0026lt;\u0026gt;(); } // setter、getter // ...... // 子节点集合 private List\u0026lt;Employee\u0026gt; subEmployees; public List\u0026lt;Employee\u0026gt; getSubEmployees() { return subEmployees; } public void add(Employee employee) { subEmployees.add(employee); } public void remove(Employee employee) { subEmployees.remove(employee); } } public class Test { public static void main(String[] args) { Employee CEO = new Employee(\u0026#34;John\u0026#34;,\u0026#34;CEO\u0026#34;); Employee headSales = new Employee(\u0026#34;Robert\u0026#34;,\u0026#34;Head Sales\u0026#34;); Employee headMarketing = new Employee(\u0026#34;Michel\u0026#34;,\u0026#34;Head Marketing\u0026#34;); Employee clerk = new Employee(\u0026#34;Laura\u0026#34;,\u0026#34;Marketing\u0026#34;); Employee salesExecutive = new Employee(\u0026#34;Richard\u0026#34;,\u0026#34;Sales\u0026#34;); CEO.add(headSales); CEO.add(headMarketing); headSales.add(salesExecutive); headMarketing.add(clerk); //打印所有雇员 printEmployee(CEO); } private static void printEmployee(Employee employee){ System.out.println(employee); for (Employee subEmployee : employee.getSubEmployees()) { printEmployee(subEmployee); } } } 应用\r#\r主要解决： 树型结构问题 应用场景： 部分、整体场景，如树形菜单，文件、文件夹的管理 注意事项： 只要是树形结构，就要考虑使用组合模式 "},{"id":220,"href":"/database/oracle/plsql/procedure/","title":"过程","section":"PL/SQL","content":"\r过程\r#\r过程 vs 函数\r#\r声明：函数必须包含一条 RETURN 子句，而存储过程没有 RETURN 子句 调用：函数可以在查询语句中直接调用，而存储过程必须单独调用 创建\r#\r-- 语法 CREATE [OR REPLACE] PROCEDURE procedure_name [(parameter_name [IN | OUT | IN OUT] type [, ...])] {IS | AS} BEGIN \u0026lt; procedure_body \u0026gt; END procedure_name; -- 示例 CREATE OR REPLACE PROCEDURE greetings AS BEGIN dbms_output.put_line(\u0026#39;Hello World!\u0026#39;); END; 执行\r#\r-- 方式1 EXEC greetings; EXECUTE greetings; -- 方式2 CALL greetings; -- 方式2 BEGIN greetings; END; 删除\r#\rDROP PROCEDURE greetings; 示例\r#\rDECLARE a NUMBER; b NUMBER; c NUMBER; PROCEDURE findMin(x IN NUMBER, y IN NUMBER, z OUT NUMBER) IS BEGIN IF x \u0026lt; y THEN z:= x; ELSE z:= y; END IF; END; BEGIN a:= 12; b:= 35; findMin(a, b, c); DBMS_OUTPUT.put_line(\u0026#39;12、35中的较小值是 : \u0026#39; || c); END; DECLARE a NUMBER; PROCEDURE squareNum(x IN OUT NUMBER) IS BEGIN x := x * x; END; BEGIN a:= 11; squareNum(a); dbms_output.put_line(\u0026#39; Square of (11): \u0026#39; || a); END; "},{"id":221,"href":"/program-design/design-pattern/structural/10-flyweight/","title":"享元模式","section":"结构型","content":"\r享元模式\r#\r概述\r#\r英文：Flyweight Pattern 简述：使用对象池来减少重复对象的创建 归纳：优化资源配置，减少重复浪费 目的：共享资源池 案例：全国社保联网 示例\r#\r// 享元类 public interface IChess { public void draw(); } public class Chess implements IChess { // 内部状态：不可改变，可以共享 private String color; public Chess(String color) { this.color = color; } // 外部状态：可以改变，不可共享 private String position; public void setPosition(String position) { this.position = position; } @Override public void draw() { System.out.println(\u0026#34;围棋：color=\u0026#34; + color + \u0026#34;, position=\u0026#34; + position); } } // 享元工厂 public class ChessFactory { // 池容器 private static final HashMap\u0026lt;String, IChess\u0026gt; chessMap = new HashMap\u0026lt;\u0026gt;(); // 获取享元对象 public static Chess getChess(String color) { if (!chessMap.containsKey(color)) { chessMap.put(color, new Chess(color)); } return (Chess) chessMap.get(color); } } public class Test { public static void main(String[] args) { Chess chess; for (int i = 0; i \u0026lt; 3; i++) { for (int j = 0; j \u0026lt; 3; j++) { if (new Random().nextBoolean()) { chess = ChessFactory.getChess(\u0026#34;黑色\u0026#34;); } else { chess = ChessFactory.getChess(\u0026#34;白色\u0026#34;); } chess.setPosition(\u0026#34;x\u0026#34; + i + \u0026#34;y\u0026#34; + j); chess.draw(); } } } } 应用\r#\r主要解决： 在有大量对象时，有可能会造成内存溢出。 把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建 应用场景： 系统有大量相似对象 需要缓冲池的场景 注意事项： 注意划分外部状态和内部状态，否则可能会引起线程安全问题。 这些类必须有一个工厂对象加以控制 "},{"id":222,"href":"/program-design/data-algorithm/sort/heap/","title":"堆排序","section":"排序算法","content":"\r堆排序\r#\r堆排序\r#\r堆是一个二叉树，其子结点的键值或索引总是小于（或者大于）它的父节点 堆排序就是利用堆这种特性进行排序 算法步骤\r#\r创建一个堆 H[0……n-1]； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤 2，直到堆的尺寸为 1。 动图演示\r#\r代码实现\r#\rpublic class HeapSort implements IArraySort { @Override public int[] sort(int[] arr) throws Exception { int len = arr.length; buildMaxHeap(arr, len); for (int i = len - 1; i \u0026gt; 0; i--) { swap(arr, 0, i); len--; heapify(arr, 0, len); } return arr; } private void buildMaxHeap(int[] arr, int len) { for (int i = (int) Math.floor(len / 2); i \u0026gt;= 0; i--) { heapify(arr, i, len); } } private void heapify(int[] arr, int i, int len) { int left = 2 * i + 1; int right = 2 * i + 2; int largest = i; if (left \u0026lt; len \u0026amp;\u0026amp; arr[left] \u0026gt; arr[largest]) { largest = left; } if (right \u0026lt; len \u0026amp;\u0026amp; arr[right] \u0026gt; arr[largest]) { largest = right; } if (largest != i) { swap(arr, i, largest); heapify(arr, largest, len); } } private void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } "},{"id":223,"href":"/database/oracle/plsql/cursor/","title":"游标","section":"PL/SQL","content":"\r游标\r#\r简介\r#\r游标是一种处理数据的机制，提供了在结果集中查看和处理数据的能力 游标可以指定结果集中的任何位置，并允许用户对数据进行处理，类似集合中的迭代器 优缺点：消耗内存，提高 sql 执行效率 语法\r#\r不带参数 DECLARE CURSOR cur_stu_info -- 定义游标 IS SELECT * FROM stu_info; v_stu_info cur_stu_info%ROWTYPE; -- 定义变量，用于保存游标检索结果行 BEGIN OPEN cur_stu_info; -- 打开游标 LOOP -- 循环遍历 FETCH cur_stu_info INTO v_stu_info; -- 提取数据 DBMS_OUTPUT.put_line( -- 处理数据 v_stu_info.id || \u0026#39;:\u0026#39; || v_stu_info.name ); EXIT WHEN cur_stu_info%NOTFOUND; -- 游标检索完后退出循环 END LOOP; CLOSE cur_stu_info; -- 关闭游标 END; 带参数 DECLARE CURSOR cur_stu_info(v_id stu_info.id%type) IS SELECT * FROM stu_info t WHERE t.id = v_id; v_stu_info stu_info%ROWTYPE; BEGIN OPEN cur_stu_info(123); FETCH cur_stu_info INTO v_stu_info; DBMS_OUTPUT.put_line(v_stu_info.id || \u0026#39; : \u0026#39; || v_stu_info.name); CLOSE cur_stu_info; END; 属性\r#\r属性 返回值类型 作用 sql%ISOPEN 布尔型 判断游标是否 ”开启“ sql%FOUND 布尔型 判断游标是否 ”获取” 到值 sql%NOTFOUND 布尔型 判断游标是否 ”没有获取” 到值 sql%ROWCOUNT 整型 ”当前” 成功执行的数据行数（非 ”总记录数”） 结构\r#\r当游标打开后，才会执行查询语句，查询到的数据会被接收到一块内存区域中存储，直到游标关闭。 游标实际上指向的是一块内存区域，此块内存位于进程全局区域内部，称为上下文区域。 分类\r#\r静态游标：隐式游标、隐式游标 动态游标：自定义类型、系统类型 显式游标\r#\r显式游标是必须通过编写必要的PL/SQL例程来进行管理的游标。 游标的整个生命期都在用户的控制之下 见 语法 隐式游标\r#\r自动创建：DML语句、select into语句 自动管理：自动声明、打开、关闭，默认游标名为 \u0026lsquo;SQL\u0026rsquo; declare v_count number; begin insert into stu_info (id, name, sex) values (3, \u0026#39;瑶瑶\u0026#39;, \u0026#39;女\u0026#39;); if sql%found then dbms_output.put_line(\u0026#39;插入成功!\u0026#39;); end if; update stu_info t set t.name = \u0026#39;悠悠\u0026#39; where t.id = 3; if sql%found then dbms_output.put_line(\u0026#39;更新成功!\u0026#39;); end if; delete from stu_info t where t.id = 3; if sql%found then dbms_output.put_line(\u0026#39;删除成功!\u0026#39;); end if; select count(1) into v_count from stu_info t; if sql%found then dbms_output.put_line(\u0026#39;总记录为： \u0026#39; || v_count); end if; if sql%isopen then dbms_output.put_line(\u0026#39;不可能的，永远不可能走这一步\u0026#39;); else dbms_output.put_line(\u0026#39;系统已自动关闭游标\u0026#39;); end if; end; "},{"id":224,"href":"/dev-tool/git/","title":"Git","section":"开发工具","content":"\rGit\r#\r是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目 Git官网 配置\r#\r系统级：/etc/gitconfig\n用户级：[用户目录]/.gitconfig\n项目级：[项目目录]/.git/config\n# 配置个人的用户名称和电子邮件地址 $ git config --global user.name \u0026#34;xxx\u0026#34; $ git config --global user.email xxx@163.com # 配置Git默认使用的文本编辑器 $ git config --global core.editor emacs # 配置差异分析工具 $ git config --global merge.tool vimdiff # 查看配置信息 $ git config --list "},{"id":225,"href":"/program-lang/web/markdown/","title":"Markdown","section":"Web","content":"\rMarkdown\r#\r概述\r#\r是一种可以使用普通文本编辑器编写的 标记语言 通过简单的标记语法，它可以使普通文本内容具有一定的格式 标题\r#\r语法 # h1 ## h2 ### h3 #### h4 ##### h5 ###### h6 文字\r#\r语法\n*斜体* **粗体** ***斜体粗体*** ~~删除线~~ 效果\n斜体 粗体 斜体粗体 删除线\n图片\r#\r语法\n![百度](https://www.baidu.com/img/baidu_jgylogo3.gif \u0026#34;百度一下\u0026#34;) 效果\n链接\r#\r语法\n//超链接 [百度](http://baidu.com \u0026#34;百度一下\u0026#34;) //自动链接 \u0026lt;address@example.com\u0026gt; //页内超链接 设锚点：\u0026lt;a id=\u0026#34;link\u0026#34;\u0026gt;目标位置\u0026lt;/a\u0026gt; 跳转到：[锚点](#link) 效果\n百度 address@example.com 设锚点：目标位置 跳转到：锚点\n列表\r#\r语法\n//无序列表 - item //有序列表 1. item 效果\nitem item 表格\r#\r语法\n左对齐|居中|右对齐 -|:-:|-: 1|2|3 a|b|c 效果\n左对齐 居中 右对齐 1 2 3 a b c 代码\r#\r语法\n`单行代码` ​```javascript // 多行代码 function fun(){ echo \u0026#34;Hello World!\u0026#34;; } ​``` 效果\n单行代码\n// 多行代码 function fun(){ echo \u0026#34;Hello World!\u0026#34;; } 分割线\r#\r语法\n--- 效果\n引用\r#\r语法\n\u0026gt; 一级引用内容 \u0026gt;\u0026gt; 二级引用内容 \u0026gt;\u0026gt;\u0026gt; 三级引用内容 ...... 效果\n一级引用内容\n二级引用内容\n三级引用内容\n"},{"id":226,"href":"/framework/quartz/","title":"Quartz","section":"开源框架","content":"\rQuartz\r#\r是一个完全由 java 编写的开源任务调度框架 核心类\r#\rJob：任务接口，承载着要被执行的具体业务逻辑 JobDetail：任务实例，记录着自定义任务的详细信息 Trigger：触发器，记录着任务的调度规则 Scheduler：调度器，负责基于 Trigger 触发器，来执行 Job 任务 "},{"id":227,"href":"/database/redis/","title":"Redis","section":"数据存储","content":"\rRedis\r#\rRemote Dictionary Server，是完全开源免费的，遵守 BSD 协议，是一个高性能的 key-value 数据库 Redis 参考手册 特点\r#\r支持数据的持久化 支持多种数据结构的存储 支持数据的备份 优势\r#\r性能极高 丰富的数据类型 所有操作都是原子性的 丰富的特性 "},{"id":228,"href":"/program-design/data-algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","title":"动态规划","section":"数据算法","content":"\r定义\r#\rDynamic Programming，简称DP 通过把复杂问题拆分为一系列单阶段子问题，利用各阶段之间的关系，递推出最终解 核心思想：是利用空间换时间，通过存储已经计算过的子问题的解，从而减少计算量 经典应用：背包问题、最短路径问题、最长公共子序列、股票买卖问题 特征\r#\r重叠子问题：原问题的求解过程中，相同的子问题会多次出现 最优子结构：原问题的最优解可以由其子问题的最优解递归地构建而成 无后效性：某阶段状态一旦确定，就不会受到后续决策的影响 步骤\r#\r定义状态：确定问题的状态，将大问题分解为子问题，并确定子问题所对应的状态 状态转移：根据问题的性质，建立状态之间的转移关系，即状态转移方程 确定边界：确定初始状态和边界条件 求最优解：从初始状态开始求解问题，并保存中间结果，递推得到最终问题的最优解 示例1\r#\r描述\n题解\n示例2\r#\r描述\n题解\n"},{"id":229,"href":"/database/oracle/plsql/package/","title":"包","section":"PL/SQL","content":"\r包\r#\rPL/SQL 包\r#\r包是一种数据对象，是对相关类型、子程序、游标、异常、变量、常量的封装。 用于将逻辑相关的 PL/SQL 块或元素组织在一起，作为一个完整的单元存储在数据库中。 创建包规范\r#\r包规范：定义了可以从包外部引用的类型、变量、常量、异常、游标和子程序 ，即被公开的部分 CREATE PACKAGE cust_sal AS PROCEDURE find_sal(c_id customers.id%type); END cust_sal; 创建包体\r#\r包体：具有包规范中声明的各种方法代码和其他私有声明，这些声明对包之外的代码是隐藏的 CREATE OR REPLACE PACKAGE BODY cust_sal AS PROCEDURE find_sal(c_id customers.id%TYPE) IS c_sal customers.salary%TYPE; BEGIN SELECT salary INTO c_sal FROM customers WHERE id = c_id; DBMS_OUTPUT.put_line(\u0026#39;Salary: \u0026#39;|| c_sal); END find_sal; END cust_sal; 调用包\r#\r-- 语法 package_name.element_name; -- 示例：调用cust_sal包中的find_sal方法 DECLARE code customers.id%type := \u0026amp;cc_id; BEGIN cust_sal.find_sal(code); END; 示例\r#\r-- 数据表 Select * from customers; /* +----+----------+-----+-----------+----------+ | ID | NAME | AGE | ADDRESS | SALARY | +----+----------+-----+-----------+----------+ | 1 | Ramesh | 32 | Ahmedabad | 3000.00 | | 2 | Khilan | 25 | Delhi | 3000.00 | | 3 | kaushik | 23 | Kota | 3000.00 | | 4 | Chaitali | 25 | Mumbai | 7500.00 | | 5 | Hardik | 27 | Bhopal | 9500.00 | | 6 | Komal | 22 | MP | 5500.00 | +----+----------+-----+-----------+----------+ */ -- 包规范 CREATE OR REPLACE PACKAGE c_package AS -- Adds a customer PROCEDURE addCustomer( c_id customers.id%TYPE, c_name customers.name%TYPE, c_age customers.age%TYPE, c_addr customers.address%TYPE, c_sal customers.salary%TYPE ); -- Removes a customer PROCEDURE delCustomer(c_id customers.id%TYPE); --Lists all customers PROCEDURE listCustomer; END c_package; -- 包体 CREATE OR REPLACE PACKAGE BODY c_package AS PROCEDURE addCustomer( c_id customers.id%type, c_name customers.name%type, c_age customers.age%type, c_addr customers.address%type, c_sal customers.salary%type) IS BEGIN INSERT INTO customers (id,name,age,address,salary) VALUES(c_id, c_name, c_age, c_addr, c_sal); END addCustomer; PROCEDURE delCustomer(c_id customers.id%type) IS BEGIN DELETE FROM customers WHERE id = c_id; END delCustomer; PROCEDURE listCustomer IS CURSOR c_customers IS SELECT name FROM customers; TYPE c_list IS TABLE OF customers.name%type; name_list c_list := c_list(); counter integer :=0; BEGIN FOR n IN c_customers LOOP counter := counter +1; name_list.extend; name_list(counter) := n.name; dbms_output.put_line(\u0026#39;Customer(\u0026#39; ||counter|| \u0026#39;)\u0026#39;||name_list(counter)); END LOOP; END listCustomer; END c_package; -- 使用程序包 DECLARE code customers.id%type:= 8; BEGIN c_package.addcustomer(7, \u0026#39;Andy Liu\u0026#39;, 25, \u0026#39;Chennai\u0026#39;, 3500); c_package.addcustomer(8, \u0026#39;Kobe Bryant\u0026#39;, 32, \u0026#39;Delhi\u0026#39;, 7500); c_package.listcustomer; c_package.delcustomer(code); c_package.listcustomer; END; -- 结果 /* Old salary: New salary: 3500 Salary difference: Old salary: New salary: 7500 Salary difference: Customer(1)Ramesh Customer(2)Khilan Customer(3)kaushik Customer(4)Chaitali Customer(5)Hardik Customer(6)Komal Customer(7)Andy Liu Customer(8)Kobe Bryant Customer(1)Ramesh Customer(2)Khilan Customer(3)kaushik Customer(4)Chaitali Customer(5)Hardik Customer(6)Komal Customer(7)Andy Liu */ "},{"id":230,"href":"/program-lang/java/thread/","title":"多线程","section":"Java","content":"\r优点\r#\r充分利用多核CPU的计算能力 方便进行业务拆分，提升系统并发能力和性能 缺点\r#\r频繁的上下文切换（任务从保存到再加载的过程） 引起线程安全问题 上下文切换\r#\r当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态 以便下次再切换回这个任务时，可以再加载这个任务的状态。 任务从保存到再加载的过程就是一次上下文切换。 "},{"id":231,"href":"/program-design/design-pattern/structural/11-adapter/","title":"适配器模式","section":"结构型","content":"\r适配器模式\r#\r概述\r#\r英文：Adapter Pattern 简述：将原来不兼容的两个类匹配在一起 归纳：万能充电器 目的：兼容转换 案例：电源适配 示例\r#\r// 源 public class Adaptee { public void adapteeMethod() { System.out.println(\u0026#34;Adaptee method!\u0026#34;); } } // 目标 public interface Target { void adapteeMethod(); void adapterMethod(); } // 适配器 public class Adapter implements Target { private Adaptee adaptee; public Adapter(Adaptee adaptee) { this.adaptee = adaptee; } @Override public void adapteeMethod() { adaptee.adapteeMethod(); } @Override public void adapterMethod() { System.out.println(\u0026#34;Adapter method!\u0026#34;); } } public class Test { public static void main(String[] args) { Target target = new Adapter(new Adaptee()); target.adapteeMethod(); target.adapterMethod(); } } 应用\r#\r主要解决： 现存系统中，将一些“存在的对象”放到新环境中。而这些现存对象，不能满足新环境接口的要求 应用场景： JAVA 中的 jdbc 有动机地修改一个正常运行的系统的接口 注意事项： 适配器不是在详细设计时添加的，而是解决正在服役的项目的问题 "},{"id":232,"href":"/framework/kafka/","title":"Kafka","section":"开源框架","content":"\rKafka\r#\r是一种高吞吐量的分布式发布订阅消息系统 使用场景：日志收集、消息系统、用户活动跟踪、运营指标 Kafka 特性\r#\r高吞吐量、低延迟 kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒 可扩展性 kafka集群支持热扩展 持久性、可靠性 消息被持久化到本地磁盘，并且支持数据备份防止数据丢失 容错性 允许集群中节点失败（若副本数量为n,则允许n-1个节点失败） 高并发 支持数千个客户端同时读写 "},{"id":233,"href":"/program-design/data-algorithm/binary/","title":"二分查找","section":"数据算法","content":"\r二分查找\r#\r条件\r#\r要求待查找的序列有序 算法步骤\r#\r每次取中间位置的值与待查值比较， 如果中间位置的值比待查值大，则在前半部分循环这个查找的过程， 如果中间位置的值比待查值小，则在后半部分循环这个查找的过程。 直到查找到了为止，否则序列中没有待查的关键字。 代码实现\r#\rpublic static int binarySearch(int[] array, int key) { int low = 0; int hight = array.length - 1; int mid; while (low \u0026lt;= hight) { // 中间位置 mid = (low + hight) / 2; if (array[mid] == key) { return mid + 1; } // 向右查找 else if (array[mid] \u0026lt; key) { low = mid + 1; } // 向左查找 else { hight = mid - 1; } } return -1; } "},{"id":234,"href":"/program-lang/java/jvm/","title":"虚拟机","section":"Java","content":"\rJava 运行\r#\rJVM 结构\r#\r类加载器，Class Loader 执行引擎，Execution Engine 运行时数据区，Runtime Data Area 本地方法接口，Native Interface "},{"id":235,"href":"/program-design/design-pattern/structural/12-decorator/","title":"装饰器模式","section":"结构型","content":"\r装饰器模式\r#\r概述\r#\r英文：Decorator Pattern 简述：不改变原类结构、不使用继承的情况下，动态地给一个对象添加一些额外的职责。 归纳：他大舅他二舅都是他舅 目的：灵活扩展、同宗同源 案例：煎饼 示例\r#\r// 被装饰类 public interface Shape { void draw(); } // 类似形状：Circle public class Rectangle implements Shape { @Override public void draw() { System.out.println(\u0026#34;Shape: 正方形\u0026#34;); } } // 装饰类 public abstract class ShapeDecorator implements Shape { protected Shape shape; public ShapeDecorator(Shape shape) { this.shape = shape; } @Override public void draw() { shape.draw(); } } // 类似装饰类:GreenShapeDecorator public class RedShapeDecorator extends ShapeDecorator { public RedShapeDecorator(Shape shape) { super(shape); } @Override public void draw() { super.draw(); setRedBorder(shape); } private void setRedBorder(Shape shape) { System.out.println(\u0026#34;Border Color: Red\u0026#34;); } } public class Test { public static void main(String[] args) { Shape circle = new Circle(); ShapeDecorator redCircle = new RedShapeDecorator(new Circle()); ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle()); System.out.println(\u0026#34;Circle with normal border\u0026#34;); circle.draw(); System.out.println(\u0026#34;Circle of red border\u0026#34;); redCircle.draw(); System.out.println(\u0026#34;Rectangle of red border\u0026#34;); redRectangle.draw(); } } 应用\r#\r主要解决： 使用继承方式扩展类的功能，随着扩展功能的增多，导致子类膨胀问题 应用场景： 扩展一个类的功能、动态增加/撤销功能 注意事项： 可代替继承 "},{"id":236,"href":"/program-design/design-pattern/behavioural/13-state/","title":"状态模式","section":"行为型","content":"\r状态模式\r#\r概述\r#\r英文：State Pattern 简述：根据不同的状态做出不同的行为 归纳：状态驱动行为，行为决定状态 目的：状态驱动行为，行为决定状态 案例：订单状态跟踪 示例\r#\r// 状态类 public abstract class LiftState { // 定义一个环境角色 protected Context context; public void setContext(Context context) { this.context = context; } public abstract void open(); public abstract void close(); public abstract void run(); public abstract void stop(); } // 类似状态：ClosingState、RunningState、StoppingState public class OpeningState extends LiftState { @Override public void close() { super.context.setLiftState(Context.closingState); super.context.getLiftState().close(); } @Override public void open() { System.out.println(\u0026#34;电梯门开启...\u0026#34;); } @Override public void run() { //do nothing; } @Override public void stop() { //do nothing; } } // 环境类 public class Context { // 定义出所有的电梯状态 public final static OpeningState openingState = new OpeningState(); public final static ClosingState closingState = new ClosingState(); public final static RunningState runningState = new RunningState(); public final static StoppingState stoppingState = new StoppingState(); // 定一个当前电梯状态 private LiftState liftState; public LiftState getLiftState() { return liftState; } public void setLiftState(LiftState liftState) { this.liftState = liftState; // 把当前的环境通知到各个实现类中 this.liftState.setContext(this); } public void open() { this.liftState.open(); } public void close() { this.liftState.close(); } public void run() { this.liftState.run(); } public void stop() { this.liftState.stop(); } } public class Test { public static void main(String[] args) { Context context = new Context(); context.setLiftState(new OpeningState()); context.open(); context.close(); context.run(); context.stop(); } } 应用\r#\r主要解决： 对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。 应用场景： 行为随状态改变而改变的场景、条件/分支语句的代替者 注意事项： 在行为受状态约束的时候使用状态模式，而且状态不超过 5 个 "},{"id":237,"href":"/program-design/design-pattern/behavioural/14-strategy/","title":"策略模式","section":"行为型","content":"\r策略模式\r#\r概述\r#\r英文：Strategy Pattern 简述：封装不同的算法，算法之间能互相替换 归纳：条条大道通罗马，具体哪条你来定 目的：把选择权交给用户 案例：选择支付方式 示例\r#\r业务场景：获取多种数据库的元数据\n// 策略类 public interface DatabaseMeta { void getColumns(); } // 类似策略类：PgsqlDatabaseMeta、OracleDatabaseMeta public class MysqlDatabaseMeta implements DatabaseMeta { @Override public void getColumns() { System.out.println(\u0026#34;Mysql column...\u0026#34;); } } // 环境类 public class Context { private DatabaseMeta meta; public Context(DatabaseMeta meta) { this.meta = meta; } public void getColumns() { meta.getColumns(); } } public class Test { public static void main(String[] args) { Context context; context = new Context(new MysqlDatabaseMeta()); context.getColumns(); context = new Context(new PgsqlDatabaseMeta()); context.getColumns(); context = new Context(new OracleDatabaseMeta()); context.getColumns(); } } 应用\r#\r主要解决： 在有多种相似算法的情况下，使用if/else所带来的复杂和难以维护的问题 应用场景： 许多相关的类仅仅是行为有异 需要使用一个算法的不同变体 一个类定义了多种行为，并且这些行为以多个条件语句的形式出现 注意事项： 如果策略类多于四个，就需要考虑使用混合模式，防止策略类膨胀 "},{"id":238,"href":"/program-design/design-pattern/behavioural/15-template/","title":"模板模式","section":"行为型","content":"\r模板模式\r#\r概述\r#\r英文：Template Pattern 简述：定义一套流程模板，根据需要实现模板中的操作 归纳：流程全部标准化，需要微调请覆盖 目的：逻辑复用 案例：把大象装进冰箱 示例\r#\r// 模板类 public abstract class Game { abstract void initialize(); abstract void startPlay(); abstract void endPlay(); // 模板方法 public final void play() { init(); startPlay(); endPlay(); } } // 类似实例：Volleyball public class Football extends Game { @Override void init() { System.out.println(\u0026#34;Football：Initialized! Start playing.\u0026#34;); } @Override void startPlay() { System.out.println(\u0026#34;Football：Started. Enjoy the game!\u0026#34;); } @Override void endPlay() { System.out.println(\u0026#34;Football：Finished!\u0026#34;); } } public class Test { public static void main(String[] args) { new Football().play(); new Volleyball().play(); } } 应用\r#\r主要解决： 一些方法通用，却在每一个子类都重新写了这一方法 应用场景： 有多个子类共有的方法，且逻辑相同； 重要的、复杂的方法，可以考虑作为模板方法 注意事项： 为防止恶意操作，一般模板方法都加上 final 关键词 "},{"id":239,"href":"/program-design/design-pattern/behavioural/16-command/","title":"命令模式","section":"行为型","content":"\r命令模式\r#\r概述\r#\r英文：Command Pattern 简述：将请求封装成命令，并记录下来，能够撤销与重做 归纳：运筹帷幄之中，决胜千里之外 目的：解耦请求和处理 案例：遥控器 示例\r#\r// 命令 public interface Command { void execute(); } // 开机命令ConcreteCommand public class CommandOn implements Command { private Tv myTv; public CommandOn(Tv tv) { myTv = tv; } public void execute() { myTv.turnOn(); } } // 关机命令ConcreteCommand public class CommandOff implements Command { private Tv myTv; public CommandOff(Tv tv) { myTv = tv; } public void execute() { myTv.turnOff(); } } // 频道切换命令ConcreteCommand public class CommandChange implements Command { private Tv myTv; private int channel; public CommandChange(Tv tv, int channel) { myTv = tv; this.channel = channel; } public void execute() { myTv.changeChannel(channel); } } // 可以看作是遥控器Invoker public class Control { private List\u0026lt;Command\u0026gt; commandList = new ArrayList\u0026lt;\u0026gt;(); public void addAction(Command command) { commandList.add(command); } public void action() { for (Command command : commandList) { command.execute(); } } } // 命令接收者Receiver public class Tv { public int currentChannel = 0; public void turnOn() { System.out.println(\u0026#34;The televisino is on.\u0026#34;); } public void turnOff() { System.out.println(\u0026#34;The television is off.\u0026#34;); } public void changeChannel(int channel) { this.currentChannel = channel; System.out.println(\u0026#34;Now TV channel is \u0026#34; + channel); } } public class Test { public static void main(String[] args) { Tv myTv = new Tv(); CommandOn on = new CommandOn(myTv); CommandOff off = new CommandOff(myTv); CommandChange channel = new CommandChange(myTv, 2); // 开机 Control control = new Control(); control.addAction(on); control.addAction(channel); control.addAction(off); // 执行 control.action(); } } 应用\r#\r主要解决： 在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系， 但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种紧耦合的设计就不太合适。 应用场景： 认为是命令的地方都可以使用命令模式 注意事项： 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式 "},{"id":240,"href":"/program-design/design-pattern/behavioural/17-iterator/","title":"迭代器模式","section":"行为型","content":"\r迭代器模式\r#\r概述\r#\r英文：Iterator Pattern 简述：提供一种方法顺序访问一个聚合对象中的各个元素，而又无须暴露该对象的内部细节 归纳：流水线上坐一天，每个包裹扫一遍 目的：统一对集合的访问方式 案例：逐个检票进站 示例\r#\r// 抽象迭代器 public interface Iterator { public boolean hasNext(); public Object next(); } // 抽象聚合 public interface Container { public Iterator getIterator(); } // 具体聚合 public class NameRepository implements Container { public String[] names = {\u0026#34;Robert\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Julie\u0026#34;, \u0026#34;Lora\u0026#34;}; @Override public Iterator getIterator() { return new NameIterator(); } // 具体迭代器 private class NameIterator implements Iterator { int index = 0; @Override public boolean hasNext() { return index \u0026lt; names.length; } @Override public Object next() { if (this.hasNext()) { return names[index++]; } return null; } } } public class Test { public static void main(String[] args) { NameRepository names = new NameRepository(); Iterator iter = names.getIterator(); while (iter.hasNext()) { String name = (String) iter.next(); System.out.println(\u0026#34;Name : \u0026#34; + name); } } } 应用\r#\r主要解决： 不同的方式来遍历整个整合对象 应用场景： 遍历一个聚合对象 注意事项： Java 已经把迭代器模式融入到集合框架 API 中，直接使用 java.util.Iterator 即可 "},{"id":241,"href":"/program-design/design-pattern/behavioural/18-interpreter/","title":"解释器模式","section":"行为型","content":"\r解释器模式\r#\r概述\r#\r英文：Interpreter Pattern 简述：给定一个语言，定义它的语法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子 归纳：我想说”方言“，一切解释权都归我 目的：实现特定语法解析 案例：摩斯密码 示例\r#\r// 解释器 public interface Expression { public boolean interpret(String context); } // 解释器TerminalExpression public class TerminalExpression implements Expression { private String data; public TerminalExpression(String data) { this.data = data; } @Override public boolean interpret(String context) { return context.contains(data); } } // 解释器OrExpression public class OrExpression implements Expression { private Expression expr1; private Expression expr2; public OrExpression(Expression expr1, Expression expr2) { this.expr1 = expr1; this.expr2 = expr2; } @Override public boolean interpret(String context) { return expr1.interpret(context) || expr2.interpret(context); } } // 解释器AndExpression public class AndExpression implements Expression { private Expression expr1; private Expression expr2; public AndExpression(Expression expr1, Expression expr2) { this.expr1 = expr1; this.expr2 = expr2; } @Override public boolean interpret(String context) { return expr1.interpret(context) \u0026amp;\u0026amp; expr2.interpret(context); } } public class Test { //规则：Robert 和 John 是男性 public static Expression getMaleExpression() { Expression robert = new TerminalExpression(\u0026#34;Robert\u0026#34;); Expression john = new TerminalExpression(\u0026#34;John\u0026#34;); return new OrExpression(robert, john); } //规则：Julie 是一个已婚的女性 public static Expression getMarriedWomanExpression() { Expression julie = new TerminalExpression(\u0026#34;Julie\u0026#34;); Expression married = new TerminalExpression(\u0026#34;Married\u0026#34;); return new AndExpression(julie, married); } public static void main(String[] args) { Expression isMale = getMaleExpression(); Expression isMarriedWoman = getMarriedWomanExpression(); System.out.println(\u0026#34;John is male? \u0026#34; + isMale.interpret(\u0026#34;John\u0026#34;)); System.out.println(\u0026#34;Julie is a married women? \u0026#34; + isMarriedWoman.interpret(\u0026#34;Married Julie\u0026#34;)); } } 应用\r#\r主要解决： 对于一些固定文法构建一个解释句子的解释器 注意事项： 可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替 "},{"id":242,"href":"/program-design/design-pattern/behavioural/19-observer/","title":"观察者模式","section":"行为型","content":"\r观察者模式\r#\r概述\r#\r英文：Observer Pattern 简述：状态发生改变时通知观察者，一对多的关系 归纳：到点就通知我 目的：解耦观察者与被观察者 案例：闹钟 示例\r#\r// 目标 public class Subject { private int state; private List\u0026lt;Observer\u0026gt; observers = new ArrayList\u0026lt;\u0026gt;(); public int getState() { return state; } public void setState(int state) { this.state = state; notifyAllObservers(); } public void attach(Observer observer) { observers.add(observer); } public void notifyAllObservers() { for (Observer observer : observers) { observer.update(); } } } // 抽象观察者 public abstract class Observer { protected Subject subject; public abstract void update(); } // 观察者BinaryObserver public class BinaryObserver extends Observer{ public BinaryObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( \u0026#34;Binary String: \u0026#34; + Integer.toBinaryString( subject.getState() ) ); } } // 观察者OctalObserver public class OctalObserver extends Observer{ public OctalObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( \u0026#34;Octal String: \u0026#34; + Integer.toOctalString( subject.getState() ) ); } } // 观察者HexaObserver public class HexaObserver extends Observer{ public HexaObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( \u0026#34;Hex String: \u0026#34; + Integer.toHexString( subject.getState() ).toUpperCase() ); } } public class Test { public static void main(String[] args) { Subject subject = new Subject(); new HexaObserver(subject); new OctalObserver(subject); new BinaryObserver(subject); System.out.println(\u0026#34;First state change: 15\u0026#34;); subject.setState(15); System.out.println(\u0026#34;Second state change: 10\u0026#34;); subject.setState(10); } } 应用\r#\r主要解决： 一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作 注意事项： 避免循环引用 JAVA 中已经有了对观察者模式的支持类 如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。 "},{"id":243,"href":"/program-design/design-pattern/behavioural/20-visitor/","title":"访问者模式","section":"行为型","content":"\r访问者模式\r#\r概述\r#\r英文：Visitor Pattern 简述：稳定数据结构，定义新的操作行为 归纳：横看成岭侧成峰，远近高低各不同 目的：解耦数据结构和数据操作 案例：KPI考核 示例\r#\r// 被访问者：员工 public abstract class Staff { public String name; public int kpi; public Staff(String name) { this.name = name; kpi = new Random().nextInt(10); } // 核心方法，接受Visitor的访问 public abstract void accept(Visitor visitor); } // 工程师 public class Engineer extends Staff { public Engineer(String name) { super(name); } @Override public void accept(Visitor visitor) { visitor.visit(this); } // 工程师一年的代码数量 public int getCodeLines() { return new Random().nextInt(10 * 10000); } } // 经理 public class Manager extends Staff { public Manager(String name) { super(name); } @Override public void accept(Visitor visitor) { visitor.visit(this); } // 一年做的产品数量 public int getProducts() { return new Random().nextInt(10); } } // 访问者 public interface Visitor { // 访问工程师类型 void visit(Engineer engineer); // 访问经理类型 void visit(Manager manager); } // CEO访问者 public class CEOVisitor implements Visitor { @Override public void visit(Engineer engineer) { System.out.println(\u0026#34;工程师: \u0026#34; + engineer.name + \u0026#34;, KPI: \u0026#34; + engineer.kpi); } @Override public void visit(Manager manager) { System.out.println(\u0026#34;经理: \u0026#34; + manager.name + \u0026#34;, KPI: \u0026#34; + manager.kpi + \u0026#34;, 新产品数量: \u0026#34; + manager.getProducts()); } } // CTO访问者 public class CTOVisitor implements Visitor { @Override public void visit(Engineer engineer) { System.out.println(\u0026#34;工程师: \u0026#34; + engineer.name + \u0026#34;, 代码行数: \u0026#34; + engineer.getCodeLines()); } @Override public void visit(Manager manager) { System.out.println(\u0026#34;经理: \u0026#34; + manager.name + \u0026#34;, 产品数量: \u0026#34; + manager.getProducts()); } } // 员工业务报表类 public class BusinessReport { private List\u0026lt;Staff\u0026gt; mStaffs = new LinkedList\u0026lt;\u0026gt;(); public BusinessReport() { mStaffs.add(new Manager(\u0026#34;经理-A\u0026#34;)); mStaffs.add(new Engineer(\u0026#34;工程师-A\u0026#34;)); mStaffs.add(new Engineer(\u0026#34;工程师-B\u0026#34;)); mStaffs.add(new Engineer(\u0026#34;工程师-C\u0026#34;)); mStaffs.add(new Manager(\u0026#34;经理-B\u0026#34;)); mStaffs.add(new Engineer(\u0026#34;工程师-D\u0026#34;)); } /** * 为访问者展示报表 * @param visitor 公司高层，如CEO、CTO */ public void showReport(Visitor visitor) { for (Staff staff : mStaffs) { staff.accept(visitor); } } } public class Test { public static void main(String[] args) { // 构建报表 BusinessReport report = new BusinessReport(); System.out.println(\u0026#34;=========== CEO看报表 ===========\u0026#34;); report.showReport(new CEOVisitor()); System.out.println(\u0026#34;=========== CTO看报表 ===========\u0026#34;); report.showReport(new CTOVisitor()); } } 应用\r#\r主要解决： 稳定的数据结构和易变的操作耦合问题 注意事项： 访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器 "},{"id":244,"href":"/program-design/design-pattern/behavioural/21-mediator/","title":"中介者模式","section":"行为型","content":"\r中介者模式\r#\r概述\r#\r英文：Mediator Pattern 简述：将对象之间的通信关联关系封装到一个中介类中单独处理，从而使其耦合松散 归纳：联系方式我给你，怎么搞定我不管 目的：统一管理网状资源 案例：朋友圈 示例\r#\r// 中介者 public class ChatRoom { public static void showMessage(User user, String message) { System.out.println(new Date().toString() + \u0026#34; [\u0026#34; + user.getName() + \u0026#34;] : \u0026#34; + message); } } // 用户 public class User { @Setter @Getter private String name; public User(String name) { this.name = name; } public void sendMessage(String message) { ChatRoom.showMessage(this, message); } } public class Test { public static void main(String[] args) { User robert = new User(\u0026#34;Robert\u0026#34;); User john = new User(\u0026#34;John\u0026#34;); robert.sendMessage(\u0026#34;Hi! John!\u0026#34;); john.sendMessage(\u0026#34;Hello! Robert!\u0026#34;); } } 应用\r#\r主要解决： 对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂， 同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。 使用场景： 系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。 注意事项： 不应当在职责混乱的时候使用。 "},{"id":245,"href":"/program-design/design-pattern/behavioural/22-memento/","title":"备忘录模式","section":"行为型","content":"\r备忘录模式\r#\r概述\r#\r英文：Memento Pattern 简述：保存对象的状态，在需要时进行恢复 归纳：失足不成千古恨，想重来时就重来 目的：备份、后悔机制 案例：草稿箱 示例\r#\r// 备忘录 public class Memento { private String state; public Memento(String state) { this.state = state; } public String getState() { return state; } } // 备忘录管理员 public class CareTaker { private List\u0026lt;Memento\u0026gt; mementoList = new ArrayList\u0026lt;Memento\u0026gt;(); public void add(Memento state) { mementoList.add(state); } public Memento get(int index) { return mementoList.get(index); } } // 发起人 public class Originator { private String state; public void setState(String state) { this.state = state; } public String getState() { return state; } public Memento saveStateToMemento() { return new Memento(state); } public void getStateFromMemento(Memento Memento) { state = Memento.getState(); } } public class Test { public static void main(String[] args) { Originator originator = new Originator(); CareTaker careTaker = new CareTaker(); originator.setState(\u0026#34;State #1\u0026#34;); originator.setState(\u0026#34;State #2\u0026#34;); careTaker.add(originator.saveStateToMemento()); originator.setState(\u0026#34;State #3\u0026#34;); careTaker.add(originator.saveStateToMemento()); originator.setState(\u0026#34;State #4\u0026#34;); System.out.println(\u0026#34;Current State: \u0026#34; + originator.getState()); originator.getStateFromMemento(careTaker.get(0)); System.out.println(\u0026#34;First saved State: \u0026#34; + originator.getState()); originator.getStateFromMemento(careTaker.get(1)); System.out.println(\u0026#34;Second saved State: \u0026#34; + originator.getState()); } } 应用\r#\r主要解决： 所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态， 并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。 使用场景： 需要保存/恢复数据的相关状态场景。 提供一个可回滚的操作。 注意事项： 为了符合迪米特原则，还要增加一个管理备忘录的类。 为了节约内存，可使用原型模式+备忘录模式 "},{"id":246,"href":"/program-design/design-pattern/behavioural/23-chainOfResponsibility/","title":"职责链模式","section":"行为型","content":"\r职责链模式\r#\r概述\r#\r英文：Chain of Responsibility Pattern 简述： 拦截的类都实现统一接口，每个接收者都包含对下一个接收者的引用。 将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 归纳：各人自扫门前雪，莫管他们瓦上霜 目的：解耦处理逻辑 案例：踢皮球 示例\r#\r// 处理者 public abstract class Logger { public static int INFO = 1; public static int DEBUG = 2; public static int ERROR = 3; protected int level; //责任链中的下一个元素 protected Logger nextLogger; public void setNextLogger(Logger nextLogger) { this.nextLogger = nextLogger; } public void logMessage(int level, String message) { if (this.level \u0026lt;= level) { write(message); } if (nextLogger != null) { nextLogger.logMessage(level, message); } } abstract protected void write(String message); } // 处理者ConsoleLogger public class ConsoleLogger extends Logger { public ConsoleLogger(int level) { this.level = level; } @Override protected void write(String message) { System.out.println(\u0026#34;StandardConsole: \u0026#34; + message); } } // 处理者ErrorLogger public class ErrorLogger extends Logger { public ErrorLogger(int level) { this.level = level; } @Override protected void write(String message) { System.out.println(\u0026#34;ErrorConsole: \u0026#34; + message); } } // 处理者FileLogger public class FileLogger extends Logger { public FileLogger(int level) { this.level = level; } @Override protected void write(String message) { System.out.println(\u0026#34;FileConsole: \u0026#34; + message); } } public class Test { private static Logger getChainOfLoggers() { Logger errorLogger = new ErrorLogger(Logger.ERROR); Logger fileLogger = new FileLogger(Logger.DEBUG); Logger consoleLogger = new ConsoleLogger(Logger.INFO); errorLogger.setNextLogger(fileLogger); fileLogger.setNextLogger(consoleLogger); return errorLogger; } public static void main(String[] args) { Logger loggerChain = getChainOfLoggers(); loggerChain.logMessage(Logger.INFO, \u0026#34;info-message\u0026#34;); loggerChain.logMessage(Logger.DEBUG, \u0026#34;debug-message\u0026#34;); loggerChain.logMessage(Logger.ERROR, \u0026#34;error-message\u0026#34;); } } 应用\r#\r主要解决： 将请求的发送者和请求的处理者解耦 使用场景： 有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求 可动态指定一组对象处理请求 注意事项： 责任链模式其实就是一个灵活版的if…else…语句 "}]