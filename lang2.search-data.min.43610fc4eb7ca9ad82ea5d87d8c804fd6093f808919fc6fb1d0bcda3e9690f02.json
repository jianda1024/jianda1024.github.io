[{"id":0,"href":"/lang2/dev-tool/git/","title":"Git","section":"开发工具","content":"\r\u0026ndash; 版本控制\r#\rSVN：是基于差异的版本控制，存储的是一组基本文件和每个文件随时间逐步累积的差异\n优缺点：节省磁盘空间，耗时、效率低。 不适合的领域：跨地域的协同开发、追求高质量代码和代码门禁 Git：是基于快照的版本控制，存储的是文件的一系列快照\n优缺点：版本切换时非常快，占用磁盘空间较大 不适合的领域：目录级别的读授权、word等二进制文档的版本控制 \u0026ndash; Git 工作流程\r#\r工作区：日常工作的工程目录\n暂存区：又称索引，工程根目录.git/index 文件夹\n版本区：又称本地仓库，工程根目录.git文件夹\n\u0026ndash; Git 基本命令\r#\r"},{"id":1,"href":"/lang2/framework/mq/mq/","title":"MQ","section":"MQ","content":"\r\u0026ndash; MQ\r#\rMessage Queue，消息队列 是一种面向消息的中间件，用于实现不同系统之间的异步通信 优点：解耦、异步、削峰 \u0026ndash; MQ 原理\r#\r1. 生产者（Producer）将消息发送到消息队列中，而不是直接发送给消费者（Consumer）。 2. 消息队列将接收到的消息存储在内部的消息存储区（Message Store）中。 3. 消费者从消息队列中拉取消息，并进行处理。 4. 消费者处理完消息后，可以发送确认消息给消息队列，表示消息已经成功处理。 5. 消息队列根据消费者的确认消息，决定是否将消息从消息存储区中删除。 \u0026ndash; MQ 消息传递模式\r#\r1. 点对点模式 一对一，消费者主动拉取数据，消息收到后消息清除 2. 发布/订阅模式 一对多，数据生产后，推送给所有订阅者 \u0026ndash; RabbitMQ、RocketMQ、Kafka\r#\rRabbitMQ RocketMQ Kafka 单机吞吐量 最差（万级） 最高（十万级） 次之（十万级） 消息延迟 微秒级 毫秒级，比Kafka快 毫秒级 消息批量操作 不支持 支持 支持 事务 不支持 支持 不支持 "},{"id":2,"href":"/lang2/database/mysql/p1/","title":"Part.1","section":"MySQL","content":"\r\u0026ndash; 数据库三范式\r#\r第一范式：原子性，字段是最小数据单元\n员工表，姓名字段仅包含员工的正式名称，就符合第一范式， 反之包含中文名、英文名、别名等，则意味着姓名字段是再拆分的 第二范式：唯一性，每一行都有唯一标识\n员工表，定义工号作为主键 第三范式：独立性，非主键字段完全依赖于主键字段\n员工表包含了部门编码，它引用到部门表中的部门编号这个主键，此时符合第三范式 如果在员工表中又包含一个部门名称，则造成了数据的冗余，不符合第三范式 \u0026ndash; InnoDB、MyISAM\r#\r区别\n区别 InnoDB MyISAM 锁级别 行级锁 表级锁 主键 必须有 可以没有 事务、外键、自增列 支持 不支持 . 全文索引 不支持 支持 表的具体行数 不保存 保存 存储空间 占用较多 占用较少 使用建议\nInnoDB：可靠性高或者要求事务处理的、表更新和查询都相当频繁的 MyISAM：做很多count的计算的、插入修改不频繁而查询非常频繁的 \u0026ndash; 事务\r#\r多条sql语句，要么全部成功，要么全部失败 \u0026ndash; 事务特性\r#\r特性 ACID 说明 原子性 Atomicity 事务应该当作一个单独单元的操作，要么成功，要么失败 一致性 Consistency 事务的执行不能破坏数据库数据的完整性和一致性 隔离性 Isolation 并发事务执行之间无影响 持久性 Durability 事务一旦执行成功，它对数据库的数据的改变必须是永久的 \u0026ndash; 事务并发问题\r#\r问题 说明 脏读 一个事务处理过程里读取了另一个未提交的事务中的数据。 不可重复读 在一个事务中，对同一条记录，多次查询到的数据值不一致。（针对 update） 幻读 在一个事务中，对于多条记录，多次查询到的记录条数不一致。（针对 insert） \u0026ndash; 事务隔离级别\r#\r级别 隔离级别 描述 脏读 不可重复读 幻读 级别一 读未提交 可以读取到其他事务未提交的内容 √ √ √ 级别二 读已提交 只能读取到其他事务已经提交的数据 × √ √ 级别三 可重复读 整个事务过程中，对同数据的多次读取结果是相同的 × × √ 级别四 串行化 所有事务操作都依次顺序执行，性能最差 × × × \u0026ndash; 索引\r#\r是帮助 MySQL 高效获取数据的数据结构 优点：类似书的目录，可以极大地提高数据检索速度 缺点：维护索引会增加额外的开销 \u0026ndash; 索引类型\r#\r索引 说明 普通索引 最基本的索引，没有任何限制 唯一索引 索引列的值必须是唯一的，允许有空值 主键索引 索引列的值必须是唯一的，不允许有空值，一张表中只能定义一个主键 全文索引 只能在文本类型CHAR、VARCHAR、TEXT类型字段上创建全文索引 组合索引 由多个列组合创建的索引，用于组合查询优化 \u0026ndash; 视图\r#\r是一个虚拟的表，它基于一个或多个数据库表的查询结果而创建，具有和物理表相同的功能。 视图的数据实际上存放在基本中，改变基表的数据会自动反映在其视图中 \u0026ndash; 内联接、左联接、右联接\r#\r内连接 INNER JOIN 获取两个表中，符合字段匹配关系的记录 左连接 LEFT JOIN 获取左表所有记录，及右表匹配到的记录，右表中未匹配到的字段则用NULL表示 右连接 RIGHT JOIN 获取右表所有记录，及左表匹配到的记录，左表中未匹配到的字段则用NULL表示 \u0026ndash; SQL优化\r#\r1. 查询语句中不要使用select * 2. 尽量减少子查询，使用关联查询替代 3. 尽量减少使用in、not in，使用exists、not exists或者关联查询语句替代 4. 尽量减少使用or, 使用 union、union all代替 5. 对于字符串类型的列，查询时没有加上引号，会使索引失效 6. 对于like查询，占位符放在前部，会使索引失效 7. 在where子句中，尽量避免以下操作，这将导致引擎放弃使用索引而进行全表扫描 a. 使用!=或\u0026lt;\u0026gt;操作 b. 进行null值判断 c. 对字段进行函数/表达式运算 d. = 的左边进行函数/表达式运算 \u0026ndash; 大表优化\r#\r1. 限定数据的范围 务必禁止不带任何限制数据范围条件的SQL查询语句。 2. 读/写分离 主库负责写，从库负责读 3. 垂直分区 根据数据表的相关性，拆分数据表的列，把一张列比较多的表拆分为多张表 4. 水平分区 保持数据表结构不变，通过某种策略存储数据分片。 这样每一片数据分散到不同的表或者库中，达到了分布式的目的 \u0026ndash; char、varchar\r#\r定长字符串类型：char 变长字符串类型：varchar 对效率要求高用 char，对空间使用要求高用 varchar \u0026ndash; delete、truncate、drop\r#\r区别 delete truncate drop 速度 慢 中 快 空间 不释放空间 恢复到初始大小 释放全部空间 表结构 不删 不删 删除 类型 DML DDL DDL 事务 支持 不支持 不支持 trigger 触发 不触发 不触发 生效时机 事务提交后生效 执行立即生效 执行立即生效 "},{"id":3,"href":"/lang2/database/redis/p1/","title":"Part.1","section":"Redis","content":"\r\u0026ndash; Redis\r#\rRemote Dictionary Server 是一个开源、基于内存、支持多种数据结构的存储系统，可以作为数据库、缓存和消息中间件。 \u0026ndash; Redis 持久化：RDB\r#\rRedis DataBase\n在指定的时间间隔内，定时的将Redis存储的数据生成快照并存储到磁盘上 持久化文件：dump.rdb 触发时机\n1. 通过配置文件的配置参数自动触发 save 300 10 # 在300秒内，如果至少有10个键发生变化，就会触发RDB快照保存 2. 通过调用Redis命令手动触发 SAVE # 会阻塞当前Redis服务器，直到持久化完成，线上应该禁止使用 BGSAVE # 该触发方式会fork一个子进程，由子进程负责持久化过程，因此阻塞只会发生在fork子进程的时候 优点\n1. 只有一个文件dump.rdb，方便持久化。 2. 容灾性好，一个文件可以保存到安全的磁盘。 3. 性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，保证了Redis的高性能 4. 相对于数据集大时，比AOF的启动效率更高。 缺点\n1. 数据安全性低。如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改 2. 每次保存RDB的时候，Redis都要fork()出一个子进程。这可能会非常耗时，造成服务器暂时停止处理客户端。 \u0026ndash; Redis 持久化：AOF\r#\rAppend Only File\n以日志的形式来记录每个写指令，并追加到文件中。当Redis重启时，通过重新执行这些写命令，就能实现数恢复。 持久化文件：appendonly.aof 触发时机\n1. 通过配置文件的配置参数自动触发 auto-aof-rewrite-min-size 64mb # AOF文件的最小大小 auto-aof-rewrite-percentage 100 # AOF文件大小相对于上次重写后的增长比例 2. 通过调用Redis命令手动触发 BGREWRITEAOF # 开启AOF文件的重写，且不会影响Redis的正常运行 优点\n1. 数据安全性高 2. 解决了数据一致性问题 3. AOF机制的rewrite模式 缺点\n1. AOF文件比RDB文件大，且恢复速度慢。 2. 数据集大的时候，比RDB启动效率低。 \u0026ndash; Redis 数据类型\r#\r字符串：String\n最基本的数据类型，可以存储字符串或数字 应用场景：缓存会话、配置参数、计数器 哈希：Hash\n键值对的集合 应用场景：用户属性、配置文件 列表：List\n有序列表，支持两端插入和删除 应用场景：消息队列、栈或队列、最新帖子列表 集合：Set\n无序集合，元素唯一 应用场景：共同好友、标签、去重 有序集合：Zset\n有序集合，元素唯一，每个元素关联一个分数，元素按分数排序 应用场景：排行榜、延迟队列 \u0026ndash; Redis 过期策略\r#\rRedis采用：定期删除+惰性删除 过期策略 说明 优点 缺点 定时删除 为每个定时键创建一个定时器，一旦过期就立即删除 对内存友好 对CPU不友好 定期删除 每隔一段时间随机抽查一些键，删除其中已经过期的键 兼顾内存与CPU 难以衡量删除操作的执行频率 惰性删除 只有在访问键时，才会检查键是否过期，过期则删除 对CPU友好 对内存不友好，会造成内存泄漏 \u0026ndash; Redis 内存淘汰策略\r#\r如果定期删除漏掉了很多过期的key，也没有及时去查（即未走惰性删除），则通过内存淘汰策略释放内存\n内存淘汰策略：当Redis的内存超过了配置的最大内存值时，以一定的策略释放内存\n策略 说明 noeviction 默认策略，不进行内存淘汰，当内存不足时，新写入命令会报错 allkeys-lru 从所有键值对中，移除最近最少使用的键值对 allkeys-random 从所有键值对中，随机移除某个键值对 volatile-lru 在设置了过期时间的键值对中，移除最近最少使用的键值对 volatile-random 在设置了过期时间的键值对中，随机移除某个键值对 volatile-ttl 在设置了过期时间的键值对中，移除剩余生存时间最短的键值对 \u0026ndash; Redis 单线程却高效的原因\r#\rC语言实现 纯内存操作 高效的数据结构和算法‌ 基于非阻塞的IO复用模型机制 单线程操作，避免了频繁的上下文切换 \u0026ndash; 缓存雪崩\r#\r缓存雪崩\n同一时间大面积的缓存数据过期，此时又有大批量的请求这些数据。 缓存中取不到数据，就会将请求全部转发到数据库，造成数据库瞬时压力过重宕机。 从而形成一系列连锁反应，造成整个系统崩溃 解决方法\n1. 尽量错开缓存过期时间 2. 并发不是特别多的时候，使用加锁或者队列的方式，防止瞬时大量并发 3. 给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存 \u0026ndash; 缓存穿透\r#\r缓存穿透\n指查询数据库中一定不存在的数据，在缓存中自然也查不到，每次都要去数据库再查询一遍， 以至于产生了两次无用查询，每次请求都会到达数据库，就失去了使用缓存的意义 解决方法\n1. 采用布隆过滤器 将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉 2. 缓存空查询 将空结果也缓存起来，设置较短的过期时间，如此第二次就不会继续访问数据库了 \u0026ndash; 缓存预热\r#\r缓存预热\n就是系统上线后，提前将相关的缓存数据直接加载到缓存系统 解决方法\n1. 直接写个缓存刷新页面，上线时手工操作下 2. 数据量不大，可以在项目启动的时候自动进行加载 3. 定时刷新缓存 "},{"id":4,"href":"/lang2/framework/spring/p1/","title":"Part.1","section":"Spring","content":"\r\u0026ndash; Spring\r#\rSpring 是一个开源的轻量级 Java 开发框架 Spring 的核心是控制反转（IoC）和面向切面（AOP） \u0026ndash; Spring 优点\r#\r方便解耦，简化开发 用户可以将所有对象的创建和依赖关系的维护，交给Spring管理 支持AOP编程 Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能 支持声明式事务 只需要通过配置就可以完成对事务的管理，而无需手动编程 方便程序测试 Spring对Junit4支持，可以通过注解方便的测试Spring程序 集成各种优秀框架 Spring内部提供了对各种优秀框架的直接支持 简化JavaEE的使用 Spring对JavaEE开发中非常难用的一些API，都提供了封装，降低了使用难度 \u0026ndash; IOC\r#\rInversion of Control，即“控制反转”，是一种设计思想，用于解决对象之间的耦合问题。 以前对象的创建及依赖关系是由开发人员自己维护，现在反转交给 spring 来完成创建及注入 控制：指的是对象创建（实例化、管理）的权利 反转：控制权交给外部环境了（spring框架、IoC容器） \u0026ndash; IoC 容器\r#\r具有依赖注入功能的容器，它可以创建对象，负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖 IoC容器底层其实就是一个Bean工厂，Spring提供了两种IoC容器，即BeanFactory、ApplicationContext BeanFactory：最简单的IoC容器，它提供了IoC容器最基本的功能 ApplicationContext：BeanFactory的子接口，并添加了更多的企业特定的功能 \u0026ndash; IOC、DI\r#\rDI，Dependency Injection，即“依赖注入”，由容器动态的将某个依赖关系注入到组件之中。 IOC 是一种软件设计思想，DI 是这种软件设计思想的一个实现。 \u0026ndash; AOP\r#\rAspect Oriented Programming，面向切面编程，是一种编程思想 是通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术 在面向对象编程(OOP)中，基本单元是类(class)，而 AOP 中的基本单元是切面(aspect) OOP是解决了纵向的代码复用问题，AOP是解决了横向的代码复用问题 \u0026ndash; AOP 术语\r#\r术语 名称 描述 Jointpoint 连接点 程序类中，允许插入通知（Advice）的位置点 Pointcut 切入点 程序类中，已经插入通知（Advice）的位置点 Advice 通知、增强 在切入点（Pointcut）上要执行的代码 Aspect 切面 是切入点（Pointcut）和通知（Advice）的结合 Target 目标 被织入通知（Advice）的目标对象，这个对象永远是一个被代理对象 Weaving 织入 将通知（Advice）添加到目标类具体连接点上的过程 \u0026ndash; AOP 通知类型\r#\r通知 说明 备注 around 环绕通知 在建议方法调用之前和之后，执行通知。 before 前置通知 在一个方法执行之前，执行通知。 after 后置通知 在一个方法执行之后，不考虑其结果，执行通知。 after-returning 正常返回通知 在一个方法执行之后，只有在方法成功完成时，才能执行通知。 after-throwing 异常返回通知 在一个方法执行之后，只有在方法退出抛出异常时，才能执行通知。 \u0026ndash; Bean\r#\rBean是指由Spring IoC容器实例化、组装和管理的对象 可以把Spring IoC容器看作是一个大工厂，Bean就相当于工厂的产品 \u0026ndash; Bean 作用域\r#\r对于prototype作用域的Bean来说，Spring IoC 容器只负责创建 作用域 描述 singleton 默认值，在 spring IoC 容器仅存在一个 Bean 实例 prototype 每次通过 Spring 容器获取 Bean 时，容器都会创建一个新的 Bean 实例 request 每次 HTTP 请求，容器都会创建一个 Bean 实例， 仅在当前 HTTP Request 内有效 session 同一个 HTTP Session 共享一个 Bean 实例，仅在当前 HTTP Session 内有效 application 同一个 Web 应用共享一个 Bean 实例，在当前 ServletContext 内有效 \u0026ndash; Bean 生命周期\r#\r实例化\n对于BeanFactory容器，当被请求未初始化的bean时，容器就会调用createBean进行实例化。 对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean 属性注入\n实例化后的对象被封装在BeanWrapper对象中，Spring根据BeanDefinition、BeanWrapper完成属性注入 初始化\n1、处理Aware接口 若Bean实现了接口BeanNameAware，则执行setBeanName()，设置bean的名字 若Bean实现了接口BeanFactoryAware，则执行setBeanFactory()，设置BeanFactory 若Bean实现了接口ApplicationContextAware，则执行setApplicationContext()，设置应用上下文 2、BeanPostProcessor前置处理 若Bean实现了接口BeanPostProcessor，则先执行postProcessBeforeInitialization() 3、InitializingBean与init-method 若Bean实现了接口InitializingBean，则执行afterPropertiesSet() 若Bean配置了属性init-method，则执行自定义方法； 4、BeanPostProcessor后置处理 若Bean实现了接口BeanPostProcessor，则先执行postProcessAfterInitialization() 使用\n此时 Bean 已经准备就绪，可以被使用了 销毁\n当Bean不再需要时，会进入清理阶段 若Bean实现了DisposableBean接口，则会调用其destory()； 若Bean配置了destory-method属性，则会调用其配置的销毁方法。 \u0026ndash; Spring 用到的设计模式\r#\r单例模式\n当使用Bean默认作用域时，用到了单例模式 在整个应用程序中只有一个Bean实例，由Spring容器负责管理 类似的如Service层的业务逻辑组件、DAO层的数据访问组件也是单例 原型模式\n当设置Bean为prototype作用域时，用到了原型模式 每次获取的是通过克隆生成的新实例，对其进行修改时，对原有实例对象不造成任何影响。 工厂模式\nSpring中的BeanFactory、ApplicationContext类，用到了工厂模式 由工厂类根据传入的参数，动态的决定实例化哪个Bean 代理模式\nSpring的AOP功能，是通过代理模式中的动态代理实现的 模板模式\nSpring中的JdbcTemplate类，用到了模板模式 JdbcTemplate是Spring提供的用于简化JDBC操作的模板类，它封装了一些常见的JDBC操作 策略模式\nSpring中访问资源的Resource接口，用到了策略模式 ClassPathResourece、FileSystemResource、ServletContextResource、UrlResource定义了不同的资源访问策略 装饰器模式\nSpring中配置的DataSource可能是不同的数据源 SessionFactory根据用户的每次请求，将DataSource设置成不同的数据源，以达到切换数据源的目的 \u0026ndash; Spring 中的单例 Bean 是否线程安全\r#\r1. Spring并没有对单例Bean进行任何多线程的封装处理，需要开发者手动处理 2. Spring关注的是：根据配置，创建单例Bean或多例Bean \u0026ndash; @Autowired、@Resource\r#\r共同点\n1. 都是用于Bean的注入 2. 都可以标注在字段和setter方法上 @Autowired\n1. 是Spring提供的注解 2. 只能按照类型（byType）注入Bean 3. 可与@Qualifier一起使用，改为按照名称（ByName）注入Bean @Resource\n1. 是J2EE提供的注解，Spring 做了支持 2. 默认按照名称（ByName）注入bean 3. 可以通过属性（name、type）指定注入策略 \u0026ndash; @Transactional\r#\r1. 表明该方法要参与事务\r2. 配置相关属性来定制事务的参与方式和运行行为\r声明式事务主要是得益于Spring AOP。使用一个事务拦截器，在方法调用的前后/周围进行事务性\r增强（advice），来驱动事务完成。 "},{"id":5,"href":"/lang2/program-design/distributed/p1/","title":"Part.1","section":"分布式","content":"\r\u0026ndash; 分布式幂等性\r#\r幂等性\n幂等性：对于同一操作，不论该操作被执行多少次，产生的影响都是相同的 例如：支付功能，用户多点了几次，不做幂等校验就可能重复支付了 解决方案\n1. 分布式锁 2. 数据表唯一索引 3. token机制 \u0026ndash; CAP 原则\r#\rCAP\n1. 一致性（Consistency） 在分布式系统中的所有数据备份，在同一时刻是否同样的值 2. 可用性（Availability） 系统提供的整体服务一直处于可用的状态，每次请求都能获得正确的响应 3. 分区容忍性（Partition tolerance） 系统在遇到任何网络分区故障的时候，仍然能够保持运行和提供服务 CAP原则\n指的是在一个分布式系统中，CAP这三个要素最多只能同时实现两点，不可能三者兼顾 BASE理论\n核心思想：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。 1. 基本可用，Basically Available 2. 软状态，Soft state 3. 最终一致性，Eventually consistent \u0026ndash; 分布式事务方案\r#\r1. 两阶段提交(2PC) 2. 三阶段提交(3PC) 3. 补偿事务(TCC=Try-Confirm-Cancel) 4. 本地消息队列表(MQ) 5. Sagas事务模型(最终一致性) \u0026ndash; 限流算法\r#\r固定窗口算法\n又称计算器算法，使用计数器在周期内累加访问次数，当达到设定的限流值时，触发限流策略。 下一个周期开始时，进行清零，重新计数。 滑动窗口算法\n将时间周期分为N个小周期，分别记录每个小周期内访问次数。 跟随时间的滑动，删除超限的小周期数据，以便更精确地控制流量。 漏桶算法\n使用一个固定容量、固定流出速度的漏桶，访问请求到达后，直接放入漏桶中。 如果漏桶未满，请求将被接受并排队等待处理；如果漏桶已满，则根据算法策略处理。 令牌桶算法\n使用一个固定容量、固定速率添加令牌的令牌桶，请求到达时向令牌桶请求令牌。 如获取到令牌则通过请求，否则触发限流策略 "},{"id":6,"href":"/lang2/program-lang/java-base/p1/","title":"Part.1","section":"Java基础","content":"\r\u0026ndash; 面向过程、面向对象\r#\r面向过程\n是一种以过程为中心的编程思想 分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现 面向对象\n是一种以对象为中心的编程思想 把构成问题的事务分解成各个对象，建立对象，来描述某个事物在解决整个问题的过程中所发生的行为 \u0026ndash; 四种引用类型\r#\r引用类型 说明 强引用 最常见的引用类型，引用存在时，对象不会被回收 软引用 适用于内存敏感的缓存，当内存不足时，对象才会被回收 弱引用 适用于非重要对象，当垃圾收集器运行时，对象就可能被回收 虚引用 适用于对象回收跟踪，就和没有引用一样，在任何时候都可能被回收 // 强引用 String strongRef = new String(\u0026#34;abc\u0026#34;); // 软引用 SoftReference\u0026lt;String\u0026gt; softRef = new SoftReference\u0026lt;\u0026gt;(\u0026#34;abc\u0026#34;); // 弱引用 WeakReference\u0026lt;String\u0026gt; weakRef = new WeakReference\u0026lt;\u0026gt;(\u0026#34;abc\u0026#34;); // 虚引用 ReferenceQueue queue = new ReferenceQueue(); PhantomReference phantomRef = new PhantomReference(\u0026#34;abc\u0026#34;, queue); \u0026ndash; 访问修饰符\r#\r修饰符 当前类 同包 子类 其他包 public OK OK OK OK protected OK OK OK default OK OK private OK \u0026ndash; 数据类型\r#\r基本数据类型\n字符型：char 布尔型：boolean 数值型： 整数类型：byte, short, int, long 浮点类型：float, double 引用数据类型\n类： class 接口： interface 数组： [] \u0026ndash; 创建对象的方式\r#\r1. new创建新对象 2. 通过反射机制 3. 采用clone机制 4. 通过序列化机制 \u0026ndash; 获取Class对象的方式\r#\rString str = new String(\u0026#34;abc\u0026#34;); // 方式一：通过类对象的 getClass() Class\u0026lt;?\u0026gt; clazz = str.getClass(); // 方式二：通过类的静态成员 Class\u0026lt;?\u0026gt; clazz = String.class; // 方式三：通过Class 类的静态方法 forName() Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;java.lang.String\u0026#34;); \u0026ndash; 浅拷贝、深拷贝\r#\r浅拷贝： 在拷贝一个对象时，对基本数据类型的成员变量进行拷贝，对引用类型的成员变量只进行引用的传递 深拷贝： 在拷贝一个对象时，对基本数据类型的成员变量进行拷贝，对引用类型的成员变量，创建一个新的对象，并复制其内容。 实现深拷贝的方式： 1. 将对象序列化为字节流，然后再反序列化为新的对象 2. 逐个复制引用类型属性 \u0026ndash; 自动装箱、自动拆箱\r#\r自动装箱： 自动将基本数据类型转换为包装器类型（int--\u0026gt;Integer），调用Integer的valueOf(int)方法 自动拆箱： 自动将包装器类型转换为基本数据类型（Integer--\u0026gt;int），调用Integer的intValue()方法 // 试题 Integer i1 = 100; Integer i2 = 100; Integer i3 = 200; Integer i4 = 200; System.out.println(i1==i2); System.out.println(i3==i4); 运行结果： true false ---------------------------------------------------------------------- 在通过valueOf方法创建Integer对象的时候， 如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用； 否则创建一个新的Integer对象 ps：在某个范围内的整型数值的个数是有限的，而浮点数不是 \u0026ndash; 方法重载、方法重写\r#\r重载 overload\n在一个类里面，方法名字相同，而参数不同 每个重载的方法都必须有独一无二的参数类型列表（参数个数、参数类型、参数顺序） 重写 override\n是子类对父类方法的实现进行重新编写 方法名、参数列表均相同 重写方法抛出的异常，需宽于被重写方法 构造方法不能被重写 区别\n区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常捕获 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问限制 可以修改 一定不能做更严格的限制（可以降低限制） \u0026ndash; 红黑树的特征\r#\r1. 节点颜色：每个节点被标记为红色或黑色 2. 根节和叶子节点都是黑色的 3. 红色节点的子节点不能是红色，即红色节点不能连续存在 4. 从任意节点到其每个叶子节点的路径包含相同数量的黑色节点 \u0026ndash; switch 能作用的类型\r#\rswitch可以作用于 byte、short、char、int 类型 从Java5开始，可以作用于 enum 类型 从Java7开始，可以作用于 String 类型 "},{"id":7,"href":"/lang2/program-lang/java-jvm/p1/","title":"Part.1","section":"Java虚拟机","content":"\r\u0026ndash; JVM 结构\r#\r类加载器，Class Loader 执行引擎，Execution Engine 运行时数据区，Runtime Data Area 本地方法接口，Native Interface \u0026ndash; 类加载过程\r#\r\u0026ndash; 类加载机制\r#\r双亲委派模式\n1. 当类加载器需要加载某一个 .class 字节码文件时，它会首先将这个任务委托给其父类加载器。 2. 递归这个操作，直至传递到顶层的启动类加载器。 3. 只有当父类加载器无法完成此加载任务时，子类加载器才会自己去加载。 优点\n1. 避免类的重复加载 2. 避免Java的核心API被篡改 3. Java类随着类加载器一起具备了带有优先级的层级关系 \u0026ndash; JVM 内存模型\r#\r方法区\n即永久代 用于存储类信息、常量、静态常量、即时编译后的代码 运行时常量池，也是方法区的一部分，用于存放编译期生成的各种字面量和符号引用 堆内存\n用于存储对象实例、数组 是垃圾收集器管理的主要区域 堆内存采用分代收集算法，又细分为：新生代（Eden区、SurvivorFrom区、SurvivorTo区）、老年代 虚拟机栈\n栈内存，是Java方法执行的内存模型 每个方法被执行时，都会创建一个栈帧来存储局部变量表、操作数栈、动态链接、方法出口等信息 方法从被调用到执行完成的过程，就对应着栈帧在虚拟机栈中从入栈到出栈的过程 本地方法栈\n与虚拟机栈相同，区别是虚拟机栈为执行 Java 方法服务，而本地方法栈则为 Native 方法服务 程序计算器\n在 Java 虚拟机中，唯一没有 OOM 的区域 是一小块内存空间，用于存储当前线程正在执行字节码指令的地址值 正在执行 Java 方法时，记录的是当前指令的地址 正在执行 Native 方法时，则为 Undefined \u0026ndash; 内存区域分代\r#\r新生代\n由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收 分为：Eden区、ServivorFrom区、ServivorTo区 老年代\n主要存放应用程序中生命周期长的内存对象，老年代的对象比较稳定，所以 MajorGC 不会频繁执行 永久代\n指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息 GC 不会在主程序运行期对永久区域进行清理 在JDK1.8中，永久代被元空间取代，元空间并不在虚拟机中，而是使用本地内存 \u0026ndash; 堆和栈的区别\r#\r堆内存\r栈内存\r功能不同\r存储Java中的对象\r存储局部变量和方法调用\r共享性不同\r是线程共有的\r是线程私有的\r异常错误不同\r堆空间不足：java.lang.OutOfMemoryError\r栈空间不足：java.lang.StackOverFlowError\r空间大小\r堆内存远远大于栈内存\r\u0026ndash; 垃圾收集算法\r#\r标记-清除\n标记：扫描内存空间，对存活的对象进行标记 清除：扫描内存空间，回收未标记的对象。 标记-压缩\n标记：扫描内存空间，对存活的对象进行标记 压缩：再次扫描，并整理存活的对象 复制算法\n从 From 区找到存活的对象，复制到 To 区。 From、To区交互身份，进行下一轮垃圾收集。 \u0026ndash; 垃圾判定算法\r#\r引用计数法\n1、给对象添加一个引用计数器，记录引用该对象的次数 2、新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收 3、缺陷：无法解决对象间循环引用的问题 可达性分析法\n1、从GC Roots开始向下搜索，搜索所走过的路径称为引用链。 2、当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，即垃圾对象 \u0026ndash; 垃圾回收方式\r#\r串行（Serial）、并行（Parallel）、并发（Concurrent）、STW \u0026ndash; JVM 垃圾收集器\r#\r垃圾收集器 作用区域 收集算法 收集方式 说明 Serial 新生代 复制算法 串行 优点：简单高效 ParNew 新生代 复制算法 并行 Serial的多线程版本 Serial Old 老年代 标记-整理算法 串行 Serial的老年代版本 . Parallel Scavenge 新生代 复制算法 并行 追求高吞吐量，高效利用 CPU Parallel Old 老年代 标记-整理算法 并行 Parallel Scavenge的老年代版本 . CMS 老年代 标记-清除算法 并行 优点：高并发、低停顿 G1 新生代、老年代 标记-整理算法 并行 \u0026ndash; 触发FullGC执行的场景\r#\r1、直接触发 直接调用System.gc jvm参数显式地触发 2、内存区域已满 永久代或元空间内存不足 老年代内存不足 3、CMS垃圾回收失败 4、内存分配失败 当JVM尝试分配对象时，如果堆内存中没有足够的空间来容纳新的对象 \u0026ndash; 永久代中会发生垃圾回收吗\r#\r垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(FullGC) "},{"id":8,"href":"/lang2/program-lang/java-thread/p1/","title":"Part.1","section":"Java多线程","content":"\r\u0026ndash; 程序、进程、线程\r#\r程序\n是含有指令和数据的文件，存储在硬件设备中，因此程序是静态的 进程\n是程序的一次执行过程，是程序的一个运行实例，因此进程是动态的 进程之间是相互独立的，各自有自己独立的内存空间和系统资源 线程\n是指在一个进程内的独立执行路径。一个进程可以包含多个线程。 每个线程都是独立运行的，有自己的执行顺序和状态。 多个线程可以共享内存空间和系统资源。 \u0026ndash; 创建线程的方式\r#\r继承Thread类 实现Runnable接口 实现Callable接口 使用线程池创建 \u0026ndash; 停止线程的方式\r#\r使用退出标志，使线程正常退出 使用interrupt()方法中断线程 使用stop()方法强行终止，但不推荐，可能会产生不可预料的结果 \u0026ndash; 线程安全\r#\r如果在多线程下执行和在单线程下执行永远都能获得一样的结果，那么代码就是线程安全的 \u0026ndash; 并发三特性\r#\r原子性\n不可分割，是一个整体 即一个操作或者多个操作，要么全部执行并且不被打断，要么就都不执行 可见性\n当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值 有序性\n程序执行的顺序按照代码的先后顺序执行 \u0026ndash; 线程池\r#\r核心参数\n工作过程\n1. 创建线程池后，等待提交过来的任务请求 2. 当调用execute()添加一个新任务时，线程池会做如下判断： a. 如果当前运行的线程数量还小于corePoolSize，则会创建新线程来执行新任务 b. 如果当前运行的线程数量不小于corePoolSize，则会将提交的任务放入阻塞队列中 c. 如果当前阻塞队列满了，且当前运行的线程数量还小于maximumPoolSize，则创建线程运行这个任务 d. 如果当前阻塞队列满了，且当前运行的线程数量不小于maximumPoolSize，则启动拒绝策略 3. 当一个线程完成任务时，它会从队列中取下一个任务来执行 4. 当一个线程空闲超过一定时间，并且此时当前运行的线程大于corePoolSize时，这个线程会被销毁 \u0026ndash; 常见线程池\r#\rnewSingleThreadExecutor：\n创建一个单线程的线程池 此线程池保证所有任务的执行顺序按照任务的提交顺序执行 newFixedThreadPool：\n创建固定大小的线程池 每次提交一个任务就创建一个线程，直到线程数达到线程池的最大数量 newCachedThreadPool：\n创建一个可缓存的线程池 此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程数量 newScheduledThreadPool：\n创建一个大小无限的线程池 此线程池支持定时以及周期性执行任务的需求 \u0026ndash; 线程池拒绝策略\r#\r拒绝策略 说明 AbortPolicy 默认策略，直接丢弃任务，抛出异常 CallerRunsPolicy 由调用者所在的线程处理该任务 DiscardPolicy 直接丢弃任务，也不抛出异常 DiscardOldestPolicy 丢弃等待队列中最旧的任务，并执行当前任务 \u0026ndash; 死锁的必要条件\r#\r互斥使用 一个资源每次只能被一个线程使用 不可抢占 资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放 请求和保持 当资源请求者在请求其他的资源的同时保持对原有资源的占有 循环等待 若干线程之间形成一种头尾相接的循环等待资源关系 \u0026ndash; CAS\r#\rCAS\n1. 比较并交换，Compare-And-Swap 2. 通过处理器的指令来保证操作的原子性，是一种无锁算法 3. Java CAS硬件底层接口：sun.misc.Unsafe 原理\n涉及三个操作数： 1. V：变量内存地址 2. A：旧的预期值 3. B：准备设置的新值 当执行CAS指令时，只有当V等于A时，才会用B去更新V的值，否则就不会执行更新操作 一般情况下是一个自旋操作，即不断的重试 缺点\n1. 自旋时间长开销很大 2. 只能保证一个共享变量的原子性 3. 存在ABA问题 ABA问题： 存在场景：在一段时间内，其他线程将A值改成B值，又改回A值 而CAS却误认为数据未被修改 \u0026ndash; AQS\r#\rAQS\n抽象的队列同步器，AbstarctQueuedSynchronizer，简称AQS AQS定义了一套多线程访问共享资源的同步器基础框架，许多同步类实现都依赖于它 AQS原理\n1. AQS维护了一个共享变量state和一个CLH队列（FIFO先入先出双向队列）。 2. 线程通过CAS去改变state状态，成功则获取锁成功，失败则进入等待队列，等待被唤醒。 AQS实现\n1、AQS的设计是基于模板模式。 2、AQS已实现了对等待队列的维护，自定义同步器只需要实现共享资源state的获取与释放方式即可。 3、AQS定义了两种资源共享方式： a. 独占方式：Exclusive，只有一个线程能执行，如ReentrantLock b. 共享方式：Share，多个线程可以同时执行，如Semaphore、CountDownLatch "},{"id":9,"href":"/lang2/service-manage/spring-boot/","title":"SpringBoot","section":"服务治理","content":"\r\u0026ndash; SpringBoot\r#\rSpringBoot\n是一个用来简化新Spring应用的初始搭建以及开发过程的框架 优点\n1. 简化配置依赖 SpringBoot通过约定的默认配置和默认依赖，可以自动化配置和快速引入依赖 2. 独立运行 SpringBoot内嵌了各种servlet容器，应用可以打包为可执行JAR或WAR文件，直接执行 3. 应用监控 SpringBoot提供了运行时的应用监控，能方便地监控应用程序的运行情况 4. 无代码生成和XML配置 SpringBoot的大部分功能都可以通过配置来实现，无需编写代码或者XML配置 \u0026ndash; SpringBoot 核心注解\r#\r注解 说明 @SpringBootApplication 是一个组合注解，组合了以下三个注解 @SpringBootConfiguration 标注当前类是一个配置类，是@Configuration的特化版本 @EnableAutoConfiguration 启用自动配置功能 @ComponentScan 启用组件扫描功能 \u0026ndash; SpringBoot 启动方式\r#\r在IDE中，直接执行main()方法 使用 Maven 或 Gradle 命令来运行 打包成可执行 JAR 文件来运行 \u0026ndash; SpringBoot 实现热部署\r#\r配置开启\n\u0026lt;!-- pom.xml --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; # application.properties spring.devtools.restart.enabled=true spring.devtools.restart.additional-paths=src/main/java IDE 工具开启\nIntelliJ IDEA： File ==\u0026gt; Setting ==\u0026gt; Build, Execution, Deployment ==\u0026gt; Compiler：勾选 [Build project automatically] \u0026ndash; SpringBoot 自动配置原理\r#\r1. 在spring-boot-autoconfigure.jar包中的META-INF/spring.factories文件列出了所有自动配置类 2. SpringBoot启动时，注解@EnableAutoConfiguration会查找并加载spring.factories中列出的所有自动配置类 3. 对每个自动配置类进行条件检查，如果需要自动配置，则将其配置加载到spring容器中 "},{"id":10,"href":"/lang2/program-design/structure-algorithm/leetcode/%E5%93%88%E5%B8%8C/","title":"哈希","section":"leetcode","content":"\r哈希\r#\r哈希\r#\r用空间换时间，提高查询速度 两数之和\r#\r原题\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。 你可以按任意顺序返回答案。 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 题解\n枚举数组中的每一个数 x，寻找数组中是否存在 target - x import java.util.HashMap; public class Main { public int[] twoSum(int[] nums, int target) { HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { int choose = nums[i]; int diff = target - choose; if (map.containsKey(diff)) { return new int[]{map.get(diff), i}; } map.put(choose, i); } return null; } } 字母异位词分组\r#\r原题\n给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的所有字母得到的一个新单词。 输入: strs = [\u0026#34;eat\u0026#34;, \u0026#34;tea\u0026#34;, \u0026#34;tan\u0026#34;, \u0026#34;ate\u0026#34;, \u0026#34;nat\u0026#34;, \u0026#34;bat\u0026#34;] 输出: [[\u0026#34;bat\u0026#34;],[\u0026#34;nat\u0026#34;,\u0026#34;tan\u0026#34;],[\u0026#34;ate\u0026#34;,\u0026#34;eat\u0026#34;,\u0026#34;tea\u0026#34;]] 题解\n互为字母异位词的字符串，排序后的字符串一定是相同的 故可以将排序之后的字符串作为哈希表的键 import java.util.ArrayList; import java.util.Arrays; import java.util.HashMap; import java.util.List; public class Main { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groupAnagrams(String[] strs) { HashMap\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (String key : strs) { char[] chars = key.toCharArray(); Arrays.sort(chars); String sortKey = new String(chars); if (map.containsKey(sortKey)) { map.get(sortKey).add(key); } else { List\u0026lt;String\u0026gt; s = new ArrayList\u0026lt;\u0026gt;(); s.add(key); map.put(sortKey, s); } } return new ArrayList\u0026lt;\u0026gt;(map.values()); } } 最长连续序列\r#\r原题\n给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。 输入：nums = [100,4,200,1,3,2] 输出：4 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 题解\n如果数组中不存在 x-1，则 x 是序列的起始数 如果数组中不存在 x+1，则 x 是序列的终止数 import java.util.HashSet; public class Main { public int longestConsecutive(int[] nums) { HashSet\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int n : nums) { set.add(n); } int count = 0; int ans = 0; for (int n : set) { if (!set.contains(n - 1)) { //说明这部分是开始的数据：头 count = 1; int curr = n; while (set.contains(curr + 1)) { //如果存在说明是：中 count++; curr++; } //结束了不满足条件说明到了：尾 ans = Math.max(ans, count); } } return ans; } } "},{"id":11,"href":"/lang2/program-design/structure-algorithm/huawei-od/%E5%BF%85%E4%BC%9A%E9%A2%981/","title":"必会题 - 1","section":"华为OD","content":"\r01. 字符串分割\r#\r描述\n给定一个非空字符串S，其被N个‘-’分隔成N+1的子串，给定正整数K，要求除第一个子串外，其余的子串每K个字符组成新的子串，并用‘-’分隔。 对于新组成的每一个子串， 如果它含有的小写字母比大写字母多，则将这个子串的所有大写字母转换为小写字母； 如果它含有的大写字母比小写字母多，则将这个子串的所有小写字母转换为大写字母； 大小写字母的数量相等时，不做转换。 输入描述：输入为两行，第一行为参数K，第二行为字符串S。 输出描述：输出转换后的字符串 输入： 3 12abc-abcABC-4aB@ 输出： 12abc-abc-ABC-4aB-@ 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int k = Integer.parseInt(sc.nextLine()); String input = sc.nextLine(); String[] strings = input.split(\u0026#34;-\u0026#34;); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(strings[0]); StringBuilder str = new StringBuilder(); for (int i = 1; i \u0026lt; strings.length; i++) { str.append(strings[i]); } for (int i = 0; i \u0026lt; str.length(); i += k) { if (i + k \u0026lt;= str.length()) { list.add(caseConversion(str.substring(i, i + k))); } else { list.add(caseConversion(str.substring(i))); } } System.out.println(String.join(\u0026#34;-\u0026#34;, list)); } private static String caseConversion(String s) { int upperCaseLength = s.length() - s.replaceAll(\u0026#34;[A-Z]\u0026#34;, \u0026#34;\u0026#34;).length(); int lowerCaseLength = s.length() - s.replaceAll(\u0026#34;[a-z]\u0026#34;, \u0026#34;\u0026#34;).length(); if (upperCaseLength \u0026gt; lowerCaseLength) { return s.toUpperCase(Locale.ROOT); } if (lowerCaseLength \u0026gt; upperCaseLength) { return s.toLowerCase(Locale.ROOT); } return s; } 02. 组成最大数\r#\r描述\n小组中每位都有一张卡片，卡片上是6位内的正整数，将卡片连起来可以组成多种数字，计算组成的最大数字。 输入描述：“,”号分割的多个正整数字符串，不需要考虑非数字异常情况，小组最多25个人。 输出描述：最大的数字字符串 输入： 4589,101,41425,9999 输出： 9999458941425101 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String input = sc.nextLine(); String[] strings = input.split(\u0026#34;,\u0026#34;); Arrays.sort(strings); for (int i = strings.length - 1; i \u0026gt;= 0; i--) { System.out.print(strings[i]); } } 03. 统计射击比赛成绩\r#\r描述\n给定一个射击比赛成绩单，包含多个选手若干次射击的成绩分数， 请对每个选手按其最高3个分数之和进行降序排名，输出降序排名后的选手ID序列。 1、一个选手可以有多个射击成绩的分数，且次序不固定。 2、如果一个选手成绩少于3个，则认为选手的所有成绩无效，排名忽略该选手。 3、如果选手的成绩之和相等，则成绩之和相等的选手按照其ID降序排列。 输入描述： 输入第一行，一个整数N，表示该场比赛总共进行了N次射击，产生N个成绩分数（2≤N≤100）。 输入第二行，一个长度为N整数序列，表示参与每次射击的选手ID（0≤ID≤99）。 输入第三行，一个长度为N整数序列，表示参与每次射击的选手对应的成绩（0≤成绩≤100）。 输出描述：符合题设条件的降序排名后的选手ID序列。 输入: 13 3,3,7,4,4,4,4,7,7,3,5,5,5 53,80,68,24,39,76,66,16,100,55,53,80,55 输出： 5,3,7,4 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); String[] idArr = sc.nextLine().split(\u0026#34;,\u0026#34;); String[] scoreArr = sc.nextLine().split(\u0026#34;,\u0026#34;); Integer[] ids = Arrays.stream(idArr).map(Integer::parseInt).toArray(Integer[]::new); Integer[] scores = Arrays.stream(scoreArr).map(Integer::parseInt).toArray(Integer[]::new); Map\u0026lt;Integer, ArrayList\u0026lt;Integer\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; num; i++) { map.putIfAbsent(ids[i], new ArrayList\u0026lt;\u0026gt;()); map.get(ids[i]).add(scores[i]); } ArrayList\u0026lt;int[]\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int id : map.keySet()) { ArrayList\u0026lt;Integer\u0026gt; idScores = map.get(id); if (idScores.size() \u0026lt; 3) { continue; } int total = idScores.stream().sorted((a, b) -\u0026gt; b - a) .limit(3).reduce(Integer::sum).orElse(0); ans.add(new int[]{id, total}); } ans.sort((a, b) -\u0026gt; a[1] != b[1] ? b[1] - a[1] : b[0] - a[0]); String result = ans.stream().map(arr -\u0026gt; String.valueOf(arr[0])) .collect(Collectors.joining(\u0026#34;,\u0026#34;)); System.out.print(result); } 04. 字符串序列判定\r#\r描述\n给定两个字符串 s和 t ，判断 s是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度n ~= 500,000），而 s 是个短字符串（长度 ≤ 100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。 （例如，\u0026#34;ace\u0026#34;是\u0026#34;abcde\u0026#34;的一个子序列，而\u0026#34;aec\u0026#34;不是）。 输入描述：共两行，第一行为字符串s（1≤m≤100）, 第二行为字符串t（1≤n≤500000） 输出描述：输出true或者是false 输入： abc ahbgdc 输出： true 题解\npublic static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); char[] chars1 = br.readLine().toCharArray(); int read; int index = 0; char temp = \u0026#39; \u0026#39;; while ((read = br.read()) != \u0026#39;\\n\u0026#39;) { char ch = (char) read; if (index \u0026lt; chars1.length \u0026amp;\u0026amp; ch == chars1[index] \u0026amp;\u0026amp; ch != temp) { temp = ch; index++; } } String result = index == chars1.length ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;; System.out.print(result); } 05. 数据分类\r#\r描述\n对一个数据a进行分类， 分类方法是，此数据a(4个字节大小)的4个字节相加对一个给定值b取模， 如果得到的结果小于一个给定的值c则数据a为有效类型，其类型为取模的值。 如果得到的结果大于或者等于c则数据a为无效类型。 比如一个数据a = 0x01010103，b = 3 按分类方法计算：(0x01 + 0x01 + 0x01 + 0x03) % 3 = 0 所以如果c = 2则此a就是有效类型，其类型为0 如果c = 0则此a是无效类型 输入描述：输入12个数据， 第一个数据为c，第二个数据为b， 剩余10个数据为需要分类的数据 输出描述： 请找到有效类型中包含数据最多的类型， 并输出该类型含有多少个数据。 输入：3 4 256 257 258 259 260 261 262 263 264 265 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] ints = new int[12]; for (int i = 0; i \u0026lt; ints.length; i++) { ints[i] = sc.nextInt(); } solution(ints); } private static void solution(int[] ints) { int c = ints[0]; int b = ints[1]; Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 2; i \u0026lt; ints.length; i++) { int r = intByteSum(ints[i]) % b; if (r \u0026lt; c) { map.putIfAbsent(r, 0); map.put(r, map.get(r) + 1); } } int max = 0; for (Integer value : map.values()) { if (value \u0026gt; max) { max = value; } } System.out.println(max); } private static int intByteSum(int x) { int sum = 0; for (int i = 0; i \u0026lt; 4; i++) { sum += (byte) (x \u0026gt;\u0026gt; (i * 8)); } return sum; } 06. 五键键盘的输出\r#\r描述\n有一个特殊的 5键键盘，上面有 a,ctrl-c,ctrl-x,ctrl-v,ctrl-a五个键，给定一系列键盘输入，输出最终屏幕上字母的数量。 a键在屏幕上输出一个字母 a; ctrl-c将当前选择的字母复制到剪贴板; ctrl-x将当前选择的 字母复制到剪贴板，并清空选择的字母; ctrl-v将当前剪贴板里的字母输出到屏幕; ctrl-a选择当前屏幕上所有字母。 注意: 1、剪贴板初始为空，新的内容被复制到剪贴板时会覆盖原来的内容 2、当屏幕上没有字母时，ctrl-a无效 3、当没有选择字母时，ctrl-c和 ctrl-x无效 4、当有字母被选择时，a和ctrl-v这两个有输出功能的键会先清空选择的字母，再进行输出 输入描述：输入为一行，为简化解析，用数字 12345代表 a,ctrl-c,ctrl-x,ctrl-v,ctrl-a五个键的输入，数字用空格分隔 输出描述：输出一个数字，为最终屏目上字母的数量。 输入：1 1 5 1 5 2 4 4 输出：2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] strings = sc.nextLine().split(\u0026#34; \u0026#34;); int copy = 0; int sum = 0; boolean isCopy = false; boolean isSelect = false; for (String str : strings) { if (\u0026#34;1\u0026#34;.equals(str) \u0026amp;\u0026amp; isSelect) { sum = 1; isSelect = false; continue; } if (\u0026#34;1\u0026#34;.equals(str) \u0026amp;\u0026amp; !isSelect) { sum++; continue; } if (\u0026#34;2\u0026#34;.equals(str) \u0026amp;\u0026amp; isSelect) { copy = sum; isCopy = true; continue; } if (\u0026#34;3\u0026#34;.equals(str) \u0026amp;\u0026amp; isSelect) { copy = sum; sum = 0; isCopy = true; isSelect = false; continue; } if (\u0026#34;4\u0026#34;.equals(str) \u0026amp;\u0026amp; isCopy \u0026amp;\u0026amp; isSelect) { sum = copy; isSelect = false; continue; } if (\u0026#34;4\u0026#34;.equals(str) \u0026amp;\u0026amp; isCopy \u0026amp;\u0026amp; !isSelect) { sum = sum + copy; continue; } if (\u0026#34;5\u0026#34;.equals(str)) { copy = sum; isSelect=true; } } System.out.println(sum); } 07. 检查是否存在满足条件的数字组合\r#\r描述\n给定一个正整数数组，检查数组中是否存在满足规则的数字组合 规则：A = B + 2C 备注： 数组长度在3~100之间 数组成员为0~65535 数组成员可以重复，但每个成员只能在结果算式中使用一次， 如数组成员为 [0,0,1,5]，0出现两次允许，但结果0=0+2*0不允许 因为算式中使用了3个0 用例保证每组数字里最多只有一组符合要求的解 输入描述： 第一行输出数组的元素个数。 第二行输出所有数组元素，用空格隔开。 输出描述： 如果存在满足要求的数，在同一行里依次输出规则里A/B/C的取值，用空格隔开。 如果不存在，输出0。 输入： 4 2 7 3 0 输出： 7 3 2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); String[] strings = sc.nextLine().split(\u0026#34; \u0026#34;); Integer[] arr = new Integer[strings.length]; for (int i = 0; i \u0026lt; strings.length; i++) { arr[i] = Integer.parseInt(strings[i]); } System.out.println(getResult(n, arr)); } public static String getResult(int n, Integer[] arr) { Arrays.sort(arr, (a, b) -\u0026gt; b - a); for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { for (int k = j + 1; k \u0026lt; n; k++) { if (arr[i] == arr[j] + 2 * arr[k]) { return arr[i] + \u0026#34; \u0026#34; + arr[j] + \u0026#34; \u0026#34; + arr[k]; } if (arr[i] == arr[k] + 2 * arr[j]) { return arr[i] + \u0026#34; \u0026#34; + arr[k] + \u0026#34; \u0026#34; + arr[j]; } } } } return \u0026#34;0\u0026#34;; } 08. 数组拼接\r#\r描述\n现在有多组整数数组，需要将它们合并成一个新的数组。 合并规则，循环从每个数组里按顺序取出固定长度的内容合并到新的数组中，取完的内容会删除掉， 如果该行不足固定长度或者已经为空，则直接取出剩余部分的内容放到新的数组中，继续下一行。 输入描述： 第一行是每次读取的固定长度，0＜长度＜10 第二行是整数数组的数目，0＜数目＜1000 第3-n行是需要合并的数组，不同的数组用回车换行分隔，数组内部用逗号分隔，最大不超过100个元素 输出描述：输出一个新的数组，用逗号分隔。 输入： 3 2 2,5,6,7,9,5,7 1,7,4,3,4 输出： 2,5,6,1,7,4,7,9,5,3,4,7 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int len = Integer.parseInt(sc.nextLine()); int num = Integer.parseInt(sc.nextLine()); List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; num; i++) { list.add(Arrays.asList(sc.nextLine().split(\u0026#34;,\u0026#34;))); } int start = 0; int end; List\u0026lt;String\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); int count = 0; while (count \u0026lt; list.size()) { for (List\u0026lt;String\u0026gt; strings : list) { if (start \u0026gt; strings.size() - 1) { continue; } end = Math.min(start + len, strings.size()); if (end == strings.size()) { count++; } result.addAll(strings.subList(start, end)); } start += len; } System.out.println(String.join(\u0026#34;,\u0026#34;, result)); } 09. 数列描述\r#\r描述\n有一个数列A[n]，从A[0]开始每一项都是一个数字，数列中A[n+1]都是A[n]的描述，其中A[0]=1，规则如下： A[0]:1 A[1]:11 表示A[0]从左到右连续出现了1次1 A[2]:21 表示A[1]从左到右连续出现了2次1 A[3]:1211 表示A[2]从左到右连续出现了一次2又连续出现了一次1 A[4]:111221 表示A[3]从左到右连续出现了一次1又连续出现了一次2又连续出现了2次1 输出第n项的结果 输入描述：数列第n项 0≤n≤59 输出描述：数列内容 输入：4 输出：111221 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); if (num == 0) { System.out.println(\u0026#34;1\u0026#34;); return; } String result = \u0026#34;1\u0026#34;; for (int i = 1; i \u0026lt;= num; i++) { result = getNext(result); } System.out.println(result); } private static String getNext(String str) { char[] chars = str.toCharArray(); int sum = 0; char ch = chars[0]; StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; chars.length; i++) { if (ch == chars[i]) { sum++; continue; } sb.append(sum).append(ch); ch = chars[i]; sum = 1; } sb.append(sum).append(ch); return sb.toString(); } 10. 考勤信息\r#\r描述\n公司用一个字符串来表示员工的出勤信息 缺勤-absent，迟到-late，早退-leaveearly，正常上班-resent 现需根据员工出勤信息，判断本次是否能获得出勤奖，能获得出勤奖的条件如下： 缺勤不超过一次； 没有连续的迟到/早退； 任意连续7次考勤，缺勤/迟到/早退不超过3次。 输入描述： 第一行输入一个整数n，表示有多少个员工 后面n行，每一行输入若干个字符串，表示第i名员工的出勤信息 输出描述： 输出n行，每一行表示这名员工能否获得出勤奖，如果可以，则输出“true\u0026#34;，否则输出”false\u0026#34; 输入： 2 present present absent present present leaveearly present absent 输出： true false 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; num; i++) { list.add(getResult(sc.nextLine())); } list.forEach(System.out::println); } private static String getResult(String string) { // 缺勤不超过一次 String str = string.replaceFirst(\u0026#34;absent\u0026#34;, \u0026#34;\u0026#34;); if (str.contains(\u0026#34;absent\u0026#34;)) { return \u0026#34;false\u0026#34;; } // 没有连续的迟到/早退； if (string.contains(\u0026#34;late leaveearly\u0026#34;) || string.contains(\u0026#34;leaveearly late\u0026#34;)) { return \u0026#34;false\u0026#34;; } // 任意连续7次考勤，缺勤/迟到/早退不超过3次。 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(string.split(\u0026#34; \u0026#34;))); if (list.size() \u0026lt; 7) { // 填充到7天 for (int i = 0; i \u0026lt; 7 - list.size(); i++) { list.add(\u0026#34;\u0026#34;); } } for (int i = 0; i \u0026lt; list.size() - 6; i++) { int time = 0; List\u0026lt;String\u0026gt; subList = list.subList(i, i + 7); for (String subStr : subList) { if (!\u0026#34;resent\u0026#34;.equals(subStr)) { time++; } if (time \u0026gt; 3) { return \u0026#34;false\u0026#34;; } } } return \u0026#34;ture\u0026#34;; } 11. 按单词下标区间翻转文章内容\r#\r描述\n给定一段英文文章片段，由若干单词组成，单词间以空格间隔，单词下标从0开始。 请翻转片段中指定区间的单词顺序并返回翻转后的内容。 例如给定的英文文章片段为\u0026#34;I am a developer\u0026#34;，翻转区间为[0,3]，则输出“developer a am I”。 输入描述：使用换行隔开三个参数 第一个参数为英文文章内容即英文字符串 第二个参数为待翻转内容起始单词下标 第三个参数为待翻转内容最后一个单词下标 输出描述：翻转后的英文文章片段所有单词之间以一个半角空格分隔进行输出。 输入：I am a developer. 0 3 输出：developer. a am I 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String text = sc.nextLine(); int left = Integer.parseInt(sc.nextLine()); int right = Integer.parseInt(sc.nextLine()); List\u0026lt;String\u0026gt; strList = Arrays.stream(text.split(\u0026#34; \u0026#34;)) .filter(str -\u0026gt; str != null \u0026amp;\u0026amp; !str.isBlank()).collect(Collectors.toList()); left = Math.min(left, 0); right = Math.min(right, strList.size() - 1); if (right == left || left \u0026gt; strList.size() - 1 || right \u0026lt; 0) { System.out.println(\u0026#34;EMPTY\u0026#34;); return; } List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; left; i++) { list.add(strList.get(i)); } for (int i = right; i \u0026gt;= left; i--) { list.add(strList.get(i)); } for (int i = right + 1; i \u0026lt; strList.size(); i++) { list.add(strList.get(i)); } System.out.println(String.join(\u0026#34; \u0026#34;, list)); } 12. 最大括号深度\r#\r描述\n现有一字符串 仅由 \u0026#39;(\u0026#39;, \u0026#39;)\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;}\u0026#39;, \u0026#39;[\u0026#39;, \u0026#39;]\u0026#39;一共六种括号组成。若字符串满足以下条件之一，则为无效字符串。 1、任意类型的左右括号数量不相等 2、存在未按正确顺序(先左后右)闭合的括号，输出括号的最大嵌套深度，若字符串无效则输出 0。 输入描述：一个只包括 \u0026#39;(\u0026#39;, \u0026#39;)\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;}\u0026#39;, \u0026#39;[\u0026#39;, \u0026#39;]\u0026#39; 以一共6种字符的字符串。 输出描述：一个整数，表示最大的括号深度。若字符串无效，则输出 0 输入：([]{()}) 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chars = sc.nextLine().toCharArray(); int depth = 0; Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (char ch : chars) { if (ch == \u0026#39;(\u0026#39; || ch == \u0026#39;{\u0026#39; || ch == \u0026#39;[\u0026#39;) { stack.push(ch); depth = Math.max(depth, stack.size()); continue; } if (stack.isEmpty()) { System.out.println(\u0026#34;0\u0026#34;); return; } char left = stack.pop(); if ((ch == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; left != \u0026#39;(\u0026#39;) || (ch == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; left != \u0026#39;{\u0026#39;) || (ch == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; left != \u0026#39;[\u0026#39;)) { System.out.println(\u0026#34;0\u0026#34;); return; } } System.out.println(depth); } 13. 字符串加密\r#\r描述\n给你一串未加密的字符串str，过对字符串的每一个字母进行改变来实现加密， 加密方式是在每一个字母str[i]偏移特定数组元素a[i]的量， 数组a前三位已经赋值：a[0]=1,a[1]=2,a[2]=4。 当i\u0026gt;=3时，数组元素a[i]=a[i-1]+a[i-2]+a[i-3]， 例如：原文 abcde 加密后 bdgkr，其中偏移量分别是1,2,4,7,13。 输入描述： 第一行为一个整数n（1 ≤ n ≤ 1000）， 表示有n组测试数据，每组数据包含一行， 原文str（只含有小写字母， 长度小于等于50）。 输出描述：每组测试数据输出一行，表示字符串的密文 输入：1 xy 输出：a 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); for (int i = 0; i \u0026lt; num; i++) { getResult(sc.nextLine()); } } private static void getResult(String string) { char[] chars = string.toCharArray(); StringBuilder sb = new StringBuilder(); int temp1 = 1; int temp2 = 2; int temp3 = 4; int offset = 0; for (int i = 0; i \u0026lt; chars.length; i++) { if (i == 0) { sb.append(getNextChar(chars[i], temp1)); continue; } if (i == 1) { sb.append(getNextChar(chars[i], temp2)); continue; } if (i == 2) { sb.append(getNextChar(chars[i], temp3)); continue; } offset = temp1 + temp2 + temp3; sb.append(getNextChar(chars[i], offset)); temp1 = temp2; temp2 = temp3; temp3 = offset; } System.out.println(sb.toString()); } private static char getNextChar(char c, int offset) { offset = ((c - \u0026#39;a\u0026#39;) + offset) % 26; return (char) (\u0026#39;a\u0026#39; + offset); } 14. 整数对最小和\r#\r描述\n给定两个整数数组 array1、array2，数组元素按升序排列 假设从array1、array2中分别取出一个元素可构成一对元素 现在需要取出K个元素，对取出的所有元素求和，计算和的最小值 注意： 两对元素如果对应于array1、array2中的两个下标均相同，则视为同一个元素 输入描述： 输入两行数组：array1、array2, 每行首个数字为数组大小：size(0＜size≤100), 0＜array1[i]≤1000, 0＜array2[i]≤1000 接下来一行为正整数k：0＜k≤ array1.size()*array2.size() 输出描述： 满足要求的最小和 输入：3 1 1 2 3 1 2 3 2 输出：4 说明： 用例中，需要取2对元素 取第一个数组第0个元素与第二个数组第0个元素组成1对元素[1，1]； 取第一个数组第1个元素与第二个数组第0个元素组成1对元素[1，1]； 求和为1+1+1+1=4，为满足要求的最小和 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] arr1 = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int[] arr2 = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int k = Integer.parseInt(sc.nextLine()); Arrays.sort(arr1); Arrays.sort(arr2); int l = 2; int r = 2; Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;1-1\u0026#34;, arr1[1] + arr2[1]); while (map.size() \u0026lt; k) { if (arr1[l] \u0026lt;= arr2[r]) { for (int i = 1; i \u0026lt; r; i++) { String key = l + \u0026#34;-\u0026#34; + i; if (!map.containsKey(key)) { map.put(key, arr1[l] + arr2[i]); } } l++; continue; } if (arr1[l] \u0026gt; arr2[r]) { for (int i = 1; i \u0026lt; l; i++) { String key = i + \u0026#34;-\u0026#34; + r; if (!map.containsKey(key)) { map.put(key, arr1[i] + arr2[r]); } } r++; } } System.out.println(map.values().stream().reduce(Integer::sum).orElse(0)); } 15. 求字符串中所有整数的最小和\r#\r描述\n输入字符串s，输出s中包含所有整数的最小和。 说明： 字符串s，只包含 a-z A-Z ± ； 合法的整数包括 正整数：一个或者多个0-9组成，如0，2，3，002，102 负整数：负号 – 开头，数字部分由一个或者多个0-9组成，如-0，-012，-23，-00023 输入描述：包含数字的字符串。 输出描述：所有整数的最小和。 输入：b12-34aa 输出：-31 说明：1+2+(-34)=-31 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chars = sc.nextLine().toCharArray(); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); String temp = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; chars.length; i++) { if (\u0026#39;-\u0026#39; == chars[i]) { temp = \u0026#34;-\u0026#34;; continue; } if (chars[i] \u0026lt; \u0026#39;0\u0026#39; || chars[i] \u0026gt; \u0026#39;9\u0026#39;) { if (temp.length() \u0026gt; 1) { list.add(temp); temp = \u0026#34;\u0026#34;; } continue; } if (!temp.isEmpty()) { temp += chars[i]; continue; } list.add(String.valueOf(chars[i])); } if (temp.length() \u0026gt; 1) { list.add(temp); } System.out.println(list.stream().mapToInt(Integer::parseInt).reduce(Integer::sum).orElse(0)); } 16. 乱序整数序列两数之和绝对值最小\r#\r描述\n给定一个随机的整数数组(可能存在正整数和负整数)nums, 请你在该数组中找出两个数，其和的绝对值(|nums[x]+nums[y]|)为最小值，并返回这两个数(按从小到大返回)以及绝对值。 每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 输入描述：一个通过空格空格分割的有序整数序列字符串，最多1000个整数，且整数数值范围是[-65535,65535] 输出描述：两个数、两数之和绝对值 输入：-1 -3 7 5 11 15 输出：-3 5 2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); List\u0026lt;Integer\u0026gt; list = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).distinct() .map(Integer::parseInt).collect(Collectors.toCollection(ArrayList::new)); int a = 0; int b = 0; int sum = Integer.MAX_VALUE; for (int i = 0; i \u0026lt; list.size(); i++) { for (int j = 0; j \u0026lt; list.size(); j++) { if (i == j) { continue; } int temp = Math.abs(list.get(i) + list.get(j)); if (temp \u0026lt; sum) { a = list.get(i); b = list.get(j); sum = temp; } } } System.out.print(Math.min(a, b) + \u0026#34; \u0026#34; + Math.max(a, b) + \u0026#34; \u0026#34; + sum); } 17. 非严格递增连续数字序列\r#\r描述\n输入一个字符串仅包含大小写字母和数字，求字符串中包含的最长的非严格递增连续数字序列长度 比如： 12234属于非严格递增数字序列 输入描述：输入一个字符串仅包含大小写字母和数字 输出描述：出字符串中包含的最长的非严格递增连续数字序列长度 输入：abc2234019A334bc 输出：4 说明：2234为最长的非严格递增连续数字序列 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chars = sc.nextLine().toCharArray(); int curLen = 0; int maxLen = 0; char last = \u0026#39;0\u0026#39;; for (int i = 0; i \u0026lt; chars.length; i++) { char ch = chars[i]; if (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { curLen = 0; continue; } if (ch \u0026lt; last) { last = \u0026#39;0\u0026#39;; curLen = 1; continue; } curLen++; last = ch; maxLen = Math.max(maxLen, curLen); } System.out.println(maxLen); } 18. 分积木\r#\r描述\nsolo和koko是两兄弟，分一堆积木，每块积木有自己的重量，现在他们将积木分成两堆。 弟弟koko还小只会将数字转化为二进制进行计算，而且总是忘记进位。 弟弟koko按照他计算的方式要求两堆积木重量相等，要不然就会哭 哥哥solo进行分积木希望尽量给弟弟少分，并且不让弟弟哭 输入描述： 第一行是一个整数N (2 ≤ N ≤ 100)，表示有多少块积木 第二行为空格分开的N个整数Ci (1 ≤ Ci ≤ 10^6)，表示第i块积木的重量 输出描述：让koko不哭，输入solo所能获得积木的最大总重量否则输出 \u0026#34;No\u0026#34; 输入：3 3 5 6 输出：11 按koko计算，其得到的积木的重量都是11(二进制) 按真实计算，solo得到的积木的重量是5+6=11(十进制) 101 十进制--5 + 110 十进制--6 —————— 011 十进制--3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); int[] arr = new int[num]; String[] strings = sc.nextLine().split(\u0026#34; \u0026#34;); for (int i = 0; i \u0026lt; strings.length; i++) { arr[i] = Integer.parseInt(strings[i]); } String result = solution(arr); System.out.print(result); } private static String solution(int[] arr) { if (arr.length \u0026lt; 2 || (arr.length == 2 \u0026amp;\u0026amp; arr[0] != arr[1])) { return \u0026#34;NO\u0026#34;; } int min = arr[0]; int sum = min; int temp = min; for (int i = 1; i \u0026lt; arr.length; i++) { sum += arr[i]; min = Math.min(min, arr[i]); temp ^= arr[i]; } if (temp != 0) { return \u0026#34;NO\u0026#34;; } else { return String.valueOf(sum - min); } } 19. 连续字母长度\r#\r描述\n给定一个字符串，只包含大写字母，求在包含同一字母的子串中，长度第 k 长的子串的长度，相同字母只取最长的那个子串。 输入描述： 第一行有一个子串(1＜长度≤100)，只包含大写字母。 第二行为 k的值 输出描述：输出连续出现次数第k多的字母的次数。 输入：AABAAA 2 输出：1 说明：同一字母连续出现的最多的是A，3次；第二多的还是A，两次，但是A已经出现过了，故为B，一次； 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chars = sc.nextLine().toCharArray(); int k = Integer.parseInt(sc.nextLine()); System.out.println(getResult(chars, k)); } public static int getResult(char[] chars, int k) { if (k \u0026lt;= 0) { return -1; } Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int tempLen = 1; char tempCh = \u0026#39;-\u0026#39;; for (char curCh : chars) { if (curCh == tempCh) { tempLen++; map.put(curCh, Math.max(tempLen, map.get(curCh))); } else { map.putIfAbsent(curCh, 1); tempCh = curCh; tempLen = 1; } } Integer[] arr = map.values().stream().sorted((a, b) -\u0026gt; b - a).toArray(Integer[]::new); if (k \u0026lt;= arr.length) { return arr[k - 1]; } return -1; } 20. 滑动窗口最大和\r#\r描述\n给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 输入：1,3,-1,-3,5,3,6,7 3 输出：3,3,5,5,6,7 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] ints = Arrays.stream(sc.nextLine().split(\u0026#34;,\u0026#34;)).mapToInt(Integer::parseInt).toArray(); int k = Integer.parseInt(sc.nextLine()); int max; List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; ints.length - k + 1; i++) { max = ints[i]; for (int j = 1; j \u0026lt; k; j++) { max = Math.max(max, ints[i + j]); } list.add(String.valueOf(max)); } System.out.println(String.join(\u0026#34;,\u0026#34;, list)); } 21. 素数之积\r#\r描述\nRSA加密算法在网络安全世界中无处不在，它利用了极大整数因数分解的困难度，数据越大，安全系数越高。 给定一个32位正整数，请对其进行因数分解，找出是哪两个素数的乘积。 输入描述：一个正整数num，0＜num≤2147483647 输出描述：如果成功找到，以单个空格分割，从小到大输出两个素数，分解失败，请输出-1 -1 输入： 15 输出： 3 5 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); int r1 = -1; int r2 = -1; for (int i = 2; i \u0026lt; Math.sqrt(num) + 1; i++) { if (num % i != 0) { continue; } if (isPrime(i) \u0026amp;\u0026amp; isPrime(num / i)) { r1 = i; r2 = num / i; break; } } System.out.println(r1 + \u0026#34; \u0026#34; + r2); } // 判断 n 是否为素数 private static boolean isPrime(int n) { if (n \u0026lt; 2) { return false; } for (int i = 2; i \u0026lt;= Math.sqrt(n); i++) { if (n % i == 0) { return false; } } return true; } 22. 仿LISP运算\r#\r描述\nLISP语言唯一的语法就是括号要配对。 形如 (OP P1 P2 …)，括号内元素由单个空格分割。其中第一个元素OP为操作符，后续元素均为其参数，参数个数取决于操作符类型 注意：参数 P1, P2 也有可能是另外一个嵌套的 (OP P1 P2 …) 当前OP类型为add/sub/mul/div(全小写)，分别代表整数的加减乘除法。简单起见，所以OP参数个数为2 输入描述：合法C字符串，字符串长度不超过512，用例保证了无语法错误 输出描述：合法C字符串，字符包括’0’-‘9’及负号’-‘或者’error’ 输入：(mul 3 -7)输出：-21 输入：(add 1 2) 输出：3 输入：(sub (mul 2 4) (div 9 3)) 输出 ：5 输入：(div 1 0) 输出：error 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); solution(str); } public static void solution(String str) { Stack\u0026lt;Integer\u0026gt; numStack = new Stack\u0026lt;\u0026gt;(); Stack\u0026lt;String\u0026gt; opStack = new Stack\u0026lt;\u0026gt;(); int mark = 0; int paramOne = 0; int paramTwo = 0; for (int i = 0; i \u0026lt; str.length(); i++) { char chas = str.charAt(i); if (chas == \u0026#39;(\u0026#39;) { //截取符号位 opStack.push(str.substring(i + 1, i + 4)); //这里为空格的索引位置 i = i + 4; //符号位后第一个数字的索引坐标 mark = i + 1; } else if (chas == \u0026#39;)\u0026#39;) { if (mark \u0026lt; i) { //所有数字的截取 numStack.push(Integer.valueOf(str.substring(mark, i))); i++; mark = i + 1; } //得到一次（）的对应，就进行一次计算 paramTwo = numStack.pop(); paramOne = numStack.pop(); calc(numStack, opStack, paramOne, paramTwo); } else { //空格位将数字进行区分 if (chas == \u0026#39; \u0026#39;) { if (mark \u0026lt; i) { numStack.push(Integer.valueOf(str.substring(mark, i))); //下一个数字的索引为空格后面一位，故mark = i+1; mark = i + 1; } } } } //如果还有没计算完的，就进行再次计算 while (!opStack.isEmpty()) { paramTwo = numStack.pop(); paramOne = numStack.pop(); calc(numStack, opStack, paramOne, paramTwo); } System.out.println(numStack.pop()); } private static void calc(Stack\u0026lt;Integer\u0026gt; numStack, Stack\u0026lt;String\u0026gt; operStack, int paramOne, int paramTwo) { switch (operStack.pop()) { case \u0026#34;add\u0026#34;: numStack.push(paramOne + paramTwo); break; case \u0026#34;sub\u0026#34;: numStack.push(paramOne - paramTwo); break; case \u0026#34;mul\u0026#34;: numStack.push(paramOne * paramTwo); break; case \u0026#34;div\u0026#34;: if (paramTwo == 0) System.out.println(\u0026#34;error\u0026#34;); else numStack.push(paramOne / paramTwo); break; } } 23. 贪吃蛇\r#\r描述\n贪吃蛇是一个经典游戏，蛇的身体由若干方格连接而成，身体随蛇头移动。蛇头触碰到食物时，蛇的长度会增加一格。 蛇头和身体的任一方格或者游戏版图边界碰撞时，游戏结束。 贪吃蛇游戏的模拟： 给定一个NM的数组ar，代表NM个方格组成的版图，贪吃蛇每次移动一个方格。 若ar[i][j]==\u0026#39;H\u0026#39;，表示该方可为贪吃蛇的起始位置; 若ar[i][j]==\u0026#39;F\u0026#39;，表示该方格为食物， 若ar[i][j]==\u0026#39;E\u0026#39;，表示该方格为空格。 贪吃蛇初始长度为1，初始移动方向为向左。 输入为给定一系列贪吃蛇的移动操作，返回操作后蛇的长度，如果在操作执行完之前已经游戏结束，返回游戏结束时贪吃蛇的长度。 输入描述: 第1行：为空格分隔的字母，代表贪吃蛇的移动操作。字母取值为 U、D、L、R、G， 其中UDLR分别表示贪吃蛇往上下左右转向，转向时贪吃蛇不移动，G表示贪吃蛇按 当前的方向移动一格。用例保证输入的操作正确。 第2行：为空格分隔的两个数，指定为 N和 M，为数组的行和列数。 余下 N行每行是空格分 隔的 M个字母。字母取值为 H、F和 E，H表示贪吃蛇的起始位置，F表示食物，E表示该 方格为空。 用例保证有且只有一个 H，而 F和 E会有多个。 输出描述: 输出一个数字为蛇的长度。 输入：D G G 3 3 F F F F F H E F E 输出：1 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] roadArr = sc.nextLine().split(\u0026#34; \u0026#34;); String[] numArr = sc.nextLine().split(\u0026#34; \u0026#34;); int n = Integer.parseInt(numArr[0]); int m = Integer.parseInt(numArr[1]); String[][] arr = new String[n][m]; for (int i = 0; i \u0026lt; n; i++) { String[] tempArr = sc.nextLine().split(\u0026#34; \u0026#34;); for (int j = 0; j \u0026lt; m; j++) { arr[i][j] = tempArr[j]; } } int ans = solution(roadArr, arr, n, m); System.out.println(ans); } public static int solution(String[] roadArr, String[][] arr, int n, int m) { int[] start = {0, 0}; ArrayDeque\u0026lt;String\u0026gt; body = new ArrayDeque\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { if (\u0026#34;H\u0026#34;.equals(arr[i][j])) { body.add(i + \u0026#34;-\u0026#34; + j); start[0] = i; start[1] = j; } } } String curDir = \u0026#34;L\u0026#34;; for (int i = 0; i \u0026lt; roadArr.length; i++) { String str = roadArr[i]; if (\u0026#34;U\u0026#34;.equals(str) || \u0026#34;D\u0026#34;.equals(str) || \u0026#34;L\u0026#34;.equals(str) || \u0026#34;R\u0026#34;.equals(str)) { curDir = str; } if (\u0026#34;G\u0026#34;.equals(str)) { if (\u0026#34;U\u0026#34;.equals(curDir)) start = new int[]{start[0] - 1, start[1]}; if (\u0026#34;D\u0026#34;.equals(curDir)) start = new int[]{start[0] + 1, start[1]}; if (\u0026#34;L\u0026#34;.equals(curDir)) start = new int[]{start[0], start[1] - 1}; if (\u0026#34;R\u0026#34;.equals(curDir)) start = new int[]{start[0], start[1] + 1}; if (start[0] \u0026lt; 0 || start[1] \u0026lt; 0 || start[0] \u0026gt; n - 1 || start[1] \u0026gt; m - 1 || body.contains(start[0] + \u0026#34;-\u0026#34; + start[1])) { return body.size(); } if (\u0026#34;E\u0026#34;.equals(arr[start[0]][start[1]])) { body.addFirst(start[0] + \u0026#34;-\u0026#34; + start[1]); body.removeLast(); } if (\u0026#34;F\u0026#34;.equals(arr[start[0]][start[1]])) { body.addFirst(start[0] + \u0026#34;-\u0026#34; + start[1]); } } } return body.size(); } 24. 解密犯罪时间\r#\r描述\n警察在侦破一个案件时，得到了线人给出的可能犯罪时间，形如 “HH:MM” 表示的时刻。根据约定，为了隐蔽，该时间是修改过的， 解密规则为：利用当前出现过的数字，构造下一个距离当前时间最近的时刻，则该时间为可能的犯罪时间。 每个出现的数字都可以被无限次使用。 输入描述：形如 HH:SS 的字符串，表示原始输入 输出描述：形如 HH:SS 的字符串，表示推理出来的犯罪时间 注意事项：1、可以保证线人给定的字符串一定是合法的。2、最近的时刻有可能在第二天。 输入：18:52 输出：18:55 说明：利用数字 1, 8, 5, 2 构造出来的最近时刻是 18:55，是 3 分钟之后。 输入：23:59 输出：22:22 说明：利用数字 2, 3, 5, 9 构造出来的最近时刻是 22:22 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String input = sc.nextLine(); String[] split = input.split(\u0026#34;:\u0026#34;); // 记录已经出现的数字 boolean[] exists = new boolean[10]; for (char c : input.toCharArray()) { if (Character.isDigit(c)) { exists[c - \u0026#39;0\u0026#39;] = true; } } // 原始时间 int times = Integer.parseInt(split[0]) * 60 + Integer.parseInt(split[1]); // 枚举所有时间，找到下一个距离当前事件最近的时刻 // -- 如果时间点中有字符未出现，则不考虑该时间点，因为该时间点已经不可能是答案了 // -- 如果时间点中有字符出现: // -- -- 如果时间相同，则不考虑该时间点，因为该时间点已经不可能是答案了 // -- -- 如果时间不同，则考虑该时间点，因为该时间点可能是答案了，但是要判断当天还是下一天 int hour = 0; int minute = 0; int d = Integer.MAX_VALUE; for (int h = 0; h \u0026lt; 24; h++) { if (!exists[h % 10] || !exists[h / 10]) continue; for (int m = 0; m \u0026lt; 60; m++) { int curTimes = h * 60 + m; // 字符未出现或时间相同 if (!exists[m % 10] || !exists[m / 10] || curTimes == times) continue; // 计算时间间隔，找到更近的时刻 int curD = (curTimes \u0026gt; times) ? curTimes - times : 24 * 60 - (times - curTimes); if (curD \u0026lt; d) { hour = h; minute = m; d = curD; } } } // %02d 表示将整数值按照至少占据两个字符的方式输出，不足两位时会在前面补零 // %n 表示一个换行符 System.out.printf(\u0026#34;%02d:%02d%n\u0026#34;, hour, minute); } 25. 求满足条件的最长子串的长度\r#\r描述\n给定一个字符串，只包含字母和数字，按要求找出字符串中的最长（连续）子串的长度，字符串本身是其最长的子串， 如果找不到满足要求的子串，如全是字母或全是数字，则返回-1。 子串要求： 1、只包含1个字母(a~z, A~Z)，其余必须是数字； 2、字母可以在子串中的任意位置； 输入描述：字符串(只包含字母和数字) 输出描述：子串的长度 输入：abC124ACb 输出：4 说明：满足条件的最长子串是C124或者124A，长度都是4 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chars = sc.nextLine().toCharArray(); // 是否字母 boolean isCap = false; int maxLen = -1; for (int i = 0; i \u0026lt; chars.length; i++) { if (Character.isLetter(chars[i])) { isCap = true; } for (int j = i + 1; j \u0026lt; chars.length; j++) { if (Character.isLetter(chars[j])) { if (isCap) { if (j - i \u0026gt; 1) { maxLen = Math.max(maxLen, j - i); } isCap = false; break; } else { isCap = true; } } else { if (isCap) { maxLen = Math.max(maxLen, j - i + 1); } } } } System.out.println(maxLen); } "},{"id":12,"href":"/lang2/program-base/network/","title":"网络","section":"编程基础","content":"\r\u0026ndash; 网络模型\r#\r\u0026ndash; TCP 协议\r#\r1. Transmission Control Protocol，传输控制协议 2. 是面向连接的协议，在收发数据前，必须和对方建立可靠的连接。 3. 一个TCP连接必须有三次握手、四次挥手 \u0026ndash; TCP 三次握手\r#\r三次握手：Three-way Handshake，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包\n第一次握手：客户端发出报文（SYN），请求建立连接 第二次握手：服务器收到报文（SYN），如果同意连接，则发出确认报文（SYN+ASK） 第三次握手：客户端收到确认报文（SYN+ASK）后，再发出确认报文（ASK） 过程简述： 第一次握手：A请求建立连接 第二次握手：A发送正常，B接收正常 第三次握手：B发送正常，A接收正常 类比打电话： A：你听清楚么？ B：能听清楚，你呢？ A：也能听清楚。 \u0026ndash; TCP 四次挥手\r#\r四次挥手：Four-way handshake，即TCP 的连接的拆除需要发送四个包\n第一次挥手：客户端发出报文（FIN），请求释放连接，停止发送数据 第二次挥手：服务器收到报文（FIN），发出确认报文（ASK），停止接收数据 第三次挥手：服务器发出报文（FIN），停止发送数据 第四次挥手：客户端收到报文（FIN），发出确认报文（ASK），停止接收数据 过程简述： 第一次挥手：A请求断开连接 第二次挥手：B收到请求，同意断开连接 第三次挥手：B确认断开连接 第四次挥手：A收到确认，断开连接 类比打电话： A：我要挂电话了？ B：收到，挂吧。 B：我也没有话要说了。 A：挂断电话。 \u0026ndash; TCP、UDP\r#\rTCP UDP 连接性 面向字节流，需要建立连接 面向报文，不需建立连接 可靠性 可靠，不丢包 不可靠，会丢包 传输效率 传输效率低，速度慢 传输效率高，速度快 流量控制 滑动窗口 无 拥塞控制 慢开始、拥塞避免、快重传、快恢复 无 应用场合 对效率要求低，对准确性要求高或要求有连接的场景 对效率要求高，对准确性要求低 连接方式 只支持点到点 支持一对一、一对多、多对多 首部开销 开销20字节 开销8字节 \u0026ndash; HTTP 协议\r#\r1. Hyper Text Transfer Protocol，超文本传输协议，是一种网络通信协议 2. 用于将超文本标记语言（HTML）文档从Web服务器传送到本地浏览器 3. 基于客户端/服务端（C/S）模型，将浏览器为客户端，通过URL向服务端发送所有请求 \u0026ndash; HTTP 状态码\r#\r状态码 含义 描述 1xx 消息响应 服务器收到请求，需要请求者继续执行操作 2xx 成功响应 操作被成功接收并处理 3xx 重定向 需要进一步的操作以完成请求 4xx 客户端错误 请求包含语法错误或无法完成请求 5xx 服务器错误 服务器在处理请求的过程中发生了错误 \u0026ndash; HTTP 请求步骤\r#\r1、DNS 解析 2、HTTP 请求，当输入一个请求时，建立一个 Socket 连接发起 TCP的 3 次握手 3.1、客户端向服务器发送请求命令 3.2、客户端发送请求头信息和数据。 4.1、服务器发送应答头信息。 4.2、服务器向客户端发送数据。 5、服务器关闭 TCP 连接（4次挥手）。 6、客户端根据返回的 HTML 、 CSS 、 JS 进行渲染。 \u0026ndash; HTTP、HTTPS\r#\r1. https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 4. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 \u0026ndash; URI、URL\r#\rURI： Uniform Resource Identifier，统一资源标识符 是一种语义上的抽象概念 唯一标识了资源 URL： Uniform Resource Location，统一资源定位符 是URI的一个子集，一种具体的URI 唯一标识并定位了资源 \u0026ndash; GET、POST\r#\r数据传输方式\nGET: 数据通过URL传递，数据以 key=value 的形式拼接在URL后面。 POST: 数据通过请求体传递，可以包含大量数据，格式灵活。 数据长度限制\nGET: 受到URL长度的限制，一般为2048字符。 POST: 请求体数据长度不受限制，可以传输大量数据。 安全性\nGET: 数据明文传输，容易被截取和篡改，适合传输少量不敏感数据。 POST: 数据在请求体中传输，经多重编码安全性较高，适合传输敏感数据。 缓存\nGET: 请求可以被浏览器缓存，可以被收藏为标签 POST: 请求不能被浏览器缓存，不能被收藏为标签 \u0026ndash; Cookie、Session\r#\rCookie、Session 都是一种用于维持客户端与服务端之间会话的机制 Cookie Session 数据存放位置 客户的浏览器 服务器 安全程度 可能会被篡改 安全 性能方面 只影响客户的浏览器 占用服务器性能 存储数据量 客户的浏览器对其有限制 不影响 存储结构 键值对形式的文本 哈希表结构 \u0026ndash; Forward、Redirect\r#\r转发是服务器行为，重定向是客户端行为 请求转发 请求重定向 服务器内部跳转，所有地址栏上的路径不会改变 是浏览器再次发送请求，地址栏上的路径会发生改变 只发送一次请求 会发送两次请求 只能在当前应用内部跳转 可以在内部跳转，也可以跳出当前应用 可以共享reqeust 不能可以共享reqeust request.getRequestDispatcher().forward(); response.sendRedirect(); "},{"id":13,"href":"/lang2/program-base/linux/","title":"Linux","section":"编程基础","content":"\r\u0026ndash; 目录路径\r#\r绝对路径： /etc/init.d 当前目录： ./ 上层目录： ../ 主目录： ~/ 切换目录： cd \u0026ndash; 命令：查看文件\r#\r$ vi 文件名 #编辑方式查看，可修改 $ cat 文件名 #显示全部文件内容 $ more 文件名 #分页显示文件内容 $ less 文件名 #与 more 相似，更好的是可以往前翻页 $ tail 文件名 #仅查看尾部，还可以指定行数 $ head 文件名 #仅查看头部,还可以指定行数 "},{"id":14,"href":"/lang2/dev-tool/maven/","title":"Maven","section":"开发工具","content":"\r\u0026ndash; Maven\r#\r是一款纯 java 开发的、用于项目构建和管理的工具\n作用： 1. 添加第三方jar包 2. 处理jar包之间的依赖关系 3. 获取第三方jar包 4. 将项目拆分为多个工程模块 \u0026ndash; Maven 生命周期\r#\r阶段 处理 描述 validate 验证 验证项目是否正确，且所有必须信息是可用的 compile 编译 编译源代码 test 测试 使用单元测试框架运行测试 package 打包 创建jar/war包 verify 检查 对集成测试结果进行检查，以保证质量达标 install 安装 安装打包的项目到本地仓库，以供其他项目使用 deploy 部署 拷贝最终的工程包到远程仓库，以共享给其他工程 \u0026ndash; Maven 常用命令\r#\rmvn clean # 清除项目目录中的生成结果 mvn compile # 编译源代码 mvn test-compile # 编译测试源代码 mvn test # 运行应用程序中的单元测试 mvn package # 根据项目生成的jar mvn install # 在本地Repository中安装jar mvn deploy # 发布项目 # 启动tomcat服务 mvntomcat:run # 清除以前的包后重新打包，跳过测试类 mvn clean package -Dmaven.test.skip=true \u0026ndash; Maven 依赖原则\r#\r1. 最短路径原则 依赖传递的路径越短越优先 2. 声明顺序优先 路径长度一样，则先声明的优先 3. 覆写原则 当前pom文件里声明的直接覆盖父工程传过来的 \u0026ndash; Maven 依赖冲突\r#\r使用exclusion进行排除\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.3.14.RELEASE\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;commons-logging\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;commons-logging\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; "},{"id":15,"href":"/lang2/framework/spring/p2/","title":"Part.2","section":"Spring","content":"\r\u0026ndash; Spring MVC\r#\r一种基于 Java 的、实现了 MVC 设计模式的、请求驱动类型的轻量级 Web 框架。 \u0026ndash; MVC 设计模式\r#\rModel、View、Controller\n是一种软件设计典范，通过分离业务逻辑、数据、界面显示的方式来组织代码。\n使程序分层、分工合作，既相互独立，又协同合作。\nModel 模型 负责数据封装及业务逻辑处理 View 视图 负责渲染模型数据，进行可视化展示 Controller 控制器 负责居中调度。将接收的用户请求，指派给模型进行处理，并将结果传递给视图进行展示 \u0026ndash; Spring MVC 工作流程\r#\r1. 发起请求到前端控制器。 2. 前端控制器请求 HandlerMapping 查找 Handler。 3. HandlerMapping 向前端控制器返回 Handler 执行链。 4. 前端控制器调用 HandlerAdapter 去执行 Handler。 5. HandlerAdapter 执行 Handler。 6. Handler 执行完成后，向 HandlerAdapter 返回 ModelAndView。 7. HandlerAdapter 将 ModelAndView返回给前端控制器。 8. 前端控制器将 ModelAndView 传给 ViewReslover。 9. ViewReslover 解析后，向前端控制器返回具体 View。 10. 前端控制器根据 View 进行渲染视图。 11. 前端控制器响应用户。 \u0026ndash; Spring MVC 常用注解\r#\r@RequestMapping： 用于处理请求url映射的注解，可用于类或方法上。 用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。 @RequestBody： 注解实现接收http请求的json数据，将json转换为java对象。 @ResponseBody： 注解实现将conreoller方法返回对象转化为json对象响应给客户。 "},{"id":16,"href":"/lang2/program-lang/java-base/p2/","title":"Part.2","section":"Java基础","content":"\r\u0026ndash; equals、==\r#\r==\n是一个运算符，用于比较两个对象的引用是否指向同一个内存地址 对于基本数据类型，比较的是值 对于引用数据类型，比较的是内存地址 equals\n是一个定义在 Object 类中的方法，用于比较两个对象的内容是否相等 默认情况下，equals 与 == 等同，但许多类会重写 equals 方法 \u0026ndash; final\r#\r修饰符，可以修饰类、变量、方法\n1. 被final修饰的类不可以被继承 2. 被final修饰的方法不可以被重写 3. 被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的 4. 被final修饰的常量，在编译阶段会存入常量池中 \u0026ndash; final、finally、finalize\r#\rfinal\n修饰符，可以修饰类、变量、方法 finally\n用于跟在try-catch代码块后， 表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。 finalize\n是java.lang.Object类中的一个方法 该方法一般由垃圾回收器来调用，当调用System.gc()方法时，由垃圾回收器调用finalize() \u0026ndash; String\r#\r字符串常量\n由final修饰，一经创建，便不能再改变 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象 字符串 + 拼接，JVM会进行优化\nString str = \u0026#34;abc\u0026#34; + \u0026#34;def\u0026#34;; // 优化成 String str = \u0026#34;abcdef\u0026#34;; String str1 = \u0026#34;abc\u0026#34;; String str2 = str1 + \u0026#34;abc\u0026#34;; // 优化成 String str2 = (new StringBuilder()).append(str1).append(\u0026#34;def\u0026#34;).toString(); \u0026ndash; String、StringBuffer、StringBuilder\r#\rString可以赋null值，后者两者不行 String StringBuffer StringBuilder 不可变字符串 可变字符串 可变字符串 线程安全 线程不安全 效率低 效率高 \u0026ndash; Vector、ArrayList、LinkedList\r#\r相同点\n1. 实现List接口 2. 有序性 3. 可包含重复元素 4. 可动态调整大小 ArrayList\n底层基于动态数组实现，非线程安全 随机访问和遍历方面，效率相对较高 插入和删除元素时，涉及到数组元素的移动，效率相对较低 LinkedList\n底层基于双向链表实现，非线程安全 随机访问元素时，需要遍历链表，效率相对较低 插入和删除元素时，只需要改变相邻节点的引用，效率相对较高 Vector\n底层基于动态数组实现，线程安全 底层与ArrayList类似，但由于线程同步的开销，性能通常不如ArrayList "},{"id":17,"href":"/lang2/program-lang/java-jvm/p2/","title":"Part.2","section":"Java虚拟机","content":"\r\u0026ndash; JVM 调优工具\r#\rjconsole\nJDK中自带的java监控和管理控制台 用于对JVM中内存，线程和类等的监控 jvisualvm\njdk自带全能工具 可以分析内存快照、线程快照；监控内存变化、GC变化等 MAT\nMemory Analyzer Tool 一个基于Eclipse的内存分析工具 可以帮助查找内存泄漏和减少内存消耗 GChisto\n一款专业分析gc日志的工具 \u0026ndash; JVM 调优参数\r#\r示例 说明 -XX:-PrintGCDetails 关闭：打印GC收集细节 -XX:+PrintGCDetails 开启：打印GC收集细节 -XX:MetaspaceSize=128m 设置元空间的内存大小，默认21m 备注： 布尔类型：-XX:+或-某个属性（+ 表示开启，- 表示关闭） 键值类型：-XX:属性键=属性值 \u0026ndash; JVM 调优参数：堆栈内存\r#\r参数 说明 等价于 -Xms 设置堆的初始内存大小，默认是物理内存的1/64 -XX:InitialHeapSize -Xmx 设置堆的最大内存大小，默认是物理内存的1/4 -XX:MaxHeapSize -Xmn 设置新生代的内存大小，一般使用默认值 -XX:NewSize、-XX:MaxnewSize -Xss 设置单个线程栈的内存大小，一般默认512K ~ 1024K -XX:ThreadStackSize 参数 说明 -XX:MetaspaceSize 设置元空间的内存大小，默认21m -XX:NewRatio 设置新生代与老年代的比值 -XX:SurvivorRatio 设置新生代中Eden区与两个Survivor区的比值 -XX:MaxTenuringThreshold 设置新生代中对象最大存活次数 -XX:PretenureSizeThreshold 当创建的对象超过指定大小时，直接把对象分配在老年代 \u0026ndash; JVM 调优参数：垃圾收集器\r#\r参数 说明 XX:+UseSerialGC 使用 Serial 收集器 -XX:+UseParNewGC 使用 ParNew 收集器 -XX:+UseParallelGC 使用 Parallel Scavenge 收集器 -XX:+UseParallelOldGC 使用 Parallel Old 收集器 -XX:+UseConcMarkSweepGC 使用 CMS 收集器 . -XX:ParallelGCThreads 配置并行收集器的线程数 \u0026ndash; JVM 调优参数：辅助信息\r#\r参数 说明 -XX:+PrintFlagsInitial 打印全部初始默认参数 -XX:+PrintFlagsFinal 打印全部最终参数 -XX:+PrintCommandLineFlags 打印特定参数 -XX:+PrintGCDetails 打印GC详细信息 -XX:+PrintTLAB 打印TLAB空间的使用情况 -XX:+DisableExplicitGC 禁止系统System.gc() -XX:+HeapDumpOnOutOfMemoryError 在内存溢出的时候，自动生成内存快照 "},{"id":18,"href":"/lang2/program-lang/java-thread/p2/","title":"Part.2","section":"Java多线程","content":"\r\u0026ndash; volatile\r#\rvolatile\n1. 是java提供的一种轻量级同步机制 2. 用于修饰变量，保证所修饰变量的可见性，不保证原子性 3. 会禁止指令重排优化 底层原理\n1. 当对volatile变量进行写操作的时候，JVM会增加Lock前缀指令 2. 基于缓存一致性协议，cpu会检查缓存是否过期，如果过期，则重新读取系统内存数据 2. 缓存一致性：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期 \u0026ndash; synchronized\r#\rsynchronized\n1. 是Java提供的一种基于内置锁的同步机制 2. 保证原子性、可见性、有序性 底层原理\n完全依赖于JVM虚拟机进行实现，基于Java对象头、Monitor监视器 当线程进入同步代码块时，如果此同步对象没有被锁定， JVM会在当前线程的栈中创建Lock Record空间，用于存储锁对象的Mark Word的拷贝。 每一个被锁住的对象Mark Word都会和一个Lock Record关联， Lock Record 锁记录\n1. Lock Record，是线程私有的数据结构 2. Lock Record中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用 Monitor监视器\n1. Monitor，可以理解为一种同步机制、一个对象。任何一个对象都有一个Monitor与之关联。 2. Monitor只能被一个线程持有，此时当前对象就处于锁定状态，其它线程只能阻塞等待。 3. 在JVM中，Synchronized是基于进入和退出Monitor对象，来实现方法同步和代码块同步。 java对象头\n\u0026ndash; synchronized 同步优化\r#\r为优化synchronized性能，在JDK1.6后增加了自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁等策略\n锁膨胀：方向不可逆\n1. 无锁 ——\u0026gt; 偏向锁： 当持有锁的线程再次请求该锁时，无需再做任何同步操作，即获取锁 2. 偏向锁 ——\u0026gt; 轻量级锁： 当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁 3. 轻量级锁——\u0026gt; 重量级锁： 当同一时间有多个线程竞争锁时，锁就会被升级成重量级锁，此时其申请锁带来的开销也就变大 其他策略\n锁消除 当检测到不可能存在共享数据的竞争时，JVM会对这些同步锁进行消除 锁粗化 将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁 自旋锁 是一种锁机制，尝试获取锁的线程不会立即阻塞，而是采用循环的方式去多次尝试 自适应自旋锁 自旋的次数不是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定 \u0026ndash; synchronized、ReentrantLock\r#\r相同点\n1. 都是用来协调多线程共享对象、变量的访问。 2. 都是可重入锁，同一线程可以多次获得同一个锁。 3. 都保证了可见性和互斥性。 不同点\n不同点 synchronized ReentrantLock 实现级别 是一个关键字，属于 JVM 级别 是一个接口，属于 API 级别 底层实现 是同步阻塞，使用悲观并发策略 同步非阻塞，使用乐观并发策略 锁 隐式的获得/释放锁，会自动释放锁 显式的获得/释放锁，须手动释放锁 ReentrantLock 高级功能\n1. 可实现公平锁 2. 可锁绑定多个条件 3. 等待可中断：当锁长时间不释放的时候，可以选择放弃等待 \u0026ndash; wait()、sleep()\r#\rwait() sleep() 所属类 java.lang.Object java.lang.Thread 对象锁 释放 不释放 使用位置 只能在同步块中使用 任意地方 捕获异常 不需要 需要 \u0026ndash; wait()、notify()、notifyAll()\r#\rwait()\n1. 使当前线程等待，把当前线程放入等待池中 2. 释放当前的锁 3. 满足一定条件时被唤醒, 重新尝试获取这个锁 4. 须在 synchronized 同步块中调用 notify()\n1. 唤醒在此对象监视器上等待的其中一个线程（由虚拟机控制） 2. 调用对象的 notify() 方法后，要等到执行 notify() 方法的线程将程序执行完，当前线程才会释放锁 3. 须在同步方法、同步块中调用 notifyAll()\n1. 唤醒在此对象监视器上等待的所有线程 2. 由这些线程重新竞争锁，竞争成功者则继续执行 \u0026ndash; interrupt()、interrupted()、isInterrupted()\r#\r1. 都是 java.lang.Thread 类中的方法 2. interrupt(): 是实例方法，中断线程，设置中断标识为true 3. interrupted(): 是静态方法，判断线程是否被中断，并清除中断状态 4. isInterrupted(): 是实例方法，获取线程的中断状态 \u0026ndash; ThreadLocal\r#\r线程本地变量\n1. ThreadLocal会为每个访问线程都创建一个本地副本 2. 各个线程实际上是操作独属于本线程的变量，从而起到线程隔离的作用，避免了线程安全问题 实现原理\n1. Thread类中，有个ThreadLocal.ThreadLocalMap 的成员变量 2. ThreadLocalMap的key是ThreadLocal实例本身，value则存储泛型对象值 3. 每个线程都是操作自己的成员变量，从而互相不影响 \u0026ndash; CountDownLatch\r#\rCountDownLatch\n倒计时器： 一个或多个线程一直等待，直到其他线程完成某件事情之后再执行 实现原理\n1. 通过一个计数器进行实现。计数器初始值为线程的数量。 2. 每当一个线程执行完毕后，计数器的值就减1。 3. 当计数器的值为0时，表示所有线程都执行完毕，然后在CountDownLatch上等待的线程就可以恢复执行了 \u0026ndash; CyclicBarrier\r#\rCyclicBarrier\n循环栅栏： 多个线程互相等待，直到全部都到达同一个同步点，再继续一起执行 实现原理\n1. 在CyclicBarrier类的内部有一个计数器 2. 每个线程在到达屏障点的时候都会调用await()将自己阻塞，此时计数器会减1 3. 当计数器减为0的时候，所有因调用await()而被阻塞的线程将被唤醒 \u0026ndash; Semaphore\r#\rSemaphore\n信号灯： 作为一种流量控制手段，用于控制同时访问特定资源的线程数量，保证合理的使用共享资源 实现原理\n1. Semaphore管理一系列许可（仅维护许可的计数）。 2. 线程通过acquire()获取许可。当没有可用的许可的时候，线程阻塞，直到有可用的许可为止。 3. 线程通过release()释放许可。 \u0026ndash; Exchanger\r#\rExchanger\n交换器： 是一个用于线程间协作的工具类，用于两个线程间交换数据。 实现原理\n1. Exchanger提供了一个交换的同步点，在这个同步点两个线程能够交换数据。 2. 如果一个线程先执行exchange()，那它会阻塞等待另一个线程也执行exchange()。 3. 当两个线程就都达到了同步点，它们就可以交换数据。 "},{"id":19,"href":"/lang2/service-manage/spring-cloud/","title":"SpringCloud","section":"服务治理","content":"\r\u0026ndash; SpringCloud\r#\r分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的有序集合 \u0026ndash; SpringBoot、SpringCloud\r#\rSpringBoot： 专注于快速方便的开发单个个体微服务 SpringCloud： 关注全局的微服务协调治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来 SpringBoot可以离开SpringCloud独立使用开发项目，但是SpringCloud离不开SpringBoot，属于依赖的关系 \u0026ndash; 雪崩效应\r#\r1. 分布式系统环境下，各服务之前有依赖关系\r2. 由于各种原因，服务不能保证100%可用\r3. 如果单个服务不可用，会导致依赖于它的服务不可用，如此循环导致更多的服务不可用\r4. 这种将不可用逐渐放大导致系统崩溃的现象，即雪崩效应 \u0026ndash; 服务降级、服务熔断\r#\r服务降级： 是一种在服务不可用或响应过慢的情况下，通过执行预设的降级逻辑来保障核心功能和服务可用性的措施 服务熔断： 是一种保护系统的措施，当系统某个服务的异常调用达到预设的阈值时， 熔断器会主动阻止对该服务的调用，立即返回错误信息或执行降级处理，从而避免系统整体崩溃 "},{"id":20,"href":"/lang2/program-design/structure-algorithm/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/","title":"双指针","section":"leetcode","content":"\r双指针\r#\r双指针\r#\r前提：数据具有规则性 由于数据的有序性（大小或正负），可以证明当前节点优于过往节点 从而可以通过数据的维度数量的指针，逐步的迭代收敛，最终找到最优解 移动零\r#\r原题\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0] 题解\n1、左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。 2、右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。 注意到以下性质： 左指针左边均为非零数； 右指针左边直到左指针处均为零。 public class Main { public void moveZeroes(int[] nums) { int n = nums.length, left = 0, right = 0; while (right \u0026lt; n) { if (nums[right] != 0) { swap(nums, left, right); left++; } right++; } } public void swap(int[] nums, int left, int right) { int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; } } 盛最多水的容器\r#\r原题\n给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 输入：[1,8,6,2,5,4,8,3,7] 输出：49 题解\n1、用左右指针位置表示容器的边界 2、由于容量由短边决定，移动短边的指针 public class Main { public int maxArea(int[] height) { int l = 0; int r = height.length - 1; int ans = 0; while (l \u0026lt; r) { int area = Math.min(height[l], height[r]) * (r - l); ans = Math.max(ans, area); if (height[l] \u0026lt;= height[r]) { ++l; } else { --r; } } return ans; } } 三数之和\r#\r原题\n给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 题解\n1、先排序，使用双指针 2、根据条件，移动左右指针 public class Main { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { Arrays.sort(nums); int n = nums.length; List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { // 处理重复 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } int right = n - 1; int target = -nums[i]; for (int left = i + 1; left \u0026lt; right; left++) { // 处理重复 if (left != i + 1 \u0026amp;\u0026amp; nums[left] == nums[left - 1]) { continue; } while (nums[left] + nums[right] \u0026gt; target \u0026amp;\u0026amp; right \u0026gt; left) { right--; } if (left == right) { break; } if (nums[left] + nums[right] == target) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(nums[i]); list.add(nums[left]); list.add(nums[right]); ans.add(list); } } } return ans; } } "},{"id":21,"href":"/lang2/program-design/structure-algorithm/huawei-od/%E5%BF%85%E4%BC%9A%E9%A2%982/","title":"必会题 - 2","section":"华为OD","content":"\r01. 机器人走迷宫\r#\r描述\n1、房间有X*Y的方格组成，例如下图为6*4的大小。每一个放个以坐标(x,y)描述。 2、机器人固定从方格(0,0)出发，只能向东或者向北前进，出口固定为房间的最东北角，用例保证机器人可以从入口走到出口。 3、房间有些方格是墙壁，如(4,1),机器人不能经过那儿。 4、有些地方是一旦到达就无法走到出口的，如标记为B的方格，称之为陷阱方格。 5、有些地方是机器人无法达到的，如标记为A的方格，称之为不可达方格，不可达方格不包括墙壁所在的位置 6、如下实例图中，陷阱方格有2个，不可达方格有3个。 请为该机器人实现路径规划功能：给定房间大小，墙壁位置，请计算出陷阱方格与不可达方格分别有多少个 输入描述： 1、第一行为房间的x和y(0 ＜ x,y ≤ 1000) 2、第二行为房间中墙壁的个数N (0 ≤ N ＜ X*Y) 3、接着下面会有N行墙壁的坐标 同一行中如果有多个数据以一个空格隔开，用例保证所有的输入数据均合法，(结尾不带回车换行) 输出描述： 陷阱方格与不可达方格数量，两个信息在一行中输出，以一个空格隔开。(结尾不带回车换行) 输入：6 4 5 0 2 1 2 2 2 4 1 5 1 输出：2 3 题解\npublic static void main(String[] args) { // 0 是未踩过的。 1是墙。 2是踩过的。 Scanner sc = new Scanner(System.in); String[] xyArr = sc.nextLine().split(\u0026#34; \u0026#34;); int x = Integer.parseInt(xyArr[0]); int y = Integer.parseInt(xyArr[1]); int wallNum = Integer.parseInt(sc.nextLine()); int[][] room = new int[x][y]; for (int i = 0; i \u0026lt; wallNum; i++) { String[] tempArr = sc.nextLine().split(\u0026#34; \u0026#34;); int wallX = Integer.parseInt(tempArr[0]); int wallY = Integer.parseInt(tempArr[1]); room[wallX][wallY] = 1; } path(room, 0, 0, x - 1, y - 1); int badPath = 0; //陷阱 int noWay = 0; // 不可达 for (int i = 0; i \u0026lt; x; i++) { for (int j = 0; j \u0026lt; y; j++) { if (room[i][j] == 9) { badPath += 1; } else if (room[i][j] == 0) { noWay += 1; } } } System.out.println(badPath + \u0026#34; \u0026#34; + noWay); } // 不可达方格 : 机器人无法通过增加X Y值到的方格。走完还是0的方格 // 陷阱方格 : 走到该位置不能正确走到终点的方格。 向前/向上不可达、同为陷阱方格则也标记为 9 // 标记：0未踩过、 1墙、2已踩过、9陷阱 private static void path(int[][] room, int nextX, int nextY, int wallX, int wallY) { // 跳过：墙、已踩过 if (room[nextX][nextY] == 1 || room[nextX][nextY] == 2) { return; } // 已到出口 if (nextX == wallX \u0026amp;\u0026amp; nextY == wallY) { room[nextX][nextY] = 2; return; } // 递归走完所有能走的方格 if (nextX \u0026lt; wallX) { path(room, nextX + 1, nextY, wallX, wallY); } if (nextY \u0026lt; wallY) { path(room, nextX, nextY + 1, wallX, wallY); } // 标记：0未踩过、 1墙、2已踩过、9陷阱 if (nextX == wallX || nextY == wallY) { // 已走到x边，且向y一格不可达 if (nextX == wallX \u0026amp;\u0026amp; nextY \u0026lt; wallY \u0026amp;\u0026amp; room[nextX][nextY + 1] != 2) { room[nextX][nextY] = 9; return; } // 已走到y边，且向x一格不可达 if (nextY == wallY \u0026amp;\u0026amp; nextX \u0026lt; wallX \u0026amp;\u0026amp; room[nextX + 1][nextY] != 2) { room[nextX][nextY] = 9; return; } // 当前方格已踩过 room[nextX][nextY] = 2; return; } // 未到达xy边界，且向x向y一格都不可达 if (room[nextX + 1][nextY] != 2 \u0026amp;\u0026amp; room[nextX][nextY + 1] != 2) { room[nextX][nextY] = 9; } else { room[nextX][nextY] = 2; } } 02. 高效的任务规划\r#\r描述\n你有 n 台机器编号为 1~n，每台都需要完成完成一项工作，机器经过配置后都能完成独立完成一项工作。 假设第 i 台机器你需要花 B 分钟进行设置，然后开始运行，J 分钟后完成任务。 现在，你需要选择布置工作的顺序，使得用最短的时间完成所有工作。 注意，不能同时对两台进行配置，但配置完成的机器们可以同时执行他们各自的工作。 输入描述： 第一行输入代表总共有 M 组任务数据（1＜M≤10）。 每组数第一行为一个整数指定机器的数量 N（0＜N≤1000）。 随后的 N 行每行两个整数，第一个表示 B（0≤B≤10000），第二个表示 J（0≤J≤10000）。 每组数据连续输入，不会用空行分隔。各组任务单独计时。 输出描述： 对于每组任务，输出最短完成时间，且每组的结果独占一行。例如，两组任务就应该有两行输出。 输入：2 2 1 1 2 2 3 1 1 2 2 3 3 输出：4 7 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); for (int i = 0; i \u0026lt; m; i++) { int n = sc.nextInt(); int[][] jobs = new int[n][2]; for (int j = 0; j \u0026lt; n; j++) { jobs[j][0] = sc.nextInt(); jobs[j][1] = sc.nextInt(); } solution(jobs); } } // 因为是顺序配置，所以配置的总时长是固定的 // 因此只要让耗时长的先执行，即可保证最高效 private static void solution(int[][] jobs) { Arrays.sort(jobs, (job1, job2) -\u0026gt; job2[1] - job1[1]); int time = 0; int remaining = 0; for (int[] job : jobs) { // 添加配置时间 time += job[0]; remaining -= job[0]; if (remaining \u0026lt;= 0) { remaining = job[1]; } else { remaining = remaining - job[0] + job[1]; } } time += remaining; System.out.println(time); } 03. 二叉树遍历\r#\r描述\n根据给定的二叉树结构描述字符串，输出该二叉树按照中序遍历结果字符串。中序遍历顺序为:左子树，根结点，右子树。 输入描述：由大小写字母、左右大括号、逗号组成的字符串: 1、字母代表一个节点值，左右括号内包含该节点的子节点。 2、左右子节点使用逗号分隔，逗号前为空则表示左子节点为空,没有逗号则表示右子节点为空。 3、二叉树节点数最大不超过100。 注：输入字符串格式是正确的，无需考虑格式错误的情况。 输出描述 输出一个字符串，为二叉树中序遍历各节点值的拼接结果。 示例： 输入：a{b{d,e{g,h{,I}}},c{f}} 输出：dbgehIafc 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chars = sc.nextLine().toCharArray(); System.out.println(getResult(chars)); } public static String getResult(char[] chars) { Map\u0026lt;String, TreeNode\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (char ch : chars) { stack.push(ch); if (ch == \u0026#39;}\u0026#39;) { stack.pop(); StringBuilder sb = new StringBuilder(); while (stack.peek() != \u0026#39;{\u0026#39;) { sb.append(stack.pop()); } stack.pop(); String key = stack.peek() + \u0026#34;\u0026#34;; TreeNode node = new TreeNode(key); map.put(key, node); String[] split = sb.reverse().toString().split(\u0026#34;,\u0026#34;); if (!split[0].isBlank()) { node.left = map.getOrDefault(split[0], new TreeNode(split[0])); } if (split.length == 2 \u0026amp;\u0026amp; !split[1].isBlank()) { node.right = map.getOrDefault(split[1], new TreeNode(split[1])); } } } TreeNode root = map.get(chars[0] + \u0026#34;\u0026#34;); StringBuilder sb = new StringBuilder(); show(sb, root); return sb.toString(); } private static void show(StringBuilder sb, TreeNode node) { if (node == null) { return; } show(sb, node.left); sb.append(node.value); show(sb, node.right); } static class TreeNode { public TreeNode(String value) { this.value = value; } public String value; public TreeNode left; public TreeNode right; } 04. 书籍叠放\r#\r描述\n书籍的长宽都是整数对(l,w) 如果书A的长度宽度都比B长宽大，则允许将B排列放在A上面。 现在有一组规格的书籍，书籍叠放时要求书籍不能做旋转，请计算最多能有多少个规格书籍能叠放在一起。 输入描述：书本长宽对的数组 输出描述：最多可堆叠摆放的规则数量 输入：[[20,16],[15,11],[10,10],[9,10]] 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String input = sc.nextLine(); String[] strings = input.replaceAll(\u0026#34;\\\\[\u0026#34;, \u0026#34;\u0026#34;) .replaceAll(\u0026#34;]\u0026#34;, \u0026#34;\u0026#34;).split(\u0026#34;,\u0026#34;); int num = strings.length / 2; int[][] books = new int[num][2]; int j = 0; for (int i = 0; i \u0026lt; num; i++) { books[i][0] = Integer.parseInt(strings[j]); j++; books[i][1] = Integer.parseInt(strings[j]); j++; } // 降序排序 Arrays.sort(books, ((o1, o2) -\u0026gt; { if (o1[0] != o2[0]) { return o2[0] - o1[0]; } return o2[1] - o1[1]; })); // 获取当前长宽最大的书籍作为基 int[] preArr = books[0]; int count = 1; for (int i = 1; i \u0026lt; books.length; i++) { int[] curArr = books[i]; if (preArr[0] \u0026gt; curArr[0] \u0026amp;\u0026amp; preArr[1] \u0026gt; curArr[1]) { count++; preArr = curArr; } } System.out.println(count); } 05. 区间交集\r#\r描述\n给定一组闭区间，其中部分区间存在交集。 任意两个给定区间的交集，称为公共区间(如:[1,2],[2,3]的公共区间为[2,2]，[3,5],[3,6]的公共区间为[3,5])。 公共区间之间若存在交集，则需要合并(如:[1,3],[3,5]区间存在交集[3,3]，需合并为[1,5])。 输入描述：一组区间列表，区间数为 N: 0≤N≤1000；区间元素为 X: -10000≤X≤10000。 输出描述：按升序输出合并后的区间列表。 备注说明：1、区间元素均为数字，不考虑字母、符号等异常输入。2、单个区间认定为无公共区间。 输入：0 3 1 3 3 5 3 6 输出：1 5 说明： [0,3]和[1,3]的公共区间为[1,3]，[0,3]和[3,5]的公共区间为[3,3]，[0,3]和[3,6]的公共区间为[3,3]， [1,3]和[3,5]的公共区间为[3,3]，[1,3]和[3,6]的公共区间为[3,3]， [3,5]和[3,6]的公共区间为[3,5]， 公共区间列表为[[1,3],[3,3],[3,5]]，存在交集，须合并为[1,5] 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); List\u0026lt;int[]\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); while (sc.hasNextLine()) { String input = sc.nextLine(); if (input.isBlank()) { break; } String[] strings = input.split(\u0026#34; \u0026#34;); int[] arr = new int[2]; arr[0] = Integer.parseInt(strings[0]); arr[1] = Integer.parseInt(strings[1]); list.add(arr); } List\u0026lt;int[]\u0026gt; regions = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; list.size(); i++) { for (int j = i + 1; j \u0026lt; list.size(); j++) { int[] arr = intersection(list.get(i), list.get(j)); if (arr != null) { regions.add(arr); } } } regions.sort(Comparator.comparingInt(r -\u0026gt; r[0])); int left = regions.get(0)[0]; int right = regions.get(0)[1]; List\u0026lt;int[]\u0026gt; resList = new ArrayList\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt; regions.size(); i++) { int[] tempArr = regions.get(i); if (right \u0026lt; tempArr[0]) { resList.add(new int[]{left, right}); left = tempArr[0]; right = tempArr[1]; } else if (right \u0026lt;= tempArr[1]) { right = tempArr[1]; } } resList.add(new int[]{left, right}); for (int[] ints : resList) { System.out.println(ints[0] + \u0026#34; \u0026#34; + ints[1]); } } private static int[] intersection(int[] r1, int[] r2) { if (r1[1] \u0026lt; r2[0] || r2[1] \u0026lt; r1[0]) { return null; } int[] arr = new int[2]; arr[0] = Math.max(r1[0], r2[0]); arr[1] = Math.min(r1[1], r2[1]); return arr; } 06. 分月饼\r#\r描述\n中秋节，公司要给员工分月饼。公司有m个员工，买了n个月饼，且m≤n。每个员工至少分到 1 个月饼，但可以分多个。 要求： 单人分到最多的月饼个数为Max1，单人分到第二多的月饼个数为Max2，需要满足Max1−Max2≤3。 单人分到倒数第二多的月饼个数为Max(n−1)，单人分到最少的月饼个数为Max(n)，需要满足Max(n−1)−Max(n)≤3。 问有多少种分月饼的方法？ 输入描述：第一行输入两个整数m和n，表示m个员工和n个月饼，m≤n。 输出描述：输出有多少种分月饼的方法。 输入：3 12 输出：6 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] input = sc.nextLine().split(\u0026#34; \u0026#34;); int m = Integer.parseInt(input[0]); int n = Integer.parseInt(input[1]); System.out.println(countWays(m, n)); } // 动态规划 // 定义状态 dp[i][j][k] 表示前 i 个人分配了 j 个月饼，且第 i 个人分配了 k 个月饼的方案数。 // 状态方程为 dp[i][j]=∑k=1\u0026gt;\u0026gt;3 dp[i−1][j−k] public static int countWays(int m, int n) { int[][][] dp = new int[m + 1][n + 1][n + 1]; // 初始化 for (int k = 1; k \u0026lt;= n; k++) { // 只有1个员工时，只有一种分法 dp[1][k][k] = 1; } // 动态规划 for (int i = 1; i \u0026lt;= m; i++) { // 确保月饼数量不少于员工数 for (int j = i; j \u0026lt;= n; j++) { // 每个员工至少分得1个月饼 for (int k = 1; k \u0026lt;= j; k++) { //确保当前分配不超过上一个员工的分配 for (int l = Math.max(1, k - 3); l \u0026lt;= k; l++) { dp[i][j][k] += dp[i - 1][j - k][l]; } } } } // 汇总结果 int count = 0; for (int k = 0; k \u0026lt;= n; k++) { System.out.println(\u0026#34;m=\u0026#34; + m + \u0026#34;, n=\u0026#34; + n + \u0026#34;, k=\u0026#34; + k + \u0026#34;, dp[m][n][k]=\u0026#34; + dp[m][n][k]); count += dp[m][n][k]; } return count; } 07. 找最小数\r#\r描述\n给一个正整数NUM1，计算出新正整数NUM2，NUM2为NUM1中移除N位数字后的结果，需要使得NUM2的值最小。 输入描述： 1.输入的第一行为一个字符串，字符串由0-9字符组成，记录正整数NUM1，NUM1长度小于32。 2.输入的第二行为需要移除的数字的个数，小于NUM1长度。 输出描述： 输出一个数字字符串，记录最小值NUM2。 输入：2615371 4 输出：131 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chars = sc.nextLine().toCharArray(); int n = sc.nextInt(); Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (char ch : chars) { while (!stack.empty() \u0026amp;\u0026amp; stack.peek() \u0026gt; ch \u0026amp;\u0026amp; n \u0026gt; 0) { stack.pop(); n--; } if (stack.empty() \u0026amp;\u0026amp; ch == \u0026#39;0\u0026#39;) { //跳过前置0 continue; } stack.push(ch); } StringBuilder sb = new StringBuilder(); while (!stack.empty()) { if (n \u0026gt; 0) { //当还要再移除数字的时候：从此时单调递增栈的top部删去数字 n--; } else if (n == 0) { //当不用再移除数字的时候：把字符串取出来到result sb.append(stack.peek()); } stack.pop(); } sb.reverse(); String res = sb.isEmpty() ? \u0026#34;0\u0026#34; : sb.toString(); System.out.println(res); } 08. 简易内存池\r#\r描述\n请实现一个简易内存池Q，根据请求命令完成内存分配和释放。 内存池支持两种操作命令，REQUEST和RELEASE， REQUEST=请求的内存大小 表示请求分配指定大小内存，如果分配成功，返回分配到的内存首地址；如果内存不足，或指定的大小为0,则输出error. RELEASE=释放的内存首地址， 表示释放掉之前分配的内存，释放成功无需输出，如果释放不存在的首地址则输出error。 注意： 1.内存池总大小为100字节。 2.内存池地址分配必须是连续内存，并优先从低地址分配。 3.内存释放后可被再次分配，已释放的内存在空闲时不能被二次释放 4.不会释放已申请的内存块的中间地址， 5.释放操作只是针对首地址所对应的单个内存块进行操作，不会影响其它内存块。 输入描述： 首行为整数N，表示操作命令的个数，取值范围：N≤100. 接下来的N行，每行将给出一个操作命令，操作命令和参数之间用等号分割。 输出描述： 根据操作命令返回输出 输入：5 REQUEST=10 REQUEST=20 RELEASE=0 REQUEST=15 RELEASE=10 输出：0 10 10 题解\n// 0 表示未分配 1表示已经分配 public static final int[] RAM_ARR = new int[100]; // 存放分配过的内存的首地址及长度 static final HashMap\u0026lt;Integer, Integer\u0026gt; MAP = new HashMap\u0026lt;\u0026gt;(); public static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = sc.nextInt(); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; num; i++) { String[] strings = sc.nextLine().split(\u0026#34;=\u0026#34;); int answer = answer(strings[0], Integer.parseInt(strings[1])); if (answer != -2) { list.add(answer == -1 ? \u0026#34;error\u0026#34; : answer + \u0026#34;\u0026#34;); } } list.forEach(System.out::println); } public static int answer(String str, int num) { if (str.equals(\u0026#34;REQUEST\u0026#34;)) { if (num == 0) { return -1; } int len = 0; for (int i = 0; i \u0026lt; RAM_ARR.length; i++) { if (RAM_ARR[i] != 0) { continue; } for (int j = i; j \u0026lt; RAM_ARR.length; j++) { if (RAM_ARR[j] == 0) { len++; } else { i = len - 1; len = 0; break; } if (len == num) { for (int k = i; k \u0026lt; i + num; k++) { RAM_ARR[k] = 1; } MAP.put(i, num); return i; } } } return -1; } if (str.equals(\u0026#34;RELEASE\u0026#34;)) { if (MAP.containsKey(num)) { Integer len = MAP.get(num); MAP.remove(num); for (int i = num; i \u0026lt; len + num; i++) { RAM_ARR[i] = 0; } return -2; } else { return -1; } } return -1; } 09. 服务失效判断\r#\r描述\n某系统中有众多服务，每个服务用字符串（只包含字母和数字，长度≤10）唯一标识， 服务间可能有依赖关系，如A依赖B，则当B故障时导致A也故障。 依赖具有传递性，如A依赖B，B依赖C，当C故障时导致B故障，也导致A故障。 给出所有依赖关系，以及当前已知故障服务，要求输出所有正常服务。 依赖关系：服务1-服务2 表示“服务1”依赖“服务2” 不必考虑输入异常，用例保证：依赖关系列表、故障列表非空，且依赖关系数，故障服务数都不会超过3000，服务标识格式正常。 输入描述： 第1行是依赖关系列表，用逗号分隔 第2行是故障服务列表，用逗号分隔 输出描述： 依赖关系列表中提到的所有服务中可以正常工作的服务列表，用逗号分隔， 按依赖关系列表中出现的顺序排序，如果没有正常节点，则输出一个逗号 输入： a1-a2,a5-a6,a2-a3 a5,a2 输出：a6,a3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); // 服务器的状态 Map\u0026lt;String, Boolean\u0026gt; resMap = new LinkedHashMap\u0026lt;\u0026gt;(); // 依赖关系 Map\u0026lt;String, String\u0026gt; tempMap = new HashMap\u0026lt;\u0026gt;(); String[] strings = sc.nextLine().split(\u0026#34;,\u0026#34;); for (int i = 0; i \u0026lt; strings.length; i++) { String[] arr = strings[i].split(\u0026#34;-\u0026#34;); resMap.put(arr[0], true); resMap.put(arr[1], true); tempMap.put(arr[0], arr[1]); } String[] arr = sc.nextLine().split(\u0026#34;,\u0026#34;); for (String str : arr) { resMap.put(str, false); } boolean flag = true; while (flag) { int sum = 0; for (String s1 : tempMap.keySet()) { String s2 = tempMap.get(s1); if (!resMap.get(s2) \u0026amp;\u0026amp; resMap.get(s1)) { resMap.put(s1, false); break; } sum++; if (sum == tempMap.size()) { flag = false; } } } String res = resMap.entrySet().stream().filter(Map.Entry::getValue) .map(Map.Entry::getKey).collect(Collectors.joining(\u0026#34;,\u0026#34;)); res = res.isBlank() ? \u0026#34;,\u0026#34; : res; System.out.println(res); } 10. 图像物体的边界\r#\r描述\n给定一个二维数组M行N列，二维数组里的数字代表图片的像素， 为了简化问题，仅包含像素1和5两种像素，每种像素代表一个物体，2个物体相邻的格子为边界，求像素1代表的物体的边界个数。 像素1代表的物体的边界指与像素5相邻的像素1的格子，边界相邻的属于同一个边界， 相邻需要考虑8个方向(上，下，左，右，左上，左下，右上，右下)。 输入描述： 第一行包含两个正整数 M 和 N，表示二维数组的行数和列数。 接下来的 M 行，每行包含 N 个数字，表示二维数组的像素。 输出描述： 输出像素1代表的物体的边界数目。如果没有边界，输出0（例如只存在像素1，或者只存在像素5）。 输入： 6 6 1 1 1 1 1 1 1 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5 1 1 1 1 1 1 1 输出：1 题解\nprivate static int m; private static int n; private static int[] dx = {0, 0, -1, 1, -1, 1, -1, 1}; private static int[] dy = {-1, 1, 0, 0, -1, 1, 1, -1}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); m = sc.nextInt(); n = sc.nextInt(); int[][] grid = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { grid[i][j] = sc.nextInt(); } } sc.close(); // 标记边界 int[][] border = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == 5) { for (int k = 0; k \u0026lt; 8; k++) { int newI = i + dx[k]; int newJ = j + dy[k]; if (0 \u0026lt;= newI \u0026amp;\u0026amp; newI \u0026lt; m \u0026amp;\u0026amp; 0 \u0026lt;= newJ \u0026amp;\u0026amp; newJ \u0026lt; n \u0026amp;\u0026amp; grid[newI][newJ] == 1) { border[newI][newJ] = 1; } } } } } // 计算边界数量 int count = 0; boolean[][] visited = new boolean[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (border[i][j] == 1 \u0026amp;\u0026amp; !visited[i][j]) { count++; dfs(i, j, border, visited); } } } System.out.println(count); } public static void dfs(int x, int y, int[][] border, boolean[][] visited) { if (x \u0026lt; 0 || x \u0026gt;= n || y \u0026lt; 0 || y \u0026gt;= m || border[x][y] == 0 || visited[x][y]) { return; } visited[x][y] = true; for (int i = 0; i \u0026lt; 8; i++) { dfs(x + dx[i], y + dy[i], border, visited); } } 11. 跳格子游戏\r#\r描述\n小明和朋友们一起玩跳格子游戏，每个格子上有特定的分数 score = [1, -1, -6, 7, -17, 7]， 从起点score[0]开始，每次最大的步长为k，请你返回小明跳到终点 score[n-1] 时，能得到的最大得分。 输入描述： 第一行输入总的格子数量 n 第二行输入每个格子的分数 score[i] 第三行输入最大跳的步长 k 输出描述： 输出最大得分 输入：6 1 -1 -6 7 -17 7 2 输出：14 说明：输出最大得分数，小明从起点score[0]开始跳，第一次跳score[1],第二次跳到score[3],第三次跳到score[5]， 因此得到的最大的得分是score[0] + score[1] + score[3] + score[5] = 14 题解\n// 动态规划： // 创建一个数组 dp，其中 dp[i] 表示跳到 score[i] 时能得到的最大得分。 // 状态转移方程：dp[i] = max(dp[i-1],dp[i-2],...,dp[i-k]) + score[i]; // // 单调队列优化： // 使用双向队列从尾部添加dp[i]的下标i，添加之前判断队列尾部的下标last对应的元素dp[last]是否比dp[i]小 // dp[last]比dp[i]小，则将dp[last]取出丢弃。因为在dp[i]前面的比dp[i]还小的值不会被后面使用到，后面要的是最大值。 // 这样队列里保存的下标对应的dp元素是单调递减的。较小的元素直接淘汰，无需多次排序。 public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); int[] arr = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int k = Integer.parseInt(sc.nextLine()); sc.close(); int[] dp = new int[arr.length]; // 使用一个双端队列来维护单调递减的索引 Deque\u0026lt;Integer\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; arr.length; i++) { // 移除队列中超出步长限制的索引 if (!deque.isEmpty() \u0026amp;\u0026amp; i - deque.peekFirst() \u0026gt; k) { deque.pollFirst(); } // 更新当前位置的最大得分 dp[i] = (deque.isEmpty() ? 0 : dp[deque.peekFirst()]) + arr[i]; // 保持单调递减性质，比当前dp[i]还小的dp[i-x]已经没有用了，要取也是取当前dp[i]或前面更大的值 while (!deque.isEmpty() \u0026amp;\u0026amp; dp[i] \u0026gt;= dp[deque.peekLast()]) { // 队列中无用的索引移除 deque.pollLast(); } // 将当前索引加入队列 deque.offerLast(i); // 对于dp数组 8 5 4 3 7 0 0，假如步长k=4，arr[4]=-1 // i=4时队列里存的dp的索引index为 0 1 2 3，其对应的dp元素是递减的 // 计算dp[4] = 8 + arr[4] = 7 // 此时，dp数组中dp[1] dp[2] dp[3]都比dp[4] 小，将队列中的对应index移除 // 最后添加当前索引i=4到队列末尾，此时队列中的index对应的dp元素还是递减的 } System.out.println(dp[dp.length-1]); } 12. 最小叶子节点\r#\r描述\n二叉树也可以用数组来存储，给定一个数组，树的根节点的值储存在下标1， 对于储存在下标n的节点，他的左子节点和右子节点分别储存在下标 2*n 和 2*n+1，并且我们用-1代表一个节点为空。 给定一个数组存储的二叉树，试求从根节点到最小的叶子节点的路径，路径由节点的值组成。 输入描述： 输入一行为数组的内容，数组的每个元素都是正整数，元素间用空格分割。 注意第一个元素即为根节点的值，即数组的第n元素对应下标 n。下标0在树的表示中没有使用，所以我们省略了。 输入的树最多为7层。 输出描述： 输出从根节点到最小叶子节点的路径上各个节点的值由空格分割 用例保证最小叶子节点只有一个 输入：3 5 7 -1 -1 2 4 输出：3 7 2 输入：5 9 8 -1 -1 7 -1 -1 -1 -1 -1 6 输出：5 8 7 6 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); String[] arr = (\u0026#34;0 \u0026#34; + str).split(\u0026#34; \u0026#34;); // 获取最小叶子节点的位置 int minPos = 0; int min = Integer.MAX_VALUE; for (int i = 2; i \u0026lt; arr.length; i++) { int tmp = Integer.parseInt(arr[i]); if (tmp != 0 \u0026amp;\u0026amp; tmp != -1 \u0026amp;\u0026amp; tmp \u0026lt; min \u0026amp;\u0026amp; i * 2 \u0026gt; arr.length) { min = tmp; minPos = i; } } // 向上回溯 List\u0026lt;String\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); back(arr, minPos, path); Collections.reverse(path); System.out.println(String.join(\u0026#34; \u0026#34;, path)); } private static void back(String[] split, int minPos, List\u0026lt;String\u0026gt; path) { path.add(split[minPos]); if (minPos == 1) { return; } if (minPos % 2 == 0) { back(split, minPos / 2, path); } else { back(split, (minPos - 1) / 2, path); } } 13. 考古学家\r#\r描述\n有一个考古学家发现一个石碑，但是很可惜发现时其已经断成多段。 有N个断口整齐的石碑碎片，为了破解石碑内容，考古学家希望有程序能帮忙计算复原后的石碑文字组合数 输入描述： 第一行输入N，N表示石碑碎片的个数 第二行依次输入石碑碎片上的文字内容S共有N组 输出描述： 输出石碑文字的组合(按照升序排列)，行尾无多余空格 输入：3 a b ab 输出：aabb abab abba baab baba 题解\nprivate static int num; private static int len; private static String[] arr; public static void main(String[] args) { Scanner sc = new Scanner(System.in); num = Integer.parseInt(sc.nextLine()); String line = sc.nextLine(); len = line.replaceAll(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;).length(); arr = line.split(\u0026#34; \u0026#34;); Arrays.sort(arr); boolean[] used = new boolean[num]; TreeSet\u0026lt;String\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); dfs(used, \u0026#34;\u0026#34;, set); set.forEach(System.out::println); } public static void dfs(boolean[] used, String path, TreeSet\u0026lt;String\u0026gt; set) { if (path.length() == len) { set.add(path); return; } // 记录上一次访问的索引 int lastIndex = -1; for (int i = 0; i \u0026lt; num; i++) { if (used[i] || i == lastIndex) { continue; } used[i] = true; dfs(used, path + arr[i], set); used[i] = false; // 更新上一次访问的索引 lastIndex = i; } } 14. 解压报文\r#\r描述\n为了提升数据传输的效率，会对传输的报文进行压缩处理。输入一个压缩后的报文，请返回它解压后的原始报文。 压缩规则：n[str]，表示方括号内部的 str 正好重复 n 次。 注意 n 为正整数（0 ＜ n ≤ 100），str只包含小写英文字母，不考虑异常情况。 输入压缩后的报文： 1）不考虑无效的输入，报文没有额外的空格，方括号总是符合格式要求的； 2）原始报文不包含数字，所有的数字只表示重复的次数 n,例如不会出现像 5b 或 3[8] 的输入； 输出描述: 解压后的原始报文 输入：3[k]2[mn] 输出：kkkmnmn 输入：3[m2[c]] 输出：mccmccmcc 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chars = sc.nextLine().toCharArray(); Stack\u0026lt;Object\u0026gt; stack1 = new Stack\u0026lt;\u0026gt;(); Stack\u0026lt;Object\u0026gt; stack2 = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; chars.length; i++) { //如果是数字，需要判断接下来的字符是不是数字，如果是，要进行拼接 if (chars[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; chars[i] \u0026lt;= \u0026#39;9\u0026#39;) { StringBuilder temp = new StringBuilder(\u0026#34;\u0026#34; + chars[i]); for (int j = i + 1; j \u0026lt; chars.length; j++) { if (chars[j] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; chars[j] \u0026lt;= \u0026#39;9\u0026#39;) { temp.append(chars[j]); } else { i = j - 1; stack1.add(Integer.parseInt(temp.toString())); break; } } } else if (chars[i] != \u0026#39;]\u0026#39;) { stack1.add(chars[i]); } else { //遇到]，形成闭环，将 [ ] 之间的字符拼串，然后按 [ 前方的数字拼接 while (!stack1.peek().equals(\u0026#39;[\u0026#39;)) { stack2.add(stack1.pop()); } stack1.pop(); int nums = Integer.parseInt(\u0026#34;\u0026#34; + stack1.pop()); StringBuilder temp = new StringBuilder(); while (!stack2.isEmpty()) { temp.append(stack2.pop()); } String paste = temp.toString(); while (nums-- \u0026gt; 1) { temp.append(paste); } stack1.push(temp); } } //拼串 StringBuilder result = new StringBuilder(); while (!stack1.isEmpty()) { stack2.push(stack1.pop()); } while (!stack2.isEmpty()) { result.append(stack2.pop()); } System.out.println(result); } 15. 最长的指定瑕疵度的元音子串\r#\r描述\n如果一个字符串的开头和结尾都是元音字母（a、e、i、o、u、A、E、I、O、U），那么它就被称为元音字符串。 元音字符串中非元音字母的数量定义为该字符串的瑕疵度 现在，给定一个字符串和一个目标瑕疵度，请你找出具有指定瑕疵度的最长元音子串，并输出其长度。如果不存在则输出0 注意：字符串中任意连续的字符组成的子序列称为该字符串的子串。 a 和 aa 都是元音字符串，它们的瑕疵度为 0。 aiur 不是元音字符串，因为它的结尾不是元音字母。 abira 是一个元音字符串，它的瑕疵度为2 输入描述： 第一行包含一个整数flaw，表示目标瑕疵度，满足0≤flaw≤65535。 第二行包含一个字符串str，仅由小写字母和大写字母组成，满足1≤str≤65535。 输出描述： 输出一个整数，表示满足条件的最长元音子串的长度。如果不存在满足条件的元音子串，则输出0 输入：1 aabeebuu 输出：5 题解\nprivate static final char[] YAUN = {\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;U\u0026#39;}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); char[] chars = sc.nextLine().toCharArray(); boolean[] arr = new boolean[chars.length]; for (int i = 0; i \u0026lt; chars.length; i++) { arr[i] = isYuan(chars[i]); } int maxLen = 0; for (int i = 0; i \u0026lt; arr.length; i++) { if (!arr[i]) { continue; } int sum = 0; for (int j = i + 1; j \u0026lt; arr.length; j++) { if (arr[j]) { if (sum == num) { maxLen = Math.max(maxLen, j - i + 1); } } else { sum++; } } } System.out.println(maxLen); } private static boolean isYuan(char ch) { for (char c : YAUN) { if (ch == c) { return true; } } return false; } 16. 目录删除\r#\r描述\n某文件系统中有N个目录，每个目录都一个独一无二的ID。 每个目录只有一个父目录，但每个父目录下可以有零个或者多个子目录，目录结构呈树状结构。 假设，根目录的ID为0，且根目录没有父目录，其他所有目录的ID用唯一的正整数表示，并统一编号。 现给定目录ID和其父目录ID的对应父子关系表[子目录ID，父目录ID]，以及一个待删除的目录ID， 请计算并返回一个ID序列，表示因为删除指定目录后剩下的所有目录，返回的ID序列以递增序输出。 注意: 1、被删除的目录或文件编号一定在输入的ID序列中 2、当一个目录删除时，它所有的子目录都会被删除 输入描述： 输入的第一行为父子关系表的长度m; 接下来的行为m个父子关系对; 最后一行为待删除的ID。序列中的元素以空格分割，参见样例。 输出描述： 输出一个序列，表示因为删除指定目录后，剩余的目录ID. 输入：5 8 6 10 8 6 0 20 8 2 6 8 输出：2 6 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); int[][] arr = new int[num][2]; for (int i = 0; i \u0026lt; num; i++) { String[] strings = sc.nextLine().split(\u0026#34; \u0026#34;); arr[i][0] = Integer.parseInt(strings[0]); arr[i][1] = Integer.parseInt(strings[1]); } List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); String[] strings = sc.nextLine().split(\u0026#34; \u0026#34;); for (String str : strings) { list.add(Integer.parseInt(str)); } Map\u0026lt;Integer, Boolean\u0026gt; ansMap = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Integer, Integer\u0026gt; tmpMap = new HashMap\u0026lt;\u0026gt;(); for (int[] subArr : arr) { ansMap.put(subArr[0], true); ansMap.put(subArr[1], true); tmpMap.put(subArr[0], subArr[1]); } for (Integer i : list) { ansMap.put(i, false); } boolean flag = true; while (flag) { int sum = 0; for (Map.Entry\u0026lt;Integer, Integer\u0026gt; entry : tmpMap.entrySet()) { Integer parent = entry.getValue(); Integer sub = entry.getKey(); if (!ansMap.get(parent) \u0026amp;\u0026amp; ansMap.get(sub)) { ansMap.put(sub, false); break; } sum++; if (sum == tmpMap.size()) { flag = false; } } } String ans = ansMap.entrySet().stream() .filter(Map.Entry::getValue).map(Map.Entry::getKey).filter(key -\u0026gt; key != 0) .sorted().map(String::valueOf).collect(Collectors.joining(\u0026#34; \u0026#34;)); System.out.println(ans); } 17. 吃火锅\r#\r描述\n火锅里会在不同时间下很多菜，不同食材要煮不同时间，才能变得刚好合适，你希望吃到最多的刚好合适的菜， 但是你的手速不够快用m代替手速，每次下手捞菜后至少要过m秒，才能再捞（每次只能捞一个） 那么用最合理的策略，最多能吃到多少，刚好合适的菜 输入描述： 第一行两个整数n、m，其中n代表往锅里下菜的个数，m代表手速 接下来有n行，每行有两个数x、y，代表第x秒下的菜过y秒才能变得刚好合适（1 ＜ mn ＜ 1000），（1 ＜ xy ＜ 1000） 输出描述： 输出一个整数代表用最合理的策略，最多能吃到刚好合适的菜的数量 输入：3 2 1 2 2 1 3 2 输出：2 往锅里下的菜的个数3，手速2； 第1秒的时候下入菜品1，2秒后熟了； 第2秒的时候下入菜品2，1秒后熟了； 第3秒的时候下入菜品3，2秒后熟了； 第一种菜品和第二种菜品只能吃到一种，第三种菜品可以吃到； 题解\n// 遍历每一种菜，若当前与上一次捞菜的时间差\u0026gt;=m，则当前可以进行捞菜 public static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int n = Integer.parseInt(split[0]); int m = Integer.parseInt(split[1]); int[] arr = new int[n]; for (int i = 0; i \u0026lt; n; i++) { String[] tmp = sc.nextLine().split(\u0026#34; \u0026#34;); // 每种菜刚好合适的时间点 arr[i] = Integer.parseInt(tmp[0]) + Integer.parseInt(tmp[1]); } Arrays.sort(arr); // 第1个合适的菜 int count = 1; int pre = 0; for (int i = 1; i \u0026lt; arr.length; i++) { if (arr[i] \u0026gt;= arr[pre] + m) { // 当前与上次捞菜的时间差大于等于m，则可以进行捞菜 count++; // 更新本次捞菜时间点 pre = i; } } System.out.println(count); } 18. 服务器广播\r#\r描述\n服务器连接方式包括直接相连，间接连接。 A 和 B 直接连接， B 和 C 直接连接，则 A 和 C 间接连接。直接连接和间接连接都可以发送广播。 给出一个 N * N 数组，代表 N 个服务器， matrix[i][j] == 1 ，则代表 i 和 j 直接连接； 不等于 1 时，代表 i 和 j 不直接连接。 matrix[i][i]== 1 ，即自己和自己直接连接。matrix[i][j]==matrix[j][i] 。 计算初始需要给几台服务器广播，才可以使每个服务器都收到广播。 输入描述：输入为N行，每行有N个数字，为0或1，由空格分隔，构成N*N的数组，N的范围为 1 ≤ N ≤ 40 输出描述：输出一个数字，为需要广播的服务器的数量 输入：1 0 0 0 1 0 0 0 1 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] str = sc.nextLine().split(\u0026#34; \u0026#34;); int n = str.length; int[][] arr = new int[n][n]; for (int i = 0; i \u0026lt; n; i++) { arr[0][i] = Integer.parseInt(str[i]); } for (int i = 1; i \u0026lt; n; i++) { String[] s = sc.nextLine().split(\u0026#34; \u0026#34;); for (int j = 0; j \u0026lt; n; j++) { arr[i][j] = Integer.parseInt(s[j]); } } int count = 0; List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { if (!list.contains(i)) { dfs(arr, list, i); count++; } } System.out.println(count); } public static void dfs(int[][] arr, List\u0026lt;Integer\u0026gt; list, int index) { list.add(index); for (int i = index + 1; i \u0026lt; arr.length; i++) { if (arr[index][i] == 1 \u0026amp;\u0026amp; !list.contains(i)) { dfs(arr, list, i); } } } 19. 二叉树的广度优先遍历\r#\r描述\n有一棵二叉树，每个节点由一个大写字母标识(最多26个节点）。 现有两组字母，分别表示前序遍历（父节点-\u0026gt;左孩子-\u0026gt;右孩子）和中序遍历（左孩子-\u0026gt;父节点-\u0026gt;右孩子）的结果， 请你输出后序遍历（左孩子-\u0026gt;右孩子-\u0026gt;父节点）的结果。 输入描述： 每个输入文件包含两串字母，各占一行。（每串只包含大写字母） 第一行字母表示前序遍历结果，第二行字母表示中序遍历结果。 输出描述： 输出仅一行，表示后序遍历的结果，结尾换行。 输入：DBACEGF ABCDEFG 输出：ACBFGED 思路：先从先序遍历中找到根节点，然后从中序遍历中找到左子树和右子树，递归，构建二叉树，最后再进行后序遍历。 例如：已知前序遍历是DBACEGF，中序遍历是ABCDEFG，那么由前序遍历先根，可知道D是树的根，再看在中序遍历中D左边是ABC，所以可知道ABC一定在D的左子树上，而EFG在D的右子树上。那么前序遍历为BAC,中序遍历为ABC 题解\npublic static class TreeNode { char val; TreeNode left; TreeNode right; TreeNode(char val) { this.val = val; } } public static void lastOrder(StringBuilder sb, TreeNode node) { if (node == null) { return; } lastOrder(sb, node.left); lastOrder(sb, node.right); sb.append(node.val); } private static TreeNode build(String preOrder, String inOrder) { if (preOrder.isEmpty()) { return null; } char midVal = preOrder.charAt(0); TreeNode root = new TreeNode(midVal); if (preOrder.length() == 1) { return root; } int midIndex = inOrder.indexOf(midVal); String preLeft = preOrder.substring(1, midIndex + 1); String preRight = preOrder.substring(midIndex + 1); String inLeft = inOrder.substring(0, midIndex); String inRight = inOrder.substring(midIndex + 1); root.left = build(preLeft, inLeft); root.right = build(preRight, inRight); return root; } public static void main(String[] args) { Scanner sc = new Scanner(System.in); String preOrder = sc.nextLine(); String inOrder = sc.nextLine(); TreeNode root = build(preOrder, inOrder); StringBuilder sb = new StringBuilder(); lastOrder(sb, root); System.out.println(sb); } 20. 单词搜索\r#\r描述\n给一个字符串和一个二维字符数组，如果该字符串存在于该数组中，则按字符串的字符顺序输出字符串每个字符所在单元格的位置下标字符串，如果找不到返回字符串N。 1.需要按照字符串的字符组成顺序搜索，且搜索到的位置必须是相邻单元格，其中“相邻单元格”是指那些水平相邻或垂直相邻的单元格。 2.同一个单元格内的字母不允许被重复使用。 3.假定在数组中最多只存在一个可能的匹配。 输入描述： 第1行为一个数字N指示二维数组在后续输入所占的行数。 第2行到第N+1行输入为一个二维大写字符数组，每行字符用半角,分割。二维数组的大小为N*N，小于等于 100。 第N+2行为待查找的字符串，由大写字符组成。单词长度K，小于 1000。 输出描述： 输出一个位置下标字符串，拼接格式为：第1个字符行下标+\u0026#34;,\u0026#34;+第1个字符列下标+\u0026#34;,\u0026#34;+第2个字符行下标+\u0026#34;,\u0026#34;+第2个字符列下标...+\u0026#34;,\u0026#34;+第N个字符行下标+\u0026#34;,\u0026#34;+第N个字符列下标示例1 输入：4 A,C,C,F C,D,E,D B,E,S,S F,E,C,A ACCESS 输出：0,0,0,1,0,2,1,2,2,2,2,3 说明：ACCESS分别对应二维数组的[0,0] [0,1] [0,2] [1,2] [2,2] [2,3]下标位置 题解\nprivate static final List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); public static void main(String[] args) { Scanner sc = new Scanner(System.in); int N = Integer.parseInt(sc.nextLine()); char[][] arr = new char[N][N]; for (int i = 0; i \u0026lt; N; i++) { arr[i] = sc.nextLine().replaceAll(\u0026#34;,\u0026#34;, \u0026#34;\u0026#34;).toCharArray(); } String word = sc.nextLine(); sc.close(); if (exist(arr, word)) { for (int i = list.size() - 1; i \u0026gt;= 0; i--) { System.out.print(list.get(i)); if (i != 0) { System.out.print(\u0026#34;,\u0026#34;); } } } else { System.out.println(\u0026#34;N\u0026#34;); } } private static boolean exist(char[][] board, String word) { char[] words = word.toCharArray(); for (int i = 0; i \u0026lt; board.length; i++) { for (int j = 0; j \u0026lt; board[0].length; j++) { if (dfs(board, words, i, j, 0)) { list.add(i + \u0026#34;,\u0026#34; + j); return true; } } } return false; } private static boolean dfs(char[][] arr, char[] word, int i, int j, int k) { if (i \u0026gt;= arr.length || i \u0026lt; 0 || j \u0026gt;= arr[0].length || j \u0026lt; 0 || arr[i][j] != word[k]) { return false; } if (k == word.length - 1) { return true; } int newI = i; int newJ = j; boolean flag = false; if (dfs(arr, word, i + 1, j, k + 1)) { flag = true; newI = i + 1; } if (dfs(arr, word, i - 1, j, k + 1)) { flag = true; newI = i - 1; } if (dfs(arr, word, i, j + 1, k + 1)) { flag = true; newJ = j + 1; } if (dfs(arr, word, i, j - 1, k + 1)) { flag = true; newJ = j - 1; } if (flag) { list.add(newI + \u0026#34;,\u0026#34; + newJ); } return flag; } 21. 最少面试官数\r#\r描述\n某公司组织一场公开招聘活动，假设由于人数和场地的限制，每人每次面试的时长不等，并已经安排给定， 用(S1,E1)、(S2,E2)、(Sj,Ej)...(Si 小于 Ei，均为非负整数)表示每场面试的开始和结束时间。 面试采用一对一的方式，即一名面试官同时只能面试一名应试者， 一名面试官完成一次面试后可以立即进行下一场面试，且每个面试官的面试人次不超过m。 为了支撑招聘活动高效顺利进行，请你计算至少需要多少名面试官。 输入描述： 输入的第一行为面试官的最多面试人次m，第二行为当天总的面试场次n， 接下来的n行为每场面试的起始时间和结束时间，起始时间和结束时间用空格分隔。其中，1 ≤ n, m ≤ 500 输出描述： 输出一个整数，表示至少需要的面试官数量。 输入：2 5 1 2 2 3 3 4 4 5 5 6 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); int n = sc.nextInt(); int[][] arr = new int[n][2]; for (int i = 0; i \u0026lt; n; i++) { arr[i][0] = sc.nextInt(); arr[i][1] = sc.nextInt(); } solution(m, n, arr); } private static void solution(int m, int n, int[][] arr) { Arrays.sort(arr, Comparator.comparing(c1 -\u0026gt; c1[0])); List\u0026lt;int[]\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(new int[]{arr[0][1], 1}); for (int i = 1; i \u0026lt; n; i++) { boolean flag = false; for (int[] p : list) { if (p[0] \u0026lt;= arr[i][0] \u0026amp;\u0026amp; p[1] \u0026lt; m) { p[1]++; p[0] = arr[i][1]; flag = true; break; } } if (!flag) { list.add(new int[]{arr[i][1], 1}); } } System.out.print(list.size()); } 22. 斗地主之顺子\r#\r描述\n在斗地主扑克牌游戏中， 扑克牌由小到大的顺序为：3,4,5,6,7,8,9,10,J,Q,K,A,2，玩家可以出的扑克牌阵型有：单张、对子、顺子、飞机、炸弹等。 其中顺子的出牌规则为：由至少5张由小到大连续递增的扑克牌组成，且不能包含2。 例如：{3,4,5,6,7}{3,4,5,6,7,8,9,10,J,Q,K,A}都是有效的顺子；而{J,Q,K,A,2}{3,4,5,6}{3,4,5,6,8}等都不是顺子。 给定一个包含13张牌的数组，如果有满足出牌规则的顺子，请输出顺子。 如果存在多个顺子，请每行输出一个顺子，且需要按顺子的第一张牌的大小（必须从小到大）依次输出。 如果没有满足出牌规则的顺子，请输出No。 输入描述：13张任意顺序的扑克牌，每张扑克牌数字用空格隔开，每张扑克牌的数字都是合法的，并且不包括大小王： 输出描述：组成的顺子，每张扑克牌数字用空格隔开： 输入：2 9 J 10 3 4 K A 7 Q A 5 6 输出：3 4 5 6 7 9 10 J Q K A 输入：3 3 4 4 5 5 6 6 7 7 8 8 9 输出：3 4 5 6 7 8 3 4 5 6 7 8 9 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] strings = sc.nextLine().split(\u0026#34; \u0026#34;); int[] arr = new int[15]; int index; for (String str : strings) { index = getIndex(str); arr[index]++; } solution(arr); } private static void solution(int[] arr) { List\u0026lt;String\u0026gt; ansList = new ArrayList\u0026lt;\u0026gt;(); for (int left = 3; left \u0026lt;= 10; left++) { if (arr[left] \u0026lt;= 0) { continue; } int right = left + 1; for (; right \u0026lt;= 14; right++) { if (arr[right] \u0026lt;= 0) { break; } } right--; if (right - left \u0026gt;= 4) { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int k = left; k \u0026lt;= right; k++) { arr[k]--; list.add(getString(k)); } ansList.add(String.join(\u0026#34; \u0026#34;, list)); left--; } } ansList.stream().sorted().forEach(System.out::println); } private static int getIndex(String str) { return switch (str) { case \u0026#34;J\u0026#34; -\u0026gt; 11; case \u0026#34;Q\u0026#34; -\u0026gt; 12; case \u0026#34;K\u0026#34; -\u0026gt; 13; case \u0026#34;A\u0026#34; -\u0026gt; 14; default -\u0026gt; Integer.parseInt(str); }; } private static String getString(int index) { return switch (index) { case 11 -\u0026gt; \u0026#34;J\u0026#34;; case 12 -\u0026gt; \u0026#34;Q\u0026#34;; case 13 -\u0026gt; \u0026#34;K\u0026#34;; case 14 -\u0026gt; \u0026#34;A\u0026#34;; default -\u0026gt; String.valueOf(index); }; } "},{"id":22,"href":"/lang2/framework/mybatis/","title":"MyBatis","section":"开源框架","content":"\r\u0026ndash; MyBatis\r#\rMyBatis\n是一个基于java的持久层框架 它内部封装了JDBC，使开发者只需要专注于sql语句本身 特点\n1. 与JDBC相比，减少了50%以上的代码量 2. 基于SQL语句编程，相当灵活。 3. SQL写在XML里，降低了耦合度，便于统一管理和优化，且可重用 4. 提供XML标签，支持编写动态SQL语句 5. 提供映射标签，支持对象与数据库的ORM字段关系映射 6. 兼容各种数据库，能够与Spring很好的集成 \u0026ndash; MyBatis 缓存机制\r#\r1. mybatis提供查询缓存，用于减轻数据压力，提高数据库性能 2. 缓存失效：查询条件不相同，或两次查询之间出现了增删改操作 缓存 级别 开启 缓存范围 一级缓存 SqlSession 级别 默认开启 同一个SqlSession，即数据库会话 二级缓存 Mapper 级别 配置开启 同一个Mapper，即同一个 namespace 的 mapper.xml \u0026ndash; JDBC 编程步骤\r#\r加载驱动\nClass.forName(\u0026#34;com.mysql.jdbc.Driver\u0026#34;); 建立连接\nString user = \u0026#34;xxx\u0026#34;; String password = \u0026#34;xxx\u0026#34;; String url = \u0026#34;jdbc:mysql://127.0.0.1:3306/xxx?useUnicode=true\u0026#34;; Connection conn = DriverManager.getConnection(url, user, password); 创建 Statement\nString sql =\u0026#34;SELECT * FROM catalog_info WHERE catalog_name=?\u0026#34;; PreparedStatement prs = conn.prepareStatement(sql); prs.setString(1, \u0026#34;JavaSE\u0026#34;); 执行sql语句，获取结果集\nResultSet res = prs.executeQuery(); while (res.next()) { System.out.println(res.getLong(\u0026#34;catalog_id\u0026#34;) + \u0026#34; - \u0026#34; + res.getString(\u0026#34;catalog_name\u0026#34;)); } 关闭资源\nres.close(); prs.close(); conn.close(); \u0026ndash; #{}、${}\r#\r含义 Mybatis 处理过程 防止SQL注入 #{} 预编译处理 将 #{} 替换为 ? 号，再调用PreparedStatement的set方法来赋值 可以 ${} 字符串替换 将 ${} 替换成变量的值 不能 "},{"id":23,"href":"/lang2/program-lang/java-base/p3/","title":"Part.3","section":"Java基础","content":"\r\u0026ndash; HashMap 的工作原理\r#\r底层数据结构\nHashMap 底层是由数组和单向链表实现，数组中的每个元素都是链表，由 Node 内部类实现 HashMap 通过 put \u0026amp; get 方法存储和获取元素对象 存储对象时，将 K/V 键值传给 put() 方法\n1、调用 hash(K)方法计算 K的 hash值，然后结合数组长度，计算得数组下标； 2、判断数组该下标节点是否存在： A. 如果不存在，则新增节点，直接执行插入 B. 如果已存在，即为发生哈希碰撞，则遍历该位置的链表，对比判断 K值、hash值，是否在链表节点中已经存在： a. 如果已存在，则更新链表节点的键值对； b. 如果不存在，则新增节点，插入链表的尾部（尾插法）或者红黑树中（树的添加方式） 3、判断是否需要扩容，调整数组大小； 获取对象时，将 K 传给 get() 方法\n1、调用 hash(K)方法计算 K的 hash值，然后结合数组长度，计算得数组下标，即找到了该 K所在的链表 2、顺序遍历链表，对比查找 K值、hash值两者相同的链表节点 3、如果找到，则返回链表节点的 V值，否则返回空 \u0026ndash; HashMap 的数据结构\r#\rJDK1.7及其之前，是数组+链表\nJDK1.8及其之后，是数组+链表/红黑树\n\u0026ndash; HashMap 的数组的初始化长度\r#\r默认的初始容量值是16，也可以手动指定 \u0026ndash; HashMap 的容量\r#\r1、容量capacity，决定着table 数组的大小，默认是16，也可以构造时传入 2、装载因子loadFactor，主要目的是用来确认table 数组是否需要动态扩展，默认值是0.75(概率泊松分布) 3、阈值threshold，等于capacity * loadFactor，当超过阈值时 table 就需要动态扩容 \u0026ndash; HashMap 的数组什么时候扩容\r#\rJDK1.7及其之前，以下两个条件同时满足时会扩容： 1、size 达到 threshold 2、table[index]!=null JDK1.8及其之后，以下两个条件满足其一时会扩容： 1、size达到threshold 2、当table[index]下的结点个数达到8个但是table.length又没有达到64 \u0026ndash; HashMap 什么时候会转红黑树\r#\r当table[index]下的结点个数达到8个，但是table.length已经达到64 \u0026ndash; HashMap 的数组长度为什么是2的幂次方数\r#\r为了效率更快： 1、在HashMap中，先得到key的hashcode，然后通过hashcode \u0026amp; (table.length - 1) 运算得到一个数组下标index 2、用与运算计算数组下标，相比于取余运算速度更快，但这有个前提条件，就是数组的长度得是一个2的幂次方数。 \u0026ndash; HashMap、HashTable\r#\rHashMap HashTable 非线程安全，效率相对较高 线程安全，效率相对较低 key/value 都允许为 null key/value 都不允许为 null 默认初始容量16，按 2n 进行扩容 默认初始容量11，按 2n+1 进行扩容 重新计算hash值 直接使用对象的 hashCode \u0026ndash; HashMap、ConcurrentHashMap\r#\r区别\nHashMap： 1. key/value 都允许为 null值 2. 非线程安全 ConcurrentHashMap： 1. key/value 都不允许为 null值 2. 线程安全 ConcurrentHashMap 线程锁：\nJDK 1.7中 1、使用分段锁，相当于把一个 HashMap 分成多个段，每段分配一把锁。 2、锁粒度：基于 Segment，包含多个 HashEntry。 JDK 1.8中 1、使用 CAS + synchronized + Node + 红黑树 2、锁粒度：Node（首结点） \u0026ndash; HashMap、LinkedHashMap、TreeMap\r#\rHashMap\n1、底层是基于哈希表（散列表/数组）的数据结构 2、key是无序的 TreeMap\n1、底层是基于红黑树的数据结构 2、key是有序的 3、使用场景：在需要按自然顺序或自定义顺序遍历键的情况下 LinkedHashMap\n1、继承自HashMap，其内部多维护了一个双向链表 2、key是有序的 3、使用场景：在需要输出的顺序和输入的顺序相同的情况下 "},{"id":24,"href":"/lang2/dev-tool/tomcat/","title":"Tomcat","section":"开发工具","content":"\r\u0026ndash; Tomcat\r#\r是一个免费开源的轻量级Web应用服务器 默认端口：8080 \u0026ndash; Tomcat 部署方式\r#\r使用 Tomcat 的自动部署\n将web应用拷贝到webapps目录。 当Tomcat启动时，会自动部署应用。 使用 Manager 应用部署\n进入Tomcat主页的Manager App控制台，可以指定一个web应用的路径或war文件 修改 conf/server.xml 文件部署\n在server.xml文件的\u0026lt;Host\u0026gt;标签内添加\u0026lt;Context\u0026gt;标签，可以指定应用路径和文件位置 \u0026ndash; Tomcat 目录结构\r#\rbin -- 脚本文件 conf -- 配置文件 lib -- 公共类库 logs -- 日志文件 temp -- 临时文件 webapps -- web应用目录 work -- 编译后的文件 "},{"id":25,"href":"/lang2/program-design/structure-algorithm/huawei-od/%E5%8F%82%E8%80%83%E9%A2%981/","title":"参考题 - 1","section":"华为OD","content":"\r01. 字符串反转\r#\r描述\n接受一个只包含小写字母的字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000） 输入描述：输入一行，为一个只包含小写字母的字符串。 输出描述：输出该字符串反转后的字符串。 输入：abcd 输出：dcba 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); StringBuilder sb = new StringBuilder(str); sb.reverse(); System.out.println(sb); } 02. 数字颠倒\r#\r描述\n输入一个整数，将这个整数以字符串的形式逆序输出 程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001 数据范围：0≤n≤2^30−1 输入描述：输入一个int整数 输出描述：将这个整数以字符串的形式逆序输出 输入：1516000 输出：0006151 题解\n同01题 03. 表达式求值\r#\r描述\n给定一个字符串描述的算术表达式，计算出结果值。 输入字符串长度不超过 100 ，合法的字符包括 +, -, *, /, (, ),0-9 数据范围：运算过程中和最终结果均满足∣val∣≤2^31 −1 ，即只进行整型运算，确保输入的表达式合法 输入描述：输入算术表达式 输出描述：计算出结果值 输入：400+5 输出：405 题解\npublic static void main(String[] args) throws ScriptException { Scanner sc = new Scanner(System.in); String line = sc.nextLine(); ScriptEngine engine = new ScriptEngineManager().getEngineByName(\u0026#34;js\u0026#34;); System.out.println(engine.eval(line)); } 04. 字符逆序\r#\r描述\n将一个字符串str的内容颠倒过来，并输出。 数据范围：1≤len(str)≤10000 输入描述：输入一个字符串，可以有空格 输出描述：输出逆序的字符串 输入：I am a student 输出：tneduts a ma I 题解\npublic static void main(String[] args){ Scanner sc = new Scanner(System.in); String line = sc.nextLine(); StringBuilder res = new StringBuilder(line); System.out.println(res.reverse()); } 05. 尼科彻斯定力\r#\r描述\n验证尼科彻斯定理，即：任何一个整数m的立方都可以写成m个连续奇数之和。 例如： 1^3=1 2^3=3+5 3^3=7+9+11 4^3=13+15+17+19 输入一个正整数m（m≤100），将m的立方写成m个连续奇数之和的形式输出。 数据范围：1≤m≤100 输入描述：输入一个int整数 输出描述：输出分解后的string 输入：6 输出：31+33+35+37+39+41 题解\n// 由等差数列公式，公差d=2 // 可得a1=m(m-1)+1 public static void main(String[] args){ Scanner sc = new Scanner(System.in); int m = sc.nextInt(); int a1 = m * (m - 1) + 1; StringBuilder sb = new StringBuilder(Integer.toString(a1)); for(int i = 1; i \u0026lt; m; i++){ a1 = a1 + 2; sb.append(\u0026#34;+\u0026#34;); sb.append(a1); } System.out.println(sb); } 06. 公共子串计算\r#\r描述\n给定两个只包含小写字母的字符串，计算两个字符串的最大公共子串的长度。 注：子串的定义指一个字符串删掉其部分前缀和后缀（也可以不删）后形成的字符串。 数据范围：字符串长度：1≤s≤150 输入描述：输入两个只包含小写字母的字符串 输出描述：输出一个整数，代表最大公共子串的长度 输入：asdfas werasdfaswer 输出：6 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chs1 = sc.nextLine().toCharArray(); char[] chs2 = sc.nextLine().toCharArray(); int maxLen = 0; for (int i = 0; i \u0026lt; chs1.length; i++) { for (int j = 0; j \u0026lt; chs2.length; j++) { int t1 = i; int t2 = j; int count = 0; while (chs1[t1] == chs2[t2]) { t1++; t2++; count++; maxLen = Math.max(count, maxLen); if (t1 == chs1.length || t2 == chs2.length) { break; } } } } System.out.println(maxLen); } 07. 求最大连续bit数\r#\r描述\n求一个int类型数字对应的二进制数字中1的最大连续数，例如3的二进制为00000011，最大连续2个1 数据范围：数据组数：1≤t≤5 ，1≤n≤500000 输入描述：输入一个int类型数字 输出描述：输出转成二进制之后连续1的个数 输入：200 输出：2 题解\npublic static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String input = null; while ((input = br.readLine()) != null) { char[] binary = Integer.toBinaryString(Integer.parseInt(input)).toCharArray(); int max = 0; // 最大连续数 int count = 0; // 当前连续数 for (char b : binary) { if (b == \u0026#39;1\u0026#39;) { count++; if (count \u0026gt; max) { max = count; } } else { count = 0; } } System.out.println(max); } } 08. 最长回文子串\r#\r描述\n给定一个仅包含小写字母的字符串，求它的最长回文子串的长度。所谓回文串，指左右对称的字符串。 所谓子串，指一个字符串删掉其部分前缀和后缀（也可以不删）的字符串 数据范围：字符串长度1≤s≤350 输入描述：输入一个仅包含小写字母的字符串 输出描述：返回最长回文子串的长度 输入：cdabbacc 输出：4 说明：abba为最长的回文子串 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String line = sc.nextLine(); int maxLen = 0; for (int i = 0; i \u0026lt; line.length(); i++) { for (int j = i + 1; j \u0026lt;= line.length(); j++) { // 回文字符串 反转后与其自身相等 String sub = line.substring(i, j); String subRev = new StringBuilder(sub).reverse().toString(); if (sub.equals(subRev)) { maxLen = Math.max(maxLen, sub.length()); } } } System.out.println(maxLen); } 09. 等差数列\r#\r描述\n等差数列 2，5，8，11，14。。。。（从 2 开始的 3 为公差的等差数列） 输出求等差数列前n项和 数据范围：1≤n≤1000 输入描述：输入一个正整数n。 输出描述：输出一个相加后的整数。 输入：2 输出：7 说明：2+5=7 输入：275 输出：113575 题解\n// 等差数列求和公式 public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int sum = 2 * n + (n * (n - 1) * 3) / 2; System.out.println(sum); } 10. 密码强度等级\r#\r描述\n密码按如下规则进行计分，并根据不同的得分为密码进行安全等级划分。 一、密码长度: 5 分: 小于等于4 个字符 10 分: 5 到7 字符 25 分: 大于等于8 个字符 二、字母: 0 分: 没有字母 10 分: 密码里的字母全都是小（大）写字母 20 分: 密码里的字母符合”大小写混合“ 三、数字: 0 分: 没有数字 10 分: 1 个数字 20 分: 大于1 个数字 四、符号: 0 分: 没有符号 10 分: 1 个符号 25 分: 大于1 个符号 五、奖励（只能选符合最多的那一种奖励）: 2 分: 字母和数字 3 分: 字母、数字和符号 5 分: 大小写字母、数字和符号 最后的评分标准: \u0026gt;= 90: 非常安全 \u0026gt;= 80: 安全（Secure） \u0026gt;= 70: 非常强 \u0026gt;= 60: 强（Strong） \u0026gt;= 50: 一般（Average） \u0026gt;= 25: 弱（Weak） \u0026gt;= 0: 非常弱（Very_Weak） 对应输出为：VERY_SECURE、SECURE、VERY_STRONG、STRONG、AVERAGE、WEAK、VERY_WEAK 请根据输入的密码字符串，进行安全评定。 注： 字母：a-z, A-Z 数字：0-9 符号包含如下： (ASCII码表可以在UltraEdit的菜单view-\u0026gt;ASCII Table查看) !\u0026#34;#$%\u0026amp;\u0026#39;()*+,-./ (ASCII码：0x21~0x2F) :;\u0026lt;=\u0026gt;?@ (ASCII码：0x3A~0x40) [\\]^_` (ASCII码：0x5B~0x60) {|}~ (ASCII码：0x7B~0x7E) 提示：1≤字符串的长度≤300 输入描述：输入一个string的密码 输出描述：输出密码等级 输入：38$@NoNoN 输出：VERY_SECURE 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chs = sc.nextLine().toCharArray(); int score = 0; //统计长度 int len = chs.length; if (len \u0026lt;= 4) score += 5; else if (len \u0026lt; 8) score += 10; else score += 25; //遍历获取大小写字母、数字、符号数目 int upCount = 0; int lowCount = 0; int numCount = 0; int sigCount = 0; for (char ch : chs) { if (Character.isUpperCase(ch)) ++upCount; else if (Character.isLowerCase(ch)) ++lowCount; else if (Character.isDigit(ch)) ++numCount; else ++sigCount; } //字母分数 if ((upCount \u0026gt; 0 \u0026amp;\u0026amp; lowCount == 0) || (upCount == 0 \u0026amp;\u0026amp; lowCount \u0026gt; 0)) score += 10; else if (upCount \u0026gt; 0 \u0026amp;\u0026amp; lowCount \u0026gt; 0) score += 20; //数字分数 if (numCount == 1) score += 10; else if (numCount \u0026gt; 1) score += 20; //符号分数 if (sigCount == 1) score += 10; else if (sigCount \u0026gt; 1) score += 25; //奖励分数 if (numCount \u0026gt; 0 \u0026amp;\u0026amp; upCount \u0026gt; 0 \u0026amp;\u0026amp; lowCount \u0026gt; 0 \u0026amp;\u0026amp; sigCount \u0026gt; 0) score += 5; else if (numCount \u0026gt; 0 \u0026amp;\u0026amp; sigCount \u0026gt; 0 \u0026amp;\u0026amp; (upCount \u0026gt; 0 || lowCount \u0026gt; 0)) score += 3; else if (numCount \u0026gt; 0 \u0026amp;\u0026amp; (upCount \u0026gt; 0 || lowCount \u0026gt; 0)) score += 2; //评分 if (score \u0026gt;= 90) System.out.println(\u0026#34;VERY_SECURE\u0026#34;); else if (score \u0026gt;= 80) System.out.println(\u0026#34;SECURE\u0026#34;); else if (score \u0026gt;= 70) System.out.println(\u0026#34;VERY_STRONG\u0026#34;); else if (score \u0026gt;= 60) System.out.println(\u0026#34;STRONG\u0026#34;); else if (score \u0026gt;= 50) System.out.println(\u0026#34;AVERAGE\u0026#34;); else if (score \u0026gt;= 25) System.out.println(\u0026#34;WEAK\u0026#34;); else System.out.println(\u0026#34;VERY_WEAK\u0026#34;); } 11. 字符个数统计\r#\r描述\n编写一个函数，计算字符串中含有的不同字符的个数。字符在 ASCII 码范围内( 0~127 ，包括 0 和 127 )，换行表示结束符，不算在字符里。不在范围内的不作统计。多个相同的字符只计算一次 例如，对于字符串 abaca 而言，有 a、b、c 三种不同的字符，因此输出 3 。 数据范围：1≤n≤500 输入描述：输入一行没有空格的字符串。 输出描述：输出 输入字符串 中范围在(0~127，包括0和127)字符的种数。 输入：abc 输出：3 题解\n// 数组下标不重复，且有序 public static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chs = sc.nextLine().toCharArray(); int[] temArr = new int[128]; int count = 0; for (char ch : chs) { if (temArr[ch] == 0) { count++; temArr[ch] = 1; } } System.out.println(count); } 12. 截取字符串\r#\r描述\n输入一个字符串和一个整数 k ，截取字符串的前k个字符并输出 数据范围：字符串长度满足 1≤n≤1000，1≤k≤n 输入描述：1.输入待截取的字符串。2.输入一个正整数k，代表截取的长度 输出描述：截取后的字符串 输入：abABCcDEF 6 输出：abABCc 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); int k = Integer.parseInt(sc.nextLine()); System.out.println(str.substring(0, k)); } 13. 查找组成一个偶数最接近的两个素数\r#\r描述\n任意一个偶数（大于2）都可以由2个素数组成，组成偶数的2个素数有很多种情况，本题目要求输出组成指定偶数的两个素数差值最小的素数对。 数据范围：输入的数据满足 4≤n≤1000 输入描述：输入一个大于2的偶数 输出描述：从小到大输出两个素数 输入：20 输出：7 13 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m1 = n / 2; int m2 = n / 2; while (!isPrime(m1) || !isPrime(m2)) { m1--; m2++; } System.out.println(m1); System.out.println(m2); } public static boolean isPrime(int n) { for (int i = 2; i \u0026lt;= n / 2; i++) { if (n % i == 0) { return false; } } return true; } 14. 统计字符\r#\r描述\n输入一行字符，分别统计出包含英文字母、空格、数字和其它字符的个数。 数据范围：输入的字符串长度满足 1≤n≤1000 输入描述：输入一行字符串，可以有空格 输出描述：统计其中英文字符，空格字符，数字字符，其他字符的个数 输入：1qazxsw23 edcvfr45tgbn hy67uj m,ki89ol.\\\\/;p0-=\\\\][ 输出：26 3 10 12 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); String str1 = str.replaceAll(\u0026#34;[^a-zA-Z]\u0026#34;, \u0026#34;\u0026#34;); String str2 = str.replaceAll(\u0026#34;[^ ]\u0026#34;, \u0026#34;\u0026#34;); String str3 = str.replaceAll(\u0026#34;[^0-9]\u0026#34;, \u0026#34;\u0026#34;); String str4 = str.replaceAll(\u0026#34;[a-zA-Z0-9 ]\u0026#34;, \u0026#34;\u0026#34;); System.out.println(str1.length()); System.out.println(str2.length()); System.out.println(str3.length()); System.out.println(str4.length()); } 15. 字符串排序\r#\r描述\n给定 n 个字符串，请对 n 个字符串按照字典序排列。 数据范围：1≤n≤1000，字符串长度满足 1≤len≤100 输入描述：输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。 输出描述：数据输出n行，输出结果为按照字典序排列的字符串。 输入：5 cap to cat boat boot 输出：boat boot cap cat to 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int sum = Integer.parseInt(sc.nextLine()); String[] arr = new String[sum]; for (int i = 0; i \u0026lt; sum; i++) { arr[i] = sc.nextLine(); } Arrays.sort(arr); Arrays.stream(arr).forEach(System.out::println); } 16. 进制转换\r#\r描述\n写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。 数据范围：保证结果在1≤n≤2^31−1 输入描述：输入一个十六进制的数值字符串。 输出描述：输出该数值的十进制字符串。不同组的测试用例用\\n隔开。 输入：0xAA 输出：170 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine().substring(2); int val = Integer.parseInt(str, 16); System.out.println(val); } 17. 找出字符串中第一个只出现一次的字符\r#\r描述\n找出字符串中第一个只出现一次的字符 数据范围：输入的字符串长度满足1≤n≤1000 输入描述：输入一个非空字符串 输出描述：输出第一个只出现一次的字符，如果不存在输出-1 输入：asdfasdfo 输出：o 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); for (int i = 0; i \u0026lt; str.length(); i++) { char ch = str.charAt(i); if (str.indexOf(ch) == str.lastIndexOf(ch)) { System.out.println(ch); return; } } System.out.println(-1); } 18. 输入n个整数，输出其中最小的K个\r#\r描述\n输入n个整数，找出其中最小的k个整数并按升序输出 本题有多组输入样例 数据范围：1≤n≤1000，输入的整数满足 1≤val≤10000 输入描述：第一行输入两个整数n和k，第二行输入一个整数数组 输出描述：从小到大输出最小的k个整数，用空格分开。 输入：5 2 1 3 5 7 2 输出：1 2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); int k = sc.nextInt(); int[] arr = new int[n]; for (int i = 0; i \u0026lt; n; i++) { arr[i] = sc.nextInt(); } Arrays.sort(arr); StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; k; i++) { sb.append(arr[i]).append(\u0026#34; \u0026#34;); } System.out.println(sb.toString().trim()); } } 19. 字符串字符匹配\r#\r描述\n判断短字符串S中的所有字符是否在长字符串T中全部出现。 请注意本题有多组样例输入。 数据范围：1≤len(S),len(T)≤200 输入描述：输入两个字符串。第一个为短字符串，第二个为长字符串。两个字符串均由小写字母组成。 输出描述：如果短字符串的所有字符均在长字符串中出现过，则输出字符串\u0026#34;true\u0026#34;。否则输出字符串\u0026#34;false\u0026#34;。 输入：bc abc 输出：true 说明：其中abc含有bc，输出\u0026#34;true\u0026#34; 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String shortStr = sc.nextLine(); String longStr = sc.nextLine(); Set\u0026lt;Character\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; shortStr.length(); ++i) { set.add(shortStr.charAt(i)); } for (int i = 0; i \u0026lt; longStr.length(); ++i) { set.remove(longStr.charAt(i)); } System.out.println(set.isEmpty()); } } "},{"id":26,"href":"/lang2/program-design/structure-algorithm/leetcode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","title":"滑动窗口","section":"leetcode","content":"\r滑动窗口\r#\r滑动窗口\r#\r使用两个指针划出一个窗口，并维护窗口数据的有效性 无重复字符的最长子串\r#\r原题\n给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。 输入: s = \u0026#34;abcabcbb\u0026#34; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026#34;abc\u0026#34;，所以其长度为 3。 题解\n1、窗口内是无重复子串 2、在窗口右端追加一个字符，则要判断窗口内是否已经存在该字符 3、如果存在，则要去除窗口内重复字符位置左端的所有字符 // 滑动窗口 public class Main { public int lengthOfLongestSubstring(String s) { // 窗口 Set\u0026lt;Character\u0026gt; occ = new HashSet\u0026lt;\u0026gt;(); int ans = 0; int left = 0; for (int right = 0; right \u0026lt; s.length(); right++) { while (occ.contains(s.charAt(right))) { occ.remove(s.charAt(left++)); } occ.add(s.charAt(right)); ans = Math.max(ans, right - left + 1); } return ans; } } // 加入哈希 public class Main { public int lengthOfLongestSubstringHash(String s) { HashMap\u0026lt;Character, Integer\u0026gt; keyIndex = new HashMap\u0026lt;\u0026gt;(); int length = s.length(); int maxLength = 0; int lashIndex = 0; for (int i = 0; i \u0026lt; length ; i++) { final char c = s.charAt(i); if (keyIndex.containsKey(c)) { lashIndex = Math.max(keyIndex.get(c) + 1, lashIndex); } keyIndex.put(c, i); int currLength = i - lashIndex + 1; if (maxLength \u0026lt; currLength) { maxLength = currLength; } } return maxLength; } } 找到字符串中所有字母异位词\r#\r原题\n给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。 输入: s = \u0026#34;cbaebabacd\u0026#34;, p = \u0026#34;abc\u0026#34; 输出: [0,6] 解释: 起始索引等于 0 的子串是 \u0026#34;cba\u0026#34;, 它是 \u0026#34;abc\u0026#34; 的异位词。 起始索引等于 6 的子串是 \u0026#34;bac\u0026#34;, 它是 \u0026#34;abc\u0026#34; 的异位词。 题解\npublic class Main { public List\u0026lt;Integer\u0026gt; findAnagrams(String s, String p) { List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); if (s.length() \u0026lt; p.length()) { return ans; } // 窗口 int[] sCount = count(s, p.length() - 1); int[] target = count(p, p.length()); for (int i = 0; i \u0026lt; s.length() - p.length() + 1; i++) { sCount[s.charAt(i + p.length() - 1) - \u0026#39;a\u0026#39;]++; if (Arrays.equals(target, sCount)) { ans.add(i); } sCount[s.charAt(i) - \u0026#39;a\u0026#39;]--; } return ans; } private int[] count(String s, int end) { int[] ans = new int[26]; for (int i = 0; i \u0026lt; end; i++) { final int c = s.charAt(i) - \u0026#39;a\u0026#39;; ans[c]++; } return ans; } } "},{"id":27,"href":"/lang2/program-design/structure-algorithm/dir/","title":"目录","section":"数据结构与算法","content":"\r素数\r#\r// 判断 n 是否为素数 private static boolean isPrime(int n) { if (n \u0026lt; 2) { return false; } for (int i = 2; i \u0026lt;= Math.sqrt(n); i++) { if (n % i == 0) { return false; } } return true; } 互质\r#\r// 计算它们的最大公约数，如果最大公约数为1，则说明两个数互质 private static boolean isRelativePrime(int x, int y) { // 两个数辗转相除 while (y \u0026gt; 0) { int mod = x % y; x = y; y = mod; } return x == 1; } 并查集\r#\r// 并查集 static class UnionFindSet { int[] fa; // 初始化，设置i的父节点fa[i]为自身 public UnionFindSet(int n) { this.fa = new int[n]; for (int i = 0; i \u0026lt; n; i++) { fa[i] = i; } } // 查找x的根节点 public int findRoot(int x) { // 递归中断条件：根节点为自身 if (fa[x] == x) { return x; } // 递归：查询x的根节点 int root = findRoot(fa[x]); // 递归路径压缩：直接设置x的父节点为根 fa[x] = root; return root; } // 合并节点x、y public void union(int x, int y) { // 查找xy两者的根节点 int xFa = this.findRoot(x); int yFa = this.findRoot(y); // 合并：将xy两者的根节点设为一样 fa[xFa] = yFa; } } DFS\r#\rint area(int[][] grid, int r, int c) { // 判断 base case if (!inArea(grid, r, c)) { return 0; } // 如果这个格子不是岛屿，直接返回 if (grid[r][c] != 1) { return 0; } // 将格子标记为「已遍历过」 grid[r][c] = 2; // 访问上、下、左、右四个相邻结点 return 1 + area(grid, r - 1, c) + area(grid, r + 1, c) + area(grid, r, c - 1) + area(grid, r, c + 1); } // 判断坐标 (r, c) 是否在网格中 boolean inArea(int[][] grid, int r, int c) { return 0 \u0026lt;= r \u0026amp;\u0026amp; r \u0026lt; grid.length \u0026amp;\u0026amp; 0 \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt; grid[0].length; } 打印\r#\r/* %f : 输出浮点数 %.nf : 控制小数点后的位数，n为数字 %c : 输出字符 %d : 输出十进制整数 %o : 输出八进制整数 %x : 输出十六进制整数 %X : 输出大写十六进制整数 */ System.out.printf(\u0026#34;%.2f%n\u0026#34;, d); // %02d 表示将整数值按照至少占据两个字符的方式输出，不足两位时会在前面补零 // %n 表示一个换行符 System.out.printf(\u0026#34;%02d:%02d%n\u0026#34;, hour, minute); 其他\r#\r全排列 如果：一共n个元素，其中某元素A重复x次，某元素B重复了y次， 那么：最终不重复全排列个数 = n! / x! / y! 生成哈夫曼树的固定思路： 取出优先队列中前两个权值最小的节点，作为新节点的左右子树 水仙花数\r#\r// 或者预先计算水仙花数表 // 3 位：153, 370, 371, 407 // 4 位：1634, 8208, 9474 // 5 位：54748, 92727, 93084 // 6 位：548834 // 7 位：1741725, 4210818, 9800817, 9926315 必会 1. 数组 2. 字符串 3. 排序 4. 贪心 5. 递归 6. 循环 7. 滑窗 8. 栈 9. 进制转换 10. 位运算 11. 队列 12. 哈希表 13. 链表 14. 线性表 15. 二分查找 进阶 1. 图 2. 树 3. DFS搜索 4. BFS搜索 5. 动态规划 6. 前缀和 7. 排列组合 8. 矩阵 9. 双指针 10. 回溯 11. 状态机 12. 并查集 13. 正则表达式 14. 分治 15. 枚举 16. 统计 建议 必会部分知识点倾向于出现在100分题中，进阶知识点倾向于出现在200分题中。 建议必会部分优先掌握1-10知识点， 进阶部分优先掌握1-4知识点，这部分出现频次高，短时间内刷题性价比高。 import java.util.Scanner; // 注意类名必须为 Main, 不要有任何 package xxx 信息 public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 注意 hasNext 和 hasNextLine 的区别 while (in.hasNext()) { // 注意 while 处理多个 case Long a = in.nextLong(); Long b = in.nextLong(); System.out.println(a + b); } } } ASCII 48-57：0-9\r65-90：A-Z\r97-122：a-z 输入 //1. Scanner in = new Scanner(System.in); // InputStream is = System.in; // BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); ## 1\r- 原题\r```html\r```\r- 题解\r```html\r```\r```java\rpublic class Main {\r}\r```\r"},{"id":28,"href":"/lang2/program-design/structure-algorithm/leetcode/%E5%AD%90%E4%B8%B2/","title":"子串","section":"leetcode","content":"\r子串\r#\r子串\r#\r长串数据中一段连续的数据 和为 K 的子数组\r#\r原题\n给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。 子数组是数组中元素的连续非空序列。 输入：nums = [1,1,1], k = 2 输出：2 题解\n1、遍历数组，计算nums[0]到nums[i]的和pre 2、使用哈希表存储键值对，键为pre，值为次数 3、如果哈希表存在键pre-k，则代表存在一个子数组，该子数组末端到nums[i]之间的数字之和等于k 问题转为：pre[i]−pre[j−1]==k （前缀和之差为k，代表这两个前缀之间的数字相加就是K） public class Main { public int subarraySum(int[] nums, int k) { HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(0, 1); int pre = 0; int count = 0; for (int i = 0; i \u0026lt; nums.length; i++) { pre += nums[i]; if (map.containsKey(pre - k)) { count += map.get(pre - k); } map.put(pre, map.getOrDefault(pre, 0) + 1); } return count; } } 1\r#\r原题\n题解\npublic class Main { } 1\r#\r原题\n题解\npublic class Main { } "},{"id":29,"href":"/lang2/service-manage/nginx/","title":"Nginx","section":"服务治理","content":"\r\u0026ndash; Nginx\r#\r是一个开源的高性能 HTTP 服务器和反向代理服务器\n优点： 1. 高并发、高可靠性、低内存消耗 2. 配置简单、支持热部署 3. 良好的负载均衡和缓存功能 \u0026ndash; Nginx 处理HTTP请求\r#\rNginx 是一个高性能的 Web 服务器，能够同时处理大量的并发请求\n1. 多进程机制 Nginx包含一个主进程和多个工作进程。 主进程主要负责调度管理工作进程，工作进程则负责处理用户的请求 2. 异步非阻塞机制 工作进程接收到客户端的请求以后，会调用IO进行处理， 当发生等待时，工作线程会注册一个事件，转而去处理其他的请求 当IO返回时，就会触发该事件，工作线程会继续执行该未完成的请求 \u0026ndash; 正向代理、反向代理\r#\r正向代理\n1. 是一个代理服务器，它代表客户端向目标服务器发起请求。 2. 代理的对象是客户端，对外隐藏了真实的客户端 反向代理\n1. 是一个代理服务器，它代表服务端向客户端提供服务 2. 代理的对象是服务端，对外隐藏了真实的服务端 "},{"id":30,"href":"/lang2/service-manage/dubbo/","title":"Dubbo","section":"服务治理","content":"\r\u0026ndash; Dubbo\r#\r是一款高性能、轻量级的开源Java RPC框架 \u0026ndash; Dubbo 工作原理\r#\r0. 服务容器负责启动、加载、运行服务提供者。 1. 服务提供者向注册中心注册自己提供的服务 2. 服务消费者向注册中心订阅自己消费的服务 3. 注册中心通知服务消费者，服务节点的变更 4. 服务消费者基于负载均衡算法，从服务列表中选一台进行调用 5. 服务消费者/提供者，将调用信息发送到监控中心 \u0026ndash; Dubbo 负载均衡策略\r#\r策略 策略 说明 随机策略 random 随机选择一个可用的服务节点 轮询策略 roundrobin 按公平轮询的方式选择服务节点 最少活跃数策略 leastactive 优先选择活跃调用数最少的服务节点 一致性哈希策略 consistenthash 通过哈希算法将相同参数的请求发送到同一个服务节点 \u0026ndash; Dubbo、Spring Cloud\r#\rDubbo Spring Cloud 所属厂商 阿里系的分布式服务治理框架 Apache 旗下的 Spring 体系下的微服务解决方案 通信机制 RPC 通信 基于 HTTP 的 REST 方式 技术维度 只是实现了服务治理 覆盖了微服务架构下的方方面面 \u0026ndash; Dubbo、Zookeeper\r#\rDubbo推荐使用Zookeeper作为服务的注册中心\n1. Dubbo是管理中间层的工具，在业务层到数据仓库间，有很多服务需要接入和调度，dubbo提供一个框架解决这个问题 2. Dubbo有多种注册中心供选择，使用Zookeeper，是为了引入Zookeeper特性 \u0026ndash; RPC、REST\r#\rRPC\n1. RPC，远程过程调用，是一种进程间通信方式 2. 优点：调用简单、性能高、低延迟、自带负载均衡 3. 缺点：耦合性强、无法跨语言，平台敏感 REST\n1. REST，即RESTful ，是一种架构风格，指的是一组架构约束条件和原则。 2. 优点：耦合性低，兼容性好，通用性好，跨语言支持 3. 缺点：性能不如 RPC 高 RPC、REST\nRPC适用于内网服务调用，对外提供服务请走REST。 IO密集的服务调用用RPC，低频服务用REST 服务调用过于密集与复杂，RPC就比较适用 "},{"id":31,"href":"/lang2/service-manage/zookeeper/","title":"Zookeeper","section":"服务治理","content":"\r\u0026ndash; Zookeeper\r#\r是一个开源的分布式的服务协调框架 特点 说明 数据一致性 每个server都保存了一份相同的数据副本，client无论连接到哪个server，数据都是一致的 请求顺序性 来自同一个client的更新请求，其发送顺序和最后的执行顺序是一致的 可靠性 当一个消息被成功更新后，不会因为网络波动或其他原因而回滚 原子性 更新要不成功要不失败，没有第三个状态 独立性 不同的client之间互不影响 实时性 在一定时间范围内，client能读到最新数据 \u0026ndash; Zookeeper 角色\r#\r角色 角色 说明 Leader 领导者 为客户端提供读服务和写服务。管理集群内的所有事务的顺序，以及维护集群状态的同步 Follower 跟随者 为客户端提供读服务，参与Leader选举过程 Observer 观察者 为客户端提供读服务，不参与Leader选举过程 \u0026ndash; Zookeeper 应用场景\r#\r1. 数据发布与订阅 2. 命名服务 3. 配置管理 4. 集群管理 5. 分布式通知与协调 6. 分布式锁 7. 分布式队列 \u0026ndash; Zookeeper 工作原理\r#\r1. Zookeeper是基于观察者模式设计，接受观察者的注册 2. Zookeeper上存储和管理着大家都关心的数据 3. 当这些数据发生变化时，Zookeeper将会通知已注册的观察者做出相应的回应 \u0026ndash; Zookeeper 通知机制\r#\r1. Zookeeper允许客户端向服务端的某个znode注册一个Watcher监听 2. 当服务端的一些指定事件触发了这个Watcher，服务端会向指定客户端发送一个事件通知 3. 客户端根据Watcher通知状态和事件类型做出业务上的改变 \u0026ndash; Zookeeper 选举原则\r#\r1. Zookeeper 集群中只有超过半数以上的服务器启动，集群才能正常工作； 2. 在集群正常工作之前，myid 小的服务器给 myid 大的服务器投票，直到集群正常工作，选出 Leader； 3. 选出Leader之后，之前的服务器状态由 Looking 改变为 Following，以后的服务器都是 Follower。 \u0026ndash; Zookeeper 选举过程\r#\r假设：有五台服务器，从S1-S5 依序启动\nS1启动，发起选举\nS1投自己一票 此时S1为1票，不够半数以上，选举无法完成； S2启动，发起选举\nS2投自己一票，然后与S1交换选票，因为S2的ServerID大于S1，S1更改投S2 此时S1为0票，S2为2票，不够半数以上，选举无法完成； S3启动，发起选举\nS3投自己一票，然后与S1、S2交换选票，因为S3的ServerID最大，S1、S2更改投S3 此时S1、S2为0票，S3为3票，S3票数已经超过半数当选Leader； S4启动，发起选举\nS4投自己一票，然后相互交换选票，因为S1、S2、S3已经不是LOOKING状态，不会更改选票信息。 此时S3为3票，S4为1票，S4服从多数改投S3 S5启动，发起选举\n同4一样，S5改投S3， 最终S3是Leader，状态为LEADING； 其余服务器是Follower，状态为FOLLOWING。 \u0026ndash; Zookeeper 监听原理\r#\r1. 在Main()主线程中创建zkClient客户端。 2. zkClient会创建两个线程，一个负责网络连接通信（connet），一个负责监听（listener）。 3. zkClient通过connet线程，将监听事件注册到Zookeeper的监听列表。 4. 当数据或路径发生改变时，Zookeeper会将消息发送给listener线程。 5. listener线程调用process()方法，执行相应的操作。 "},{"id":32,"href":"/lang2/program-design/structure-algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%931/","title":"机试题库 - 1","section":"华为OD","content":"\r01. 车路协同场景\r#\r描述\n数轴×有两个点的序列 A={A1， A2, …, Am}和 B={B1, B2, ..., Bn}， Ai 和 Bj 均为正整数， A、 B 已经从小到大排好序， A、 B 均肯定不为空， 给定一个距离 R（正整数），列出同时满足如下条件的所有（Ai， Bj）数对 条件： 1、Ai ≤ Bj 2、Ai,Bj 距离小于等于 R，但如果 Ai 找不到 R 范围内的 Bj，则列出距它最近的 1 个 Bj，当然此种情况仍然要满足 1， 但如果仍然找不到，就丢弃 Ai。 输入描述：按照人易读的格式输入一行数据，参见输入样例 输出描述：(Ai,Bj)数对序列 输入：A={1,3,5},B={2,4,6},R=1 输出：(1,2)(3,4)(5,6) 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String line = sc.nextLine(); String[] strArr = line.split(\u0026#34;\\\\{|\\\\}\u0026#34;); int[] arrA = Arrays.stream(strArr[1].split(\u0026#34;,\u0026#34;)).mapToInt(Integer::parseInt).toArray(); int[] arrB = Arrays.stream(strArr[3].split(\u0026#34;,\u0026#34;)).mapToInt(Integer::parseInt).toArray(); int r = Integer.parseInt(line.substring(line.lastIndexOf(\u0026#34;=\u0026#34;) + 1)); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int a : arrA) { int sum = 0; for (int b : arrB) { if (b \u0026lt; a) { continue; } if (b - a \u0026lt;= r || sum == 0) { list.add(\u0026#34;(\u0026#34; + a + \u0026#34;,\u0026#34; + b + \u0026#34;)\u0026#34;); sum++; } else { break; } } } System.out.println(String.join(\u0026#34;,\u0026#34;, list)); } 02. API集群负载统计\r#\r描述\n某个产品的RESTful API集合部署在服务器集群的多个节点上，近期需要统计各个API的访问频次，根据热点信息在服务器节点之间做负载均衡，现在需要实现热点信息统计查询功能。RESTful API是由多个层级构成。 层级之间使用/连接，如/A/B/C/D这个地址，A属于第一级，B属于第二级，C属于第三级，D属于第四级。 现在负载均衡模块需要知道给定层级上某个名字出现的频次，未出现过用0表示，实现这个功能。 输入描述： 第一行为N，表示访问历史日志的条数，0 ＜ N ≤ 100。 接下来N行，每一行为一个URL地址，约束地址中仅包含英文字母和连接符 / ，最大层级为10，每层级字符串最大长度为10。 最后一行为层级L和要查询的关键字。 输出描述：输出给定层级上，关键字出现的频次，使用完全匹配方式（大小写敏感）。 输入：5 /huawei/computing/no/one /huawei/computing /huawei /huawei/cloud/no/one /huawei/wireless/no/one 2 computing 输出：2 说明：在第二层级上，computing出现了2次，因此输出2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); String[] arr = new String[num]; for (int i = 0; i \u0026lt; num; i++) { arr[i] = sc.nextLine(); } String[] strings = sc.nextLine().split(\u0026#34; \u0026#34;); int l = Integer.parseInt(strings[0]); String key = strings[1]; int sum = 0; for (int i = 0; i \u0026lt; num; i++) { String[] tempArr = arr[i].split(\u0026#34;/\u0026#34;); if (l \u0026lt; tempArr.length \u0026amp;\u0026amp; key.equals(tempArr[l])) { sum++; } } System.out.println(sum); } 03. CPU算力分配\r#\r描述\n现有两组服务器A和B，每组有多个算力不同的CPU，其中A[i]是A组第i个CPU的运算能力，B[i]是B组第i个CPU的运算能力。 一组服务器的总算力是各CPU的算力之和。为了让两组服务器的算力相等，允许从每组各选出一个CPU进行一次交换， 求两组服务器中，用于交换的CPU的算力，并且要求从A组服务器中选出的CPU，算力尽可能小。 输入描述： 第一行输入为L1和L2，以空格分隔，L1表示A组服务器中的CPU数量，L2表示B组服务器中的CPU数量。 第二行输入为A组服务器中各个CPU的算力值，以空格分隔。 第三行输入为B组服务器中各个CPU的算力值，以空格分隔。 1 ≤ L1 ≤ 10000 1 ≤ L2 ≤ 10000 1 ≤ A[i] ≤ 100000 1 ≤ B[i] ≤ 100000 输出描述： 对于每组测试数据，输出两个整数，以空格分隔，依次表示A组选出的CPU算力，B组选出的CPU算力。 要求从A组选出的CPU的算力尽可能小。 输入：3 2 1 2 5 2 4 输出：5 4 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int l1 = sc.nextInt(); int l2 = sc.nextInt(); int sumA = 0; int[] arrA = new int[l1]; for (int i = 0; i \u0026lt; l1; i++) { arrA[i] = sc.nextInt(); sumA += arrA[i]; } int sumB = 0; Set\u0026lt;Integer\u0026gt; tempSet = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; l2; i++) { int b = sc.nextInt(); sumB += b; tempSet.add(b); } String ans = \u0026#34;\u0026#34;; int minA = Integer.MAX_VALUE; int half = (sumA - sumB) / 2; for (int a : arrA) { // sumA - a + b = sumB - b + a // b = a - (sumA - sumB)/2 int b = a - half; if (tempSet.contains(b)) { minA = Math.min(a, minA); ans = minA + \u0026#34; \u0026#34; + b; } } for (int i = 0; i \u0026lt; l1; i++) { // sumA - a + b = sumB - b + a // b = a - (sumA - sumB)/2 int b = arrA[i] - half; if (tempSet.contains(b)) { minA = Math.min(arrA[i], minA); ans = minA + \u0026#34; \u0026#34; + b; } } System.out.println(ans); } } 04. We Are A Team\r#\r描述\n总共有 n 个人在机房，每个人有一个标号（1≤标号≤n）， 他们分成了多个团队，需要你根据收到的 m 条消息判定指定的两个人是否在一个团队中，具体的： 1. 消息构成为 a b c，整数 a、b 分别代表两个人的标号，整数 c 代表指令 2. c == 0 代表 a 和 b 在一个团队内 3. c == 1 代表需要判定，如果 a 和 b 是一个团队，输出一行’we are a team’,否则输出一行’we are not a team’ 4. c 为其他值，或当前行 a 或 b 超出 1~n 的范围，输出‘da pian zi’ 输入描述： 第一行包含两个整数 n，m(1≤n,m＜100000),分别表示有 n 个人和 m 条消息 随后的 m 行，每行一条消息，消息格式为：a b c(1≤a,b≤n,0≤c≤1) 输出描述： c ==1,判断 a 和 b关系，在一个团队中输出‘we are a team‘,不在一个团队中输出’we are not a team’ c 为其他值，或当前行 a 或 b 的标号小于 1 或者大于 n 时，输出字符串‘da pian zi‘ 如果第一行 n 和 m 的值超出约定的范围时，输出字符串”NULL“。 输入：5 6 1 2 0 1 2 1 1 5 0 2 3 1 2 5 1 1 3 2 输出：we are a team we are not a team we are a team da pian zi 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int[][] msgs = new int[m][3]; for (int i = 0; i \u0026lt; m; i++) { msgs[i][0] = sc.nextInt(); msgs[i][1] = sc.nextInt(); msgs[i][2] = sc.nextInt(); } getResult(msgs, n, m); } public static void getResult(int[][] msgs, int n, int m) { // 如果第一行 n 和 m 的值超出约定的范围时，输出字符串”Null“。 if (n \u0026lt; 1 || n \u0026gt;= 100000 || m \u0026lt; 1 || m \u0026gt;= 100000) { System.out.println(\u0026#34;NULL\u0026#34;); return; } UnionFindSet ufs = new UnionFindSet(n + 1); for (int[] msg : msgs) { int a = msg[0], b = msg[1], c = msg[2]; if (a \u0026lt; 1 || a \u0026gt; n || b \u0026lt; 1 || b \u0026gt; n) { // 当前行 a 或 b 的标号小于 1 或者大于 n 时，输出字符串‘da pian zi‘ System.out.println(\u0026#34;da pian zi\u0026#34;); continue; } if (c == 0) { // c == 0 代表 a 和 b 在一个团队内 ufs.union(a, b); } else if (c == 1) { // c == 1 代表需要判定 a 和 b 的关系 String str = ufs.findRoot(a) == ufs.findRoot(b) ? \u0026#34;we are a team\u0026#34; : \u0026#34;we are not a team\u0026#34;; System.out.println(str); } else { // c 为其他值，输出字符串‘da pian zi‘ System.out.println(\u0026#34;da pian zi\u0026#34;); } } } // 并查集 static class UnionFindSet { int[] fa; // 初始化，设置i的父节点fa[i]为自身 public UnionFindSet(int n) { this.fa = new int[n]; for (int i = 0; i \u0026lt; n; i++) { fa[i] = i; } } // 查找x的根节点 public int findRoot(int x) { // 递归中断条件：根节点为自身 if (fa[x] == x) { return x; } // 递归：查询x的根节点 int root = findRoot(fa[x]); // 递归路径压缩：直接设置x的父节点为根 fa[x] = root; return root; } // 合并节点x、y public void union(int x, int y) { // 查找xy两者的根节点 int xFa = this.findRoot(x); int yFa = this.findRoot(y); // 合并：将xy两者的根节点设为一样 fa[xFa] = yFa; } } 05. 爱吃蟠桃的孙悟空\r#\r描述\n孙悟空爱吃蟠桃，有一天趁着蟠桃园守卫不在来偷吃。已知蟠桃园有 N 棵桃树，每颗树上都有桃子，守卫将在 H 小时后回来。 孙悟空可以决定他吃蟠桃的速度K（个/小时），每个小时选一颗桃树，并从树上吃掉 K 个，如果树上的桃子少于 K 个，则全部吃掉，并且这一小时剩余的时间里不再吃桃。 孙悟空喜欢慢慢吃，但又想在守卫回来前吃完桃子。 请返回孙悟空可以在 H 小时内吃掉所有桃子的最小速度 K（K为整数）。如果以任何速度都吃不完所有桃子，则返回0。 输入描述： 第一行输入为 N 个数字，N 表示桃树的数量，这 N 个数字表示每颗桃树上蟠桃的数量。 第二行输入为一个数字，表示守卫离开的时间 H。 其中数字通过空格分割，N、H为正整数，每颗树上都有蟠桃，且 0 ＜ N ＜ 10000，0 ＜ H ＜ 10000。 输出描述： 吃掉所有蟠桃的最小速度 K，无解或输入异常时输出 0。 输入：30 11 23 4 20 6 输出：23 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] arr = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int h = Integer.parseInt(sc.nextLine()); System.out.println(getResult(arr, h)); } public static int getResult(int[] arr, int h) { // 每个小时只能选一颗桃树，如果桃树数量大于h，那么肯定吃不完 if (arr.length \u0026gt; h) { return 0; } // 拥有最多桃子的那颗桃树上的桃子数量 int max = Arrays.stream(arr).max().orElse(0); // 如果桃树数量就是h棵，那么必须一小时吃完一颗树，此时，吃桃速度至少是max if (arr.length == h) { return max; } // 如果只有1棵桃树，且这颗树上只有1个桃，那么吃桃速度可以是1 int min = 1; // 当桃树数量少于h棵时，以max速度吃桃肯定可以吃完，但是不一定是最优解 int ans = max; // 二分法 while (min \u0026lt;= max) { // 取中间值作为吃桃速度进行尝试 int mid = (min + max) \u0026gt;\u0026gt; 1; if (check(mid, h, arr)) { ans = mid; // 尝试更小的速度 max = mid - 1; } else { // 尝试更大的速度 min = mid + 1; } } return ans; } public static boolean check(int speed, int limit, int[] arr) { int cost = 0; for (int cnt : arr) { cost += cnt / speed + (cnt % speed \u0026gt; 0 ? 1 : 0); if (cost \u0026gt; limit) { return false; } } return true; } 06. 按身高和体重排队\r#\r描述\n某学校举行运动会，学生们按编号(1、2、3…n)进行标识，现需要按照身高由低到高排列，对身高相同的人，按体重由轻到重排列；对于身高体重都相同的人，维持原有的编号顺序关系。请输出排列后的学生编号。 输入描述： 两个序列，每个序列由n个正整数组成（0 ＜ n ≤ 100）。第一个序列中的数值代表身高，第二个序列中的数值代表体重。 输出描述： 排列结果，每个数值都是原始序列中的学生编号，编号从1开始 输入：4 100 100 120 130 40 30 60 50 输出：2 1 3 4 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); int[][] students = new int[n][3]; for (int i = 0; i \u0026lt; n; i++) { students[i][0] = sc.nextInt(); } for (int i = 0; i \u0026lt; n; i++) { students[i][1] = sc.nextInt(); students[i][2] = i + 1; } sc.close(); Arrays.sort(students, (a, b) -\u0026gt; a[0] != b[0] ? a[0] - b[0] : a[1] != b[1] ? a[1] - b[1] : a[2] - b[2]); String ans = Arrays.stream(students) .map(arr -\u0026gt; String.valueOf(arr[2])).collect(Collectors.joining(\u0026#34; \u0026#34;)); System.out.println(ans); } 07. 报数游戏\r#\r描述\n100个人围成一圈，每个人有一个编码，编号从1开始到100。 他们从1开始依次报数，报到为M的人自动退出圈圈，然后下一个人接着从1开始报数，直到剩余的人数小于M。 请问最后剩余的人在原先的编号为多少？ 输入描述：输入一个整数参数 M 输出描述：如果输入参数M小于等于1或者大于等于100，输出“ERROR!”； 否则按照原先的编号从小到大的顺序，以英文逗号分割输出编号字符串 输入：3 输出：58,91 说明：输入M为3，最后剩下两个人。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); if (m \u0026lt;= 1 || m \u0026gt;= 100) { System.out.println(\u0026#34;ERROR!\u0026#34;); return; } CycleLinkedList list = new CycleLinkedList(); for (int i = 1; i \u0026lt;= 100; i++) { list.append(i); } int idx = 1; Node cur = list.head; while (list.size \u0026gt;= m) { if (idx == m) { idx = 1; cur = list.remove(cur); } else { idx++; cur = cur.next; } } System.out.println(list); } static class Node { int val; Node prev; Node next; public Node(int val, Node prev, Node next) { this.val = val; this.prev = prev; this.next = next; } } static class CycleLinkedList { Node head; Node tail; int size = 0; public void append(int val) { Node node = new Node(val, null, null); if (this.size \u0026gt; 0) { this.tail.next = node; node.prev = this.tail; this.tail = node; } else { this.head = node; this.tail = node; } this.head.prev = this.tail; this.tail.next = this.head; this.size++; } public Node remove(Node cur) { Node pre = cur.prev; Node nxt = cur.next; pre.next = nxt; nxt.prev = pre; cur.next = cur.prev = null; if (this.head == cur) { this.head = nxt; } if (this.tail == cur) { this.tail = pre; } this.size--; return nxt; } @Override public String toString() { StringJoiner sj = new StringJoiner(\u0026#34;,\u0026#34;); Node cur = this.head; for (int i = 0; i \u0026lt; this.size; i++) { sj.add(cur.val + \u0026#34;\u0026#34;); cur = cur.next; } return sj.toString(); } } 08. 表达式括号匹配\r#\r描述\n(1+(2+3)*(3+(8+0))+1-2)这是一个简单的数学表达式,今天不是计算它的值,而是比较它的括号匹配是否正确。 前面这个式子可以简化为(()(()))这样的括号我们认为它是匹配正确的, 而((())这样的我们就说他是错误的。注意括号里面的表达式可能是错的,也可能有多个空格，对于这些我们是不用去管的， 我们只关心括号是否使用正确。 输入描述：给出一行表达式(长度不超过 100)。 输出描述：如果匹配正确输出括号的对数，否则输出-1。 输入：(1+(2+3)*(3+(8+0))+1-2) 输出：4 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chs = sc.nextLine().toCharArray(); Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); int sum = 0; for (char ch : chs) { if (ch == \u0026#39;(\u0026#39;) { stack.push(ch); continue; } if (ch != \u0026#39;)\u0026#39;) { continue; } if (stack.isEmpty()) { System.out.println(\u0026#34;-1\u0026#34;); break; } char c = stack.pop(); if (c != \u0026#39;(\u0026#39;) { System.out.println(\u0026#34;-1\u0026#34;); break; } sum++; } System.out.println(sum); } 09. 部门人力分配\r#\r描述\n部门在进行需求开发时需要进行人力安排。 当前部门需要完成 N 个需求，需求用 requirements 表述，requirements[i] 表示第 i 个需求的工作量大小，单位：人月。 这部分需求需要在 M 个月内完成开发，进行人力安排后每个月人力时固定的。 目前要求每个月最多有2个需求开发，并且每个月需要完成的需求不能超过部门人力。 请帮助部门评估在满足需求开发进度的情况下，每个月需要的最小人力是多少？ 输入描述： 输入为 M 和 requirements，M 表示需求开发时间要求，requirements 表示每个需求工作量大小，N 为 requirements长度， 1 ≤ N/2 ≤ M ≤ N ≤ 10000 1 ≤ requirements[i] ≤ 10^9 输出描述： 对于每一组测试数据，输出部门需要人力需求，行末无多余的空格 输入：3 3 5 3 4 输出：6 换个说法： 目前有 N 个人（N个需求），每个人的体重为requirements[i]，（每个需求开发需要的人力为requirements[i]） 以及 M 辆自行车（M个月开发），每辆自行车至多坐两人（每个月至多开发两个需求）， 现在想要用 M 辆自行车带走 N 个人，问每辆自行车的限重至少是多少？（M个月开发完N个需求，每个月至少需要多少人力） 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = Integer.parseInt(sc.nextLine()); int[] arr = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(m, arr)); } public static long getResult(int m, int[] requirements) { Arrays.sort(requirements); int n = requirements.length; // 每辆自行车的限重 至少是 最重的那个人的体重 long min = requirements[n - 1]; // 每辆自行车的限重 至多是 最重的和次重的那两个的体重 long max = requirements[n - 2] + requirements[n - 1]; long ans = max; // 二分取中间值 while (min \u0026lt;= max) { // min，max单独看都不超过int，但是二者相加会超过int，因此需要用long类型 long mid = (min + max) \u0026gt;\u0026gt; 1; if (check(mid, m, requirements)) { // 如果mid限重，可以满足m辆车带走n个人，则mid就是一个可能解，但不一定是最优解 ans = mid; // 继续尝试更小的限重，即缩小右边界 max = mid - 1; } else { // 如果mid限重，不能满足m辆车带走n个人，则mid限重小了 // 我们应该尝试更大的限重，即扩大左边界 min = mid + 1; } } return ans; } /** * @param limit 每辆自行车的限重 * @param m m辆自行车 * @param requirements n个人的体重数组 * @return m辆自行车，每辆限重limit的情况下，能否带走n个人 */ public static boolean check(long limit, int m, int[] requirements) { int l = 0; // 指向体重最轻的人 int r = requirements.length - 1; // 指向体重最重的人 // 需要的自行车数量 int need = 0; while (l \u0026lt;= r) { // 如果最轻的人和最重的人可以共享一辆车，则l++,r--， // 否则最重的人只能单独坐一辆车，即仅r-- if (requirements[l] + requirements[r] \u0026lt;= limit) { l++; } r--; // 用掉一辆车 need++; } // 如果m \u0026gt;= need，当前有的自行车数量足够 return m \u0026gt;= need; } 10. 求幸存数之和\r#\r描述\n给一个正整数数列 nums，一个跳数 jump，及幸存数量 left。 运算过程为：从索引0的位置开始向后跳，中间跳过 J 个数字，命中索引为 J+1 的数字，该数被敲出，并从该点起跳，以此类推，直到幸存 left 个数为止，然后返回幸存数之和。 约束： 1. 0是第一个起跳点 2. 起跳点和命中点之间间隔 jump 个数字，已被敲出的数字不计入在内。 3. 跳到末尾时无缝从头开始（循环查找），并可以多次循环。 4. 若起始时 left \u0026gt; len(nums) 则无需跳数处理过程。 输入描述： 第一行输入正整数数列 第二行输入跳数 第三行输入幸存数量 输出描述： 输出幸存数之和 输入：1,2,3,4,5,6,7,8,9 4 3 输出：13 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] nums = Arrays.stream(sc.nextLine().split(\u0026#34;,\u0026#34;)).mapToInt(Integer::parseInt).toArray(); int jump = Integer.parseInt(sc.nextLine()); int left = Integer.parseInt(sc.nextLine()); System.out.println(sumOfLeft(nums, jump, left)); } public static int sumOfLeft(int[] nums, int jump, int left) { ArrayList\u0026lt;Integer\u0026gt; list = (ArrayList\u0026lt;Integer\u0026gt;) Arrays.stream(nums).boxed().collect(Collectors.toList()); // 从起跳点的下一个节点开始 int start = 1; // 如果剩余节点数 \u0026gt; 幸存数量，则还需要继续删除节点 while (list.size() \u0026gt; left) { // 跳 jump 次 start += jump; // 为了避免越界，新起跳点索引位置对剩余节点数取余 start %= list.size(); list.remove(start); } return list.stream().reduce(Integer::sum).orElse(0); } 11. 测试用例执行计划\r#\r描述\n某个产品当前迭代周期内有 N 个特性（F1,F2,......FN）需要进行覆盖测试， 每个特性都被评估了对应的优先级，特性使用其 ID 作为下标进行标识。 设计了 M 个测试用例（T1,T2,......,TM），每个测试用例对应一个覆盖特性的集合， 测试用例使用其 ID 作为下标进行标识，测试用例的优先级定义为其覆盖的特性的优先级之和。 在开展测试之前，需要制定测试用例的执行顺序， 规则为：优先级大的用例先执行，如果存在优先级相同的用例，用例 ID 小的先执行。 输入描述 第一行输入为 N 和 M， N 表示特性的数量，0 ＜ N ≤ 100 M 表示测试用例的数量，0 ＜ M ≤ 100 之后 N 行表示特性 ID=1 到特性 ID=N 的优先级， 再接下来 M 行表示测试用例 ID=1 到测试用例 ID=M 关联的特性的 ID 的列表。 输出描述： 按照执行顺序（优先级从大到小）输出测试用例的 ID，每行一个ID。 测试用例覆盖的 ID 不重复。 输入：5 4 1 1 2 3 5 1 2 3 1 4 3 4 5 2 3 4 输出：3 4 1 2 说明：\t测试用例的优先级计算如下： T1 = Pf1 + Pf2 + Pf3 = 1 + 1 + 2 = 4 T2 = Pf1 + Pf4 = 1 + 3 = 4 T3 = Pf3 + Pf4 + Pf5 = 2 + 3 + 5 = 10 T4 = Pf2 + Pf3 + Pf4 = 1 + 2 + 3 = 6 按照优先级从小到大，以及相同优先级，ID小的先执行的规则，执行顺序为T3,T4,T1,T2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] strings = sc.nextLine().split(\u0026#34; \u0026#34;); int n = Integer.parseInt(strings[0]); int m = Integer.parseInt(strings[1]); int[] arrF = new int[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { arrF[i] = Integer.parseInt(sc.nextLine()); } int[][] arrT = new int[m][2]; for (int i = 0; i \u0026lt; m; i++) { arrT[i][1] = i + 1; int sum = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)) .map(Integer::parseInt).map(id -\u0026gt; arrF[id]).reduce(Integer::sum).orElse(0); arrT[i][0] = sum; } Arrays.sort(arrT, (a, b) -\u0026gt; a[0] != b[0] ? b[0] - a[0] : a[1] - b[1]); Arrays.stream(arrT).map(arr -\u0026gt; String.valueOf(arr[1])).forEach(System.out::println); } 12. 查找接口成功率最优时间段\r#\r描述\n服务之间交换的接口成功率作为服务调用关键质量特性，某个时间段内的接口失败率使用一个数组表示， 数组中每个元素都是单位时间内失败率数值，数组中的数值为0~100的整数， 给定一个数值(minAverageLost)表示某个时间段内平均失败率容忍值，即平均失败率小于等于minAverageLost， 找出数组中最长时间段，如果未找到则直接返回NULL。 输入描述： 输入有两行内容，第一行为{minAverageLost}，第二行为{数组}，数组元素通过空格(” “)分隔， minAverageLost及数组中元素取值范围为0~100的整数，数组元素的个数不会超过100个。 输出描述： 找出平均值小于等于minAverageLost的最长时间段，输出数组下标对，格式{beginIndex}-{endIndx}(下标从0开始)， 如果同时存在多个最长时间段，则输出多个下标对且下标对之间使用空格(” “)拼接，多个下标对按下标从小到大排序。 输入：2 0 0 100 2 2 99 0 2 输出：0-1 3-4 6-7 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int minAverageLost = Integer.parseInt(sc.nextLine()); int[] nums = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(nums, minAverageLost)); } public static String getResult(int[] nums, int minAverageLost) { int n = nums.length; int[] preSum = new int[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { preSum[i] = preSum[i - 1] + nums[i - 1]; } int maxLen = 0; ArrayList\u0026lt;int[]\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt;= n; j++) { // sum 是 区间 [i, j-1] 的和 int sum = preSum[j] - preSum[i]; int len = j - i; int minLost = len * minAverageLost; if (sum \u0026gt; minLost) { continue; } if (len \u0026gt; maxLen) { list = new ArrayList\u0026lt;\u0026gt;(); } if (len \u0026gt;= maxLen) { list.add(new int[]{i, j - 1}); maxLen = len; } } } if (list.isEmpty()) { return \u0026#34;NULL\u0026#34;; } list.sort(Comparator.comparingInt(a -\u0026gt; a[0])); return list.stream().map(arr -\u0026gt; arr[0] + \u0026#34;-\u0026#34; + arr[1]).collect(Collectors.joining(\u0026#34; \u0026#34;)); } 13. 查找众数及中位数\r#\r描述\n众数是指一组数据中出现次数量多的那个数，众数可以是多个。 中位数是指把一组数据从小到大排列，最中间的那个数，如果这组数据的个数是奇数，那最中间那个就是中位数， 如果这组数据的个数为偶数，那就把中间的两个数之和除以2，所得的结果就是中位数。 查找整型数组中元素的众数并组成一个新的数组，求新数组的中位数。 输入描述：输入一个一维整型数组，数组大小取值范围 0＜N＜1000，数组中每个元素取值范围 0＜E＜1000 输出描述：输出众数组成的新数组的中位数 输入：5 1 5 3 5 2 5 5 7 6 7 3 7 11 7 55 7 9 98 9 17 9 15 9 9 1 39 输出：7 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] nums = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(nums)); } public static int getResult(int[] nums) { HashMap\u0026lt;Integer, Integer\u0026gt; count = new HashMap\u0026lt;\u0026gt;(); for (int num : nums) { count.put(num, count.getOrDefault(num, 0) + 1); } // 获取最大出现次数 int max = count.values().stream().max(Comparator.comparingInt(a -\u0026gt; a)).orElse(0); // 将众数挑选出来 ArrayList\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (Integer k : count.keySet()) { if (count.get(k) == max) ans.add(k); } // 众数升序 ans.sort(Comparator.comparingInt(a -\u0026gt; a)); // 中位数取值 int mid = ans.size() / 2; if (ans.size() % 2 == 0) { return (ans.get(mid) + ans.get(mid - 1)) / 2; } else { return ans.get(mid); } } 14. 单词加密\r#\r描述\n1、输入一个英文句子，句子中包含若干个单词，每个单词间有一个空格； 2、需要将句子中的每个单词按照要求加密输出。 要求： 1）单词中包括元音字符（‘aeuio’、‘AEUIO’，大小写都算），则将元音字符替换成‘*’ 2）单词中不包括元音字符，将单词首尾字符进行对换 输入描述：输入只有一行，包含一个长度都不超过100的字符串，表示英文句子。 输出描述：输出只有一行，即按要求输出加密处理后的英文句子 输入：Hello world 输出：H*ll* w*rld 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.nextLine(); System.out.println(getResult(s)); } public static String getResult(String s) { String[] words = s.split(\u0026#34; \u0026#34;); for (int i = 0; i \u0026lt; words.length; i++) { Matcher matcher = Pattern.compile(\u0026#34;[aeiouAEIOU]\u0026#34;).matcher(words[i]); if (matcher.find()) { words[i] = matcher.replaceAll(\u0026#34;*\u0026#34;); } else { char[] cArr = words[i].toCharArray(); char tmp = cArr[0]; cArr[0] = cArr[cArr.length - 1]; cArr[cArr.length - 1] = tmp; words[i] = new String(cArr); } } return String.join(\u0026#34; \u0026#34;, words); } 15. 单词接龙\r#\r描述\n单词接龙的规则是： 可用于接龙的单词首字母必须要前一个单词的尾字母相同； 当存在多个首字母相同的单词时，取长度最长的单词，如果长度也相等，则取字典序最小的单词；已经参与接龙的单词不能重复使用。 现给定一组全部由小写字母组成单词数组，并指定其中的一个单词作为起始单词，进行单词接龙， 请输出最长的单词串，单词串是单词拼接而成，中间没有空格。 备注： 单词个数N的取值范围为[1, 20]； 单个单词的长度的取值范围为[1, 30]； 输入描述： 输入的第一行为一个非负整数，表示起始单词在数组中的索引K，0 ≤ K ＜ N ； 输入的第二行为一个非负整数，表示单词的个数N； 接下来的N行，分别表示单词数组中的单词。 输出描述： 输出一个字符串，表示最终拼接的单词串。 输入：4 6 word dd da dc dword d 输出：dwordda 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int k = Integer.parseInt(sc.nextLine()); int n = Integer.parseInt(sc.nextLine()); String[] arr = new String[n]; for (int i = 0; i \u0026lt; n; i++) { arr[i] = sc.nextLine(); } Map\u0026lt;String, LinkedList\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { if (i == k) { continue; } String str = arr[i]; String key = String.valueOf(str.charAt(0)); map.putIfAbsent(key, new LinkedList\u0026lt;\u0026gt;()); map.get(key).add(str); } for (LinkedList\u0026lt;String\u0026gt; list : map.values()) { list.sort((s1, s2) -\u0026gt; s1.length() != s2.length() ? s2.length() - s1.length() : s1.compareTo(s2)); } String tempStr = arr[k]; StringBuilder sb = new StringBuilder(tempStr); while (true) { String key = String.valueOf(tempStr.charAt(tempStr.length() - 1)); if (!map.containsKey(key) || map.get(key).isEmpty()) { break; } tempStr = map.get(key).removeFirst(); sb.append(tempStr); } System.out.println(sb); } 16. 单词重量\r#\r描述\n每个句子由多个单词组成，句子中的每个单词的长度都可能不一样，我们假设每个单词的长度Ni为该单词的重量，你需要做的就是给出整个句子的平均重量V。 输入：Who Love Solo 输出：3.67 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] arr = sc.nextLine().split(\u0026#34; \u0026#34;); int len = Arrays.stream(arr).mapToInt(String::length).reduce(Integer::sum).orElse(0); double d = (double) len / arr.length; /* %f : 输出浮点数 %.nf : 控制小数点后的位数，n为数字 %c : 输出字符 %d : 输出十进制整数 %o : 输出八进制整数 %x : 输出十六进制整数 %X : 输出大写十六进制整数 */ System.out.printf(\u0026#34;%.2f%n\u0026#34;, d); } 17. 德州扑克\r#\r描述\n五张牌，每张牌由牌大小和花色组成，牌大小2~10、J、Q、K、A，牌花色为红桃、黑桃、梅花、方块四种花色之一。 判断牌型: 牌型1，同花顺：同一花色的顺子，如红桃2红桃3红桃4红桃5红桃6。 牌型2，四条：四张相同数字 + 单张，如红桃A黑桃A梅花A方块A + 黑桃K。 牌型3，葫芦：三张相同数字 + 一对，如红桃5黑桃5梅花5 + 方块9梅花9。 牌型4，同花：同一花色，如方块3方块7方块10方块J方块Q。 牌型5，顺子：花色不一样的顺子，如红桃2黑桃3红桃4红桃5方块6。 牌型6，三条：三张相同+两张单。 说明： （1）五张牌里不会出现牌大小和花色完全相同的牌。 （2）编号小的牌型较大，如同花顺比四条大，依次类推。 （3）包含A的合法的顺子只有10 J Q K A和A 2 3 4 5;类似K A 2 3 4的序列不认为是顺子。 输入描述： 输入由5行组成，每行为一张牌大小和花色，牌大小为2~10、J、Q、K、A，花色分别用字符H、S、C、D表示红桃、黑桃、梅花、方块。 输出描述： 输出牌型序号，5张牌符合多种牌型时，取最大的牌型序号输出。 输入：9 S 5 S 6 S 7 S 8 S 输出：1 说明：既是顺子又是同花，输出1，同花顺 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] nums = new int[5]; String[] colors = new String[5]; for (int i = 0; i \u0026lt; 5; i++) { String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); nums[i] = cards(split[0]); colors[i] = split[1]; } System.out.println(getResult(nums, colors)); } public static int getResult(int[] nums, String[] colors) { // 同花 boolean isTongHua = new HashSet\u0026lt;\u0026gt;(Arrays.asList(colors)).size() == 1; // 顺子 boolean isShunZi = isShunZi(nums); int[] arr = new int[15]; for (int num : nums) { arr[num]++; } // 对子 boolean isDuiZi = false; for (int j : arr) { if (j == 2) { isDuiZi = true; break; } } // 相同数字的最大张数 int maxLen = Arrays.stream(arr).max().orElse(0); // 同花顺 if (isShunZi \u0026amp;\u0026amp; isTongHua) { return 1; } // 四条 if (maxLen == 4) { return 2; } // 葫芦 if (maxLen == 3 \u0026amp;\u0026amp; isDuiZi) { return 3; } // 同花 if (isTongHua) { return 4; } // 顺子 if (isShunZi) { return 5; } // 三条 if (maxLen == 3) { return 6; } return 0; } public static int getMaxLen(int[] nums) { int[] arr = new int[15]; for (int num : nums) { arr[num]++; } return Arrays.stream(arr).max().orElse(0); } public static boolean isShunZi(int[] nums) { Arrays.sort(nums); if (\u0026#34;234514\u0026#34;.equals(\u0026#34;\u0026#34; + nums[0] + nums[1] + nums[2] + nums[3] + nums[4])) { return true; } for (int i = 0; i \u0026lt; nums.length; i++) { if (nums[0] + i != nums[i]) { return false; } } return true; } private static int cards(String str) { return switch (str) { case \u0026#34;J\u0026#34; -\u0026gt; 11; case \u0026#34;Q\u0026#34; -\u0026gt; 12; case \u0026#34;K\u0026#34; -\u0026gt; 13; case \u0026#34;A\u0026#34; -\u0026gt; 14; default -\u0026gt; Integer.parseInt(str); }; } 18. 第k个排列\r#\r描述\n给定参数n，从1到n会有n个整数：1,2,3,…,n,这n个数字共有n!种排列。按大小顺序升序列出所有排列的情况，并一一标记， 当n=3时,所有排列如下:“123” “132” “213” “231” “312” “321” 给定n和k，返回第k个排列。 输入描述：输入两行，第一行为n，第二行为k，给定n的范围是[1,9],给定k的范围是[1,n!]。 输出描述：输出排在第k位置的数字。 输入：3 3 输出：213 输入：4 9 输出：2314 题解 #\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextInt()) { int n = sc.nextInt(); int k = sc.nextInt(); String res = getResult(n, k); System.out.println(res); } } // 康托展开公式：X = a[n]*(n-1)! + a[n-1]*(n-2)! + ... + a[i]*(i-1)! + ... + a[1]*0! public static String getResult(int n, int k) { // int fac[] = { 1, 1, 2, 6, 24, 120, 720, 5040, 40320 }; int[] fac = new int[n]; fac[0] = 1; for (int i = 1; i \u0026lt; n; i++) { fac[i] = fac[i - 1] * i; } StringBuilder sb = new StringBuilder(); int[] visit = new int[10]; k = k - 1; for (int i = n - 1; i \u0026gt;= 0; i--) { int t = k / fac[i]; for (int j = 1; j \u0026lt;= n; j++) { if (visit[j] == 0) { if (t == 0) { sb.append(j); visit[j] = 1; break; } t--; } } k = k % fac[i]; } return sb.toString(); } 19. 堆内存申请\r#\r描述\n有一个总空间为100字节的堆，现要从中新申请一块内存，内存分配原则为：优先紧接着前一块已使用内存，分配空间足够且最接近申请大小的空闲内存。 输入描述： 第1行是1个整数，表示期望申请的内存字节数 第2到第N行是用空格分割的两个整数，表示当前已分配的内存的情况， 每一行表示一块已分配的连续内存空间，每行的第1和第2个整数分别表示偏移地址和内存块大小 输出描述： 若申请成功，输出申请到内存的偏移； 若申请失败，输出 -1。 备注： 若输入信息不合法或无效，则申请失败 若没有足够的空间供分配，则申请失败 堆内存信息有区域重叠或有非法值等都是无效输入 输入：1 0 1 3 2 输出：1 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int len = Integer.parseInt(sc.nextLine()); boolean[] arr = new boolean[100]; while (sc.hasNextLine()) { String line = sc.nextLine(); if (line.isEmpty()) break; String[] split = line.split(\u0026#34; \u0026#34;); int index; int offset; try { index = Integer.parseInt(split[0]); offset = Integer.parseInt(split[1]); } catch (Exception e) { System.out.println(-1); return; } if (index \u0026lt; 0 || offset \u0026lt; 1) { System.out.println(-1); return; } int end = index + offset; for (int i = index; i \u0026lt; end; i++) { if (i \u0026gt; 99 || arr[i]) { System.out.println(-1); return; } arr[i] = true; } } System.out.println(getResult(arr, len)); } public static int getResult(boolean[] arr, int len) { List\u0026lt;int[]\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; arr.length; i++) { if (arr[i]) { continue; } int[] tempArr = new int[2]; tempArr[0] = i; for (int j = i; j \u0026lt; arr.length; j++) { if (arr[j]) { break; } else { tempArr[1] = j; } } i = tempArr[1]; list.add(tempArr); } for (int[] tempArr : list) { if (tempArr[1] - tempArr[0] \u0026gt;= len - 1) { return tempArr[0]; } } return -1; } 20. 堆栈中的剩余数字\r#\r描述\n向一个空栈中依次存入正整数，假设入栈元素 n(1≤n≤2^31-1)按顺序依次为 nx…n4、 n3、n2、 n1, 每当元素入栈时，如果 n1=n2+…+ny(y 的范围[2,x]， 1≤x≤1000)，则 n1~ny 全部元素出栈，重新入栈新元素 m(m=2*n1)。 如：依次向栈存入 6、 1、 2、 3, 当存入 6、 1、 2 时，栈底至栈顶依次为[6、 1、 2]；当存入 3时， 3=2+1， 3、 2、 1 全部出栈，重新入栈元素 6(6=2*3)，此时栈中有元素 6； 因为 6=6，所以两个 6 全部出栈，存入 12，最终栈中只剩一个元素 12。 输入描述： 使用单个空格隔开的正整数的字符串，如”5 6 7 8″， 左边的数字先入栈，输入的正整数个数为 x， 1\u0026lt;=x\u0026lt;=1000。 输出描述： 最终栈中存留的元素值，元素值使用空格隔开，如”8 7 6 5″， 栈顶数字在左边。 6 1 2 3 输入：1 2 5 7 9 1 2 2 输出：4 1 9 14 1 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); for (int num : nums) { addNum(list, num); } Collections.reverse(list); String ans = list.stream().map(String::valueOf).collect(Collectors.joining(\u0026#34; \u0026#34;)); System.out.println(ans); } public static void addNum(LinkedList\u0026lt;Integer\u0026gt; list, int num) { int sum = 0; boolean isClear = false; for (int i = list.size() - 1; i \u0026gt;= 0; i--) { sum += list.get(i); if (sum == num) { list.subList(i, list.size()).clear(); isClear = true; break; } } if (isClear) { addNum(list, 2 * num); return; } list.add(num); } 21. 多段线数据压缩\r#\r描述\n下图中，每个方块代表一个像素，每个像素用其行号和列号表示。 为简化处理，多线段的走向只能是水平、竖直、斜向45度。 上图中的多线段可以用下面的坐标串表示：(2,8),(3,7),(3,6),(3,5),(4,4),(5,3),(6,2),(7,3),(8,4),(7,5)。 但可以发现，这种表示不是最简的，其实只需要存储6个蓝色的关键点即可，它们是线段的起点、拐点、终点，而剩下4个点是冗余的。 现在，请根据输入的包含有冗余数据的多线段坐标列表，输出其最简化的结果。 输入描述： 所有数字以空格分隔，每两个数字一组，第一个数字是行号，第二个数字是列号； 行号和列号范围 为 [0, 64)，用例输入保证不会越界，考生不必检查； 输入数据至少包含两个坐标点 输出描述： 压缩后的最简化坐标列表，和输入数据的格式相同。 输入：2 8 3 7 3 6 3 5 4 4 5 3 6 2 7 3 8 4 7 5 输出：2 8 3 7 3 5 6 2 8 4 7 5 题解\nprivate static final List\u0026lt;String\u0026gt; TEMP_LIST = Arrays.asList(\u0026#34;0-1\u0026#34;, \u0026#34;01\u0026#34;, \u0026#34;-10\u0026#34;, \u0026#34;10\u0026#34;, \u0026#34;-1-1\u0026#34;, \u0026#34;11\u0026#34;, \u0026#34;-11\u0026#34;, \u0026#34;1-1\u0026#34;); public static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); int[][] arr = new int[nums.length / 2][2]; int k = 0; for (int i = 0; i \u0026lt; nums.length / 2; i++) { for (int j = 0; j \u0026lt; 2; j++) { arr[i][j] = nums[k]; k++; } } List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(arr[0][0]); list.add(arr[0][1]); int direct = getDirect(arr[0], arr[1]); for (int i = 2; i \u0026lt; arr.length; i++) { int currDirect = getDirect(arr[i - 1], arr[i]); if (direct == currDirect) { continue; } direct = currDirect; list.add(arr[i - 1][0]); list.add(arr[i - 1][1]); } list.add(arr[arr.length - 1][0]); list.add(arr[arr.length - 1][1]); String str = list.stream().map(String::valueOf).collect(Collectors.joining(\u0026#34; \u0026#34;)); System.out.println(str); } public static int getDirect(int[] pre, int[] next) { int x = next[0] - pre[0]; int y = next[1] - pre[1]; String key = \u0026#34;\u0026#34; + x + y; return TEMP_LIST.indexOf(key); } 22. 翻牌求最大分\r#\r描述\n给出n个牌数，在-100到100之间，求最大得分。 规则如下：连续翻牌，如果选当前牌，则总得分等于上一次翻牌总得分加上当前牌的数字， 如果当前总得分小于它前三次的总得分的话，那此次不翻牌，并且总得分就等于它前三次的得分。 1到3次翻牌数如果小于0的话就取0。 例子：1，-5，-6，4，7，2，-2 （1）1大于零 翻牌 （2）-5 加上1 小于0 不翻 结果为0 （3）-6 加上0 小于0 不翻 结果为0 （4）4 加上0 大于0（1）翻牌 结果为4 （5）7 加上4 大于0（2） 翻牌 结果为11 （6）2 加上11 大于0（3） 翻牌 结果为13 （7）-2 加上14 大于4（4）翻牌 结果为11 输入：1,-5,-6,4,7,2,-2 输出：11 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34;,\u0026#34;); int[] arr = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(arr)); } public static int getResult(int[] arr) { int n = arr.length; int[] dp = new int[n]; for (int i = 0; i \u0026lt; n; i++) { if (i == 0) { dp[0] = Math.max(0, arr[0]); } else if (i \u0026lt; 3) { dp[i] = Math.max(0, dp[i - 1] + arr[i]); } else { dp[i] = Math.max(dp[i - 3], dp[i - 1] + arr[i]); } } return dp[n - 1]; } 23. 分割均衡字符串\r#\r描述\n均衡串定义：字符串中只包含两种字符，且这两种字符的个数相同。 给定一个均衡字符串，请给出可分割成新的均衡子串的最大个数。 约定：字符串中只包含大写的 X 和 Y 两种字符。 输入描述： 输入一个均衡串。 字符串的长度：[2， 10000]。给定的字符串均为均衡字符串 输出描述： 输出可分割成新的均衡子串的最大个数。 备注： 分割后的子串，是原字符串的连续子串 输入：XXYYXY 输出：2 说明：XXYYXY可分割为2个均衡子串，分别为：XXYY、XY 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chs = sc.nextLine().toCharArray(); int countX = 0; int countY = 0; int sum = 0; for (char ch : chs) { if (ch == \u0026#39;X\u0026#39;) { countX++; } else { countY++; } if (countX == countY) { sum++; } } System.out.println(sum); } 24. 分配土地\r#\r描述\n从前有个村庄，村民们喜欢在各种田地上插上小旗子，旗子上标识了各种不同的数字。 某天集体村民决定将覆盖相同数字的最小矩阵形的土地分配给村里做出巨大贡献的村民， 请问此次分配土地，做出贡献的村民种最大会分配多大面积? 输入描述： 第一行输入 m 和 n。m代表村子的土地的长，n代表土地的宽 第二行开始输入地图上的具体标识 输出描述： 此次分配土地，做出贡献的村民种最大会分配多大面积 备注： 旗子上的数字为1~500，土地边长不超过500 未插旗子的土地用0标识 输入：3 3 1 0 1 0 0 0 0 1 0 输出：9 题解\nstatic class Rect { int minRow = Integer.MAX_VALUE; int maxRow = Integer.MIN_VALUE; int minCol = Integer.MAX_VALUE; int maxCol = Integer.MIN_VALUE; private void setRow(int row) { this.minRow = Math.min(this.minRow, row); this.maxRow = Math.max(this.maxRow, row); } private void setCol(int col) { this.minCol = Math.min(this.minCol, col); this.maxCol = Math.max(this.maxCol, col); } private int getArea() { return (maxRow - minRow + 1) * (maxCol - minCol + 1); } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); // 长（行数） int n = sc.nextInt(); // 宽（列数） HashMap\u0026lt;Integer, Rect\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { int num = sc.nextInt(); if (num \u0026gt; 0) { map.putIfAbsent(num, new Rect()); map.get(num).setRow(i); map.get(num).setCol(j); } } } int maxArea = 0; for (int num : map.keySet()) { Rect rect = map.get(num); maxArea = Math.max(maxArea, rect.getArea()); } System.out.println(maxArea); } 25. 分披萨\r#\r描述\n\u0026#34;吃货\u0026#34;和\u0026#34;馋嘴\u0026#34;两人到披萨店点了一份铁盘（圆形）披萨，并嘱咐店员将披萨按放射状切成大小相同的偶数个小块。但是粗心的服务员将披萨切成了每块大小都完全不同奇数块，且肉眼能分辨出大小。 由于两人都想吃到最多的披萨，他们商量了一个他们认为公平的分法：从\u0026#34;吃货\u0026#34;开始，轮流取披萨。除了第一块披萨可以任意选取外，其他都必须从缺口开始选。 他俩选披萨的思路不同。\u0026#34;馋嘴\u0026#34;每次都会选最大块的披萨，而且\u0026#34;吃货\u0026#34;知道\u0026#34;馋嘴\u0026#34;的想法。 已知披萨小块的数量以及每块的大小，求\u0026#34;吃货\u0026#34;能分得的最大的披萨大小的总和。 输入描述： 第 1 行为一个正整数奇数 N，表示披萨小块数量。3 ≤ N ＜ 500 接下来的第 2 行到第 N + 1 行（共 N 行），每行为一个正整数，表示第 i 块披萨的大小，1 ≤ i ≤ N 披萨小块从某一块开始，按照一个方向次序顺序编号为 1 ~ N，每块披萨的大小范围为 [1, 2147483647] 输出描述： \u0026#34;吃货\u0026#34;能分得到的最大的披萨大小的总和。 输入：5 8 2 10 5 7 输出：19 题解\nstatic int[] pizza; static long[][] cache; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); pizza = new int[n]; for (int i = 0; i \u0026lt; n; i++) { pizza[i] = sc.nextInt(); } // 缓存 cache = new long[n][n]; int l, r; long len; long maxLen = 0; // i 指向首轮被\u0026#34;吃货\u0026#34;选取的披萨位置，可以理解为缺口位置，相当于给环切了一个口 for (int i = 0; i \u0026lt; n; i++) { // i - 1 是缺口的左边披萨，i + 1 是缺口的右边披萨， // getIndex防止越界, 以便进行绕环运动 l = getIndex(i - 1); r = getIndex(i + 1); // 而第 i 块是首轮就被\u0026#34;吃货\u0026#34;拿走的，因此是recursive + pizza[i] // recursive的作用求解是\u0026#34;吃货\u0026#34;从缺失了 第 i 块的披萨铁盘 开始选，最终可得的最大披萨大小， len = recursive(l, r) + pizza[i]; maxLen = Math.max(maxLen, len); } System.out.println(maxLen); } public static long recursive(int l, int r) { if (pizza[l] \u0026gt; pizza[r]) { l = getIndex(l - 1); } else { r = getIndex(r + 1); } // 缓存优化，如果已经算过了，则无需再次重复递归 if (cache[l][r] \u0026gt; 0) { return cache[l][r]; } // 缓存对应缺口状态下，吃货可得的最大披萨大小 if (l == r) { cache[l][r] = pizza[l]; } else { long lenL = recursive(getIndex(l - 1), r) + pizza[l]; long lenR = recursive(l, getIndex(r + 1)) + pizza[r]; cache[l][r] = Math.max(lenL, lenR); } return cache[l][r]; } public static int getIndex(int idx) { if (idx \u0026lt; 0) { idx = pizza.length - 1; } else if (idx \u0026gt;= pizza.length) { idx = 0; } return idx; } "},{"id":33,"href":"/lang2/program-design/structure-algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%932/","title":"机试题库 - 2","section":"华为OD","content":"\r01. 工号不够用了怎么办\r#\r描述\n3020年，空间通信集团的员工人数突破20亿人，即将遇到现有工号不够用的窘境。 现在，请你负责调研新工号系统。继承历史传统，新的工号系统由小写英文字母（a-z）和数字（0-9）两部分构成。 新工号由一段英文字母开头，之后跟随一段数字，比如”aaahw0001″,”a12345″,”abcd1″,”a00″。 注意新工号不能全为字母或者数字,允许数字部分有前导0或者全为0。 但是过长的工号会增加同事们的记忆成本，现在给出新工号至少需要分配的人数X和新工号中字母的长度Y，求新工号中数字的最短长度Z。 输入描述： 一行两个非负整数 X Y，用数字用单个空格分隔。 0＜ X ≤2^50 – 1 0＜ Y ≤5 输出描述： 输出新工号中数字的最短长度Z 输入：2600 1 输出：2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); long x = sc.nextLong(); int y = sc.nextInt(); // 工号总个数x，字母个数y，数字个数z，z最小取1 // x = 26^y * 10^z // z = log(x / 26^y) long min = (long) Math.ceil(Math.log10(x / Math.pow(26, y))); System.out.println(Math.max(1, min)); } 02. 勾股数元组\r#\r描述\n如果3个正整数(a,b,c)满足a^2 + b^2 = c^2的关系，则称(a,b,c)为勾股数（著名的勾三股四弦五）， 为了探索勾股数的规律，我们定义如果勾股数(a,b,c)之间两两互质（即a与b，a与c，b与c之间均互质，没有公约数），则其为勾股数元组（例如(3,4,5)是勾股数元组，(6,8,10)则不是勾股数元组）。 请求出给定范围[N,M]内，所有的勾股数元组。 输入描述： 起始范围N，1 ≤ N ≤ 10000 结束范围M，N ＜ M ≤ 10000 输出描述： 1. a,b,c请保证a ＜ b ＜ c,输出格式：a b c； 2. 多组勾股数元组请按照a升序，b升序，最后c升序的方式排序输出； 3. 给定范围中如果找不到勾股数元组时，输出”NA“。 输入：1 20 输出：3 4 5 5 12 13 8 15 17 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); getResult(n, m); } public static void getResult(int n, int m) { ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = n; i \u0026lt;= m; i++) { list.add(i * i); } HashSet\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(list); ArrayList\u0026lt;Integer[]\u0026gt; arrList = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; list.size(); i++) { for (int j = i + 1; j \u0026lt; list.size(); j++) { // 判断勾股数 a^2 + b^2 = c^2 int sum = list.get(i) + list.get(j); if (set.contains(sum)) { Integer[] arr = new Integer[3]; arr[0] = (int) Math.sqrt(list.get(i)); arr[1] = (int) Math.sqrt(list.get(j)); arr[2] = (int) Math.sqrt(sum); arrList.add(arr); } } } List\u0026lt;Integer[]\u0026gt; collect = arrList.stream() .filter(Main::isRelativePrime).collect(Collectors.toList()); if (collect.isEmpty()) { System.out.println(\u0026#34;NA\u0026#34;); } else { collect.forEach(arr -\u0026gt; System.out.println(arr[0] + \u0026#34; \u0026#34; + arr[1] + \u0026#34; \u0026#34; + arr[2])); } } private static boolean isRelativePrime(Integer[] arr) { return isRelativePrime(arr[0], arr[1]) \u0026amp;\u0026amp; isRelativePrime(arr[0], arr[2]) \u0026amp;\u0026amp; isRelativePrime(arr[1], arr[2]); } // 计算它们的最大公约数，如果最大公约数为1，则说明两个数互质 private static boolean isRelativePrime(int x, int y) { // 两个数辗转相除 while (y \u0026gt; 0) { int mod = x % y; x = y; y = mod; } return x == 1; } 03. 冠亚军排名，奖牌榜排名\r#\r描述\n奖牌榜的排名规则如下，我们假设国家名称不超过二十个字符，各类奖牌数不超过100，且大于0. 1. 首先gold medal数量多的排在前面 2. 其次silver medal数量多的排在前面 3. 然后bronze medal数量多的排在前面 4. 若以上三个条件仍无法区分名次，则以国家名称的字典顺序排定。 输入描述： 第一行输入一个整数N（0＜N＜21），代表国家数量， 然后接下来的N行，每行包含：一个字符串Name表示各个国家的名称和三个整数Gi,Si,Bi分别表示奖牌的数量，以空格隔开 输出描述： 输出奖牌榜的依次顺序，只输出国家名称，各占一行，具体见样例输出。 输入：5 China 32 28 34 England 12 34 22 France 23 33 2 Japan 12 34 25 Rusia 23 43 0 输出：China Rusia France Japan England 题解\nstatic class Country { String name; int gold; int silver; int bronze; public Country(String name) { this.name = name; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); Country[] arr = new Country[n]; for (int i = 0; i \u0026lt; n; i++) { String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); Country country = new Country(split[0]); country.gold = Integer.parseInt(split[1]); country.silver = Integer.parseInt(split[2]); country.bronze = Integer.parseInt(split[3]); arr[i] = country; } Arrays.sort(arr, (a, b) -\u0026gt; a.gold != b.gold ? b.gold - a.gold : a.silver != b.silver ? b.silver - a.silver : a.bronze != b.bronze ? b.bronze - a.bronze : a.name.compareTo(b.name)); Arrays.asList(arr).forEach(country -\u0026gt; System.out.println(country.name)); } 04. 猴子爬山\r#\r描述\n一天一只顽猴想去从山脚爬到山顶，途中经过一个有个N个台阶的阶梯，但是这猴子有一个习惯： 每一次只能跳1步或跳3步，试问猴子通过这个阶梯有多少种不同的跳跃方式？ 输入描述：输入只有一个整数N（0＜N≤50）此阶梯有多少个台阶。 输出描述：输出有多少种跳跃方式（解决方案数）。 输入：50 输出：122106097 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); System.out.println(getResult(n)); } public static int getResult(int n) { int[] dp = new int[n + 1]; if (n \u0026gt;= 1) dp[1] = 1; if (n \u0026gt;= 2) dp[2] = 1; if (n \u0026gt;= 3) dp[3] = 2; for (int i = 4; i \u0026lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 3]; } return dp[n]; } 05. 滑动窗口最大和\r#\r描述\n有一个N个整数的数组，和一个长度为M的窗口，窗口从数组内的第一个数开始滑动直到窗口不能滑动为止， 每次窗口滑动产生一个窗口和（窗口内所有数的和），求窗口滑动产生的所有窗口和的最大值。 输入描述： 第一行输入一个正整数N，表示整数个数。（0＜N＜100000） 第二行输入N个整数，整数的取值范围为[-100,100]。 第三行输入一个正整数M，M代表窗口的大小，M≤100000，且M≤N。 输出描述： 窗口滑动产生所有窗口和的最大值。 输入：6 10 20 30 15 23 12 3 输出：68 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] arr = new int[n]; for (int i = 0; i \u0026lt; n; i++) { arr[i] = sc.nextInt(); } int m = sc.nextInt(); sc.close(); // 初始滑窗内部和 int sum = 0; for (int i = 0; i \u0026lt; m; i++) { sum += arr[i]; } int max = sum; for (int i = 1; i \u0026lt;= n - m; i++) { // 基于初始滑窗进行差异求和 sum += arr[i + m - 1] - arr[i - 1]; max = Math.max(max, sum); } System.out.println(max); } 06. 灰度图存储\r#\r描述\n黑白图像常采用灰度图的方式存储，即图像的每个像素填充一个灰色阶段值，256阶灰图是一个灰阶值取值范围为 0~255 的灰阶矩阵，0表示全黑，255表示全白，范围内的其他值表示不同的灰度。 但在计算机中实际存储时，会使用压缩算法，其中一个种压缩格式描述如如下： 10 10 255 34 0 1 255 8 0 3 255 6 0 5 255 4 0 7 255 2 0 9 255 21 1. 所有的数值以空格分隔； 2. 前两个数分别表示矩阵的行数和列数； 3. 从第三个数开始，每两个数一组，每组第一个数是灰阶值，第二个数表示该灰阶值从左到右，从上到下（可理解为二维数组按行存储在一维矩阵中）的连续像素个数。比如题目所述的例子， “255 34” 表示有连续 34 个像素的灰阶值是 255。 如此，图像软件在打开此格式灰度图的时候，就可以根据此算法从压缩数据恢复出原始灰度图矩阵。 请从输入的压缩数恢复灰度图原始矩阵，并返回指定像素的灰阶值。 输入描述： 第一行是灰度图压缩数据 第二行表示一个像素位置的行号和列号，如 0 0 表示左上角像素 输出描述： 输出数据表示的灰阶矩阵的指定像素的灰阶值。 备注： 系保证输入的压缩数据是合法有效的，不会出现数据起界、数值不合法等无法恢复的场景 系统保证输入的像素坐标是合法的，不会出现不在矩阵中的像素 矩阵的行和列数范图为:(0,100] 灰阶值取值范图:[0,255] 输入：10 10 56 34 99 1 87 8 99 3 255 6 99 5 255 4 99 7 255 2 99 9 255 21 3 4 输出：99 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] nums = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int[] pos = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int rows = nums[0]; int cols = nums[1]; int start = 0; int[] graph = new int[rows * cols]; for (int i = 2; i \u0026lt; nums.length; i += 2) { // 灰阶值 int gray = nums[i]; // 该灰阶值从左到右，从上到下（可理解为二维数组按行存储在一维矩阵中）的连续像素个数 int len = nums[i + 1]; Arrays.fill(graph, start, start + len, gray); start += len; } // 将二维坐标转为一维坐标 int target = pos[0] * cols + pos[1]; System.out.println(graph[target]); } 07. 会议室占用时间\r#\r描述\n现有若干个会议，所有会议共享一个会议室，用数组表示各个会议的开始时间和结束时间，格式为： [[会议1开始时间, 会议1结束时间], [会议2开始时间, 会议2结束时间]] 请计算会议室占用时间段。 输入描述： 第一行输入一个整数 n，表示会议数量 之后输入n行，每行两个整数，以空格分隔，分别表示会议开始时间，会议结束时间 输出描述： 输出多行，每个两个整数，以空格分隔，分别表示会议室占用时间段开始和结束 备注： 会议室个数范围：[1, 100] 会议室时间段：[1, 24] 输入：4 1 4 2 5 7 9 14 18 输出：1 5 7 9 14 18 输入：[[1,4],[2,5],[7,9],[14,18]] 输出：[[1,5],[7,9],[14,18]] 说明：时间段[1,4]和[2,5]重叠，合并为[1,5] 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[][] roomTimes = new int[n][2]; for (int i = 0; i \u0026lt; n; i++) { roomTimes[i][0] = sc.nextInt(); roomTimes[i][1] = sc.nextInt(); } // 将各个会议按照开始时间升序 Arrays.sort(roomTimes, (a, b) -\u0026gt; a[0] - b[0]); ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); int[] pre = roomTimes[0]; for (int i = 1; i \u0026lt; roomTimes.length; i++) { // 当前会议占用时间段 int[] cur = roomTimes[i]; if (cur[0] \u0026lt;= pre[1]) { // 当前会议开始时间 \u0026lt;= 上一个会议结束时间，则两个会议时间重叠，可以合并 // 注意合并时，结束时间取两个时间段中较大的结束时间 pre[1] = Math.max(pre[1], cur[1]); } else { // 否则不可以合并 list.add(pre[0] + \u0026#34; \u0026#34; + pre[1]); pre = cur; } } list.add(pre[0] + \u0026#34; \u0026#34; + pre[1]); list.forEach(System.out::println); } 08. 绘图机器\r#\r描述\n绘图机器的绘图笔初始位置在原点(0,0)机器启动后按照以下规则来进行绘制直线。 1. 尝试沿着横线坐标正向绘制直线直到给定的终点E 2. 期间可以通过指令在纵坐标轴方向进行偏移，offsetY为正数表示正向偏移,为负数表示负向偏移 给定的横坐标终点值E 以及若干条绘制指令， 请计算绘制的直线和横坐标轴以及x=E的直线组成的图形面积。 输入描述： 首行为两个整数 N 和 E 表示有N条指令,机器运行的横坐标终点值E 接下来N行 每行两个整数表示一条绘制指令x，offsetY 用例保证横坐标x以递增排序的方式出现 且不会出现相同横坐标x 取值范围： 0＜N≤10000 0≤x≤E≤20000 -10000≤offsetY≤10000 输出描述： 一个整数表示计算得到的面积 用例保证结果范围在0到4294967295之内。 输入：4 10 1 1 2 1 3 1 4 -2 输出：12 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int endX = sc.nextInt(); long ans = 0; long lastX = 0; // 上一个点的横坐标 long lastY = 0; // 上一个点的纵坐标 for (int i = 0; i \u0026lt; n; i++) { int curX = sc.nextInt(); int offsetY = sc.nextInt(); ans += (curX - lastX) * Math.abs(lastY); lastX = curX; lastY += offsetY; } // 注意结束位置的处理 if (endX \u0026gt; lastX) { ans += (endX - lastX) * Math.abs(lastY); } System.out.println(ans); } 09. 火星文计算\r#\r描述\n已知火星人使用的运算符为#、$，其与地球人的等价公式如下： x#y = 2*x+3*y+4 x$y = 3*x+y+2 1. 其中x、y是无符号整数 2. 地球人公式按C语言规则计算 3. 火星人公式中，$的优先级高于#，相同的运算符，按从左到右的顺序计算 现有一段火星人的字符串报文，请你来翻译并计算结果。 输入描述： 火星人字符串表达式（结尾不带回车换行） 输入的字符串说明：字符串为仅由无符号整数和操作符（#、$）组成的计算表达式。 输出描述： 根据输入的火星人字符串输出计算结果（结尾不带回车换行）。 输入：7#6$5#12 输出：226 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.next(); System.out.println(getResult(str)); } public static long getResult(String str) { Pattern p = Pattern.compile(\u0026#34;(\\\\d+)\\\\$(\\\\d+)\u0026#34;); while (true) { Matcher m = p.matcher(str); if (!m.find()) break; String subStr = m.group(0); long x = Long.parseLong(m.group(1)); long y = Long.parseLong(m.group(2)); str = str.replaceFirst(subStr.replace(\u0026#34;$\u0026#34;, \u0026#34;\\\\$\u0026#34;), 3 * x + y + 2 + \u0026#34;\u0026#34;); } return Arrays.stream(str.split(\u0026#34;#\u0026#34;)) .map(Long::parseLong) .reduce((x, y) -\u0026gt; 2 * x + 3 * y + 4) .orElse(0L); } 10. 机场航班调度程序\r#\r描述\nXX市机场停放了多架飞机，每架飞机都有自己的航班号CA3385，CZ6678，SC6508等，航班号的前2个大写字母（或数字）代表航空公司的缩写，后面4个数字代表航班信息。但是XX市机场只有一条起飞跑道，调度人员需要安排目前停留在机场的航班有序起飞。 为保障航班的有序起飞，调度员首先按照航空公司的缩写（航班号前2个字母）对所有航班进行排序，同一航空公司的航班再按照航班号的后4个数字进行排序，最终获得安排好的航班的起飞顺序。 请编写一段代码根据输入的航班号信息帮助调度员输出航班的起飞顺序。 说明： 航空公司缩写排序按照从特殊符号$ \u0026amp; *，0~9，A~Z排序； 航班号为6为长度，后4位位纯数字，不考虑存在后4位重复的场景。 输入描述：第一行输入航班信息，多个航班号之间用逗号 \u0026#34;,\u0026#34; 分隔，输入的航班号不超过100个。 输出描述：输出航班起飞顺序，使用逗号分隔 输入：CA3385,CZ6678,SC6508,DU7523,HK4456,MK0987 输出：CA3385,CZ6678,DU7523,HK4456,MK0987,SC6508 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] flights = sc.nextLine().split(\u0026#34;,\u0026#34;); StringJoiner sj = new StringJoiner(\u0026#34;,\u0026#34;); Arrays.stream(flights).sorted(Main::compareTo).forEach(sj::add); System.out.println(sj); } private static int compareTo(String str1, String str2) { String abbr1 = str1.substring(0, 2); String num1 = str1.substring(2); String abbr2 = str2.substring(0, 2); String num2 = str2.substring(2); if (abbr1.equals(abbr2)) { return num1.compareTo(num2); } else { return abbr1.compareTo(abbr2); } } 11. 机器人搬砖\r#\r描述\n机器人搬砖，一共有 N 堆砖存放在 N 个不同的仓库中，第 i 堆砖中有 bricks[i] 块砖头，要求在 8 小时内搬完。 机器人每小时能搬砖的数量取决于有多少能量格，机器人一个小时中只能在一个仓库中搬砖，机器人的能量格只在这一个小时有效，为使得机器人损耗最小化，应尽量减小每次补充的能量格数。 为了保障在 8 小时内能完成搬砖任务，请计算每小时给机器人充能的最小能量格数。 无需考虑机器人补充能力格的耗时； 无需考虑机器人搬砖的耗时； 机器人每小时补充能量格只在这一个小时中有效； 输入描述：第一行为一行数字，空格分隔 输出描述：机器人每小时最少需要充的能量格，若无法完成任务，输出 -1 输入：30 12 25 8 19 输出：15 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] arr = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(arr)); } private static int getResult(int[] arr) { // 8个小时最多只能搬8个仓库 if (arr.length \u0026gt; 8) { return -1; } // 每小时最多需要的能量块 int num = Arrays.stream(arr).max().orElse(0); int minNum = num; while (num\u0026gt;0) { num--; if (check(arr, num)) { minNum = num; } else { break; } } return minNum; } private static boolean check(int[] bricks, int x) { int cost = 0; for (int brick : bricks) { cost += brick / x + (brick % x == 0 ? 0 : 1); if (cost \u0026gt; 8) { return false; } } return true; } 12. 计算礼品发放的最小分组数目\r#\r描述\n又到了一年的末尾，项目组让小明负责新年晚会的小礼品发放工作。 为使得参加晚会的同事所获得的小礼品价值相对平衡，需要把小礼品根据价格进行分组，但每组最多只能包括两件小礼品，并且每个分组的价格总和不能超过一个价格上限。 为了保证发放小礼品的效率，小明需要找到分组数目最少的方案。 你的任务是写一个程序，找出分组数最少的分组方案，并输出最少的分组数目。 输入描述： 第一行数据为分组礼品价格之和的上限 第二行数据为每个小礼品的价格，按照空格隔开，每个礼品价格不超过分组价格和的上限 输出描述： 输出最小分组数量 输入：5 1 2 5 输出：2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int max = Integer.parseInt(sc.nextLine()); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); Integer[] arr = Arrays.stream(split).map(Integer::parseInt).toArray(Integer[]::new); System.out.println(getResult(max, arr)); } public static int getResult(int max, Integer[] arr) { // 将商品按价格从小到大排序 Arrays.sort(arr); // l指针指向最小价格的商品 int l = 0; // r指针指向最大价格的商品 int r = arr.length - 1; // 如果商品价格不超过上限，则优先最小价格和最大价格组合 int count = 0; while (l \u0026lt; r) { // 如果最小价格+最大价格 不超过上限，则组合，否则最大价格独立一组 if (arr[l] + arr[r] \u0026lt;= max) { l++; } r--; count++; } if (l == r) { count++; } return count; } 13. 计算三叉搜索树的高度\r#\r描述\n定义构造三叉搜索树规则如下： 每个节点都存有一个数，当插入一个新的数时，从根节点向下寻找，直到找到一个合适的空节点插入。查找的规则是： 1. 如果数小于节点的数减去500，则将数插入节点的左子树 2. 如果数大于节点的数加上500，则将数插入节点的右子树 3. 否则，将数插入节点的中子树 给你一系列数，请按以上规则，按顺序将数插入树中，构建出一棵三叉搜索树，最后输出树的高度。 输入描述： 第一行为一个数 N，表示有 N 个数，1 ≤ N ≤ 10000 第二行为 N 个空格分隔的整数，每个数的范围为[1,10000] 输出描述： 输出树的高度（根节点的高度为1） 输入：5 5000 2000 5000 8000 1800 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] maxLen = {1}; TreeNode root = new TreeNode(sc.nextInt(), 1); for (int i = 1; i \u0026lt; n; i++) { int num = sc.nextInt(); addVal(maxLen, root, num); } sc.close(); System.out.println(maxLen[0]); } private static void addVal(int[] maxLen, TreeNode node, int val) { // 左子树 if (val \u0026lt; node.val - 500) { if (node.left == null) { node.left = new TreeNode(val, node.height + 1); maxLen[0] = Math.max(maxLen[0], node.height + 1); } else { addVal(maxLen, node.left, val); } return; } // 右子树 if (val \u0026gt; node.val + 500) { if (node.right == null) { node.right = new TreeNode(val, node.height + 1); maxLen[0] = Math.max(maxLen[0], node.height + 1); } else { addVal(maxLen, node.right, val); } return; } // 中子树 if (node.mid == null) { node.mid = new TreeNode(val, node.height + 1); maxLen[0] = Math.max(maxLen[0], node.height + 1); } else { addVal(maxLen, node.mid, val); } } static class TreeNode { int val; // 节点值 int height; // 节点所在高度 TreeNode left; // 左子树 TreeNode mid; // 中子树 TreeNode right; // 右子树 public TreeNode(int val, int height) { this.val = val; this.height = height; } } 14. 检查是否存在满足条件的数字组合\r#\r描述\n给定一个正整数数组，检查数组中是否存在满足规则的数字组合 规则：A = B + 2C 备注： 数组长度在3~100之间 数组成员为0~65535 数组成员可以重复，但每个成员只能在结果算式中使用一次， 如数组成员为 [0,0,1,5]，0出现两次允许，但结果0=0+2*0不允许 因为算式中使用了3个0 用例保证每组数字里最多只有一组符合要求的解 输入描述： 第一行输出数组的元素个数。 第二行输出所有数组元素，用空格隔开。 输出描述： 如果存在满足要求的数，在同一行里依次输出规则里A/B/C的取值，用空格隔开。 如果不存在，输出0。 输入： 4 2 7 3 0 输出： 7 3 2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); String[] strings = sc.nextLine().split(\u0026#34; \u0026#34;); Integer[] arr = new Integer[strings.length]; for (int i = 0; i \u0026lt; strings.length; i++) { arr[i] = Integer.parseInt(strings[i]); } System.out.println(getResult(n, arr)); } public static String getResult(int n, Integer[] arr) { Arrays.sort(arr, (a, b) -\u0026gt; b - a); for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { for (int k = j + 1; k \u0026lt; n; k++) { if (arr[i] == arr[j] + 2 * arr[k]) { return arr[i] + \u0026#34; \u0026#34; + arr[j] + \u0026#34; \u0026#34; + arr[k]; } if (arr[i] == arr[k] + 2 * arr[j]) { return arr[i] + \u0026#34; \u0026#34; + arr[k] + \u0026#34; \u0026#34; + arr[j]; } } } } return \u0026#34;0\u0026#34;; } 15. 解密犯罪时间\r#\r描述\n警察在侦破一个案件时，得到了线人给出的可能犯罪时间，形如 “HH:MM” 表示的时刻。根据约定，为了隐蔽，该时间是修改过的， 解密规则为：利用当前出现过的数字，构造下一个距离当前时间最近的时刻，则该时间为可能的犯罪时间。 每个出现的数字都可以被无限次使用。 输入描述：形如 HH:SS 的字符串，表示原始输入 输出描述：形如 HH:SS 的字符串，表示推理出来的犯罪时间 注意事项：1、可以保证线人给定的字符串一定是合法的。2、最近的时刻有可能在第二天。 输入：18:52 输出：18:55 说明：利用数字 1, 8, 5, 2 构造出来的最近时刻是 18:55，是 3 分钟之后。 输入：23:59 输出：22:22 说明：利用数字 2, 3, 5, 9 构造出来的最近时刻是 22:22 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String input = sc.nextLine(); String[] split = input.split(\u0026#34;:\u0026#34;); // 记录已经出现的数字 boolean[] exists = new boolean[10]; for (char c : input.toCharArray()) { if (Character.isDigit(c)) { exists[c - \u0026#39;0\u0026#39;] = true; } } // 原始时间 int times = Integer.parseInt(split[0]) * 60 + Integer.parseInt(split[1]); // 枚举所有时间，找到下一个距离当前事件最近的时刻 // -- 如果时间点中有字符未出现，则不考虑该时间点，因为该时间点已经不可能是答案了 // -- 如果时间点中有字符出现: // -- -- 如果时间相同，则不考虑该时间点，因为该时间点已经不可能是答案了 // -- -- 如果时间不同，则考虑该时间点，因为该时间点可能是答案了，但是要判断当天还是下一天 int hour = 0; int minute = 0; int d = Integer.MAX_VALUE; for (int h = 0; h \u0026lt; 24; h++) { if (!exists[h % 10] || !exists[h / 10]) continue; for (int m = 0; m \u0026lt; 60; m++) { int curTimes = h * 60 + m; // 字符未出现或时间相同 if (!exists[m % 10] || !exists[m / 10] || curTimes == times) continue; // 计算时间间隔，找到更近的时刻 int curD = (curTimes \u0026gt; times) ? curTimes - times : 24 * 60 - (times - curTimes); if (curD \u0026lt; d) { hour = h; minute = m; d = curD; } } } // %02d 表示将整数值按照至少占据两个字符的方式输出，不足两位时会在前面补零 // %n 表示一个换行符 System.out.printf(\u0026#34;%02d:%02d%n\u0026#34;, hour, minute); } 16. 精准核酸检测\r#\r描述\n为了达到新冠疫情精准防控的需要，为了避免全员核酸检测带来的浪费，需要精准圈定可能被感染的人群。 现在根据传染病流调以及大数据分析，得到了每个人之间在时间、空间上是否存在轨迹交叉。 现在给定一组确诊人员编号（X1,X2,X3,...,Xn），在所有人当中，找出哪些人需要进行核酸检测，输出需要进行核酸检测的人数。（注意：确诊病例自身不需要再做核酸检测） 需要进行核酸检测的人，是病毒传播链条上的所有人员，即有可能通过确诊病例所能传播到的所有人。 例如：A是确诊病例，A和B有接触、B和C有接触、C和D有接触、D和E有接触，那么B\\C\\D\\E都是需要进行核酸检测的人。 输入描述： 第一行为总人数 N 第二行为确认病例人员编号（确诊病例人员数量 ＜ N），用逗号分割 第三行开始，为一个 N * N 的矩阵，表示每个人员之间是否有接触，0表示没有接触，1表示有接触。 输出描述： 整数：需要做核酸检测的人数 备注： 人员编号从0开始 0 ＜ N ＜ 100 输入：5 1,2 1,1,0,1,0 1,1,0,0,0 0,0,1,0,1 1,0,0,1,0 0,0,1,0,1 输出：3 编号为1、2号的人员，为确诊病例。 1号和0号有接触，0号和3号有接触。 2号和4号有接触。 所以，需要做核酸检测的人是0号、3号、4号，总计3人需要进行核酸检测。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); String[] split = sc.nextLine().split(\u0026#34;,\u0026#34;); int[] confirmed = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); int[][] matrix = new int[n][n]; for (int i = 0; i \u0026lt; n; i++) { String[] strings = sc.nextLine().split(\u0026#34;,\u0026#34;); matrix[i] = Arrays.stream(strings).mapToInt(Integer::parseInt).toArray(); } System.out.println(getResult(n, confirmed, matrix)); } public static int getResult(int n, int[] confirmed, int[][] matrix) { UnionFindSet ufs = new UnionFindSet(n); for (int i = 0; i \u0026lt; n; i++) { for (int j = i; j \u0026lt; n; j++) { if (matrix[i][j] == 1) { // 有过接触的人进行合并 ufs.union(i, j); } } } // 统计每个接触群体（连通分量）中的人数 int[] cnts = new int[n]; for (int i = 0; i \u0026lt; n; i++) { int fa = ufs.findRoot(i); cnts[fa]++; } // 记录已统计过的感染群体 HashSet\u0026lt;Integer\u0026gt; confirmed_fa = new HashSet\u0026lt;\u0026gt;(); // 将有感染者的接触群体的人数统计出来 int ans = 0; for (int i : confirmed) { int fa = ufs.findRoot(i); // 如果该感染群体已统计过，则不再统计 if (confirmed_fa.contains(fa)) continue; confirmed_fa.add(fa); ans += cnts[fa]; } // 最终需要做核酸的人数，不包括已感染的人 return ans - confirmed.length; } // 并查集 static class UnionFindSet { int[] fa; // 初始化，设置i的父节点fa[i]为自身 public UnionFindSet(int n) { this.fa = new int[n]; for (int i = 0; i \u0026lt; n; i++) { fa[i] = i; } } // 查找x的根节点 public int findRoot(int x) { // 递归中断条件：根节点为自身 if (fa[x] == x) { return x; } // 递归：查询x的根节点 int root = findRoot(fa[x]); // 递归路径压缩：直接设置x的父节点为根 fa[x] = root; return root; } // 合并节点x、y public void union(int x, int y) { // 查找xy两者的根节点 int xFa = this.findRoot(x); int yFa = this.findRoot(y); // 合并：将xy两者的根节点设为一样 fa[xFa] = yFa; } } 17. 开源项目热度榜单\r#\r描述\n某个开源社区希望将最近热度比较高的开源项目出一个榜单，推荐给社区里面的开发者。 对于每个开源项目，开发者可以进行关注（watch）、收藏（star）、fork、提issue、提交合并请求（MR）等。 数据库里面统计了每个开源项目关注、收藏、fork、issue、MR的数量，开源项目的热度根据这5个维度的加权求和进行排序。 H = W(watch) x #watch + W(star) x #star + W(fork) x #fork + W(issue) x #issue + W(mr) x #mr 1. H 表示热度值 2. W(watch)、W(star)、W(fork)、W(issue)、W(mr) 分别表示5个统计维度的权重 3. #watch、#star、#fork、#issue、#mr 分别表示5个统计维度的统计值 榜单按照热度值降序排序，对于热度值相等的，按照项目名字转换为全小写字母后的字典序排序（\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,...,\u0026#39;x\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;z\u0026#39;）。 输入描述： 第一行输入为N，表示开源项目的个数，0 ＜ N ＜100。 第二行输入为权重值列表，一共 5 个整型值，分别对应关注、收藏、fork、issue、MR的权重，权重取值 0 ＜ W ≤ 50。 第三行开始接下来的 N 行为开源项目的统计维度，每一行的格式为： name nr_watch nr_start nr_fork nr_issue nr_mr 其中 name 为开源项目的名字，由英文字母组成，长度 ≤ 50，其余 5 个整型值分别为该开源项目关注、收藏、fork、issue、MR的数量，数量取值 0 ＜ nr ≤ 1000。 输出描述： 按照热度降序，输出开源项目的名字，对于热度值相等的，按照项目名字转换为全小写后的字典序排序（\u0026#39;a\u0026#39; \u0026gt; \u0026#39;b\u0026#39; \u0026gt; \u0026#39;c\u0026#39; \u0026gt; ... \u0026gt; \u0026#39;x\u0026#39; \u0026gt; \u0026#39;y\u0026#39; \u0026gt; \u0026#39;z\u0026#39;）。 输入：4 8 6 2 8 6 camila 66 70 46 158 80 victoria 94 76 86 189 211 anthony 29 17 83 21 48 emily 53 97 1 19 218 输出：victoria camila emily anthony 题解\nstatic class Project { String name; int hot; public Project(String name, int hot) { this.name = name; this.hot = hot; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] weights = new int[5]; for (int i = 0; i \u0026lt; 5; i++) { weights[i] = sc.nextInt(); } Project[] projects = new Project[n]; for (int i = 0; i \u0026lt; n; i++) { String name = sc.next(); int hot = 0; for (int j = 0; j \u0026lt; 5; j++) { hot += sc.nextInt() * weights[j]; } projects[i] = new Project(name, hot); } sc.close(); Arrays.sort(projects, (a, b) -\u0026gt; a.hot != b.hot ? b.hot - a.hot : a.name.toLowerCase().compareTo(b.name.toLowerCase())); Arrays.stream(projects).forEach(p -\u0026gt; System.out.println(p.name)); } 18. 考勤信息\r#\r描述\n公司用一个字符串来表示员工的出勤信息 缺勤-absent，迟到-late，早退-leaveearly，正常上班-resent 现需根据员工出勤信息，判断本次是否能获得出勤奖，能获得出勤奖的条件如下： 缺勤不超过一次； 没有连续的迟到/早退； 任意连续7次考勤，缺勤/迟到/早退不超过3次。 输入描述： 第一行输入一个整数n，表示有多少个员工 后面n行，每一行输入若干个字符串，表示第i名员工的出勤信息 输出描述： 输出n行，每一行表示这名员工能否获得出勤奖，如果可以，则输出“true\u0026#34;，否则输出”false\u0026#34; 输入：2 present present absent present present leaveearly present absent 输出：true false 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; num; i++) { list.add(getResult(sc.nextLine())); } list.forEach(System.out::println); } private static String getResult(String string) { // 缺勤不超过一次 String str = string.replaceFirst(\u0026#34;absent\u0026#34;, \u0026#34;\u0026#34;); if (str.contains(\u0026#34;absent\u0026#34;)) { return \u0026#34;false\u0026#34;; } // 没有连续的迟到/早退； if (string.contains(\u0026#34;late leaveearly\u0026#34;) || string.contains(\u0026#34;leaveearly late\u0026#34;)) { return \u0026#34;false\u0026#34;; } // 任意连续7次考勤，缺勤/迟到/早退不超过3次。 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(string.split(\u0026#34; \u0026#34;))); if (list.size() \u0026lt; 7) { // 填充到7天 for (int i = 0; i \u0026lt; 7 - list.size(); i++) { list.add(\u0026#34;\u0026#34;); } } for (int i = 0; i \u0026lt; list.size() - 6; i++) { int time = 0; List\u0026lt;String\u0026gt; subList = list.subList(i, i + 7); for (String subStr : subList) { if (!\u0026#34;resent\u0026#34;.equals(subStr)) { time++; } if (time \u0026gt; 3) { return \u0026#34;false\u0026#34;; } } } return \u0026#34;ture\u0026#34;; } 19. 靠谱的车\r#\r描述\n程序员小明打了一辆出租车去上班。出于职业敏感，他注意到这辆出租车的计费表有点问题，总是偏大。 出租车司机解释说他不喜欢数字4，所以改装了计费表，任何数字位置遇到数字4就直接跳过，其余功能都正常。 比如： 23再多一块钱就变为25； 39再多一块钱变为50； 399再多一块钱变为500； 小明识破了司机的伎俩，准备利用自己的学识打败司机的阴谋。 给出计费表的表面读数，返回实际产生的费用。 输入描述：只有一行，数字N，表示里程表的读数。(1≤N≤888888888)。 输出描述：一个数字，表示实际产生的费用。以回车结束。 输入：5 输出：4 输入：100 输出：81 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String line = sc.nextLine(); String[] split = line.split(\u0026#34;\u0026#34;); int[] arr = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(arr)); } // 相当于九进制 public static int getResult(int[] arr) { int sum = 0; for (int i = 0; i \u0026lt; arr.length; i++) { int num = arr[i]; if (num \u0026gt; 4) { num--; } for (int j = arr.length - i - 1; j \u0026gt; 0; j--) { num *= 9; } sum += num; } return sum; } 20. 快递运输\r#\r描述\n一辆运送快递的货车，运送的快递放在大小不等的长方体快递盒中， 为了能够装载更多的快递，同时不能让货车超载，需要计算最多能装多少个快递。 注：快递的体积不受限制，快递数最多1000个，货车载重最大50000 输入描述： 第一行输入每个快递的重量，用英文逗号隔开，如 5,10,2,11 第二行输入货车的载重量，如 20 不需要考虑异常输入 输出描述： 输出最多能装多少个快递，如 3 输入：5,10,2,11 20 输出：3 说明：货车的载重量为20，最多只能放三个快递5、10、2，因此输出3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34;,\u0026#34;); int[] weights = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); int limit = Integer.parseInt(sc.nextLine()); System.out.println(getResult(weights, limit)); } public static int getResult(int[] weights, int limit) { Arrays.sort(weights); int sum = 0; int count = 0; for (int w : weights) { // 每次都选择重量最小的快递加入 sum += w; if (sum \u0026gt; limit) break; count++; } return count; } 21. 括号匹配\r#\r描述\n给定一个字符串，里边可能包含“()”、“[]”、“{}”三种括号，请编写程序检查该字符串中的括号是否成对出现，且嵌套关系正确。 若括号成对出现且嵌套关系正确，或该字符串中无括号字符，输出：true； 若未正确使用括号字符，输出：false。 实现时，无需考虑非法输入。 输入：(1+2)/(0.5+1) 输出：true 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); System.out.println(getResult(str)); } public static boolean getResult(String str) { // 去除非括号字符 str = str.replaceAll(\u0026#34;[^\\\\(\\\\)\\\\[\\\\]\\\\{\\\\}]\u0026#34;, \u0026#34;\u0026#34;); HashMap\u0026lt;Character, Character\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#39;)\u0026#39;, \u0026#39;(\u0026#39;); map.put(\u0026#39;]\u0026#39;, \u0026#39;[\u0026#39;); map.put(\u0026#39;}\u0026#39;, \u0026#39;{\u0026#39;); LinkedList\u0026lt;Character\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; str.length(); i++) { char c = str.charAt(i); if (!stack.isEmpty() \u0026amp;\u0026amp; map.containsKey(c)) { if (stack.getLast() == map.get(c)) { stack.removeLast(); continue; } else { return false; } } stack.add(c); } return stack.isEmpty(); } 22. 来自异国的客人\r#\r描述\n有位客人来自异国，在该国使用 m 进制计数。 该客人有个幸运数字n（n ＜ m），每次购物时，其总是喜欢计算本次支付的花费（折算为异国的价格后）中存在多少幸运数字。 问：当其购买一个在我国价值 k 的产品时，其中包含多少幸运数字? 输入描述： 第一行输入为 k，n，m。 k 表示该客人购买的物品价值（以十进制计算的价格） n 表示该客人的幸运数字 m 表示该客人所在国度采用的进制 输出描述： 输出幸运数字的个数，行末无空格 备注： 当输入非法内容时，输出0 输入：10 2 4 输出：2 说明：10用4进制表示时为22，同时，异国客人的幸运数字是2，故而此处输出为2，表示有2个幸运数字。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); try { String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); long[] longs = Arrays.stream(split).mapToLong(Long::parseLong).toArray(); System.out.println(getResult(longs)); } catch (Exception e) { System.out.println(0); } } public static long getResult(long[] longs) { long k = longs[0]; long n = longs[1]; long m = longs[2]; if (n \u0026gt;= m || m \u0026lt; 1) { return 0; } long sum = 0; while (k \u0026gt; 0) { // 余数就是m进制的每一位上“位值” if (k % m == n) { sum++; } k = k / m; } return sum; } 23. 连续字母长度\r#\r描述\n给定一个字符串，只包含大写字母，求在包含同一字母的子串中，长度第 k 长的子串的长度，相同字母只取最长的那个子串。 输入描述： 第一行有一个子串(1＜长度≤100)，只包含大写字母。 第二行为 k的值 输出描述：输出连续出现次数第k多的字母的次数。 输入：AABAAA 2 输出：1 说明：同一字母连续出现的最多的是A，3次；第二多的还是A，两次，但是A已经出现过了，故为B，一次； 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chars = sc.nextLine().toCharArray(); int k = Integer.parseInt(sc.nextLine()); System.out.println(getResult(chars, k)); } public static int getResult(char[] chars, int k) { if (k \u0026lt;= 0) { return -1; } Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int tempLen = 1; char tempCh = \u0026#39;-\u0026#39;; for (char curCh : chars) { if (curCh == tempCh) { tempLen++; map.put(curCh, Math.max(tempLen, map.get(curCh))); } else { map.putIfAbsent(curCh, 1); tempCh = curCh; tempLen = 1; } } Integer[] arr = map.values().stream().sorted((a, b) -\u0026gt; b - a).toArray(Integer[]::new); if (k \u0026lt;= arr.length) { return arr[k - 1]; } return -1; } 24. 两数之和绝对值最小\r#\r描述\n给定一个从小到大的有序整数序列（存在正整数和负整数）数组 nums ，请你在该数组中找出两个数，其和的绝对值(|nums[x]+nums[y]|)为最小值，并返回这个绝对值。 每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 输入描述：一个通过空格分割的有序整数序列字符串，最多1000个整数，且整数数值范围是 -65535~65535。 输出描述：两数之和绝对值最小值 输入：-3 -1 5 7 11 15 输出：2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(nums)); } public static int getResult(int[] nums) { int min = Integer.MAX_VALUE; for (int i = 0; i \u0026lt; nums.length; i++) { for (int j = i + 1; j \u0026lt; nums.length; j++) { int sum = Math.abs(nums[i] + nums[j]); min = Math.min(min, sum); } } return min; } 25. 螺旋数字矩阵\r#\r描述\n给出数字个数 n （0 ＜ n ≤ 999）和行数 m（0 ＜ m ≤ 999），从左上角的 1 开始，按照顺时针螺旋向内写方式，依次写出2,3,....,n，最终形成一个 m 行矩阵。 这个矩阵要求： 1、每行数字的个数一样多 2、列的数量尽可能少 3、填充数字时优先填充外部 4、数字不够时，使用单个 * 号占位 输入描述：两个整数，空格隔开，依次表示 n、m 输出描述：符合要求的唯一矩阵 输入：9 4 输出：1 2 3 * * 4 9 * 5 8 7 6 说明：9个数字写出4行，最少需要3列 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); // 需要在螺旋矩阵中填入 1 ~ n 数字 int n = sc.nextInt(); // 螺旋矩阵行数 int m = sc.nextInt(); // 螺旋矩阵列数 int k = (int) Math.ceil(n * 1.0 / m); // 螺旋矩阵 int[][] arr = new int[m][k]; int top = 0; int bottom = m - 1; int left = 0; int right = k - 1; int step = 1; while (left \u0026lt;= right \u0026amp;\u0026amp; top \u0026lt;= bottom) { // 从左到右 for (int i = left; i \u0026lt;= right \u0026amp;\u0026amp; step \u0026lt;= n; i++, step++) { arr[top][i] = step; } top++; // 从上到下 for (int i = top; i \u0026lt;= bottom \u0026amp;\u0026amp; step \u0026lt;= n; i++, step++) { arr[i][right] = step; } right--; // 从右到左 for (int i = right; i \u0026gt;= left \u0026amp;\u0026amp; step \u0026lt;= n; i--, step++) { arr[bottom][i] = step; } bottom--; // 从下到上 for (int i = bottom; i \u0026gt;= top \u0026amp;\u0026amp; step \u0026lt;= n; i--, step++) { arr[i][left] = step; } left++; } // 打印 for (int i = 0; i \u0026lt; m; i++) { StringJoiner row = new StringJoiner(\u0026#34; \u0026#34;); for (int j = 0; j \u0026lt; k; j++) { if (arr[i][j] == 0) { row.add(\u0026#34;*\u0026#34;); } else { row.add(arr[i][j] + \u0026#34;\u0026#34;); } } System.out.println(row); } } "},{"id":34,"href":"/lang2/program-design/structure-algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%933/","title":"机试题库 - 3","section":"华为OD","content":"\r01. 密码解密\r#\r描述\n给定一段“密文”字符串 s，其中字符都是经过“密码本”映射的，现需要将“密文”解密并输出。 映射的规则（\u0026#39;a\u0026#39; ~ \u0026#39;i\u0026#39;）分别用（\u0026#39;1\u0026#39; ~ \u0026#39;9\u0026#39;）表示；（\u0026#39;j\u0026#39; ~ \u0026#39;z\u0026#39;）分别用（\u0026#34;10*\u0026#34; ~ \u0026#34;26*\u0026#34;）表示。 约束：映射始终唯一。 输入描述：“密文”字符串 输出描述：明文字符串 备注：翻译后的文本长度在100以内 输入：12320*19*20* 输出：abctst 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); for (int i = 26; i \u0026gt;= 1; i--) { String key = i + (i \u0026gt; 9 ? \u0026#34;\\\\*\u0026#34; : \u0026#34;\u0026#34;); String val = String.valueOf((char) (\u0026#39;a\u0026#39; + i - 1)); str = str.replaceAll(key, val); } System.out.println(str); } 02. 密码输入检测\r#\r描述\n给定用户密码输入流 input，输入流中字符 \u0026#39;\u0026lt;\u0026#39; 表示退格，可以清除前一个输入的字符，请你编写程序，输出最终得到的密码字符，并判断密码是否满足如下的密码安全要求。 密码安全要求如下： 1. 密码长度 ≥ 8； 2. 密码至少需要包含 1 个大写字母； 3. 密码至少需要包含 1 个小写字母； 4. 密码至少需要包含 1 个数字； 5. 密码至少需要包含 1 个字母和数字以外的非空白特殊字符； 注意空串退格后仍然为空串，且用户输入的字符串不包含 \u0026#39;\u0026lt;\u0026#39; 字符和空白字符。 输入描述： 用一行字符串表示输入的用户数据，输入的字符串中 \u0026#39;\u0026lt;\u0026#39; 字符标识退格，用户输入的字符串不包含空白字符 输出描述： 输出经过程序处理后，输出的实际密码字符串，并输出改密码字符串是否满足密码安全要求。两者间由 \u0026#39;,\u0026#39; 分隔， 例如： 输入：ABC\u0026lt;c89%000\u0026lt; 输出：ABc89%00,true 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chars = sc.nextLine().toCharArray(); LinkedList\u0026lt;Character\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); for (char c : chars) { if (c == \u0026#39;\u0026lt;\u0026#39;) { if (stack.isEmpty()) { continue; } stack.removeLast(); } else { stack.addLast(c); } } int upper = 0; int lower = 0; int number = 0; int other = 0; StringBuilder password = new StringBuilder(); for (Character c : stack) { password.append(c); if (c \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39;) { lower++; } else if (c \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;Z\u0026#39;) { upper++; } else if (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) { number++; } else { other++; } } if (password.length() \u0026gt;= 8 \u0026amp;\u0026amp; lower \u0026gt;= 1 \u0026amp;\u0026amp; upper \u0026gt;= 1 \u0026amp;\u0026amp; number \u0026gt;= 1 \u0026amp;\u0026amp; other \u0026gt;= 1) { password.append(\u0026#34;,true\u0026#34;); } else { password.append(\u0026#34;,false\u0026#34;); } System.out.println(password); } 03. 密钥格式化\r#\r描述\n给定一个非空字符串 S，其被 N 个’-‘分隔成 N+1 的子串，给定正整数 K， 要求除第一个子串外，其余的串每 K 个字符用’-‘分隔，并将小写字母转换为大写。 作者：晓风长路 链接：https://www.nowcoder.com/discuss/353149752197980160?sourceSSR=search 来源：牛客网 输入描述：正整数 K 和‘-’分割的字符串 输出描述：转换后的字符串 输入：4 5F3Z-2e-9-w 输出：5F3Z-2E9W 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int k = sc.nextInt(); String str = sc.next(); System.out.println(getResult(k, str)); } public static String getResult(int k, String str) { String[] arr = str.split(\u0026#34;-\u0026#34;); String first = arr[0]; if (arr.length == 1) { return first; } StringBuilder sb = new StringBuilder(); for (int i = 1; i \u0026lt; arr.length; i++) { sb.append(arr[i]); } String[] tmp = sb.toString().toUpperCase().split(\u0026#34;\u0026#34;); for (int i = 0; i \u0026lt; tmp.length; i++) { if (i % k == 0) { tmp[i] = \u0026#34;-\u0026#34; + tmp[i]; } } return first + String.join(\u0026#34;\u0026#34;, tmp); } 04. 免单统计\r#\r描述\n华为商城举办了一个促销活动，如果某顾客是某一秒内最早时刻下单的顾客（可能是多个人），则可以获取免单。 请你编程计算有多少顾客可以获取免单。 输入描述： 输入为 n 行数据，每一行表示一位顾客的下单时间 以（年-月-日时-分-秒.毫秒） yyyy-MM-ddHH:mm:ss.fff 形式给出。所有输入保证合法。 0＜n＜50000，2000＜yyyy＜2020，0＜MM≤12，0＜dd≤28，0≤HH≤23，0≤mm≤59，0≤ss≤59，0≤fff≤999 输出描述： 输出一个整数，表示有多少顾客可以获取免单。 输入：5 2019-01-01 00:00:00.004 2019-01-01 00:00:00.004 2019-01-01 00:00:01.006 2019-01-01 00:00:01.006 2019-01-01 00:00:01.005 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); String[] arr = new String[n]; for (int i = 0; i \u0026lt; n; i++) { arr[i] = sc.nextLine(); } System.out.println(getResult(arr)); } public static Long getResult(String[] arr) { Map\u0026lt;String, List\u0026lt;Integer\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (String str : arr) { String key = str.substring(0, str.length() - 3); int num = Integer.parseInt(str.substring(str.length() - 3)); map.putIfAbsent(key, new ArrayList\u0026lt;\u0026gt;()); map.get(key).add(num); } return map.values().stream().map(Main::getMinSum).reduce(0L, Long::sum); } public static long getMinSum(List\u0026lt;Integer\u0026gt; list) { int min = list.stream().reduce(Integer::min).orElse(0); return list.stream().filter(i -\u0026gt; i == min).count(); } 05. 内存冷热标记\r#\r描述\n现代计算机系统中通常存在多级的存储设备，针对海量 workload 的优化的一种思路是将热点内存页优先放到快速存储层级，这就需要对内存页进行冷热标记。 一种典型的方案是基于内存页的访问频次进行标记，如果统计窗口内访问次数大于等于设定阈值，则认为是热内存页，否则是冷内存页。 对于统计窗口内跟踪到的访存序列和阈值，现在需要实现基于频次的冷热标记。内存页使用页框号作为标识。 输入描述： 第一行输入为 N，表示访存序列的记录条数，0 ＜ N ≤ 10000。 第二行为访存序列，空格分隔的 N 个内存页框号，页面号范围0 ~ 65535，同一个页框号可能重复出现，出现的次数即为对应框号的频次 第三行为热内存的频次阈值 T，正整数范围 1 ≤ T ≤ 10000。 输出描述： 第一行输出标记为热内存的内存页个数，如果没有被标记的热内存页，则输出 0 。 如果第一行 \u0026gt; 0，则接下来按照访问频次降序输出内存页框号，一行一个，频次一样的页框号，页框号小的排前面。 输入：10 1 2 1 2 1 2 1 2 1 2 5 输出：2 1 2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); String[] arr = sc.nextLine().split(\u0026#34; \u0026#34;); int t = Integer.parseInt(sc.nextLine()); HashMap\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (String key : arr) { if (!map.containsKey(key)) { map.put(key, 1); } else { map.put(key, map.get(key) + 1); } } List\u0026lt;String\u0026gt; list = map.entrySet().stream() .filter(entry -\u0026gt; entry.getValue() \u0026gt;= t) .map(Map.Entry::getKey).collect(Collectors.toList()); if (list.isEmpty()) { System.out.println(0); return; } System.out.println(list.size()); list.stream().sorted().forEach(System.out::println); } 06. 攀登者\r#\r描述\n攀登者喜欢寻找各种地图，并且尝试攀登到最高的山峰。 地图表示为一维数组，数组的索引代表水平位置，数组的元素代表相对海拔高度。其中数组元素0代表地面。 例如：[0,1,2,4,3,1,0,0,1,2,3,1,2,1,0]，代表如下图所示的地图，地图中有两个山脉位置分别为 1,2,3,4,5 和 8,9,10,11,12,13，最高峰高度分别为 4,3。最高峰位置分别为3,10。 一个山脉可能有多座山峰(高度大于相邻位置的高度，或在地图边界且高度大于相邻的高度)。 登山者想要知道一张地图中有多少座山峰。 输入描述：输入为一个整型数组，数组长度大于1。 输出描述：输出地图中山峰的数量。 输入：0,1,4,3,1,0,0,1,2,3,1,2,1,0 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34;,\u0026#34;); int[] heights = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(heights)); } public static int getResult(int[] heights) { int count = 0; for (int i = 0; i \u0026lt; heights.length; i++) { int leftHeight = i - 1 \u0026gt;= 0 ? heights[i - 1] : 0; int rightHeight = i + 1 \u0026lt; heights.length ? heights[i + 1] : 0; if (heights[i] \u0026gt; leftHeight \u0026amp;\u0026amp; heights[i] \u0026gt; rightHeight) { count++; } } return count; } 07. 判断字符串子序列\r#\r描述\n给定字符串 target和 source，判断 target是否为 source 的子序列。认为target和 source 中仅包含英文小写字母。 字符串 source 可能会很长（长度~=500,000），而 target是个短字符串（长度≤100)。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。 请找出最后一个子序列的起始位置。 输入描述： 第一行为target，短字符串（长度 ≤100） 第二行为source，长字符串（长度 ~= 500,000） 输出描述： 最后一个子序列的起始位置，即最后一个子序列首字母的下标 备注： 若在source中找不到target，则输出-1。 输入：abc abcaybec 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(getResult(sc.nextLine(), sc.nextLine())); } public static int getResult(String target, String source) { int cursor = target.length() - 1; for (int i = source.length() - 1; i \u0026gt;= 0; i--) { if (source.charAt(i) == target.charAt(cursor)) { cursor--; if (cursor \u0026lt; 0) return i; } } return -1; } 08. 拼接URL\r#\r描述\n给定一个url前缀和url后缀,通过,分割 需要将其连接为一个完整的url 1. 如果前缀结尾和后缀开头都没有/，需要自动补上/连接符 2. 如果前缀结尾和后缀开头都为/，需要自动去重 输入描述：url前缀(一个长度小于100的字符串)，url后缀(一个长度小于100的字符串) 输出描述：拼接后的url 约束：不用考虑前后缀URL不合法情况 输入：/acm,/bb 输出：/acm/bb 输入：/acd,bef 输出：/acd/bef 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.nextLine(); String[] arr = s.split(\u0026#34;,\u0026#34;); String prefix = arr.length \u0026gt; 0 \u0026amp;\u0026amp; !arr[0].isEmpty() ? arr[0] : \u0026#34;/\u0026#34;; String suffix = arr.length \u0026gt; 1 \u0026amp;\u0026amp; !arr[1].isEmpty() ? arr[1] : \u0026#34;/\u0026#34;; System.out.println(getResult(prefix, suffix)); } public static String getResult(String prefix, String suffix) { prefix = prefix.replaceAll(\u0026#34;/+$\u0026#34;, \u0026#34;\u0026#34;); suffix = suffix.replaceAll(\u0026#34;^/+\u0026#34;, \u0026#34;\u0026#34;); return prefix + \u0026#34;/\u0026#34; + suffix; } 09. 悄悄话\r#\r描述\n给定一个二叉树，每个节点上站一个人，节点数字表示父节点到该节点传递悄悄话需要花费的时间。 初始时，根节点所在位置的人有一个悄悄话想要传递给其他人，求二叉树所有节点上的人都接收到悄悄话花费的时间。 输入：0 9 20 -1 -1 15 7 -1 -1 -1 -1 3 2 输出：38 题解\nprivate static int ans = 0; public static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] times = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); sumTime(times, times[0], 0); System.out.println(ans); } private static void sumTime(int[] times, int pTime, int pIndex) { // 如果父节点在序列中的索引是k，则其两个子节点在序列中的索引分别为 2k+1, 2k+2 int left = 2 * pIndex + 1; // 左子节点索引 int right = 2 * pIndex + 2; // 右子节点索引 // 如果存在左子节点 if (left \u0026lt; times.length \u0026amp;\u0026amp; times[left] != -1) { int curTime = pTime + times[left]; ans = Math.max(ans, curTime); sumTime(times, curTime, left); } // 如果存在右子节点 if (right \u0026lt; times.length \u0026amp;\u0026amp; times[right] != -1) { int curTime = pTime + times[right]; ans = Math.max(ans, curTime); sumTime(times, curTime, right); } } 10. 求符合要求的结对方式\r#\r描述\n用一个数组A代表程序员的工作能力，公司想通过结对编程的方式提高员工的能力， 假设结对后的能力为两个员工的能力之和，求一共有多少种结对方式使结对后能力为N。 输入描述： 第一行为员工的总人数，取值范围[1,1000] 第二行为数组A的元素，每个元素的取值范围[1,1000] 第三行为N的值，取值范围[1,1000] 输出描述： 满足结对后能力为N的结对方式总数。 输入：5 1 2 2 2 3 4 输出：4 说明：A[0]和A[4]，A[1]和A[2]，A[1]和A[3]，A[2]和A[3]。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int total = sc.nextInt(); int[] arr = new int[total]; for (int i = 0; i \u0026lt; total; i++) { arr[i] = sc.nextInt(); } int n = sc.nextInt(); sc.close(); System.out.println(getResult(arr, n)); } public static int getResult(int[] arr, int n) { Arrays.sort(arr); int ans = 0; for (int i = 0; i \u0026lt; arr.length; i++) { for (int j = arr.length - 1; j \u0026gt;= i + 1; j--) { int sum = arr[i] + arr[j]; if (sum \u0026lt; n) { break; } if (sum == n) { ans++; } } } return ans; } 11. 求解连续数列\r#\r描述\n已知连续正整数数列{K}=K1,K2,K3…Ki的各个数相加之和为S，i=N (0＜S＜100000, 0＜N＜100000), 求此数列K。 输入描述：输入包含两个参数，1）连续正整数数列和S，2）数列里数的个数N。 输出描述：如果有解输出数列K，如果无解输出-1。 输入：525 6 输出：85 86 87 88 89 90 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int sum = sc.nextInt(); int n = sc.nextInt(); sc.close(); // 等差求和公式，算出起始数 int a1 = sum / n - (n - 1) / 2; if (a1 \u0026lt; 1) { System.out.println(-1); return; } StringJoiner joiner = new StringJoiner(\u0026#34; \u0026#34;); for (int i = 0; i \u0026lt; n; i++) { joiner.add(\u0026#34;\u0026#34; + a1); a1++; } System.out.println(joiner); } 12. 求满足条件的最长子串的长度\r#\r描述\n给定一个字符串，只包含字母和数字，按要求找出字符串中的最长（连续）子串的长度，字符串本身是其最长的子串，子串要求： 1、 只包含1个字母(a~z, A~Z)，其余必须是数字； 2、 字母可以在子串中的任意位置； 如果找不到满足要求的子串，如全是字母或全是数字，则返回-1。 输入描述：字符串(只包含字母和数字) 输出描述：子串的长度 输入：abC124ACb 输出：4 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String line = sc.nextLine(); String[] split = line.split(\u0026#34;[a-zA-Z]\u0026#34;); int maxLen = -1; for (int i = 0; i \u0026lt; split.length - 1; i++) { int len = split[i].length() + split[i + 1].length() + 1; if (len \u0026gt; 1) { maxLen = Math.max(maxLen, len); } } System.out.println(maxLen); } 13. 求字符串中所有整数的最小和\r#\r描述\n输入字符串s，输出s中包含所有整数的最小和。 说明： 字符串s，只包含 a-z A-Z ± ； 合法的整数包括 正整数：一个或者多个0-9组成，如0，2，3，002，102 负整数：负号 – 开头，数字部分由一个或者多个0-9组成，如-0，-012，-23，-00023 输入描述：包含数字的字符串。 输出描述：所有整数的最小和。 输入：b12-34aa 输出：-31 说明：1+2+(-34)=-31 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chars = sc.nextLine().toCharArray(); List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); String temp = \u0026#34;\u0026#34;; for (char ch : chars) { if (ch == \u0026#39;-\u0026#39;) { temp = \u0026#34;-\u0026#34;; continue; } if (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (temp.length() \u0026gt; 1) { list.add(Integer.parseInt(temp)); temp = \u0026#34;\u0026#34;; } continue; } if (!temp.isEmpty()) { temp += ch; continue; } list.add(Integer.parseInt(\u0026#34;\u0026#34; + ch)); } if (temp.length() \u0026gt; 1) { list.add(Integer.parseInt(temp)); } System.out.println(list.stream().reduce(Integer::sum).orElse(0)); } 14. 求最多可以派出多少支团队\r#\r描述\n用数组代表每个人的能力，一个比赛活动要求参赛团队的最低能力值为N， 每个团队可以由1人或者2人组成，且1个人只能参加1个团队，计算出最多可以派出多少只符合要求的团队。 输入描述： 第一行代表总人数，范围1-500000 第二行数组代表每个人的能力，数组大小，范围1-500000，元素取值，范围1-500000 第三行数值为团队要求的最低能力值，范围1-500000 输出描述： 最多可以派出的团队数量 输入：7 3 1 5 7 9 2 6 8 输出：4 说明：3、5组成一队，1、7一队，9自己一队，2、6一队，输出4 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] capacities = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); int minCap = Integer.parseInt(sc.nextLine()); System.out.println(getResult(n, capacities, minCap)); } public static int getResult(int n, int[] capacities, int minCap) { // 升序 Arrays.sort(capacities); int l = 0; int r = n - 1; // 记录题解 int ans = 0; // 单人组队 while (r \u0026gt;= l \u0026amp;\u0026amp; capacities[r] \u0026gt;= minCap) { r--; ans++; } // 双人组队 while (l \u0026lt; r) { int sum = capacities[l] + capacities[r]; // 如果两个人的能力值之和\u0026gt;=minCap，则组队 if (sum \u0026gt;= minCap) { ans++; l++; r--; } else { // 否则将能力低的人剔除，换下一个能力更高的人 l++; } } return ans; } 15. 全排列\r#\r描述\n给定一个只包含大写英文字母的字符串S，要求你给出对S重新排列的所有不相同的排列数。 如：S为ABA，则不同的排列有ABA、AAB、BAA三种。 输入描述：输入一个长度不超过10的字符串S，我们确保都是大写的。 输出描述：输出S重新排列的所有不相同的排列数（包含自己本身）。 输入：ABCDEFGHHA 输出：907200 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.next(); System.out.println(getResult(s)); } public static int getResult(String s) { int total = getFact(s.length()); HashMap\u0026lt;Character, Integer\u0026gt; count = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; s.length(); i++) { char k = s.charAt(i); count.put(k, count.getOrDefault(k, 0) + 1); } // 如果：一共n个元素，其中某元素A重复x次，某元素B重复了y次， // 那么：最终不重复全排列个数 = n! / x! / y! for (Character k : count.keySet()) { int n = count.get(k); if (n \u0026gt; 1) { total /= getFact(n); } } return total; } public static int getFact(int n) { int fact = 1; for (int i = 1; i \u0026lt;= n; i++) fact *= i; return fact; } 16. 生成哈夫曼树\r#\r描述\n给定长度为 n 的无序的数字数组，每个数字代表二叉树的叶子节点的权值，数字数组的值均大于等于1。 请完成一个函数，根据输入的数字数组，生成哈夫曼树，并将哈夫曼树按照中序遍历输出。 为了保证输出的二叉树中序遍历结果统一，增加以下限制： 二叉树节点中，左节点权值小于右节点权值，根节点权值为左右节点权值之和。当左右节点权值相同时，左子树高度小于等于右子树高度。 哈夫曼树： 又称为最优二叉树，是一种带权路径长度最短的二叉树。 所谓树的带权路径长度，就是树中所有的叶节点的权值乘上其到根节点的路径长度（若根节点为 0 层，叶节点到根节点的路径长度为叶节点的层数） 输入描述：长度为 n 的无序的数字数组 输出描述：输出一个哈夫曼树的中序遍历数组，数值间以空格分隔 输入：5 5 15 40 30 10 输出：40 100 30 60 15 30 5 15 10 题解\nstatic class Node { Node left; // 左孩子节点 Node right; // 右孩子节点 int weight; // 当前节点的权重 int height; // 当前节点代表子树的高度 public Node(Node lc, Node rc, int weight, int height) { this.left = lc; this.right = rc; this.weight = weight; this.height = height; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] ints = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); // 将哈夫曼树节点进行排序，方便后面筛选出权值最小的两个节点 PriorityQueue\u0026lt;Node\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(Main::compareTo); for (int i = 0; i \u0026lt; n; i++) { // 创建n个哈夫曼树节点 Node node = new Node(null, null, ints[i], 0); // 加入优先队列 pq.offer(node); } // 当优先队列中只剩一个节点时即可停止合并，此时该节点就是哈夫曼树的根节点 while (pq.size() \u0026gt; 1) { // 生成哈夫曼树的固定思路： // 取出优先队列中前两个权值最小的节点，作为新节点的左右子树 Node lc = pq.poll(); Node rc = pq.poll(); // 将lc和rc合并，合并后新节点fa的权重，是两个子节点权重之和 int fa_weight = lc.weight + rc.weight; int fa_height = rc.height + 1; // 将合并后的新节点加入优先队列 Node fa = new Node(lc, rc, fa_weight, fa_height); pq.offer(fa); } // 最后优先队列中必然只剩一个节点，即哈夫曼树的根节点 // 此时对此根节点（哈夫曼树）进行中序遍历 Node root = pq.poll(); StringJoiner sj = new StringJoiner(\u0026#34; \u0026#34;); midOrder(root, sj); System.out.println(sj); } private static int compareTo(Node a, Node b) { return a.weight != b.weight ? a.weight - b.weight : a.height - b.height; } public static void midOrder(Node root, StringJoiner sj) { // 中序遍历，即先遍历二叉树的左子树，再遍历二叉树的根，最后遍历二叉树的右子树 if (root.left != null) { midOrder(root.left, sj); } sj.add(root.weight + \u0026#34;\u0026#34;); if (root.right != null) { midOrder(root.right, sj); } } 17. 剩余银饰的重量\r#\r描述\n有 N 块二手市场收集的银饰，每块银饰的重量都是正整数，收集到的银饰会被熔化用于打造新的饰品。 每一回合，从中选出三块最重的银饰，然后一起熔掉。 假设银饰的重量分别为 x 、y和z，且 x ≤ y ≤ z。那么熔掉的可能结果如下： 如果 x == y == z，那么三块银饰都会被完全熔掉； 如果 x == y 且 y != z，会剩余重量为 z - y 的银块无法被熔掉； 如果 x != y 且 y == z，会剩余重量为 y - x 的银块无法被熔掉； 如果 x != y 且 y != z，会剩余重量为 z - y 与 y - x 差值 的银块无法被熔掉。 输入描述： 第一行为银饰数组长度 n，1 ≤ n ≤ 40， 第二行为n块银饰的重量，重量的取值范围为[1，2000]，重量之间使用空格隔开 输出描述： 如果剩余两块，返回较大的重量（若两块重量相同，返回任意一块皆可）； 如果只剩下一块，返回该块的重量； 如果没有剩下，就返回 0。 输入：3 3 7 10 输出：1 说明：(7-3)-(10-7)=1，所以数组转换为 [1]，剩余一块，返回该块重量，返回 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); LinkedList\u0026lt;Integer\u0026gt; weights = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { weights.add(sc.nextInt()); } // 升序 weights.sort((a, b) -\u0026gt; a - b); while (weights.size() \u0026gt;= 3) { // 尾删三个最大值 int z = weights.removeLast(); int y = weights.removeLast(); int x = weights.removeLast(); int remain = Math.abs((z - y) - (y - x)); // 如果还有剩余银块 if (remain != 0) { // 那么就二分查找其在剩余升序weights中的有序插入位置 int idx = Collections.binarySearch(weights, remain); if (idx \u0026lt; 0) { idx = -idx - 1; } weights.add(idx, remain); } } if (weights.size() == 2) { System.out.println(Math.max(weights.get(0), weights.get(1))); } else if (weights.size() == 1) { System.out.println(weights.get(0)); } else { System.out.println(0); } } 18. 石头剪刀布游戏\r#\r描述\n石头剪刀布游戏有 3 种出拳形状：石头、剪刀、布。分别用字母A、B、C表示。 出拳形状之间的胜负规则如下：A \u0026gt; B、B \u0026gt; C、C \u0026gt; A； 当本场次中有且仅有一种出拳形状优于其他出拳形状，则该形状的玩家是胜利者。否则认为是平局。 当发生平局，没有赢家。有多个胜利者时，同为赢家。 输入描述： 在一场游戏中，每个玩家的信息为一行。玩家数量不超过1000。每个玩家信息有2个字段，用空格隔开； 玩家ID：一个仅由英文字母和数字组成的字符串 出拳形状：以英文大写字母表示，A、B、C形状。 输出描述： 输出为赢家的玩家ID列表（一个或多个），每个ID一行，按字符串升序排列。如果没有赢家，输出为”NULL“字符串。 输入：abc1 A def A alic A xyz B 输出：abc1 alic def 输入：abc1 A xyz A 输出：NULL 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); HashMap\u0026lt;Character, ArrayList\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); while (sc.hasNextLine()) { String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); String player = split[0]; char gesture = split[1].charAt(0); if (gesture != \u0026#39;A\u0026#39; \u0026amp;\u0026amp; gesture != \u0026#39;B\u0026#39; \u0026amp;\u0026amp; gesture != \u0026#39;C\u0026#39;) { System.out.println(\u0026#34;NULL\u0026#34;); return; } map.putIfAbsent(gesture, new ArrayList\u0026lt;\u0026gt;()); map.get(gesture).add(player); } switch (map.size()) { case 1: case 3: // 只有一种手势，或者三种手势都有，则平局 System.out.println(\u0026#34;NULL\u0026#34;); break; case 2: ArrayList\u0026lt;String\u0026gt; list; if (!map.containsKey(\u0026#39;A\u0026#39;)) { // 没有A手势，只有B、C手势，则B赢 list = map.get(\u0026#39;B\u0026#39;); } else if (!map.containsKey(\u0026#39;B\u0026#39;)) { // 没有B手势，只有A、C手势，则C赢 list = map.get(\u0026#39;C\u0026#39;); } else { // 没有C手势，只有A、B手势，则A赢 list = map.get(\u0026#39;A\u0026#39;); } list.sort(String::compareTo); list.forEach(System.out::println); break; } } 19. 手机App防沉迷系统\r#\r描述\n手机App防沉迷系统原理： 1. 在一天24小时内，可以注册每个App的允许使用时段 2. 一个时间段只能使用一个App 3. App有优先级，数值越高，优先级越高。注册使用时段时， 如果高优先级的App时间和低优先级的时段有冲突，则系统会自动注销低优先级的时段， 如果App的优先级相同，则后添加的App不能注册。 请编程实现，根据输入数据注册App，并根据输入的时间点，返回时间点使用的App名称， 如果该时间点没有注册任何App，请返回字符串“NA”。 输入描述： 第一行表示注册的App数量 N（N ≤ 100） 第二部分包括 N 行，每行表示一条App注册数据 最后一行输入一个时间点，程序即返回该时间点使用的App App注册数据说明： N行注册数据以空格分隔，四项数依次表示：App名称、优先级、起始时间、结束时间 优先级1~5，数字越大，优先级越高 时间格式 HH:MM，小时和分钟都是两位，不足两位前面补0 起始时间需小于结束时间，否则注册不上 注册信息中的时间段包含起始时间点，不包含结束时间点 输出描述： 输出一个字符串，表示App名称，或NA表示空闲时间 输入：2 App1 1 09:00 10:00 App2 2 09:10 09:30 09:20 输出：App2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); App[] arr = new App[n]; for (int i = 0; i \u0026lt; n; i++) { arr[i] = newApp(sc.nextLine(), i); } int queryTime = toMinutes(sc.nextLine()); System.out.println(getResult(arr, queryTime)); } public static String getResult(App[] arr, int queryTime) { // 优先级降序+索引升序 Arrays.sort(arr, (a, b) -\u0026gt; a.priority != b.priority ? b.priority - a.priority : a.index - b.index); // 高优先级的app一定会被注册 List\u0026lt;App\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; arr.length; i++) { if (arr[i].isRemove) { continue; } list.add(arr[i]); for (int j = i + 1; j \u0026lt; arr.length; j++) { if (arr[j].isRemove) { continue; } if (arr[i].isOverlap(arr[j])) { // arr[j] 一定比 arr[i] 优先级低且在后添加 arr[j].isRemove = true; } } } // 注册成功的App时段之间互不冲突，因此queryTime只会对应一个App String ans = \u0026#34;NA\u0026#34;; for (App app : list) { if (queryTime \u0026gt;= app.startTime \u0026amp;\u0026amp; queryTime \u0026lt; app.endTime) { ans = app.name; break; } } return ans; } public static App newApp(String line, int index) { String[] arr = line.split(\u0026#34; \u0026#34;); String name = arr[0]; int priority = Integer.parseInt(arr[1]); int startTime = toMinutes(arr[2]); int endTime = toMinutes(arr[3]); return new App(name, priority, startTime, endTime, index); } public static int toMinutes(String time) { String[] arr = time.split(\u0026#34;:\u0026#34;); int hour = Integer.parseInt(arr[0]); int minute = Integer.parseInt(arr[1]); return hour * 60 + minute; } public static class App { String name; int priority; int startTime; int endTime; int index; // 注册先后排序 boolean isRemove; // 是否被移除 public App(String name, int priority, int startTime, int endTime, int index) { this.name = name; this.priority = priority; this.startTime = startTime; this.endTime = endTime; this.index = index; } // 判断当前应用程序与另一个应用程序是否有时间重叠 public boolean isOverlap(App other) { return this.startTime \u0026lt; other.endTime \u0026amp;\u0026amp; other.startTime \u0026lt; this.endTime; } } 20. 输出指定字母在字符串的中的索引\r#\r描述\n给定一个字符串，把字符串按照大写在前小写在后排序，输出排好后的第 K 个字母在原来字符串的索引。 相同字母输出第一个出现的位置。 输入：hAkDAjByBq 4 输出：6 说明：排好序后 AABBDhjkqy，第 4 个是 B，第一个出现的在原字符串 6 这个位置。（注：索引是从 0 开始） 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); String str = split[0]; int idx = Integer.parseInt(split[1]); char[] arr = str.toCharArray(); Arrays.sort(arr); char target = arr[idx - 1]; System.out.println(str.indexOf(target)); } 21. 数的分解\r#\r描述\n给定一个正整数 n，如果能够分解为 m（m \u0026gt; 1）个连续正整数之和，请输出所有分解中，m最小的分解。 如果给定整数无法分解为连续正整数，则输出字符串\u0026#34;N\u0026#34;。 输入数据为一整数，范围为 (1, 2^30] 输入：21 输出：21=10+11 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); long n = Long.parseLong(sc.nextLine()); System.out.println(getResult(n)); } public static String getResult(long n) { long a1 = 0; long m = 0; for (long i = 2; i \u0026lt; n; i++) { double temp = (double) (2 * n - i * i + i) / (2 * i); if (temp \u0026lt; 1) { break; } if (temp % 1 == 0) { a1 = (long) temp; m = i; break; } } if (m == 0) { return \u0026#34;N\u0026#34;; } StringBuilder sb = new StringBuilder(n + \u0026#34;=\u0026#34;); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (long i = 0; i \u0026lt; m; i++) { list.add((a1 + i) + \u0026#34;\u0026#34;); } return sb.append(String.join(\u0026#34;+\u0026#34;, list)).toString(); } 22. 数据单元的变化替换\r#\r描述\n将一个 csv 格式的数据文件中包含有单元格引用的内容替换为对应单元格内容的实际值。 csv 格式的数据文件使用逗号 \u0026#34;,\u0026#34; 作为分隔符将各单元的内容进行分隔。 输入描述： 1. 输入只有一行数据，用逗号分隔每个单元格，行尾没有逗号。最多26个单元格，对应编号A~Z。 2. 每个单元格的内容包含字母和数字，以及使用 \u0026#39;\u0026lt;\u0026gt;\u0026#39; 分隔的单元格引用，例如：\u0026lt;A\u0026gt;表示引用第一个单元的值。 3. 每个单元格的内容，在替换前和替换后均不超过100个字符。 4. 引用单元格的位置不受限制，允许排在后面的单元格被排在前面的单元格引用。 5. 不存在循环引用的情况 6. 不存在多重 \u0026#39;\u0026lt;\u0026gt;\u0026#39; 的情况，一个单元只能引用一个其他单元格。 输出描述： 输出替换后的结果 输入：1,2\u0026lt;A\u0026gt;00 输出：1,2100 说明：第二个单元中有对A单元的引用，A单元格的值为1，替换时，将A单元的内容替代\u0026lt;A\u0026gt;的位置，并和其他内容合并。 题解\nstatic String[] cells; static Pattern p = Pattern.compile(\u0026#34;(\u0026lt;.*?\u0026gt;)\u0026#34;); public static void main(String[] args) { Scanner sc = new Scanner(System.in); cells = sc.nextLine().split(\u0026#34;,\u0026#34;); System.out.println(getResult()); } public static String getResult() { StringJoiner sj = new StringJoiner(\u0026#34;,\u0026#34;); for (int i = 0; i \u0026lt; cells.length; i++) { // 替换单元格中的引用，替换失败，则返回-1 if (!changeCell(i)) return \u0026#34;-1\u0026#34;; // 替换成功，则记录单元格内容 sj.add(cells[i]); } return sj.toString(); } public static boolean changeCell(int index) { // 通过正则匹配出单元格内容中\u0026#34;引用字符串\u0026#34; Matcher m = p.matcher(cells[index]); while (m.find()) { // reference记录引用字符串 String refStr = m.group(0); // 引用单元格编号只能是A~Z的字母，即引用引用字符串长度只能是3 if (refStr.length() != 3) { return false; } // 引用单元格的编号 int refIndex = refStr.charAt(1) - \u0026#39;A\u0026#39;; // 引用单元格编号不能超出边界，且不能自引用 if (refIndex \u0026lt; 0 || refIndex \u0026gt;= cells.length || refIndex == index) { return false; } if (!changeCell(refIndex)) return false; // 将单元格内容中的引用部分，替换为被引用的单元格的内容 cells[index] = cells[index].replaceAll(refStr, cells[refIndex]); // 重新正则匹配 m = p.matcher(cells[index]); } return true; } 23. 数字涂色\r#\r描述\n疫情过后，希望小学终于又重新开学了，三年二班开学第一天的任务是将后面的黑板报重新制作。 黑板上已经写上了N个正整数，同学们需要给这每个数分别上一种颜色。 为了让黑板报既美观又有学习意义，老师要求同种颜色的所有数都可以被这种颜色中最小的那个数整除。 现在请你帮帮小朋友们，算算最少需要多少种颜色才能给这N个数进行上色。 输入描述： 第一行有一个正整数N，其中。 第二行有N个int型数(保证输入数据在[1,100]范围中)，表示黑板上各个正整数的值。 输出描述： 输出只有一个整数，为最少需要的颜色种数。 输入：4 2 3 4 9 输出：2 说明：2与4涂一种颜色，4能被2整除；3与9涂另一种颜色，9能被3整除。 不能4个数涂同一个颜色，因为3与9不能被2整除。所以最少的颜色是两种。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] arr = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(n, arr)); } public static int getResult(int n, int[] arr) { Arrays.sort(arr); if (arr[0] == 1) { return 1; } int count = 0; boolean[] color = new boolean[n]; for (int i = 0; i \u0026lt; n; i++) { if (color[i]) { continue; } color[i] = true; for (int j = i + 1; j \u0026lt; n; j++) { if (!color[j] \u0026amp;\u0026amp; arr[j] % arr[i] == 0) { color[j] = true; } } count++; } return count; } 24. 数字字符串组合倒序\r#\r描述\n对数字，字符，数字串，字符串，以及数字与字符串组合进行倒序排列。 1. 字符范围：由 a 到 z， A 到 Z， 2. 数字范围：由 0 到 9 符号的定义： 1. “-”作为连接符使用时作为字符串的一部分，例如“20-years”作为一个整体字符串呈现； 2. 连续出现 2 个 “-” 及以上时视为字符串间隔符，如“out--standing”中的”–“视为间隔符，是 2 个独立整体字符串 3. 除了 1，2 里面定义的字符以外其他的所有字符，都是非法字符，作为字符串的间隔符处理，倒序后间隔符作为空格处理； 4. 要求倒排后的单词间隔符以一个空格表示；如果有多个间隔符时，倒排转换后也只允许出现一个字格间隔符； 输入：I am an 20-years out--standing @ * -stu- dent 输出：dent stu standing out 20-years an am I 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); System.out.println(getResult(str)); } public static String getResult(String line) { String str = line.replaceAll(\u0026#34;-{2,}\u0026#34;, \u0026#34;@\u0026#34;) .replaceAll(\u0026#34;[^0-9a-zA-Z\\\\-]\u0026#34;, \u0026#34;@\u0026#34;) .replaceAll(\u0026#34;@-\u0026#34;, \u0026#34;@\u0026#34;) .replaceAll(\u0026#34;-@\u0026#34;, \u0026#34;@\u0026#34;) .replaceAll(\u0026#34;@{2,}\u0026#34;, \u0026#34;@\u0026#34;); String[] arr = str.split(\u0026#34;@\u0026#34;); StringJoiner joiner = new StringJoiner(\u0026#34; \u0026#34;); for (int i = arr.length - 1; i \u0026gt;= 0; i--) { joiner.add(arr[i]); } return joiner.toString(); } 25. 数组连续和\r#\r描述\n给定一个含有N个正整数的数组, 求出有多少个连续区间（包括单个正整数）, 它们的和大于等于x。 输入描述： 第一行两个整数N，x（0＜N≤100000, 0≤x≤10000000) 第二行有N个正整数（每个正整数小于等于100)。 输出描述： 输出一个整数，表示所求的个数。 注意：此题对效率有要求，暴力解法通过率不高，请考虑高效的实现方式。 输入：3 7 3 4 7 输出：4 说明：组合为 3 + 4; 3 + 4 + 7; 4 + 7; 7; 都大于等于指定的7；所以共四组。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int n = Integer.parseInt(split[0]); int x = Integer.parseInt(split[1]); String[] split2 = sc.nextLine().split(\u0026#34; \u0026#34;); int[] arr = Arrays.stream(split2).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(n, x, arr)); } public static long getResult(int n, int x, int[] arr) { int[] preSum = new int[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { preSum[i] = preSum[i - 1] + arr[i - 1]; } int l = 0; int r = 1; long ans = 0; while (r \u0026lt;= n) { if (preSum[r] - preSum[l] \u0026gt;= x) { ans += n - r + 1; l++; r = l + 1; } else { r++; } } return ans; } "},{"id":35,"href":"/lang2/program-design/structure-algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%934/","title":"机试题库 - 4","section":"华为OD","content":"\r01. 数组组成的最小数字\r#\r描述\n给定一个整型数组，请从该数组中选择3个元素组成最小数字并输出（如果数组长度小于3，则选择数组中所有元素来组成最小数字）。 输入描述：一行用半角逗号分割的字符串记录的整型数组，0＜数组长度≤100，0＜整数的取值范围≤10000。 输出描述：由3个元素组成的最小数字，如果数组长度小于3，则选择数组中所有元素来组成最小数字。 输入：21,30,62,5,31 输出：21305 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34;,\u0026#34;); System.out.println(getResult(split)); } public static String getResult(String[] strs) { Arrays.sort(strs, Comparator.comparingInt(Integer::parseInt)); String[] tmp = Arrays.copyOfRange(strs, 0, Math.min(3, strs.length)); Arrays.sort(tmp, (a, b) -\u0026gt; (a + b).compareTo(b + a)); StringBuilder sb = new StringBuilder(); for (String s : tmp) { sb.append(s); } return sb.toString(); } 02. 水仙花数\r#\r描述\n所谓水仙花数，是指一个n位的正整数，其各位数字的n次方和等于该数本身。 例如153是水仙花数，153是一个3位数，并且153 = 1^3 + 5^3 + 3^3。 输入描述： 第一行输入一个整数n，表示一个n位的正整数。n在3到7之间，包含3和7。 第二行输入一个整数m，表示需要返回第m个水仙花数。 输出描述： 返回长度是n的第m个水仙花数。个数从0开始编号。 若m大于水仙花数的个数，返回最后一个水仙花数和m的乘积。 若输入不合法，返回-1。 题解\n// 或者预先计算水仙花数表 // 3 位：153, 370, 371, 407 // 4 位：1634, 8208, 9474 // 5 位：54748, 92727, 93084 // 6 位：548834 // 7 位：1741725, 4210818, 9800817, 9926315 public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); System.out.println(getResult(n, m)); } public static long getResult(int n, int m) { // 若输入不合法，返回-1 if (n \u0026lt; 3 || n \u0026gt; 7 || m \u0026lt; 0) return -1; // 提前计算好0~9的N次方, 避免后续进行重复计算 HashMap\u0026lt;Character, Integer\u0026gt; powN = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt;= 9; i++) { // 将整型0~9转化字符\u0026#39;0\u0026#39;~\u0026#39;9\u0026#39;，即让i+\u0026#39;0\u0026#39;即可 powN.put((char) (i + \u0026#39;0\u0026#39;), (int) Math.pow(i, n)); } // 最小的N位数 int min = (int) Math.pow(10, n - 1); // 最大的N位数 int max = (int) Math.pow(10, n); // 记录当前水仙花数 long ans = 0; // 记录当前水仙花数是第几个 int idx = 0; for (int num = min; num \u0026lt; max; num++) { // 记录num各位数字的N次方之和 int sum = 0; // 遍历num的每一位数字 String str = num + \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; n; i++) { sum += powN.get(str.charAt(i)); } // 判断num是否为水仙花数 if (sum == num) { ans = num; // 如果num刚好是N位数的第m个水仙花数，则直接返回，否则继续查找 if (idx++ == m) return ans; } } // 若m大于水仙花数的个数，返回最后一个水仙花数和m的乘积 return ans * m; } 03. 素数之积\r#\r描述\nRSA加密算法在网络安全世界中无处不在，它利用了极大整数因数分解的困难度，数据越大，安全系数越高。 给定一个32位正整数，请对其进行因数分解，找出是哪两个素数的乘积。 输入描述：一个正整数num，0＜num≤2147483647 输出描述：如果成功找到，以单个空格分割，从小到大输出两个素数，分解失败，请输出-1 -1 输入：15 输出：3 5 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); int r1 = -1; int r2 = -1; for (int i = 2; i \u0026lt; Math.sqrt(num) + 1; i++) { if (num % i != 0) { continue; } if (isPrime(i) \u0026amp;\u0026amp; isPrime(num / i)) { r1 = i; r2 = num / i; break; } } System.out.println(r1 + \u0026#34; \u0026#34; + r2); } // 素数只能被1和自身整除 private static boolean isPrime(int n) { if (n \u0026lt; 2) { return false; } for (int i = 2; i \u0026lt;= Math.sqrt(n); i++) { if (n % i == 0) { return false; } } return true; } 04. 提取字符串中的最长合法简单数学表达式\r#\r描述\n提取字符串中的最长合法简单数学表达式，字符串长度最长的，并计算表达式的值。如果没有，则返回 0 。 简单数学表达式只能包含以下内容：0-9数字，符号+-* 说明： 1. 所有数字，计算结果都不超过long 2. 如果有多个长度一样的，请返回第一个表达式的结果 3. 数学表达式，必须是最长的，合法的 4. 操作符不能连续出现，如 +--+1 是不合法的 输入：1-2abcd 输出：-1 题解\npublic static void main(String[] args) throws ScriptException { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); Matcher matcher = Pattern.compile(\u0026#34;((\\\\d+[+*-])*\\\\d+)\u0026#34;).matcher(str); String maxLenExp = \u0026#34;\u0026#34;; while (matcher.find()) { String exp = matcher.group(0); if (exp.length() \u0026gt; maxLenExp.length()) { maxLenExp = exp; } } ScriptEngine engine = new ScriptEngineManager().getEngineByName(\u0026#34;js\u0026#34;); System.out.println(engine.eval(maxLenExp)); } 05. 停车场车辆统计\r#\r描述\n特定大小的停车场，数组cars[]表示，其中1表示有车，0表示没车。 车辆大小不一，小车占一个车位（长度1），货车占两个车位（长度2），卡车占三个车位（长度3）。 统计停车场最少可以停多少辆车，返回具体的数目。 输入描述：整型字符串数组cars[]，其中1表示有车，0表示没车，数组长度小于1000。 输出描述：整型数字字符串，表示最少停车数目。 输入：1,1,0,0,1,1,1,0,1 输出：3 说明：1个货车占第1、2个车位；第3、4个车位空；1个卡车占第5、6、7个车位；第8个车位空；1个小车占第9个车位 最少3辆车 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String line = sc.nextLine(); String str = line.replaceAll(\u0026#34;,\u0026#34;, \u0026#34;\u0026#34;) .replaceAll(\u0026#34;111\u0026#34;, \u0026#34;x\u0026#34;) .replaceAll(\u0026#34;11\u0026#34;, \u0026#34;x\u0026#34;) .replaceAll(\u0026#34;1\u0026#34;, \u0026#34;x\u0026#34;); int ans = 0; for (int i = 0; i \u0026lt; str.length(); i++) { if (str.charAt(i) == \u0026#39;x\u0026#39;) { ans++; } } System.out.println(ans); } 06. 围棋的气\r#\r描述\n围棋棋盘由纵横各19条线垂直相交组成，棋盘上一共19 x 19 = 361 个交点， 对弈双方一方执白棋，一方执黑棋，落子时只能将棋子置于交点上。 “气”是围棋中很重要的一个概念，某个棋子有几口气，是指其上下左右方向四个相邻的交叉点中，有几个交叉点没有棋子 现在，请根据输入的黑棋和白棋得到坐标位置，计算黑棋和白棋一共各有多少气？ 输入描述： 输入包含两行数据，如： 每行数据以空格分隔，数据个数是2的整数倍，每两个数是一组，代表棋子在棋盘上的坐标； 坐标的原点在棋盘左上角点，第一个值是行号，范围从0到18；第二个值是列号，范围从0到18。 举例说明：第一行数据表示三个坐标（0, 5）、(8, 9)、(9, 10) 第一行表示黑棋的坐标，第二行表示白棋的坐标。 题目保证输入两行数据，无空行且每行按前文要求是偶数个，每个坐标不会超出棋盘范围。 输出描述： 两个数字以空格分隔，第一个数代表黑棋的气数，第二个数代表白棋的气数。 输入：0 5 8 9 9 10 5 0 9 9 9 8 输出：8 7 题解\nstatic int[] xArr = {0, 0, 1, -1}; static int[] yArr = {1, -1, 0, 0}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split1 = sc.nextLine().split(\u0026#34; \u0026#34;); int[] ints1 = Arrays.stream(split1).mapToInt(Integer::parseInt).toArray(); String[] split2 = sc.nextLine().split(\u0026#34; \u0026#34;); int[] ints2 = Arrays.stream(split2).mapToInt(Integer::parseInt).toArray(); int[][] board = new int[19][19]; List\u0026lt;Integer[]\u0026gt; list1 = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; ints1.length; ) { int x = ints1[i]; int y = ints1[i + 1]; board[x][y] = 1; list1.add(new Integer[]{x, y}); i += 2; } List\u0026lt;Integer[]\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; ints2.length; ) { int x = ints2[i]; int y = ints2[i + 1]; board[x][y] = 2; list2.add(new Integer[]{x, y}); i += 2; } int sum1 = 0; for (Integer[] arr : list1) { for (int i = 0; i \u0026lt; 4; i++) { int newX = arr[0] + xArr[i]; int newY = arr[1] + yArr[i]; if (newX \u0026lt; 0 || newX \u0026gt; 18 || newY \u0026lt; 0 || newY \u0026gt; 18) { continue; } int value = board[newX][newY]; if (value == 0) { board[newX][newY] = -1; sum1++; } } } int sum2 = 0; for (Integer[] arr : list2) { for (int i = 0; i \u0026lt; 4; i++) { int newX = arr[0] + xArr[i]; int newY = arr[1] + yArr[i]; if (newX \u0026lt; 0 || newX \u0026gt; 18 || newY \u0026lt; 0 || newY \u0026gt; 18) { continue; } int value = board[newX][newY]; if (value == 0 || value == -1) { board[newX][newY] = -2; sum2++; } } } System.out.println(sum1 + \u0026#34; \u0026#34; + sum2); } 07. 消消乐游戏\r#\r描述\n游戏规则：输入一个只包含英文字母的字符串，字符串中的两个字母如果相邻且相同，就可以消除。 在字符串上反复执行消除的动作，直到无法继续消除为止，此时游戏结束。 输出最终得到的字符串长度。 输入描述：输入原始字符串 str ，只能包含大小写英文字母，字母的大小写敏感， str 长度不超过100。 输出描述：输出游戏结束后，最终得到的字符串长度。 备注：输入中包含 非大小写英文字母 时，均为异常输入，直接返回 0。 输入：mMbccbc 输出：3 说明：mMbccbc 中，可以先消除 cc ； 此时字符串变成 mMbbc ，可以再消除 bb ； 此时字符串变成 mMc ，此时没有相邻且相同的字符，无法继续消除。最终得到的字符串为 mMc ，长度为3。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chs = sc.nextLine().toCharArray(); System.out.println(getResult(chs)); } public static int getResult(char[] chs) { LinkedList\u0026lt;Character\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); for (char ch : chs) { if (ch \u0026lt; \u0026#39;A\u0026#39; || ch \u0026gt; \u0026#39;z\u0026#39; || (ch \u0026gt; \u0026#39;Z\u0026#39; \u0026amp;\u0026amp; ch \u0026lt; \u0026#39;a\u0026#39;)) { return 0; } if (!stack.isEmpty() \u0026amp;\u0026amp; ch == stack.getLast()) { stack.removeLast(); } else { stack.addLast(ch); } } return stack.size(); } 08. 小华地图寻宝\r#\r描述\n小华按照地图去寻宝，地图上被划分成 m 行和 n 列的方格，横纵坐标范围分别是 [0, n-1] 和 [0, m-1]。 在横坐标和纵坐标的数位之和不大于 k 的方格中存在黄金（每个方格中仅存在一克黄金），但横坐标和纵坐标之和大于 k 的方格存在危险不可进入。小华从入口 (0,0) 进入，任何时候只能向左，右，上，下四个方向移动一格。 请问小华最多能获得多少克黄金？ 输入描述： 坐标取值范围如下：0 ≤ m ≤ 50，0 ≤ n ≤ 50 k 的取值范围如下：0 ≤ k ≤ 100 输入中包含3个字数，分别是m, n, k 输出描述： 输出小华最多能获得多少克黄金 输入：40 40 18 输出：1484 题解\nstatic int m; static int n; static int k; static int ans = 0; // 记录已访问过的位置 static HashSet\u0026lt;String\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); // 上下左右偏移量 static int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 数位和数组 static int[] digitSums; public static void main(String[] args) { Scanner sc = new Scanner(System.in); m = sc.nextInt(); n = sc.nextInt(); k = sc.nextInt(); digitSum(Math.max(m, n)); dfs(0, 0); System.out.println(ans); } // 深度优先搜索遍历矩阵 public static void dfs(int x, int y) { // 如果对应位置越界，或者已访问过，或者横坐标、纵坐标的数位和之和超过了k，则不能进入 if (x \u0026lt; 0 || x \u0026gt;= m || y \u0026lt; 0 || y \u0026gt;= n || visited.contains(x + \u0026#34;-\u0026#34; + y) || digitSums[x] + digitSums[y] \u0026gt; k) return; // 否则可以进入，且获得黄金 visited.add(x + \u0026#34;-\u0026#34; + y); ans++; // 继续遍历上、下、左、右方向上的新位置继续深搜 for (int[] offset : offsets) { int newX = x + offset[0]; int newY = y + offset[1]; dfs(newX, newY); } } // 提前计算好，避免后期重复计算某个数的数位和 public static void digitSum(int maxSize) { // digitSums数组的索引是原始数，值是原始数对应的数位和 digitSums = new int[maxSize]; for (int i = 0; i \u0026lt; maxSize; i++) { int num = i; while (num \u0026gt; 0) { digitSums[i] += num % 10; num /= 10; } } } 09. 小明的幸运数\r#\r描述\n小明在玩一个游戏，游戏规则如下： 在游戏开始前，小明站在坐标轴原点处（坐标值为0）。给定一组指令和一个幸运数， 每个指令都是一个整数，小明按照指令前进指定步数或者后退指定步数。前进代表朝坐标轴的正方向走，后退代表朝坐标轴的负方向走。 幸运数为一个整数，如果某个指令正好和幸运数相等，则小明行进步数+1。 例如： 幸运数为3，指令为[2,3,0,-5] 指令为2，表示前进2步；指令为3，正好和幸运数相等，前进3+1=4步； 指令为0，表示原地不动，既不前进，也不后退。指令为-5，表示后退5步。 输入描述： 第一行输入1个数字，代表指令的总个数 n（1 ≤ n ≤ 100） 第二行输入1个数字，代表幸运数m（-100 ≤ m ≤ 100） 第三行输入n个指令，每个指令的取值范围为：-100 ≤ 指令值 ≤ 100 输出描述： 输出在整个游戏过程中，小明所处的最大坐标值。异常情况下输出：12345 输入：2 1 -5 1 输出：0 输入：5 -5 -5 1 6 0 -7 输出：1 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); if (n \u0026lt; 1 || n \u0026gt; 100) { System.out.println(\u0026#34;12345\u0026#34;); return; } int m = sc.nextInt(); if (m \u0026lt; -100 || m \u0026gt; 100) { System.out.println(\u0026#34;12345\u0026#34;); return; } int pos = 0; int maxPos = 0; for (int i = 0; i \u0026lt; n; i++) { int num = sc.nextInt(); if (num \u0026lt; -100 || num \u0026gt; 100) { System.out.println(\u0026#34;12345\u0026#34;); return; } pos += num; if (num == m) { if (num \u0026gt; 0) { pos += 1; } else if (num \u0026lt; 0) { pos -= 1; } } maxPos = Math.max(maxPos, pos); } System.out.println(maxPos); } 10. 小明找位置\r#\r描述\n小朋友出操，按学号从小到大排成一列； 小明来迟了，请你给小明出个主意，让他尽快找到他应该排的位置。 算法复杂度要求不高于nLog(n)；学号为整数类型，队列规模 ≤ 10000； 输入描述： 第一行：输入已排成队列的小朋友的学号（正整数），以\u0026#34;,\u0026#34;隔开 第二行：小明学号 输出描述： 输出一个数字，代表队列位置（从1开始） 输入：93,95,97,100,102,123,155 110 输出：6 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34;,\u0026#34;); int[] nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); int target = Integer.parseInt(sc.nextLine()); int idx = Arrays.binarySearch(nums, target); if (idx \u0026lt; 0) { idx = -idx - 1; } // 队列位置（从1开始），因此索引+1 System.out.println(idx + 1); } 11. 小朋友来自多少小区\r#\r描述\n幼儿园组织活动，老师布置了一个任务：每个小朋友去了解与自己同一个小区的小朋友还有几个。 我们将这些数量汇总到数组 garden 中。 请根据这些小朋友给出的信息，计算最少的小朋友数量？ 备注： garden 数组长度最大为 999 每个小区的小朋友数量最多 1000 人，也就是 garden[i] 的范围为 [0, 999] 输入：2 2 3 输出：7 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(nums)); } public static int getResult(int[] nums) { HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int num : nums) { map.put(num, map.getOrDefault(num, 0) + 1); } int ans = 0; for (int key : map.keySet()) { // key是反馈，假设某小朋友反馈有key个人和自己一个小区，那么该小区总人数为total = key+1 int total = key + 1; ans += (int) (Math.ceil(map.get(key) * 1.0 / total) * total); } return ans; } 12. 虚拟理财游戏\r#\r描述\n在一款虚拟游戏中生活，你必须进行投资以增强在虚拟游戏中的资产以免被淘汰出局。 现有一家Bank，它提供有若干理财产品 m 个，风险及投资回报不同，你有 N（元）进行投资，能接收的总风险值为X。 你要在可接受范围内选择最优的投资方式获得最大回报。 备注： 1. 在虚拟游戏中，每项投资风险值相加为总风险值； 2. 在虚拟游戏中，最多只能投资2个理财产品； 3. 在虚拟游戏中，最小单位为整数，不能拆分为小数； 4. 投资额*回报率=投资回报 输入描述： 第一行：产品数（取值范围[1,20]），总投资额（整数，取值范围[1, 10000]），可接受的总风险（整数，取值范围[1,200]） 第二行：产品投资回报率序列，输入为整数，取值范围[1,60] 第三行：产品风险值序列，输入为整数，取值范围[1, 100] 第四行：最大投资额度序列，输入为整数，取值范围[1, 10000] 输出描述： 每个产品的投资额序列 输入：5 100 10 10 20 30 40 50 3 4 5 6 10 20 30 20 40 30 输出：0 30 0 40 0 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] tmp = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int m = tmp[0]; // 产品数 int n = tmp[1]; // 总投资 int x = tmp[2]; // 总风险 // 产品回报率序列 int[] back = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); // 产品风险值序列 int[] risk = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); // 产品投资额序列 int[] invest = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int maxBack = 0; HashMap\u0026lt;Integer, Integer\u0026gt; select = new HashMap\u0026lt;\u0026gt;(); // 情况1：只投资1个产品 for (int i = 0; i \u0026lt; m; i++) { if (risk[i] \u0026gt; x) { continue; } // 产品I的投资额不能超过该产品的最大投资额，以及总投资 int investI = Math.min(invest[i], n); // 产品投资回报 int curBack = investI * back[i]; // 如果投资回报高于其他产品组合，那么选择该产品 if (curBack \u0026gt; maxBack) { maxBack = curBack; select.clear(); select.put(i, investI); } } // 情况2：投资了2个产品 for (int i = 0; i \u0026lt; m; i++) { for (int j = i + 1; j \u0026lt; m; j++) { if (risk[i] + risk[j] \u0026gt; x) { continue; } int investI; int investJ; // 其中优先投资回报率大的 if (back[i] \u0026gt; back[j]) { // 产品I回报率高，则能投多少投多少，最多不能超过min(总投资, 产品I的最多投资额) investI = Math.min(n, invest[i]); // 留给产品J的剩余钱未 n - investI, 而产品J最多投资invest[j]，因此取二者较小值 investJ = Math.min(n - investI, invest[j]); } else { investJ = Math.min(n, invest[j]); investI = Math.min(n - investJ, invest[i]); } // 总投资回报 int curBack = investI * back[i] + investJ * back[j]; // 如果当前产品组合的总回报更大，则选当前组合产品 if (curBack \u0026gt; maxBack) { maxBack = curBack; select.clear(); // select的key记录产品的ID，val记录产品的投资额 if (investI \u0026gt; 0) select.put(i, investI); if (investJ \u0026gt; 0) select.put(j, investJ); } } } StringJoiner sj = new StringJoiner(\u0026#34; \u0026#34;); for (int i = 0; i \u0026lt; m; i++) { if (select.containsKey(i)) { sj.add(select.get(i) + \u0026#34;\u0026#34;); } else { sj.add(\u0026#34;0\u0026#34;); } } System.out.println(sj); } 13. 寻找身高相近的小朋友\r#\r描述\n小明今年升学到了小学1年级来到新班级后，发现其他小朋友身高参差不齐， 然后就想基于各小朋友和自己的身高差，对他们进行排序，请帮他实现排序。 输入描述： 第一行为正整数 h和n，0＜h＜200 为小明的身高，0＜n＜50 为新班级其他小朋友个数。 第二行为n个正整数，h1 ~ hn分别是其他小朋友的身高，取值范围0＜hi＜200，且n个正整数各不相同。 输出描述： 输出排序结果，各正整数以空格分割， 和小明身高差绝对值最小的小朋友排在前面，和小明身高差绝对值最大的小朋友排在后面， 如果两个小朋友和小明身高差一样，则个子较小的小朋友排在前面。 输入：100 10 95 96 97 98 99 101 102 103 104 105 输出：99 101 98 102 97 103 96 104 95 105 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int h = sc.nextInt(); int n = sc.nextInt(); Integer[] heights = new Integer[n]; for (int i = 0; i \u0026lt; n; i++) { heights[i] = sc.nextInt(); } System.out.println(getResult(h, heights)); } public static String getResult(int h, Integer[] heights) { Arrays.sort(heights, (a, b) -\u0026gt; { int absA = Math.abs(a - h); int abaB = Math.abs(b - h); return absA != abaB ? absA - abaB : a - b; }); StringJoiner sj = new StringJoiner(\u0026#34; \u0026#34;); for (Integer height : heights) { sj.add(height + \u0026#34;\u0026#34;); } return sj.toString(); } 14. 寻找相同子串\r#\r描述\n给你两个字符串t和p，要求从t中找到一个和p相同的连续子串，并输出该子串第一个字符的下标。 输入描述： 1. 输入文件包括两行，分别表示字符串t和p 2. 保证t的长度不小于p 3. t的长度不超过1000000 4. p的长度不超过10000 输出描述： 1. 如果能从t中找到一个和p相等的连续子串，则输出该子串第一个字符在t中的下标，下标从左到右依次为1,2,3,…； 2. 如果不能，则输出 “No” 3. 如果含有多个这样的子串，则输出第一个字符下标最小的 输入：AVERDXIVYERDIAN RDXI 输出：4 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); String subStr = sc.nextLine(); if (str.length() \u0026lt; subStr.length()) { System.out.println(\u0026#34;No\u0026#34;); return; } int idx = str.indexOf(subStr); String ans = idx == -1 ? \u0026#34;No\u0026#34; : idx + 1 + \u0026#34;\u0026#34;; System.out.println(ans); } 15. 一种字符串压缩表示的解压\r#\r描述\n有一种简易压缩算法：针对全部由小写英文字母组成的字符串， 将其中连续超过两个相同字母的部分压缩为连续个数加该字母，其他部分保持原样不变。 例如：字符串“aaabbccccd”经过压缩成为字符串“3abb4cd”。 请您编写解压函数，根据输入的字符串，判断其是否为合法压缩过的字符串， 若输入合法则输出解压缩后的字符串，否则输出字符串“!error”来报告错误。 输入描述：输入一行，为一个ASCII字符串，长度不会超过100字符，用例保证输出的字符串长度也不会超过100字符。 输出描述：若判断输入为合法的经过压缩后的字符串，则输出压缩前的字符串；若输入不合法，则输出字符串“!error”。 输入：4dff 输出：ddddff 说明：4d扩展为dddd，故解压后的字符串为ddddff。 输入：2dff 输出：!error 说明：两个d不需要压缩，故输入不合法。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(getResult(sc.nextLine())); } public static String getResult(String str) { if (!str.matches(\u0026#34;[a-z0-9]+\u0026#34;)) { return \u0026#34;!error\u0026#34;; } char[] chars = str.toCharArray(); StringBuilder sb = new StringBuilder(); LinkedList\u0026lt;Character\u0026gt; numList = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; chars.length; i++) { char ch = chars[i]; // 数字 if (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { numList.addLast(ch); continue; } // 字母 if (numList.isEmpty()) { sb.append(ch); continue; } String numStr = \u0026#34;\u0026#34;; while (!numList.isEmpty()) { numStr += numList.removeFirst(); } int num = Integer.parseInt(numStr); if (numStr.charAt(0) == \u0026#39;0\u0026#39; || num \u0026lt; 3) { return \u0026#34;!error\u0026#34;; } if (i + 1 \u0026lt; chars.length \u0026amp;\u0026amp; ch == chars[i + 1]) { return \u0026#34;!error\u0026#34;; } for (int j = 0; j \u0026lt; num; j++) { sb.append(ch); } } if (!numList.isEmpty()) { return \u0026#34;!error\u0026#34;; } if (!zip(sb.toString()).equals(str)) { return \u0026#34;!error\u0026#34;; } return sb.toString(); } public static String zip(String str) { char[] chars = str.toCharArray(); char ch; int num; StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; chars.length; i++) { ch = chars[i]; num = 1; for (int j = i + 1; j \u0026lt; chars.length; j++) { if (chars[j] == ch) { num++; continue; } break; } if (num == 1) { sb.append(ch); continue; } if (num == 2) { sb.append(ch).append(ch); i++; continue; } sb.append(num).append(ch); i += num - 1; } return sb.toString(); } 16. 英文输入法\r#\r描述\n主管期望你来实现英文输入法单词联想功能。 需求如下： 依据用户输入的单词前缀，从已输入的英文语句中联想出用户想输入的单词，按字典序输出联想到的单词序列， 如果联想不到，请输出用户输入的单词前缀。 注意： 英文单词联想时，区分大小写 缩略形式如”don’t”，判定为两个单词，”don”和”t” 输出的单词序列，不能有重复单词，且只能是英文单词，不能有标点符号 输入描述：输入为两行 首行输入一段由英文单词word和标点符号组成的语句str； 接下来一行为一个英文单词前缀pre。 0 ＜ word.length() ≤ 20 0 ＜ str.length ≤ 10000 0 ＜ pre ≤ 20 输出描述： 输出符合要求的单词序列或单词前缀，存在多个时，单词之间以单个空格分割 输入：The furthest distance in the world, Is not between life and death, But when I stand in front of you f 输出：front furthest 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); String pre = sc.nextLine(); System.out.println(getResult(str, pre)); } public static String getResult(String str, String pre) { String[] tmp = str.split(\u0026#34;[^a-zA-Z]\u0026#34;); List\u0026lt;String\u0026gt; list = Arrays.asList(tmp); String ans = list.stream().filter(s -\u0026gt; !s.isBlank()) .filter(s -\u0026gt; s.startsWith(pre)).sorted().collect(Collectors.joining(\u0026#34; \u0026#34;)); return ans.isEmpty() ? pre : ans; } 17. 用户调度问题\r#\r描述\n在通信系统中，一个常见的问题是对用户进行不同策略的调度，会得到不同的系统消耗和性能。 假设当前有n个待串行调度用户，每个用户可以使用A/B/C三种不同的调度策略，不同的策略会消耗不同的系统资源。 请你根据如下规则进行用户调度，并返回总的消耗资源数。 1. 相邻的用户不能使用相同的调度策略，例如，第1个用户使用了A策略，则第2个用户只能使用B或者C策略。 2. 对单个用户而言，不同的调度策略对系统资源的消耗可以归一化后抽象为数值。 3. 每个用户依次选择当前所能选择的对系统资源消耗最少的策略（局部最优），如果有多个满足要求的策略，选最后一个。 输入描述： 第一行表示用户个数n 接下来每一行表示一个用户分别使用三个策略的系统消耗resA resB resC 输出描述： 最优策略组合下的总的系统资源消耗数 输入：3 15 8 17 12 20 9 11 7 5 输出：24 说明：1号用户使用B策略，2号用户使用C策略，3号用户使用B策略。系统资源消耗: 8 + 9 + 7 = 24。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[][] res = new int[n][3]; for (int i = 0; i \u0026lt; n; i++) { res[i][0] = sc.nextInt(); res[i][1] = sc.nextInt(); res[i][2] = sc.nextInt(); } System.out.println(getResult(n, res)); } public static int getResult(int n, int[][] res) { int last = -1; int sum = 0; for (int i = 0; i \u0026lt; n; i++) { last = getMinEleIdx(res[i], last); sum += res[i][last]; } return sum; } public static int getMinEleIdx(int[] arr, int excludeIdx) { int minEleVal = Integer.MAX_VALUE; int minEleIdx = -1; for (int i = 0; i \u0026lt; arr.length; i++) { if (i == excludeIdx) continue; if (arr[i] \u0026lt;= minEleVal) { minEleVal = arr[i]; minEleIdx = i; } } return minEleIdx; } 18. 用连续自然数之和来表达整数\r#\r描述\n一个整数可以由连续的自然数之和来表示。 给定一个整数，计算该整数有几种连续自然数之和的表达式，且打印出每种表达式 输入描述： 一个目标整数T (1 ≤T≤ 1000) 输出描述： 该整数的所有表达式和表达式的个数。 如果有多种表达式，输出要求为：自然数个数最少的表达式优先输出，每个表达式中按自然数递增的顺序输出，具体的格式参见样例。 在每个测试数据结束时，输出一行”Result:X”，其中X是最终的表达式个数。 输入：9 输出：9=9 9=4+5 9=2+3+4 Result:3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); int i = 0; List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); while (true) { i++; int l = 2 * n - i * i + i; if (l % (2 * i) != 0) { continue; } int a1 = l / (2 * i); if (a1 \u0026lt; 1) { break; } list.add(getResult(n, a1, i)); } list.forEach(System.out::println); System.out.println(\u0026#34;Result:\u0026#34; + list.size()); } public static String getResult(int sum, int a1, int n) { StringJoiner joiner = new StringJoiner(\u0026#34;+\u0026#34;); for (int i = a1; i \u0026lt; n + a1; i++) { joiner.add(i + \u0026#34;\u0026#34;); } return sum + \u0026#34;=\u0026#34; + joiner; } 19. 游戏分组\r#\r描述\n部门准备举办一场王者荣耀表演赛，有 10 名游戏爱好者参与，分为两队，每队 5 人。 每位参与者都有一个评分，代表着他的游戏水平。为了表演赛尽可能精彩，我们需要把 10 名参赛者分为实力尽量相近的两队。 一队的实力可以表示为这一队 5 名队员的评分总和。 现在给你 10 名参与者的游戏水平评分，请你根据上述要求分队，最后输出这两组的实力差绝对值。 输入描述：10个整数，表示10名参与者的游戏水平评分。范围在 [1, 10000] 之间。 输出描述：1个整数，表示分组后两组实力差绝对值的最小值。 输入：1 2 3 4 5 6 7 8 9 10 输出：1 题解\nstatic int[] nums; public static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); dfs(list, 0, 0, 0, 0, 0); int ans = list.stream().reduce(Integer::min).orElse(0); System.out.println(ans); } public static void dfs(List\u0026lt;Integer\u0026gt; list, int index, int size1, int sum1, int size2, int sum2) { if (index \u0026gt; 9) { list.add(Math.abs(sum1 - sum2)); return; } int num = nums[index]; if (size1 \u0026lt; 5) { dfs(list, index + 1, size1 + 1, sum1 + num, size2, sum2); } if (size2 \u0026lt; 5) { dfs(list, index + 1, size1, sum1, size2 + 1, sum2 + num); } } 20. 约瑟夫问题\r#\r描述\n输入一个由随机数组成的数列（数列中每个数均是大于 0 的整数，长度已知），和初始计数值 m。 从数列首位置开始计数，计数到 m 后，将数列该位置数值替换计数值 m， 并将数列该位置数值出列，然后从下一位置从新开始计数，直到数列所有数值出列为止。 如果计数到达数列尾段，则返回数列首位置继续计数。 请编程实现上述计数过程，同时输出数值出列的顺序。 输入描述： 第一行是初始数列 第二行是初始数列的长度 第三行是初始计数值m 输出描述 输出的数值出列顺序 输入：3,1,2,4 4 7 输出：2,3,1,4 比如：输入的随机数列为：3,1,2,4，初始计数值 m=7，从数列首位置开始计数（数值 3 所在位置） 第一轮计数出列数字为 2，计数值更新 m=2，出列后数列为 3,1,4，从数值 4 所在位置从新开始计数 第二轮计数出列数字为 3，计数值更新 m=3，出列后数列为 1,4，从数值 1 所在位置开始计数 第三轮计数出列数字为 1，计数值更新 m=1，出列后数列为 4，从数值 4 所在位置开始计数 最后一轮计数出列数字为 4，计数过程完成。输出数值出列顺序为：2,3,1,4。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34;,\u0026#34;); Integer[] nums = Arrays.stream(split).map(Integer::parseInt).toArray(Integer[]::new); int len = Integer.parseInt(sc.nextLine()); int m = Integer.parseInt(sc.nextLine()); System.out.println(getResult(nums, len, m)); } public static String getResult(Integer[] nums, int len, int m) { LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(Arrays.asList(nums)); ArrayList\u0026lt;String\u0026gt; ansList = new ArrayList\u0026lt;\u0026gt;(); int i = 1; while (len \u0026gt; 0) { Integer out = list.removeFirst(); if (i == m) { ansList.add(out + \u0026#34;\u0026#34;); m = out; i = 1; len--; } else { list.add(out); i++; } } return String.join(\u0026#34;,\u0026#34;, ansList); } 21. 在字符串中找出连续最长的数字串\r#\r描述\n请在一个字符串中找出连续最长的数字串，并返回这个数字串。 如果存在长度相同的连续数字串，返回最后一个。 如果没有符合条件的字符串，返回空字符串””。 注意： 数字串可以由数字”0-9″、小数点”.”、正负号”±”组成，长度包括组成数字串的所有符号。 “.”、“±”仅能出现一次，”.”的两边必须是数字，”±”仅能出现在开头且其后必须要有数字。 长度不定，可能含有空格。 输入：1234567890abcd9.+12345.678.9ed 输出：+12345.678 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34;[^0-9.+-]\u0026#34;); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (String str : split) { if (str.isBlank()) { continue; } String[] strings = str.replaceAll(\u0026#34;\\\\+\u0026#34;, \u0026#34;@+\u0026#34;) .replaceAll(\u0026#34;-\u0026#34;, \u0026#34;@-\u0026#34;) .split(\u0026#34;@\u0026#34;); for (String string : strings) { if (string.isBlank() || string.equals(\u0026#34;+\u0026#34;) || string.equals(\u0026#34;-\u0026#34;)) { continue; } splitNumString(list, string); } } String ans = \u0026#34;\u0026#34;; for (String string : list) { if (string.length() \u0026gt;= ans.length()) { ans = string; } } System.out.println(ans); } public static void splitNumString(List\u0026lt;String\u0026gt; list, String line) { String[] arr = line.split(\u0026#34;\\\\.\u0026#34;); if (arr.length == 1) { list.add(arr[0]); return; } for (int i = 0; i \u0026lt; arr.length - 1; i++) { if (arr[i].isEmpty()) { continue; } if (arr[i + 1].isEmpty()) { list.add(arr[i]); } else { list.add(arr[i] + \u0026#34;.\u0026#34; + arr[i + 1]); } } } 22. 掌握的单词个数\r#\r描述\n有一个字符串数组 words 和一个字符串 chars。 假如可以用 chars 中的字母拼写出 words 中的某个“单词”（字符串），那么我们就认为你掌握了这个单词。 words 的字符仅由 a-z 英文小写字母组成，例如 \u0026#34;abc\u0026#34;； chars 由 a-z 英文小写字母和 \u0026#34;?\u0026#34; 组成。其中英文 \u0026#34;?\u0026#34; 表示万能字符，能够在拼写时当作任意一个英文字母。例如：\u0026#34;?\u0026#34; 可以当作 \u0026#34;a\u0026#34; 等字母。 注意： 每次拼写时，chars 中的每个字母和万能字符都只能使用一次。 输出词汇表 words 中你掌握的所有单词的个数。没有掌握任何单词，则输出0。 输入描述： 第一行：输入数组 words 的个数，记作N。 第二行 ~ 第N+1行：依次输入数组words的每个字符串元素 第N+2行：输入字符串chars 输出描述： 输出一个整数，表示词汇表 words 中你掌握的单词个数 备注： 1 ≤ words.length ≤ 100 1 ≤ words[i].length, chars.length ≤ 100 所有字符串中都仅包含小写英文字母、英文问号 输入：4 cat bt hat tree atach?? 输出：3 说明：可以拼写字符串\u0026#34;cat\u0026#34;、\u0026#34;bt\u0026#34;和\u0026#34;hat\u0026#34; 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); String[] words = new String[n]; for (int i = 0; i \u0026lt; n; i++) { words[i] = sc.nextLine(); } String chars = sc.nextLine(); System.out.println(getResult(words, n, chars)); } public static int getResult(String[] words, int n, String chars) { int sum = 0; int[] chsArr = getChs(chars); for (int i = 0; i \u0026lt; n; i++) { int diff = 0; int[] wordArr = getChs(words[i]); for (int j = 0; j \u0026lt; 128; j++) { diff += Math.max(wordArr[j] - chsArr[j], 0); } if (diff \u0026lt;= chsArr[\u0026#39;?\u0026#39;]) { sum++; } } return sum; } public static int[] getChs(String s) { int[] ints = new int[128]; char[] chs = s.toCharArray(); for (char ch : chs) { ints[ch]++; } return ints; } 23. 找出符合要求的字符串子串\r#\r描述\n给定两个字符串，从字符串2中找出字符串1中的所有字符，去重并按照ASCII值从小到大排序。 输入字符串1：长度不超过1024 输入字符串2：长度不超过1000000 字符范围满足ASCII编码要求，按照ASCII的值由小到大排序 输入：fach bbaaccedfg 输出：acf 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chs1 = sc.nextLine().toCharArray(); char[] chs2 = sc.nextLine().toCharArray(); System.out.println(getResult(chs1, chs2)); } public static String getResult(char[] chs1, char[] chs2) { HashSet\u0026lt;Character\u0026gt; set1 = new HashSet\u0026lt;\u0026gt;(); for (char ch : chs1) { set1.add(ch); } HashSet\u0026lt;Character\u0026gt; set2 = new HashSet\u0026lt;\u0026gt;(); for (char ch : chs2) { set2.add(ch); } return set1.stream().filter(set2::contains) .sorted().map(String::valueOf).collect(Collectors.joining()); } 24. 找出经过特定点的路径长度\r#\r描述\n输入描述： 输入一个字符串，都是以大写字母组成，每个相邻的距离是 1， 第二行输入一个字符串，表示必过的点。 说明每个点可过多次。 输出描述： 经过这些必过点的最小距离是多少 输入：ANTSEDXQOKPUVGIFWHJLYMCRZB ABC 输出：28 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String all = sc.nextLine(); String must = sc.nextLine(); System.out.println(getResult(all, must)); } public static int getResult(String all, String must) { HashMap\u0026lt;Character, ArrayList\u0026lt;Integer\u0026gt;\u0026gt; mustCharIdx = new HashMap\u0026lt;\u0026gt;(); HashSet\u0026lt;Character\u0026gt; mustChar = new HashSet\u0026lt;\u0026gt;(); for (char c : must.toCharArray()) { mustChar.add(c); } for (int i = 0; i \u0026lt; all.length(); i++) { char c = all.charAt(i); if (mustChar.contains(c)) { mustCharIdx.putIfAbsent(c, new ArrayList\u0026lt;\u0026gt;()); mustCharIdx.get(c).add(i); } } int[] ans = {Integer.MAX_VALUE}; dfs(0, must, mustCharIdx, new LinkedList\u0026lt;\u0026gt;(), ans); return ans[0]; } public static void dfs( int index, String must, HashMap\u0026lt;Character, ArrayList\u0026lt;Integer\u0026gt;\u0026gt; mustCharIdx, LinkedList\u0026lt;Integer\u0026gt; path, int[] ans) { if (path.size() == must.length()) { int dis = path.get(0); // 运动起点必须从第一行输入all的第一个字母开始 for (int i = 1; i \u0026lt; path.size(); i++) { dis += Math.abs(path.get(i) - path.get(i - 1)); } ans[0] = Math.min(ans[0], dis); return; } for (Integer idx : mustCharIdx.get(must.charAt(index))) { path.add(idx); dfs(index + 1, must, mustCharIdx, path, ans); path.removeLast(); } } 25. 找朋友\r#\r描述\n在学校中，N个小朋友站成一队， 第i个小朋友的身高为height[i]， 第i个小朋友可以看到的第一个比自己身高更高的小朋友j，那么j是i的好朋友(要求j \u0026gt; i)。 请重新生成一个列表，对应位置的输出是每个小朋友的好朋友位置，如果没有看到好朋友，请在该位置用0代替。 小朋友人数范围是 [0, 40000]。 输入描述： 第一行输入N，N表示有N个小朋友 第二行输入N个小朋友的身高height[i]，都是整数 输出描述： 输出N个小朋友的好朋友的位置 输入：8 123 124 125 121 119 122 126 123 输出：1 2 6 5 5 6 0 0 说明：123的好朋友是1位置上的124 124的好朋友是2位置上的125 125的好朋友是6位置上的126 以此类推 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] arr = new int[n]; for (int i = 0; i \u0026lt; n; i++) { arr[i] = sc.nextInt(); } sc.close(); System.out.println(getResult(arr)); } public static String getResult(int[] arr) { int[] ints = new int[arr.length]; for (int i = 0; i \u0026lt; arr.length; i++) { for (int j = i + 1; j \u0026lt; arr.length; j++) { if (arr[j] \u0026gt; arr[i]) { ints[i] = j; break; } } } StringJoiner joiner = new StringJoiner(\u0026#34; \u0026#34;); for (int i : ints) { joiner.add(i + \u0026#34;\u0026#34;); } return joiner.toString(); } "},{"id":36,"href":"/lang2/program-design/structure-algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%935/","title":"机试题库 - 5","section":"华为OD","content":"\r01. 找座位\r#\r描述\n在一个大型体育场内举办了一场大型活动，由于疫情防控的需要，要求每位观众的必须间隔至少一个空位才允许落座。 现在给出一排观众座位分布图，座位中存在已落座的观众，请计算出，在不移动现有观众座位的情况下，最多还能坐下多少名观众。 输入描述： 一个数组，用来标识某一排座位中，每个座位是否已经坐人。0表示该座位没有坐人，1表示该座位已经坐人。 1 ≤ 数组长度 ≤ 10000 输出描述： 整数，在不移动现有观众座位的情况下，最多还能坐下多少名观众。 输入：10001 输出：1 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(getResult(sc.nextLine().toCharArray())); } public static int getResult(char[] desk) { int ans = 0; for (int i = 0; i \u0026lt; desk.length; i++) { if (desk[i] == \u0026#39;0\u0026#39;) { boolean isLeftEmpty = i == 0 || desk[i - 1] == \u0026#39;0\u0026#39;; boolean isRightEmpty = i == desk.length - 1 || desk[i + 1] == \u0026#39;0\u0026#39;; if (isLeftEmpty \u0026amp;\u0026amp; isRightEmpty) { ans++; desk[i] = \u0026#39;1\u0026#39;; i++; } } } return ans; } 02. 整数对最小和\r#\r描述\n给定两个整数数组array1、array2，数组元素按升序排列。 假设从array1、array2中分别取出一个元素可构成一对元素，现在需要取出k对元素， 并对取出的所有元素求和，计算和的最小值。 注意： 两对元素如果对应于array1、array2中的两个下标均相同，则视为同一对元素。 输入描述： 输入两行数组array1、array2，每行首个数字为数组大小size(0 ＜ size ≤ 100); 0 ＜ array1[i],array2[i] ≤ 1000 接下来一行为正整数k 0 ＜ k ≤ array1.size() * array2.size() 输出描述： 满足要求的最小和 输入：3 1 1 2 3 1 2 3 2 输出：4 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n1 = sc.nextInt(); int[] arr1 = new int[n1]; for (int i = 0; i \u0026lt; n1; i++) { arr1[i] = sc.nextInt(); } int n2 = sc.nextInt(); int[] arr2 = new int[n2]; for (int i = 0; i \u0026lt; n2; i++) { arr2[i] = sc.nextInt(); } int k = sc.nextInt(); System.out.println(getResult(arr1, arr2, k)); } public static int getResult(int[] arr1, int[] arr2, int k) { ArrayList\u0026lt;Integer\u0026gt; pairs = new ArrayList\u0026lt;\u0026gt;(); for (int v1 : arr1) { for (int v2 : arr2) { pairs.add(v1 + v2); } } pairs.sort((a, b) -\u0026gt; a - b); int sum = 0; for (int i = 0; i \u0026lt; k; i++) { sum += pairs.get(i); } return sum; } 03. 整型数组按个位值排序\r#\r描述\n给定一个非空数组（列表），其元素数据类型为整型， 请按照数组元素十进制最低位从小到大进行排序，十进制最低位相同的元素，相对位置保持不变。 当数组元素为负值时，十进制最低位等同于去除符号位后对应十进制值最低位。 输入描述：给定一个非空数组，其元素数据类型为32位有符号整数，数组长度[1, 1000] 输出描述：输出排序后的数组 输入：1,2,5,-21,22,11,55,-101,42,8,7,32 输出：1,-21,11,-101,2,22,42,32,5,55,7,8 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] arr = sc.nextLine().split(\u0026#34;,\u0026#34;); System.out.println(getResult(arr)); } public static String getResult(String[] arr) { Arrays.sort(arr, (a, b) -\u0026gt; a.charAt(a.length() - 1) - b.charAt(b.length() - 1)); StringJoiner sj = new StringJoiner(\u0026#34;,\u0026#34;); for (String s : arr) sj.add(s); return sj.toString(); } 04. 执行任务赚积分\r#\r描述\n现有N个任务需要处理，同一时间只能处理一个任务，处理每个任务所需要的时间固定为1。 每个任务都有最晚处理时间限制和积分值，在最晚处理时间点之前处理完成任务才可获得对应的积分奖励。 可用于处理任务的时间有限，请问在有限的时间内，可获得的最多积分。 输入描述： 第一行为一个数 N，表示有 N 个任务，1 ≤ N ≤ 100 第二行为一个数 T，表示可用于处理任务的时间，1 ≤ T ≤ 100 接下来 N 行，每行两个空格分隔的整数（SLA 和 V），SLA 表示任务的最晚处理时间，V 表示任务对应的积分。 1 ≤ SLA ≤ 100，0 ≤ V ≤ 100000 输出描述： 可获得的最多积分 输入：4 3 1 2 1 3 1 4 1 5 输出：5 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int t = sc.nextInt(); int[][] wos = new int[n][2]; for (int i = 0; i \u0026lt; n; i++) { wos[i][0] = sc.nextInt(); wos[i][1] = sc.nextInt(); } System.out.println(getResult(wos, t)); } public static int getResult(int[][] wos, int t) { // 按照任务截止时间升序 Arrays.sort(wos, (a, b) -\u0026gt; a[0] - b[0]); // pq用于按照积分对任务进行优先级排序，积分越小，优先级越高，目的是为了每次替换掉最少积分的工单 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a - b); // 当前时间 int curTime = 0; // 已获得的积分 int ans = 0; // 遍历任务 for (int[] wo : wos) { int endTime = wo[0]; // 任务截止时间 int score = wo[1]; // 任务积分 if (curTime \u0026lt; endTime) { // 如果 curTime \u0026lt; 当前任务的截止时间，则curTime时刻可以指向当前任务 pq.offer(score); ans += score; curTime++; } else { // 如果 curTime \u0026gt;= 当前任务的截止时间，则当前任务只能在curTime时刻之前找一个时间点执行 // pq中记录的就是curTime之前时刻执行的任务 if (pq.isEmpty()) { continue; } // 此时取出pq记录的可执行的任务中最小积分的那个 int min_score = pq.peek(); // 如果当前任务的积分 \u0026gt; 前面时间内可执行的任务中最小积分 if (score \u0026gt; min_score) { // 则我们应该将执行pq中最小积分任务的时间，用于执行当前任务，因为这样可以获得更大积分 pq.poll(); pq.offer(score); ans += score - min_score; } } } // 由于时间限制为t单位，而每个任务花费1单位时间，因此最多完成t个任务，对于多出任务应该去除，且优先去除积分少的 while (pq.size() \u0026gt; t \u0026amp;\u0026amp; t \u0026gt; 0) { ans -= pq.poll(); } return ans; } 05. 执行时长\r#\r描述\n为了充分发挥GPU算力，需要尽可能多的将任务交给GPU执行， 现在有一个任务数组，数组元素表示在这1秒内新增的任务个数且每秒都有新增任务。 假设GPU最多一次执行n个任务，一次执行耗时1秒，在保证GPU不空闲情况下，最少需要多长时间执行完成。 输入描述： 第一个参数为GPU一次最多执行的任务个数，取值范围[1, 10000] 第二个参数为任务数组长度，取值范围[1, 10000] 第三个参数为任务数组，数字范围[1, 10000] 输出描述： 执行完所有任务最少需要多少秒。 输入：4 5 5 4 1 1 1 输出：5 说明：一次最多执行4个任务，最少耗时5s 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int maxCount = sc.nextInt(); int n = sc.nextInt(); int[] tasks = new int[n]; for (int i = 0; i \u0026lt; n; i++) { tasks[i] = sc.nextInt(); } System.out.println(getResult(maxCount, tasks)); } public static int getResult(int maxCount, int[] tasks) { int time = 0; int remain = 0; for (int task : tasks) { if (task + remain \u0026gt; maxCount) { remain = task + remain - maxCount; } else { remain = 0; } time++; } while (remain \u0026gt; 0) { remain -= maxCount; time++; } return time; } 06. 智能成绩表\r#\r描述\n小明来到某学校当老师，需要将学生按考试总分或单科分数进行排名，你能帮帮他吗？ 输入描述： 第 1 行输入两个整数，学生人数 n 和科目数量 m。0 ＜ n ＜ 100，0 ＜ m ＜ 10 第 2 行输入 m 个科目名称，彼此之间用空格隔开。 科目名称只由英文字母构成，单个长度不超过10个字符。 科目的出现顺序和后续输入的学生成绩一一对应。 不会出现重复的科目名称。 第 3 行开始的 n 行，每行包含一个学生的姓名和该生 m 个科目的成绩（空格隔开） 学生不会重名。 学生姓名只由英文字母构成，长度不超过10个字符。 成绩是0~100的整数，依次对应第2行种输入的科目。 第n+2行，输入用作排名的科目名称。若科目不存在，则按总分进行排序。 输出描述： 输出一行，按成绩排序后的学生名字，空格隔开。成绩相同的按照学生姓名字典顺序排序。 输入：3 2 yuwen shuxue fangfang 95 90 xiaohua 88 95 minmin 100 82 shuxue 输出：xiaohua fangfang minmin 题解\nstatic class Student { public String name; public int[] score; int total; public Student(String name) { this.name = name; } public void setScore(int[] score) { this.score = score; this.total = Arrays.stream(score).reduce(Integer::sum).orElse(0); } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); // 学生人数 int n = sc.nextInt(); // 科目数量 int m = sc.nextInt(); Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; m; i++) { map.put(sc.next(), i); } Student[] students = new Student[n]; for (int i = 0; i \u0026lt; n; i++) { Student stu = new Student(sc.next()); int[] score = new int[m]; for (int j = 0; j \u0026lt; m; j++) { score[j] = sc.nextInt(); } stu.setScore(score); students[i] = stu; } String rankKeMu = sc.next(); if (map.containsKey(rankKeMu)) { int index = map.get(rankKeMu); Arrays.sort(students, (a, b) -\u0026gt; a.score[index] != b.score[index] ? b.score[index] - a.score[index] : a.name.compareTo(b.name)); } else { Arrays.sort(students, (a, b) -\u0026gt; b.total != a.total ? b.total - a.total : a.name.compareTo(b.name)); } StringJoiner sj = new StringJoiner(\u0026#34; \u0026#34;); for (Student student : students) { sj.add(student.name); } System.out.println(sj); } 07. 转盘寿司\r#\r描述\n寿司店周年庆，正在举办优惠活动回馈新老客户。寿司转盘上总共有 n 盘寿司，prices[i] 是第 i 盘寿司的价格， 如果客户选择了第 i 盘寿司，寿司店免费赠送客户距离第 i 盘寿司最近的下一盘寿司 j， 前提是 prices[j] ＜ prices[i]，如果没有满足条件的 j，则不赠送寿司。 每个价格的寿司都可无限供应。 输入描述： 输入的每一个数字代表每盘寿司的价格，每盘寿司的价格之间使用空格分隔， 寿司的盘数 n 范围为：1 ≤ n ≤ 500 每盘寿司的价格 price 范围为：1 ≤ price ≤ 1000 输出描述： 输出享受优惠后的一组数据，每个值表示客户选择第 i 盘寿司时实际得到的寿司的总价格。使用空格进行分隔 输入：3 15 6 14 输出：3 21 9 17 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] ints = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int len = ints.length; int[] arr = new int[len]; for (int i = 0; i \u0026lt; len; i++) { for (int j = i + 1; j \u0026lt; len + i; j++) { int idx = getIndex(j, len); if (ints[idx] \u0026lt; ints[i]) { arr[i] = ints[i] + ints[idx]; break; } } if (arr[i] == 0) { arr[i] = ints[i]; } } StringJoiner joiner = new StringJoiner(\u0026#34; \u0026#34;); for (int i : arr) { joiner.add(i + \u0026#34;\u0026#34;); } System.out.println(joiner); } public static int getIndex(int i, int len) { if (i \u0026lt; len) { return i; } else { return i % len; } } 08. 字符串变换最小字符串\r#\r描述\n给定一个字符串s，最多只能进行一次变换，返回变换后能得到的最小字符串（按照字典序进行比较）。 变换规则：交换字符串中任意两个不同位置的字符。 输入描述：一串小写字母组成的字符串s 输出描述：按照要求进行变换得到的最小字符串。 备注：s是都是小写字符组成，1 ≤ s.length ≤ 1000 输入：bcdefa 输出：acdefb 说明：a和b进行位置交换，可以得到最小字符串 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(getResult(sc.nextLine())); } public static String getResult(String s) { char[] misChs = s.toCharArray(); Arrays.sort(misChs); String minS = new String(misChs); if (minS.equals(s)) { return s; } char[] chs = s.toCharArray(); for (int i = 0; i \u0026lt; s.length(); i++) { if (chs[i] != misChs[i]) { char tmp = chs[i]; chs[i] = misChs[i]; int swapIndex = s.lastIndexOf(misChs[i]); chs[swapIndex] = tmp; break; } } return new String(chs); } 09. 字符串分割\r#\r描述\n给定一个非空字符串S，其被N个‘-’分隔成N+1的子串，给定正整数K，要求除第一个子串外， 其余的子串每K个字符组成新的子串，并用‘-’分隔。 对于新组成的每一个子串， 如果它含有的小写字母比大写字母多，则将这个子串的所有大写字母转换为小写字母； 如果它含有的大写字母比小写字母多，则将这个子串的所有小写字母转换为大写字母； 大小写字母的数量相等时，不做转换。 输入描述：输入为两行，第一行为参数K，第二行为字符串S。 输出描述：输出转换后的字符串 输入：3 12abc-abcABC-4aB@ 输出：12abc-abc-ABC-4aB-@ 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int k = Integer.parseInt(sc.nextLine()); String input = sc.nextLine(); String[] strings = input.split(\u0026#34;-\u0026#34;); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(strings[0]); StringBuilder str = new StringBuilder(); for (int i = 1; i \u0026lt; strings.length; i++) { str.append(strings[i]); } for (int i = 0; i \u0026lt; str.length(); i += k) { if (i + k \u0026lt;= str.length()) { list.add(caseConversion(str.substring(i, i + k))); } else { list.add(caseConversion(str.substring(i))); } } System.out.println(String.join(\u0026#34;-\u0026#34;, list)); } private static String caseConversion(String s) { int upperCaseLength = s.length() - s.replaceAll(\u0026#34;[A-Z]\u0026#34;, \u0026#34;\u0026#34;).length(); int lowerCaseLength = s.length() - s.replaceAll(\u0026#34;[a-z]\u0026#34;, \u0026#34;\u0026#34;).length(); if (upperCaseLength \u0026gt; lowerCaseLength) { return s.toUpperCase(Locale.ROOT); } if (lowerCaseLength \u0026gt; upperCaseLength) { return s.toLowerCase(Locale.ROOT); } return s; } 10. 字符串排序\r#\r描述\n排序规则： 1. 单词中字母比较不区分大小写，两个单词先以第一个字母作为排序的基准，如果第一个字母相同，就用第二个字母为基准， 如果第二个字母相同就以第三个字母为基准。依此类推，如果到某个字母不相同，字母顺序在前的那个单词顺序在前。 2. 当一个短单词和一个长单词的开头部分都相同（即短单词是长单词从首字母开始的一部分），短单词顺序在前。 3. 字母大小写不同的相同单词，只输出一次。 输入：i LOVE Cc I love CC Hello Hel Hellow 输出：Cc Hel Hello Hellow i LOVE 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] arr = sc.nextLine().split(\u0026#34; \u0026#34;); System.out.println(getResult(arr)); } public static String getResult(String[] arr) { Arrays.sort(arr, (a, b) -\u0026gt; a.toLowerCase().compareTo(b.toLowerCase())); LinkedList\u0026lt;String\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); stack.add(arr[0]); for (int i = 1; i \u0026lt; arr.length; i++) { String top = stack.getLast(); if (top.equalsIgnoreCase(arr[i])) { continue; } stack.add(arr[i]); } return String.join(\u0026#34; \u0026#34;, stack); } 11. 字符串筛选排序\r#\r描述\n输入一个由N个大小写字母组成的字符串，按照ASCII码值从小到大进行排序 查找字符串中第K个最小ASCII码值的字母(k\u0026gt;=1)，输出该字母所在字符串中的位置索引(字符串的第一个位置索引为0) k如果大于字符串长度则输出最大ASCII码值的字母所在字符串的位置索引 如果有重复字母则输出字母的最小位置索引 输入描述： 第一行输入一个由大小写字母组成的字符串 第二行输入k ，k必须大于0 ，k可以大于输入字符串的长度 输出描述： 输出字符串中第k个最小ASCII码值的字母所在字符串的位置索引 k如果大于字符串长度则输出最大ASCII码值的字母所在字符串的位置索引 如果第k个最小ASCII码值的字母存在重复 则输出该字母的最小位置索引 输入：AbCdeFG 3 输出：5 输入：fAdDAkBbBq 4 输出：6 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.next(); int k = sc.nextInt(); sc.close(); System.out.println(getResult(str, k)); } public static int getResult(String str, int k) { char[] chars = str.toCharArray(); Arrays.sort(chars); if (k \u0026gt; str.length()) { k = str.length(); } char tar = chars[k - 1]; return str.indexOf(tar); } 12. 字符串序列判定\r#\r描述\n输入两个字符串 S 和 L ，都只包含英文小写字母。S长度 ≤ 100，L长度 ≤ 500,000。判定S是否是L的有效子串。 判定规则：S 中的每个字符在 L 中都能找到（可以不连续），且 S 在Ｌ中字符的前后顺序与 S 中顺序要保持一致。（例如，S = ”ace” 是 L= ”abcde” 的一个子序列且有效字符是a、c、e，而”aec”不是有效子序列，且有效字符只有a、e） 输入描述： 输入两个字符串 S 和 L，都只包含英文小写字母。S长度 ≤ 100，L长度 ≤ 500,000。 先输入S，再输入L，每个字符串占一行。 输出描述： S 串最后一个有效字符在 L 中的位置。（首位从0开始计算，无有效字符返回-1） 输入：ace abcde 输出：4 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.nextLine(); String l = sc.nextLine(); System.out.println(getResult(s, l)); } public static int getResult(String s, String l) { int i = 0; int j = 0; while (i \u0026lt; s.length() \u0026amp;\u0026amp; j \u0026lt; l.length()) { if (s.charAt(i) == l.charAt(j)) { i++; } j++; } return i == s.length() ? j - 1 : -1; } 13. 字符统计及重排\r#\r描述\n给出一个仅包含字母的字符串，不包含空格，统计字符串中各个字母（区分大小写）出现的次数， 并按照字母出现次数从大到小的顺序。输出各个字母及其出现次数。 如果次数相同，按照自然顺序进行排序，且小写字母在大写字母之前。 输入描述：输入一行，为一个仅包含字母的字符串。 输出描述： 按照字母出现次数从大到小的顺序输出各个字母和字母次数，用英文分号分隔，注意末尾的分号； 字母和次数间用英文冒号分隔。 输入：abababb 输出：b:4;a:3; 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); char[] chs = sc.nextLine().toCharArray(); int[][] arr = new int[128][3]; for (char ch : chs) { arr[ch][0] = ch; arr[ch][1]++; int idx = ch; if (idx \u0026gt;= \u0026#39;a\u0026#39;) { idx = idx - \u0026#39;a\u0026#39;; } arr[ch][2] = idx; } Arrays.sort(arr, (a, b) -\u0026gt; a[1] != b[1] ? b[1] - a[1] : a[2] - b[2]); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int[] ints : arr) { if (ints[1] == 0) { continue; } list.add((char) ints[0] + \u0026#34;:\u0026#34; + ints[1] + \u0026#34;;\u0026#34;); } System.out.println(String.join(\u0026#34;\u0026#34;, list)); } 14. 最大N个数与最小N个数的和\r#\r描述\n给定一个数组，编写一个函数来计算它的最大N个数与最小N个数的和。你需要对数组进行去重。 说明： 数组中数字范围[0, 1000] 最大N个数与最小N个数不能有重叠，如有重叠，输入非法返回-1 输入非法返回-1 输入描述： 第一行输入M， M标识数组大小 第二行输入M个数，标识数组内容 第三行输入N，N表达需要计算的最大、最小N个数 输出描述： 输出最大N个数与最小N个数的和 输入：5 95 88 83 64 100 2 输出：342 说明：最大2个数[100,95],最小2个数[83,64], 输出为342。 输入：5 3 2 3 4 2 2 输出：-1 说明：最大2个数[4,3],最小2个数[3,2], 有重叠输出为-1。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); int[] arr = new int[m]; for (int i = 0; i \u0026lt; m; i++) { arr[i] = sc.nextInt(); } int n = sc.nextInt(); sc.close(); System.out.println(getResult(m, arr, n)); } public static int getResult(int m, int[] arr, int n) { HashSet\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int val : arr) { if (val \u0026lt; 0 || val \u0026gt; 1000) { return -1; } set.add(val); } if (set.size() \u0026lt; n * 2) { return -1; } Integer[] ints = set.toArray(new Integer[0]); Arrays.sort(ints, (a, b) -\u0026gt; a - b); int l = 0; int r = ints.length - 1; int ans = 0; while (n \u0026gt; 0) { ans += ints[l] + ints[r]; l++; r--; n--; } return ans; } 15. 最大股票收益\r#\r描述\n假设知道某段连续时间内股票价格，计算通过买入卖出可获得的最大收益。 输入一个大小为 n 的数 price(p1,p2,p3,p4…….pn),pi 是第i天的股票价格。 pi 的格式为股票价格(非负整型)加上货币单位 Y 或者 S,其中 Y 代表人民币,S 代表美元,这里规定 1 美元可以兑换 7 人民币。 假设你可以在任何一天买入或者卖出股票,也可以选择放弃交易,请计其在交易周期 n 天内你能获得的最大收(以人民币计算)。 输入描述：输入一个包含交易周期内各天股票价格的字符串，以空格分隔。不考虑输入异常情况。 输出描述：输出一个整型数代表在交易周期 n 天内你能获得的最大收益，n 不能超过 10000 备注：股票价格只会用 Y 人民币或 S 美元进行输入，不考虑其他情况。 输入：2Y 3S 4S 6Y 8S 输出：76 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); Integer[] arr = Arrays.stream(split).map(Main::getRmb).toArray(Integer[]::new); System.out.println(getResult(arr)); } public static int getRmb(String str) { int num = Integer.parseInt(str.substring(0, str.length() - 1)); String unit = str.substring(str.length() - 1); return \u0026#34;Y\u0026#34;.equals(unit) ? num : num * 7; } public static int getResult(Integer[] arr) { int ans = 0; for (int i = 1; i \u0026lt; arr.length; i++) { ans += Math.max(0, arr[i] - arr[i - 1]); } return ans; } 16. 最大矩阵和\r#\r描述\n给定一个二维整数矩阵，要在这个矩阵中选出一个子矩阵，使得这个子矩阵内所有的数字和尽量大， 我们把这个子矩阵称为和最大子矩阵，子矩阵的选取原则是原矩阵中一块相互连续的矩形区域。 输入描述： 输入的第一行包含2个整数n, m(1 ≤ n, m ≤ 10)，表示一个n行m列的矩阵，下面有n行，每行有m个整数， 同一行中，每2个数字之间有1个空格，最后一个数字后面没有空格，所有的数字的在[-1000, 1000]之间。 输出描述： 输出一行一个数字，表示选出的和最大子矩阵内所有的数字和。 输入：3 4 -3 5 -1 5 2 4 -2 4 -1 3 -1 3 输出：20 说明：一个3*4的矩阵中，后面3列的子矩阵求和加起来等于20，和最大。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int[][] matrix = new int[n][m]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { matrix[i][j] = sc.nextInt(); } } System.out.println(getResult(n, m, matrix)); } public static int getResult(int n, int m, int[][] matrix) { ArrayList\u0026lt;Integer\u0026gt; dp = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { dp.add(maxSubArraySum(matrix[i])); // 一行子矩阵最大和 for (int j = i + 1; j \u0026lt; n; j++) { // 多行子矩阵最大和 int[] nums = matrixZip(Arrays.copyOfRange(matrix, i, j + 1)); dp.add(maxSubArraySum(nums)); } } return dp.stream().max((a, b) -\u0026gt; a - b).orElse(0); } // 最大子数组和求解 public static int maxSubArraySum(int[] nums) { int[] dp = new int[nums.length]; int res = dp[0] = nums[0]; for (int i = 1; i \u0026lt; nums.length; i++) { dp[i] = Math.max(dp[i - 1], 0) + nums[i]; res = Math.max(res, dp[i]); } return res; } // 多行子矩阵，压缩为一行子数组 public static int[] matrixZip(int[][] matrix) { int cols = matrix[0].length; int rows = matrix.length; int[] zip = new int[cols]; for (int c = 0; c \u0026lt; cols; c++) { for (int r = 0; r \u0026lt; rows; r++) { zip[c] += matrix[r][c]; } } return zip; } 17. 最大括号深度\r#\r描述\n现有一字符串仅由 ‘(‘，’)’，\u0026#39;{‘，’}’，\u0026#39;[‘，’]’六种括号组成。0≤字符串长度≤100000 若字符串满足以下条件之一，则为无效字符串： 1. 任一类型的左右括号数量不相等； 2. 存在未按正确顺序（先左后右）闭合的括号。 3. 输出括号的最大嵌套深度，若字符串无效则输出0。 输入描述：一个只包括 ‘(‘，’)’，\u0026#39;{‘，’}’，\u0026#39;[‘，’]’的字符串 输出描述：一个整数，最大的括号深度 输入：([]{()}) 输出：3 输入：([)] 输出：0 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.nextLine(); System.out.println(getResult(s)); } public static int getResult(String s) { HashMap\u0026lt;Character, Character\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#39;)\u0026#39;, \u0026#39;(\u0026#39;); map.put(\u0026#39;]\u0026#39;, \u0026#39;[\u0026#39;); map.put(\u0026#39;}\u0026#39;, \u0026#39;{\u0026#39;); LinkedList\u0026lt;Character\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); int maxDepth = 0; for (int i = 0; i \u0026lt; s.length(); i++) { char c = s.charAt(i); if (!stack.isEmpty() \u0026amp;\u0026amp; map.get(c) == stack.getLast()) { stack.removeLast(); } else { stack.add(c); maxDepth = Math.max(maxDepth, stack.size()); } } if (!stack.isEmpty()) { return 0; } return maxDepth; } 18. 最大时间\r#\r描述\n给定一个数组，里面有 6 个整数，求这个数组能够表示的最大 24 进制的时间是多少，输出这个时间，无法表示输出 invalid。 输入描述： 输入为一个整数数组，数组内有六个整数。 输入整数数组长度为 6，不需要考虑其它长度，元素值为 0 或者正整数，6 个数字每个数字只能使用一次。 输出描述： 输出为一个 24 进制格式的时间，或者字符串”invalid“。 输入：[0,2,3,0,5,6] 输出：23:56:00 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.nextLine(); String[] split = s.substring(1, s.length() - 1).split(\u0026#34;,\u0026#34;); Integer[] arr = Arrays.stream(split).map(Integer::parseInt).toArray(Integer[]::new); System.out.println(getResult(arr)); } public static String getResult(Integer[] arr) { ArrayList\u0026lt;Integer\u0026gt; numList = new ArrayList\u0026lt;\u0026gt;(List.of(arr)); // 小时1 int hour1 = getMaxNum(numList, 2); if (hour1 == -1) { return \u0026#34;invalid\u0026#34;; } removeFirst(numList, hour1); // 小时2 int hour2; if (hour1 == 2) { hour2 = getMaxNum(numList, 3); } else { hour2 = getMaxNum(numList, 9); } if (hour2 == -1) { return \u0026#34;invalid\u0026#34;; } removeFirst(numList, hour2); // 分钟 int min1 = getMaxNum(numList, 5); if (min1 == -1) { return \u0026#34;invalid\u0026#34;; } removeFirst(numList, min1); int min2 = getMaxNum(numList, 9); if (min2 == -1) { return \u0026#34;invalid\u0026#34;; } removeFirst(numList, min2); // 秒 Integer s1 = getMaxNum(numList, 5); if (s1 == -1) { return \u0026#34;invalid\u0026#34;; } numList.remove(s1); int s2 = getMaxNum(numList, 9); if (s2 == -1) { return \u0026#34;invalid\u0026#34;; } removeFirst(numList, s2); return \u0026#34;\u0026#34; + hour1 + hour2 + \u0026#34;:\u0026#34; + min1 + min2 + \u0026#34;:\u0026#34; + s1 + s2; } public static int getMaxNum(ArrayList\u0026lt;Integer\u0026gt; numList, int limit) { return numList.stream().filter(i -\u0026gt; i \u0026lt;= limit).reduce(Integer::max).orElse(-1); } public static void removeFirst(ArrayList\u0026lt;Integer\u0026gt; numList, int num) { for (int i = 0; i \u0026lt; numList.size(); i++) { if (numList.get(i) == num) { numList.remove(i); return; } } } 19. 最多购买宝石数目\r#\r描述\n橱窗里有一排宝石，不同的宝石对应不同的价格，宝石的价格标记为 gems[i]，0 ≤ i ＜ n，n = gems.length 宝石可同时出售0个或多个，如果同时出售多个，则要求出售的宝石编号连续； 例如客户最大购买宝石个数为m，购买的宝石编号必须为：gems[i]，gems[i+1]，...，gems[i+m-1] 假设你当前拥有总面值为 value 的钱，请问最多能购买到多少个宝石，如无法购买宝石，则返回0。 输入描述： 第一行输入n，参数类型为int，取值范围：[0,10^6]，表示橱窗中宝石的总数量。 之后 n 行分别表示从第0个到第n-1个宝石的价格，即 gems[0] 到 gems[n-1] 的价格，类型为int，取值范围：(0,1000]。 之后一行输入v，类型为int，取值范围：[0,10^9]，表示你拥有的钱。 输出描述： 输出int类型的返回值，表示最大可购买的宝石数量。 输入：7 8 4 6 3 1 6 7 10 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] arr = new int[n]; for (int i = 0; i \u0026lt; n; i++) { arr[i] = sc.nextInt(); } int v = sc.nextInt(); System.out.println(getResult(arr, v)); } public static int getResult(int[] arr, int v) { int maxLen = 0; for (int i = 0; i \u0026lt; arr.length; i++) { int sum = 0; for (int j = i; j \u0026lt; arr.length; j++) { sum = sum + arr[j]; if (sum \u0026lt;= v) { maxLen = Math.max(maxLen, j - i + 1); continue; } break; } } return maxLen; } 20. 最富裕的小家庭\r#\r描述\n在一颗树中，每个节点代表一个家庭成员，节点的数字表示其个人的财富值，一个节点及其直接相连的子节点被定义为一个小家庭。 现给你一颗树，请计算出最富裕的小家庭的财富和。 输入描述： 第一行为一个数 N，表示成员总数，成员编号 1~N。1 ≤ N ≤ 1000 第二行为 N 个空格分隔的数，表示编号 1~N 的成员的财富值。0 ≤ 财富值 ≤ 1000000 接下来 N -1 行，每行两个空格分隔的整数（N1, N2），表示 N1 是 N2 的父节点。 输出描述： 最富裕的小家庭的财富和 输入：4 100 200 300 500 1 2 1 3 2 4 输出：700 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); long[] wealth = new long[n + 1]; long[] family = new long[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { wealth[i] = sc.nextInt(); family[i] = wealth[i]; } for (int i = 0; i \u0026lt; n - 1; i++) { int fa = sc.nextInt(); int ch = sc.nextInt(); family[fa] += wealth[ch]; } System.out.println(Arrays.stream(family).max().orElse(0)); } 21. 最长的指定瑕疵度的元音子串\r#\r描述\n如果一个字符串的开头和结尾都是元音字母（a、e、i、o、u、A、E、I、O、U），那么它就被称为元音字符串。 元音字符串中非元音字母的数量定义为该字符串的瑕疵度 现在，给定一个字符串和一个目标瑕疵度，请你找出具有指定瑕疵度的最长元音子串，并输出其长度。如果不存在则输出0 注意：字符串中任意连续的字符组成的子序列称为该字符串的子串。 a 和 aa 都是元音字符串，它们的瑕疵度为 0。 aiur 不是元音字符串，因为它的结尾不是元音字母。 abira 是一个元音字符串，它的瑕疵度为2 输入描述： 第一行包含一个整数flaw，表示目标瑕疵度，满足0≤flaw≤65535。 第二行包含一个字符串str，仅由小写字母和大写字母组成，满足1≤str≤65535。 输出描述： 输出一个整数，表示满足条件的最长元音子串的长度。如果不存在满足条件的元音子串，则输出0 输入：0 asdbuiodevauufgh 输出：3 题解\nprivate static final char[] YAUN = {\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;U\u0026#39;}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.nextLine()); char[] chars = sc.nextLine().toCharArray(); boolean[] arr = new boolean[chars.length]; for (int i = 0; i \u0026lt; chars.length; i++) { arr[i] = isYuan(chars[i]); } int maxLen = 0; for (int i = 0; i \u0026lt; arr.length; i++) { if (!arr[i]) { continue; } int sum = 0; for (int j = i + 1; j \u0026lt; arr.length; j++) { if (arr[j]) { if (sum == num) { maxLen = Math.max(maxLen, j - i + 1); } } else { sum++; } } } System.out.println(maxLen); } private static boolean isYuan(char ch) { for (char c : YAUN) { if (ch == c) { return true; } } return false; } 22. 最长子字符串的长度\r#\r描述\n给你一个字符串 s，首尾相连成一个环形，请你在环中找出 \u0026#39;o\u0026#39; 字符出现了偶数次最长子字符串的长度。 输入描述：输入是一个小写字母组成的字符串 输出描述：输出是一个整数 备注： 1 ≤ s.length ≤ 500000 s 只包含小写英文字母 输入：looxdolx 输出：7 说明：最长子字符串\u0026#34;oxdolxl\u0026#34;，由于是首尾连接一起的，所以最后一个\u0026#39;x\u0026#39;和开头的\u0026#39;l\u0026#39;是连接在一起的，此字符串包含2个\u0026#39;o\u0026#39; 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(getResult(sc.nextLine())); } public static int getResult(String s) { int n = s.length(); // s中\u0026#39;o\u0026#39;的个数 int zeroCount = 0; for (int i = 0; i \u0026lt; n; i++) { if (s.charAt(i) == \u0026#39;o\u0026#39;) { zeroCount++; } } if (zeroCount % 2 == 0) { // 如果 \u0026#39;o\u0026#39; 为偶数个，则s本身就是一个含有偶数个\u0026#39;o\u0026#39;的子字符串，结果输出s.length return n; } else { // 如果 \u0026#39;o\u0026#39; 为奇数个，由于s是环形的，因此只要任选环中任意一个\u0026#39;o\u0026#39;解开（删除）， // 剩下的就是含有偶数个 \u0026#39;o\u0026#39; 的子串，该子串长度为 s.length - 1 return n - 1; } } 23. 堆内存申请\r#\r描述\n题解\n24.\r#\r描述\n题解\n25.\r#\r描述\n题解\n"},{"id":37,"href":"/lang2/program-design/structure-algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%9311/","title":"机试题库 - 11","section":"华为OD","content":"\r01. 5G网络建设\r#\r描述\n现需要在某城市进行5G网络建设，已经选取N个地点设置5G基站，编号固定为1到N，接下来需要各个基站之间使用光纤进行连接以确保基站能互联互通，不同基站之间假设光纤的成本各不相同，且有些节点之间已经存在光纤相连。 请你设计算法，计算出能联通这些基站的最小成本是多少。 注意：基站的联通具有传递性，比如基站A与基站B架设了光纤，基站B与基站C也架设了光纤，则基站A与基站C视为可以互相联通。 输入描述： 第一行输入表示基站的个数N，其中：0 ＜ N ≤ 20 第二行输入表示具备光纤直连条件的基站对的数目M，其中：0 ＜ M ＜ N * (N - 1) / 2 从第三行开始连续输入M行数据，格式为X Y Z P，其中： X，Y 表示基站的编号，0 ＜ X ≤ N，0 ＜ Y ≤ N，X ≠ Y， Z 表示在 X、Y之间架设光纤的成本，0 ＜ Z ＜ 100 P 表示是否已存在光纤连接，0 表示未连接，1表示已连接 输出描述： 如果给定条件，可以建设成功互联互通的5G网络，则输出最小的建设成本 如果给定条件，无法建设成功互联互通的5G网络，则输出 -1 输入：3 3 1 2 3 0 1 3 1 0 2 3 5 0 输出：4 说明：只需要在1，2以及1，3基站之间铺设光纤，其成本为3+1=4 题解\n// 边 static class Edge { int from; // 边起点 int to; // 边终点 int weight; // 边权重 public Edge(int from, int to, int weight) { this.from = from; this.to = to; this.weight = weight; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); // 基站数量（节点数） int m = sc.nextInt(); // 基站对数量（边数） Edge[] edges = new Edge[m]; for (int i = 0; i \u0026lt; m; i++) { int x = sc.nextInt(); int y = sc.nextInt(); int z = sc.nextInt(); int p = sc.nextInt(); // 如果p==1，则可以认为x-y边权为0 edges[i] = new Edge(x, y, p == 0 ? z : 0); } System.out.println(kruskal(edges, n)); } public static int kruskal(Edge[] edges, int n) { int minWeight = 0; // 按照边权升序 Arrays.sort(edges, (a, b) -\u0026gt; a.weight - b.weight); UnionFindSet ufs = new UnionFindSet(n + 1); // 最先遍历出来是边权最小的边 for (Edge edge : edges) { // 如果edge.from节点 和 edge.to节点 是同一个连通分量（即都在最小生成树中），则此时会产生环 // 因此只有当edge.from节点 和 edge.to节点不在同一个连通分量时，才能合并（纳入最小生成树） if (ufs.find(edge.from) != ufs.find(edge.to)) { minWeight += edge.weight; ufs.union(edge.from, edge.to); // 需要注意的是，上面初始化并查集的节点数为n+1个，因此并查集底层fa数组的长度就是n+1， // 即索引范围是[0, n]，左闭右闭，其中0索引是无用的，1~n索引对应最小生成树中各个节点， // 如果者n个节点可以变为最小生成树，那么1~n节点会被合并为一个连通分量，而0索引虽然无用， // 但是也会自己形成一个连通分量，因此最终如果能形成最小生成树，则并查集中会有两个连通分量 if (ufs.count == 2) { return minWeight; } } } return -1; } // 并查集 static class UnionFindSet { int[] fa; int count; public UnionFindSet(int n) { this.fa = new int[n]; this.count = n; for (int i = 0; i \u0026lt; n; i++) this.fa[i] = i; } public int find(int x) { if (x != this.fa[x]) { return (this.fa[x] = this.find(this.fa[x])); } return x; } public void union(int x, int y) { int x_fa = this.find(x); int y_fa = this.find(y); if (x_fa != y_fa) { this.fa[y_fa] = x_fa; this.count--; } } } 02. N进制减法\r#\r描述\n主管期望你实现一个基于字符串的N进制的减法。 需要对输入的两个字符串按照给定的N进制进行减法操作，输出正负符号和表示结果的字符串。 输入描述： 第一个参数是整数形式的进制N值，N值范围为大于等于2、小于等于35。 第二个参数为被减数字符串； 第三个参数为减数字符串。 有效的字符包括0-9以及小写字母a-z，字符串有效字符个数最大为100个字符，另外还有结尾的\\0。 限制： 输入的被减数和减数，除了单独的0以外，不能是以0开头的字符串。 如果输入有异常或计算过程中有异常，此时应当输出-1表示错误。 输出描述：输出有2个。 其一为减法计算的结果，-1表示出错，0表示结果为整数，1表示结果为负数。 其二为表示结果的字符串。 输入：8 07 1 输出：-1 说明：按8进制，检查到减数不符合非0前导的要求，返回结果为-1，没有其他结果内容。 输入：2 11 1 输出：0 10 说明：按二进制计算 11 -1 ，计算正常，0表示符号为正数，结果为10 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int n = Integer.parseInt(split[0]); String num = split[1]; String numSub = split[2]; System.out.println(getResult(n, num, numSub)); } public static String getResult(int n, String num, String numSub) { if (n \u0026lt; 2 || n \u0026gt; 35 || !isValid(num, n) || !isValid(numSub, n)) { return \u0026#34;-1\u0026#34;; } long numVal = Long.parseLong(num, n); long numSubVal = Long.parseLong(numSub, n); String diff = Long.toString(Math.abs(numVal - numSubVal), n); String sign = numVal \u0026gt;= numSubVal ? \u0026#34;0\u0026#34; : \u0026#34;1\u0026#34;; return sign + \u0026#34; \u0026#34; + diff; } public static boolean isValid(String str, int n) { // 含前导的0只有0值本身合法 if (str.startsWith(\u0026#34;0\u0026#34;)) { return \u0026#34;0\u0026#34;.equals(str); } // 被减数，减数只能包含字符0-9，a-z Pattern reg = Pattern.compile(\u0026#34;[^a-z0-9]\u0026#34;); if (reg.matcher(str).find()) { return false; } // 被减数，减数长度最多100 if (str.length() \u0026gt; 100) { return false; } // 被减数，减数的每位不能超过n for (int i = 0; i \u0026lt; str.length(); i++) { char c = str.charAt(i); if (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39; \u0026amp;\u0026amp; Integer.parseInt(c + \u0026#34;\u0026#34;) \u0026gt;= n) { return false; // 比如2进制数的每一位不能超过2 } if (c \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39; \u0026amp;\u0026amp; c - \u0026#39;a\u0026#39; + 10 \u0026gt;= n) { return false; // 比如16进制数每一位不能超过f } } return true; } 03. TLV解析\r#\r描述\n两端通过TLV格式的报文来通信，现在收到对端的一个TLV格式的消息包，要求生成匹配后的(tag, length, valueOffset)列表。 具体要求如下： (1)消息包中多组tag、length、value紧密排列，其中tag,length各占1字节(uint8_t) , value所占字节数等于length的值 (2)结果数组中tag值已知，需要填充每个tag对应数据的length和valueOffset值 (valueOffset为value在原消息包中的起始偏移量（从0开始，以字节为单位))，即将消息包中的tag与结果数组中的tag进行匹配 （可能存在匹配失败的情况，若结果数组中的tag在消息包中找不到，则length和valueOffset都为0) (3)消息包和结果数组中的tag值都按升序排列，且不重复 (4)此消息包未被篡改，但尾部可能不完整，不完整的一组TLV请丢弃掉 输入描述： 第一行：一个字符串，代表收到的消息包。字符串长度在10000以内。 说明1：字符串使用十六进制文本格式（字母为大写）来展示消息包的数据，如0F04ABABABAB代表一组TLV： 前两个字符(0F）代表tag值为15，接下来两个字符（04）代表length值为4字节，接下来8个字符即为4字节的value。 说明2：输入字符串中，每一组TLV紧密排列，中间无空格等分隔符 第二行：需要匹配的tag数量n (0 ＜ n ＜1000) 。 后面n行：需要匹配的n个tag值（十进制表示)，递增排列。 输出描述： 和需要匹配的n个tag对应的n行匹配结果，每一行由长度和偏移量组成 输入：0F04ABABABAB 1 15 输出：4 2 说明：tag15(十六进制0F)对应数据的长度为4，其value从第三个字节开始，因此偏移量为2 输入：0F04ABABABAB1001FF 2 15 17 输出：4 2 0 0 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String msg = sc.next(); int n = sc.nextInt(); int[] tags = new int[n]; for (int i = 0; i \u0026lt; n; i++) { tags[i] = sc.nextInt(); } sc.close(); getResult(msg, tags); } public static void getResult(String msg, int[] tags) { HashMap\u0026lt;Integer, Integer[]\u0026gt; tagMap = new HashMap\u0026lt;\u0026gt;(); // 这里i+3的目的是确保tag，len的截取不会越界 for (int i = 0; i + 3 \u0026lt; msg.length(); i++) { int tag = Integer.parseInt(msg.substring(i, i + 2), 16); int len = Integer.parseInt(msg.substring(i + 2, i + 4), 16); // valueOffset以字节为单位，故要除以2 int valueOffset = (i + 5) / 2; // 本TLV格式报文段结束位置i i += 3 + len * 2; // 如果结束位置i越界，则当前TLV报文段是一个不完整的，需要丢弃 if (i \u0026gt;= msg.length()) break; // 题目已经保证tag不会重复 tagMap.put(tag, new Integer[]{len, valueOffset}); } for (int tag : tags) { if (tagMap.containsKey(tag)) { Integer[] tmp = tagMap.get(tag); int len = tmp[0]; int valueOffset = tmp[1]; System.out.println(len + \u0026#34; \u0026#34; + valueOffset); } else { System.out.println(\u0026#34;0 0\u0026#34;); } } } 04. Wonderland\r#\r描述\nWonderland是小王居住地一家很受欢迎的游乐园。 Wonderland目前有4种售票方式，分别为一日票（1天）、三日票（3天）、周票（7天）和月票（30天）。 每种售票方式的价格由一个数组给出，每种票据在票面时限内可以无限制地进行游玩。 小王计划在接下来一年多次游玩该游乐园。小王计划地游玩日期将由一个数组给出。 现在，请您根据给出地售票价格数组和小王计划游玩日期数组，返回游玩计划所需要地最低消费。 输入描述： 数组1：售票价格数组为costs，costs.length = 4，默认顺序为一日票、三日票、周票和月票。 数组2：小王计划游玩日期数组为days，1 ≤ days.length ≤ 365，1 ≤ days[i] ≤ 365，默认顺序为升序。 输出描述： 完成游玩计划的最低消费。 输入：5 14 30 100 1 3 5 20 21 200 202 230 输出：40 说明：根据售票价格数组和游玩日期数组给出的信息，发现每次去玩的时候买一张一日票是最省钱的， 所以小王会卖8张一日票，每张5元，最低花费是40元。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] costs = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); int[] days = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); List\u0026lt;Integer\u0026gt; dayList = getDays(days); Cost[] costArr = getCosts(costs); System.out.println(getResult(costArr, dayList)); } private static int getResult(Cost[] costs, List\u0026lt;Integer\u0026gt; days) { for (int day : days) { minCost(costs, 0, day); } int sum = 0; for (Cost cost : costs) { sum += cost.totalCost; } return sum; } // 连续天数(len)内，先使用较便宜的票 public static void minCost(Cost[] costs, int index, int len) { if (index \u0026gt;= costs.length || len \u0026lt; 1) { return; } Cost cost = costs[index]; int size = len / cost.day; if (size \u0026gt; 0) { cost.totalCost += cost.cost * size; } if (len % cost.day != 0) { minCost(costs, index + 1, len % cost.day); } } // 处理成连续天的分段 public static List\u0026lt;Integer\u0026gt; getDays(int[] arr) { int[] tempArr = new int[366]; for (int i : arr) { tempArr[i] = 1; } String line = Arrays.stream(tempArr).mapToObj(String::valueOf).collect(Collectors.joining()); String[] dayStrArr = line.split(\u0026#34;0\u0026#34;); List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (String dayStr : dayStrArr) { if (dayStr.isBlank()) { continue; } list.add(dayStr.length()); } return list; } public static Cost[] getCosts(int[] arr) { Cost[] costs = new Cost[4]; costs[0] = new Cost(1, arr[0]); costs[1] = new Cost(3, arr[1]); costs[2] = new Cost(7, arr[2]); costs[3] = new Cost(30, arr[3]); Arrays.sort(costs, Comparator.comparingInt(a -\u0026gt; a.sort)); return costs; } public static class Cost { public int day; // 天数 public int cost; // 花费 public int sort; // 排序 public int totalCost; // 在递归中用于存储总花费 public Cost(int day, int cost) { this.day = day; this.cost = cost; this.sort = cost * 210 / day; } } 05. 比较两个版本号的大小\r#\r描述\n输入两个版本号 version1 和 version2，每个版本号由多个子版本号组成。 子版本号之间由 “.” 隔开，由大小写字母、数字组成，并且至少有一个字符。 按从左到右的顺序比较子版本号，比较规则如下： 1. 子版本号前面的0不参与比较，比如 001 和 1 是相等的。 2. 小写字母 \u0026gt; 大写字母 \u0026gt; 数字 3. 空字符和0相等，比如 1 和 1.0 相等 比较结果： 如果 version1 \u0026gt; version2 ，返回 1 如果 version1 ＜ version2 ，返回 -1 其他情况返回0 输入描述：第一行输入version1，第二行输入version2 输出描述：输出version1和version2的比较结果 输入：5.2 5.1a 输出：1 输入：5.6.1 5.6.2a 输出：-1 输入：5.6.8.a 5.6.8.0a 输出：0 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String v1 = sc.nextLine(); String v2 = sc.nextLine(); System.out.println(getResult(v1, v2)); } public static int getResult(String v1, String v2) { String[] arr1 = convert(v1); String[] arr2 = convert(v2); int n = Math.max(arr1.length, arr2.length); for (int i = 0; i \u0026lt; n; i++) { String tmp1 = arr1.length \u0026gt; i ? arr1[i] : \u0026#34;0\u0026#34;; String tmp2 = arr2.length \u0026gt; i ? arr2[i] : \u0026#34;0\u0026#34;; try { int i1 = Integer.parseInt(tmp1); int i2 = Integer.parseInt(tmp2); if (i1 != i2) return i1 \u0026gt; i2 ? 1 : -1; } catch (Exception e) { int res = tmp1.compareTo(tmp2); if (res != 0) return res \u0026gt; 0 ? 1 : -1; } } return 0; } public static String[] convert(String version) { return Arrays.stream(version.split(\u0026#34;\\\\.\u0026#34;)) .map(Main::replaceZero).toArray(String[]::new); } public static String replaceZero(String str) { // 去除前导0 String s = str.replaceAll(\u0026#34;^0+\u0026#34;, \u0026#34;\u0026#34;); // 如果是\u0026#34;0\u0026#34;，去除前导0后就变为了\u0026#34;\u0026#34;，需要做特殊处理 return s.isEmpty() ? \u0026#34;0\u0026#34; : s; } 06. 猜密码\r#\r描述\n小杨申请了一个保密柜，但是他忘记了密码。只记得密码都是数字，而且所有数字都是不重复的。 请你根据他记住的数字范围和密码的最小数字数量，帮他算下有哪些可能的组合，规则如下： 1. 输出的组合都是从可选的数字范围中选取的，且不能重复； 2. 输出的密码数字要按照从小到大的顺序排列，密码组合需要按照字母顺序，从小到大的顺序排序。 3. 输出的每一个组合的数字的数量要大于等于密码最小数字数量； 4. 如果可能的组合为空，则返回“None” 输入描述： 输入的第一行是可能的密码数字列表，数字间以半角逗号分隔 输入的第二行是密码最小数字数量 输出描述： 可能的密码组合，每种组合显示成一行，每个组合内部的数字以半角逗号分隔，从小到大的顺序排列。 出的组合间需要按照字典序排序。比如：2,3,4放到2,4的前面 输入：2,3,4 2 输出：2,3 2,3,4 2,4 3,4 题解\nstatic int[] nums; static int level; public static void main(String[] args) { Scanner sc = new Scanner(System.in); nums = Arrays.stream(sc.nextLine().split(\u0026#34;,\u0026#34;)).mapToInt(Integer::parseInt).toArray(); level = Integer.parseInt(sc.nextLine()); System.out.println(getResult()); } public static String getResult() { // 按照数值大小升序，这样后续形成的组合的内部就是按照数值大小升序的 Arrays.sort(nums); // 求不重复组合 ArrayList\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); dfs(0, new LinkedList\u0026lt;\u0026gt;(), res); if (!res.isEmpty()) { // 组合间按照字典序排序 res.sort(String::compareTo); return String.join(\u0026#34;\\n\u0026#34;, res); } else { return \u0026#34;None\u0026#34;; } } public static void dfs(int index, LinkedList\u0026lt;String\u0026gt; path, ArrayList\u0026lt;String\u0026gt; res) { if (path.size() \u0026gt;= level) { // 如果path层数到达level层，则记录该组合 res.add(String.join(\u0026#34;,\u0026#34;, path)); } for (int i = index; i \u0026lt; nums.length; i++) { // 树层去重 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; path.add(nums[i] + \u0026#34;\u0026#34;); dfs(i + 1, path, res); path.removeLast(); } } 07. 查找一个有向网络的头节点和尾节点\r#\r描述\n给定一个有向图，图中可能包含有环，图使用二维矩阵表示， 每一行的第一列表示起始节点，第二列表示终止节点，如 [0, 1] 表示从 0 到 1 的路径。 每个节点用正整数表示。 求这个数据的首节点与尾节点， 题目给的用例会是一个首节点，但可能存在多个尾节点。同时图中可能含有环。如果图中含有环，返回 [-1]。 说明：入度为0是首节点，出度为0是尾节点。 输入描述： 第一行为后续输入的键值对数量N（N ≥ 0） 第二行为2N个数字。每两个为一个起点，一个终点 输出描述： 输出一行头节点和尾节点。如果有多个尾节点，按从小到大的顺序输出。 备注： 如果图有环，输出为 -1 所有输入均合法，不会出现不配对的数据 输入：4 0 1 0 2 1 2 2 3 输出：0 3 题解\nstatic boolean hasO = false; public static class Ve { public int val; public List\u0026lt;Ve\u0026gt; subList; public Ve(int val) { this.val = val; this.subList = new ArrayList\u0026lt;\u0026gt;(); } public void addSub(Ve subVe) { this.subList.add(subVe); } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); int[] ints = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); Map\u0026lt;Integer, Ve\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); HashSet\u0026lt;Integer\u0026gt; preSet = new HashSet\u0026lt;\u0026gt;(); HashSet\u0026lt;Integer\u0026gt; subSet = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { int pre = ints[i * 2]; int sub = ints[i * 2 + 1]; preSet.add(pre); subSet.add(sub); map.putIfAbsent(pre, new Ve(pre)); map.putIfAbsent(sub, new Ve(sub)); Ve preVe = map.get(pre); Ve subVe = map.get(sub); preVe.addSub(subVe); } hasO =false; System.out.println(getResult(map, preSet, subSet)); } public static String getResult(Map\u0026lt;Integer, Ve\u0026gt; map, HashSet\u0026lt;Integer\u0026gt; preSet, HashSet\u0026lt;Integer\u0026gt; subSet) { // 有无环 for (int pre : preSet) { if (hasO) { break; } dp(pre, map.get(pre).subList); } if (hasO) { return \u0026#34;-1\u0026#34;; } int head = -1; for (int pre : preSet) { if (subSet.contains(pre)) { continue; } head = pre; break; } List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int sub : subSet) { if (!preSet.contains(sub)) { list.add(sub); } } String str = list.stream().sorted().map(String::valueOf).collect(Collectors.joining(\u0026#34; \u0026#34;)); return head + \u0026#34; \u0026#34; + str; } public static void dp(int value, List\u0026lt;Ve\u0026gt; subList) { if (hasO || subList.isEmpty()) { return; } for (Ve sub : subList) { if (value == sub.val) { hasO = true; return; } dp(value, sub.subList); } } 08. 出错的或电路\r#\r描述\n某生产门电路的厂商发现某一批次的或门电路不稳定，具体现象为计算两个二进制数的或操作时， 第一个二进制数中某两个比特位会出现交换，交换的比特位置是随机的，但只交换这两个位，其他位不变。 很明显，这个交换可能会影响最终的或结果，也可能不会有影响。 为了评估影响和定位出错的根因，工程师需要研究在各种交换的可能下，最终的或结果发生改变的情况有多少种。 输入描述： 第一行有一个正整数N; 其中1≤N≤1000000。 第二行有一个长为N的二进制数，表示与电路的第一个输入数，即会发生比特交换的输入数。 第三行有一个长为N的二进制数，表示与电路的第二个输入数。注意第二个输入数不会发生比特交换。 输出描述： 输出只有一个整数，表示会影响或结果的交换方案个数。 输入：6 011011 110110 输出：4 说明： 原本011011和110110的或结果是111111，但是第一个输入数发生如下比特交换会影响最终计算结果： 1、交换第1个比特和第3个比特，第一个输入数变为110011，计算结果变为110111 2、交换第1个比特和第6个比特，第一个输入数变为111010，计算结果变为111110 3、交换第3个比特和第4个比特，第一个输入数变为010111，计算结果变为110111 4、交换第4个比特和第6个比特，第一个输入数变为011110，计算结果变为111100 其他交换都不会影响计算结果，故输出4. 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); String bin1 = sc.next(); String bin2 = sc.next(); System.out.println(getResult(n, bin1, bin2)); } /** * @param n 二进制长度 * @param bin1 可能产生错误交换的二进制 * @param bin2 不会发生错误的二进制 * @return 产生错误结果的情况有几种 */ public static long getResult(int n, String bin1, String bin2) { // 找出bin2值为0的位，并统计对应位上bin1的值为0的有x个 long x = 0; // 找出bin2值为0的位，并统计对应位上bin1的值为1的有y个 long y = 0; // 统计bin1总共有多少个1 long a = 0; // 统计bin1总共有多少个0 long b = 0; for (int i = 0; i \u0026lt; n; i++) { if (bin1.charAt(i) == \u0026#39;0\u0026#39;) { b++; if (bin2.charAt(i) == \u0026#39;0\u0026#39;) x++; } else { a++; if (bin2.charAt(i) == \u0026#39;0\u0026#39;) y++; } } return x * a + y * b - x * y; } 09. 打印任务排序\r#\r描述\n某个打印机根据打印队列执行打印任务。 打印任务分为九个优先级，分别用数字1-9表示，数字越大优先级越高。打印机每次从队列头部取出第一个任务A， 然后检查队列余下任务中有没有比A优先级更高的任务，如果有比A优先级高的任务，则将任务A放到队列尾部，否则就执行任务A的打印。 请编写一个程序，根据输入的打印队列，输出实际的打印顺序。 输入描述：输入一行，为每个任务的优先级，优先级之间用逗号隔开，优先级取值范围是1~9。 输出描述：输出一行，为每个任务的打印顺序，打印顺序从0开始，用逗号隔开 输入：1,2,2 输出：2,0,1 说明：队列头部任务的优先级为1，被移到队列尾部；接着顺序打印两个优先级为2的任务，故其序号分别为0和1； 最后打印剩下的优先级为1的任务，其序号为2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34;,\u0026#34;); int[] nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(nums)); } public static String getResult(int[] nums) { int n = nums.length; LinkedList\u0026lt;int[]\u0026gt; link = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { link.add(new int[]{nums[i], i}); } Arrays.sort(nums); int printIdx = 0; int maxNumIdx = n - 1; int[] arr = new int[n]; while (!link.isEmpty()) { int[] head = link.removeFirst(); if (head[0] == nums[maxNumIdx]) { arr[head[1]] = printIdx; printIdx++; maxNumIdx--; } else { link.add(head); } } return Arrays.stream(arr).mapToObj(String::valueOf).collect(Collectors.joining(\u0026#34;,\u0026#34;)); } 10. 导师请吃火锅\r#\r描述\n火锅里会在不同时间下很多菜，不同食材要煮不同时间，才能变得刚好合适，你希望吃到最多的刚好合适的菜， 但是你的手速不够快用m代替手速，每次下手捞菜后至少要过m秒，才能再捞（每次只能捞一个） 那么用最合理的策略，最多能吃到多少，刚好合适的菜 输入描述： 第一行两个整数n、m，其中n代表往锅里下菜的个数，m代表手速 接下来有n行，每行有两个数x、y，代表第x秒下的菜过y秒才能变得刚好合适（1 ＜ mn ＜ 1000），（1 ＜ xy ＜ 1000） 输出描述： 输出一个整数代表用最合理的策略，最多能吃到刚好合适的菜的数量 输入：3 2 1 2 2 1 3 2 输出：2 往锅里下的菜的个数3，手速2； 第1秒的时候下入菜品1，2秒后熟了； 第2秒的时候下入菜品2，1秒后熟了； 第3秒的时候下入菜品3，2秒后熟了； 第一种菜品和第二种菜品只能吃到一种，第三种菜品可以吃到； 题解\n// 遍历每一种菜，若当前与上一次捞菜的时间差\u0026gt;=m，则当前可以进行捞菜 public static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int n = Integer.parseInt(split[0]); int m = Integer.parseInt(split[1]); int[] arr = new int[n]; for (int i = 0; i \u0026lt; n; i++) { String[] tmp = sc.nextLine().split(\u0026#34; \u0026#34;); // 每种菜刚好合适的时间点 arr[i] = Integer.parseInt(tmp[0]) + Integer.parseInt(tmp[1]); } Arrays.sort(arr); // 第1个合适的菜 int count = 1; int pre = 0; for (int i = 1; i \u0026lt; arr.length; i++) { if (arr[i] \u0026gt;= arr[pre] + m) { // 当前与上次捞菜的时间差大于等于m，则可以进行捞菜 count++; // 更新本次捞菜时间点 pre = i; } } System.out.println(count); } 11. 电脑病毒感染\r#\r描述\n一个局域网内有很多台电脑，分别标注为 1 ~ N 的数字。相连接的电脑距离不一样，所以感染时间不一样，感染时间用 t 表示。 其中网络内一台电脑被病毒感染，求其感染网络内所有的电脑最少需要多长时间。如果最后有电脑不会感染，则返回-1。 给定一个数组 times 表示一台电脑把相邻电脑感染所用的时间。 如：path[i] = {i, j, t} 表示：电脑 i-\u0026gt;j，电脑 i 上的病毒感染 j，需要时间 t。 输入：4 3 2 1 1 2 3 1 3 4 1 2 输出：2 说明： 第一个参数：局域网内电脑个数N，1 ≤ N ≤ 200； 第二个参数：总共多少条网络连接 第三个 2 1 1 表示2-\u0026gt;1时间为1 第六行：表示病毒最开始所在电脑号2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); List\u0026lt;Edge\u0026gt; edges = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; m; i++) { int a = sc.nextInt(); // 出发点 int b = sc.nextInt(); // 目标点 int c = sc.nextInt(); // 出发点到达目标点的耗时 edges.add(new Edge(a, b, c)); } // 最短路 long[] dist = new long[n + 1]; // 起始先将所有的点标记为「距离为正无穷」 Arrays.fill(dist, Integer.MAX_VALUE); // 源点 int src = sc.nextInt(); // 源点到达源点的耗时为0 dist[src] = 0; // 迭代 n 次 for (int i = 1; i \u0026lt;= n; i++) { long[] prev = dist.clone(); // 每次都使用上一次迭代的结果，执行松弛操作 for (Edge edge : edges) { int a = edge.a, b = edge.b, c = edge.c; dist[b] = Math.min(dist[b], prev[a] + c); } } // 遍历答案 long ans = 0; for (int i = 1; i \u0026lt;= n; i++) { ans = Math.max(ans, dist[i]); } System.out.println(ans == Integer.MAX_VALUE ? -1 : ans); } static class Edge { int a, b, c; Edge(int a, int b, int c) { this.a = a; this.b = b; this.c = c; } } 12. 叠积木\r#\r描述\n有一堆长方体积木，它们的宽度和高度都相同，但长度不一。 小橙想把这堆积木叠成一面墙，墙的每层可以放一个积木，也可以将两个积木拼接起来，要求每层的长度相同。 若必须用完这些积木，叠成的墙最多为多少层？ 输入描述：输入为一行，为各个积木的长度，数字为正整数，并由空格分隔。积木的数量和长度都不超过5000。 输出描述：输出一个数字，为墙的最大层数，如果无法按要求叠成每层长度一致的墙，则输出-1。 输入：3 6 6 3 输出：3 输入：1 4 2 3 6 输出：-1 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); Integer[] nums = Arrays.stream(split).map(Integer::parseInt).toArray(Integer[]::new); System.out.println(getResult(nums)); } public static int getResult(Integer[] nums) { int n = nums.length; // 如果只有一个积木，那么只能是一层高度 if (n == 1) { return 1; } // 如果有两个积木 if (n == 2) { // 如果两个积木长度相同，则最大高度为2 // 如果两个积木长度不同，则最大高度为1 return nums[0] - nums[1] != 0 ? 1 : 2; } // 积木按长度降序 Arrays.sort(nums, (a, b) -\u0026gt; b - a); // 一层的最小长度，即最长的积木的长度 int minLen = nums[0]; // 一层的最大长度 int maxLen = nums[0] + nums[nums.length - 1]; // 尝试minLen和maxLen中每一个值作为一层长度 for (int len = minLen; len \u0026lt;= maxLen; len++) { // 对应一层长度限制下的最大高度 int height = 0; // 通过l,r指针去选择组成一层的一个或两个积木 int l = 0; // l指针指向最大长度的积木 int r = n - 1; // r指针指向最小长度的积木 // 如果最大长度的积木，可以独立一层，则l++，height++ while (l \u0026lt; n \u0026amp;\u0026amp; nums[l] == len) { l++; height++; } // 如果 l,r积木无法组成一层 // 假设nums[l] + nums[r] \u0026gt; len，则必然nums[l] + nums[r-1] \u0026gt; len， // 因为nums已降序，nums[r-1] \u0026gt;= nums[r]，即必然l积木无法和其他积木组成一层 // 假设nums[l] + nums[r] \u0026lt; len，则必然nums[l+1] + nums[r] \u0026lt; len， // 因为nums已降序，nums[l+1] \u0026lt;= nums[l]，即必然r积木无法和其他积木组成一层 while (l \u0026lt; r) { if (nums[l] + nums[r] != len) break; l++; r--; height++; } // 如果正常结束，则必然l \u0026gt; r，否则就是异常结束 if (l \u0026lt;= r) continue; return height; } return -1; } 13. 二叉树的广度优先遍历\r#\r描述\n有一棵二叉树，每个节点由一个大写字母标识(最多26个节点）。 现有两组字母，分别表示后序遍历（左孩子-\u0026gt;右孩子-\u0026gt;父节点）和中序遍历（左孩子-\u0026gt;父节点-\u0026gt;右孩子）的结果， 请你输出层序遍历的结果。 输入描述： 每个输入文件一行，第一个字符串表示后序遍历结果，第二个字符串表示中序遍历结果。（每串只包含大写字母） 中间用单空格分隔。 输出描述： 输出仅一行，表示前序遍历的结果，结尾换行。 输入：CBEFDA CBAEDF 输出：ABDCEF 题解\npublic static class TreeNode { char val; TreeNode left; TreeNode right; TreeNode(char val) { this.val = val; } } public static void preOrder(StringBuilder sb, TreeNode node) { if (node == null) { return; } sb.append(node.val); preOrder(sb, node.left); preOrder(sb, node.right); } private static TreeNode build(String postOrder, String midOrder) { if (postOrder.isEmpty()) { return null; } char midVal = postOrder.charAt(postOrder.length() - 1); TreeNode root = new TreeNode(midVal); if (postOrder.length() == 1) { return root; } int midIndex = midOrder.indexOf(midVal); String postLeft = postOrder.substring(0, midIndex); String postRight = postOrder.substring(midIndex, postOrder.length() - 1); String midLeft = midOrder.substring(0, midIndex); String midRight = midOrder.substring(midIndex + 1); root.left = build(postLeft, midLeft); root.right = build(postRight, midRight); return root; } public static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); String postOrder = split[0]; String midOrder = split[1]; TreeNode root = build(postOrder, midOrder); StringBuilder sb = new StringBuilder(); preOrder(sb, root); System.out.println(sb); } 14. 二叉树计算\r#\r描述\n如图，给出一个二叉树， 由该二叉树生成一个新的二叉树，它满足其树中的每个节点将包含原始树中的左子树和右子树的和。 输入描述：2行整数，第1行表示二叉树的中序遍历，第2行表示二叉树的前序遍历，以空格分割 输出描述：1行整数，表示求和树的中序遍历，以空格分割 输入：-3 12 6 8 9 -10 -7 8 12 -3 6 -10 9 -7 输出：0 3 0 7 0 2 0 题解\npublic static class TreeNode { int num; // 当前节点的值 int sum; // 当前节点的左子树+右子树的和 TreeNode left; TreeNode right; public TreeNode(int num) { this.num = num; this.sum = 0; } public int sumChild() { if (this.left == null \u0026amp;\u0026amp; this.right == null) { this.sum = 0; return 0; } int sumL = 0; if (this.left != null) { sumL = left.sumChild() + left.num; } int sumR = 0; if (this.right != null) { sumR = right.sumChild() + right.num; ; } this.sum = sumL + sumR; return sum; } } public static void midOrder(StringBuilder sb, TreeNode node) { if (node == null) { return; } midOrder(sb, node.left); sb.append(node.sum).append(\u0026#34; \u0026#34;); midOrder(sb, node.right); } private static TreeNode build(String preOrder, String midOrder) { if (preOrder.isEmpty()) { return null; } String[] preArr = preOrder.split(\u0026#34; \u0026#34;); String[] midArr = midOrder.split(\u0026#34; \u0026#34;); String midVal = preArr[0]; TreeNode root = new TreeNode(Integer.parseInt(midVal)); if (preOrder.length() == 1) { return root; } List\u0026lt;Integer\u0026gt; idxList = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; midArr.length; i++) { if (midArr[i].equals(midVal)) { idxList.add(i); } } int midIndex = -1; for (int idx : idxList) { if (isTrueRoot(preArr, midArr, idx)) { midIndex = idx; break; } } String[] preLeft = Arrays.copyOfRange(preArr, 1, midIndex + 1); String[] minLeft = Arrays.copyOfRange(midArr, 0, midIndex); String[] preRight = Arrays.copyOfRange(preArr, midIndex + 1, preArr.length); String[] minRight = Arrays.copyOfRange(midArr, midIndex + 1, midArr.length); root.left = build(String.join(\u0026#34; \u0026#34;, preLeft), String.join(\u0026#34; \u0026#34;, minLeft)); root.right = build(String.join(\u0026#34; \u0026#34;, preRight), String.join(\u0026#34; \u0026#34;, minRight)); return root; } public static boolean isTrueRoot(String[] preArr, String[] midArr, int idx) { String[] preLeft = Arrays.copyOfRange(preArr, 1, idx + 1); String[] minLeft = Arrays.copyOfRange(midArr, 0, idx); String preLeftStr = Arrays.stream(preLeft).sorted().collect(Collectors.joining(\u0026#34; \u0026#34;)); String minLeftStr = Arrays.stream(minLeft).sorted().collect(Collectors.joining(\u0026#34; \u0026#34;)); if (!preLeftStr.equals(minLeftStr)) { return false; } String[] preRight = Arrays.copyOfRange(preArr, idx + 1, preArr.length); String[] minRight = Arrays.copyOfRange(midArr, idx + 1, midArr.length); String preRightStr = Arrays.stream(preRight).sorted().collect(Collectors.joining(\u0026#34; \u0026#34;)); String minRightStr = Arrays.stream(minRight).sorted().collect(Collectors.joining(\u0026#34; \u0026#34;)); if (!preRightStr.equals(minRightStr)) { return false; } return true; } public static void main(String[] args) { Scanner sc = new Scanner(System.in); String minOrder = sc.nextLine(); String preOrder = sc.nextLine(); TreeNode root = build(preOrder, minOrder); root.sumChild(); StringBuilder sb = new StringBuilder(); midOrder(sb, root); System.out.println(sb); } 15. 发广播\r#\r描述\n某地有N个广播站，站点之间有些有连接，有些没有。有连接的站点在接受到广播后会互相发送。 给定一个N*N的二维数组matrix,数组的元素都是字符’0’或者’1’。 matrix[i][j] = ‘1’, 代表i和j站点之间有连接，matrix[i][j] = ‘0’, 代表没连接， 现在要发一条广播，问初始最少给几个广播站发送，才能保证所有的广播站都收到消息。 输入描述：从stdin输入，共一行数据，表示二维数组的各行，用逗号分隔行。保证每行字符串所含的字符数一样的。 输出描述：返回初始最少需要发送广播站个数 输入：110,110,001 输出：2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] matrix = sc.nextLine().split(\u0026#34;,\u0026#34;); System.out.println(getResult(matrix)); } public static int getResult(String[] matrix) { int n = matrix.length; UnionFindSet ufs = new UnionFindSet(n); for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { if (matrix[i].charAt(j) == \u0026#39;1\u0026#39;) { ufs.union(i, j); } } } return ufs.count; } // 并查集实现 static class UnionFindSet { int[] fa; int count; public UnionFindSet(int n) { this.fa = new int[n]; for (int i = 0; i \u0026lt; n; i++) fa[i] = i; this.count = n; } public int find(int x) { if (x != this.fa[x]) { this.fa[x] = this.find(this.fa[x]); return this.fa[x]; } return x; } public void union(int x, int y) { int x_fa = this.find(x); int y_fa = this.find(y); if (x_fa != y_fa) { this.fa[y_fa] = x_fa; this.count--; } } } 16. 伐木工\r#\r描述\n一根X米长的树木，伐木工切割成不同长度的木材后进行交易，交易价格为每根木头长度的乘积。规定切割后的每根木头长度都为正整数；也可以不切割，直接拿整根树木进行交易。 请问伐木工如何尽量少的切割，才能使收益最大化？ 输入描述：木材的长度（X ≤ 50） 输出描述：输出最优收益时的各个树木长度，以空格分隔，按升序排列 输入：10 输出：3 3 4 题解\nstatic class Wood { // 记录木材的最大收益 int profit; // 记录木材最大收益时对应的切割状态 ArrayList\u0026lt;Integer\u0026gt; slices = new ArrayList\u0026lt;\u0026gt;(); } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int x = sc.nextInt(); Wood[] dp = new Wood[x + 1]; for (int i = 0; i \u0026lt;= x; i++) { // 初始时，将木材不切割的收益作为最大收益 dp[i] = new Wood(); dp[i].profit = i; dp[i].slices.add(i); } // 从长度为2的木材开始尝试切割 for (int i = 2; i \u0026lt;= x; i++) { for (int j = 1; j \u0026lt; i; j++) { int profit = dp[j].profit * dp[i - j].profit; // 如果该切割方案的收益更大， // 或者收益和之前切割方案的收益相同，但是切割数更少，则使用当前切割方案 if (profit \u0026gt; dp[i].profit || (profit == dp[i].profit \u0026amp;\u0026amp; dp[i].slices.size() \u0026gt; dp[j].slices.size() + dp[i - j].slices.size())) { dp[i].profit = profit; dp[i].slices.clear(); dp[i].slices.addAll(dp[j].slices); dp[i].slices.addAll(dp[i - j].slices); } } } // dp[x].slices记录的是：长度x的木材对应的最大收益的切割方案 // 按题目输出描述要求进行升序 dp[x].slices.sort((a, b) -\u0026gt; a - b); // 打印切割方案 StringJoiner sj = new StringJoiner(\u0026#34; \u0026#34;); for (int slice : dp[x].slices) { sj.add(slice + \u0026#34;\u0026#34;); } System.out.println(sj); } 17. 反射计数\r#\r描述\n给定一个包含 0 和 1 的二维矩阵。 给定一个初始位置和速度，一个物体从给定的初始位置出发，在给定的速度下进行移动，遇到矩阵的边缘则发生镜面发射。 无论物体经过 0 还是 1，都不影响其速度。 请计算并给出经过 t 时间单位后，物体经过 1 点的次数。 矩阵以左上角位置为 [0, 0]（列(x)，行(y)），例如下面A点坐标为 [2, 1]（第二列，第一行） 注意： 如果初始位置的点是 1，也计算在内 时间的最小单位为 1，不考虑小于 1 个时间单位内经过的点 输入描述： 第一行为初始信息\u0026lt;w\u0026gt;\u0026lt;h\u0026gt;\u0026lt;x\u0026gt;\u0026lt;y\u0026gt;\u0026lt;sx\u0026gt;\u0026lt;sy\u0026gt;\u0026lt;t\u0026gt; 第二行开始一共 h 行，为二维矩阵信息 其中： w，h 为矩阵的宽和高，0 ＜ w ＜ 100，0 ＜ h ＜ 100 x，y 为起始位置，0 ≤ x ＜ w，0 ≤ y ＜ h sx，sy 为初始速度，-1 ≤ sx ≤ 1，-1 ≤ sy ≤ 1 t 为经过的时间，0 ≤ t ＜100 输出描述： 经过 1 的个数，注意初始位置也要计算在内 输入：12 7 2 1 1 -1 13 001000010000 001000010000 001000010000 001000010000 001000010000 001000010000 001000010000 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int w = sc.nextInt(); int h = sc.nextInt(); int x = sc.nextInt(); int y = sc.nextInt(); int sx = sc.nextInt(); int sy = sc.nextInt(); int t = sc.nextInt(); char[][] matrix = new char[h][w]; for (int i = 0; i \u0026lt; h; i++) { matrix[i] = sc.next().toCharArray(); } int ans = 0; while (t \u0026gt;= 0) { // 注意本题横纵坐标是反的，因此y其实是行号，x是列号 if (matrix[y][x] == \u0026#39;1\u0026#39;) { ans++; } y += sy; x += sx; if (x \u0026lt; 0) { x = 1; sx = -sx; } else if (x \u0026gt;= w) { // 注意本题横纵坐标是反的，因此x是列号，w是矩阵列数 x = w - 2; sx = -sx; } if (y \u0026lt; 0) { y = 1; sy = -sy; } else if (y \u0026gt;= h) { // 注意本题横纵坐标是反的，因此y是行号，h是矩阵行数 y = h - 2; sy = -sy; } t--; } System.out.println(ans); } 18. 分月饼\r#\r描述\n中秋节，公司要给员工分月饼。公司有m个员工，买了n个月饼，且m≤n。每个员工至少分到 1 个月饼，但可以分多个。 要求： 单人分到最多的月饼个数为Max1，单人分到第二多的月饼个数为Max2，需要满足Max1−Max2≤3。 单人分到倒数第二多的月饼个数为Max(n−1)，单人分到最少的月饼个数为Max(n)，需要满足Max(n−1)−Max(n)≤3。 问有多少种分月饼的方法？ 输入描述：第一行输入两个整数m和n，表示m个员工和n个月饼，m≤n。 输出描述：输出有多少种分月饼的方法。 输入：3 12 输出：6 题解\nstatic int m; static int n; static int maxDiff = 3; static int ans = 0; public static void main(String[] args) { Scanner sc = new Scanner(System.in); m = sc.nextInt(); n = sc.nextInt(); // 如果只有一个员工分月饼，那么就只有一种方案 if (m == 1) { System.out.println(1); return; } // 如果有多个员工分月饼， // 为了保证分月饼的方案不重复，我们这里保证 员工i的月饼数量 \u0026lt;= 员工i+1的月饼数量 // 因此对于第0个员工，至少分得1个月饼，至多分得n/m个月饼（均分数量） recursive(0, 1, n / m, n); System.out.println(ans); } /** * @param level 第几个员工 * @param min 当前员工至少分得几个月饼 * @param max 当前员工至多分得几个月饼 * @param remain 分月饼给当前员工前，月饼的剩余数量 */ public static void recursive(int level, int min, int max, int remain) { if (level == m - 1) { // 分到最后一个员工时，我们应该将剩余月饼都给他 // 因此最后一个员工的月饼数量就是remain， // 而倒数第二个员工的月饼数量是min（本轮递归的min参数，即上一轮员工分得的月饼数量） // 如果二者差距不超过maxDiff，则分月饼方案可行 if (remain - min \u0026lt;= maxDiff) { ans++; } return; } // i 是当前员工可以分得的月饼数量 for (int i = min; i \u0026lt;= max; i++) { // 下一个员工至少分得 i 个月饼（当前员工分得的月饼数量），至多分得 i + maxDiff // 同时下一个员工分得的月饼数量不能超过：均分月饼数量（即剩余月饼总数 / 剩余员工总数）， // 否则破坏去重策略（为了保证分月饼的方案不重复，我们这里保证后面的员工分得月饼数不小于前面员工） remain -= i; recursive(level + 1, i, Math.min(i + maxDiff, remain / (m - level - 1)), remain); remain += i; } } 19. 符号运算\r#\r描述\n给定一个表达式，求其分数计算结果。用例输入一定合法，不会出现括号匹配的情况 表达式的限制如下： 1. 所有的输入数字皆为正整数（包括0） 2. 仅支持四则运算（+-*/）和括号 3. 结果为整数或分数，分数必须化为最简格式（比如6，3/4，7/8，90/7） 4. 除数可能为0，如果遇到这种情况，直接输出\u0026#34;ERROR\u0026#34; 5. 输入和最终计算结果中的数字都不会超出整型范围 输入描述： 字符串格式的表达式，仅支持+-*/，数字可能超过两位，可能带有空格，没有负数 长度小于200个字符 输出描述： 表达式结果，以最简格式表达 1. 如果结果为整数，那么直接输出整数 2. 如果结果为负数，那么分子分母不可再约分，可以为假分数，不可表达为带分数 3. 结果可能是负数，符号放在前面 输入：1 + 5 * 7 / 8 输出：43/8 输入：1 / (0 - 5) 输出：-1/5 说明：符号需要提到最前面 输入：1 * (3*4/(8-(7+0))) 输出：12 说明：注意括号可以多重嵌套 题解\n// 分数 static class Fractions { int fa; // 分母 int ch; // 分子 public Fractions() { } public Fractions(int fa, int ch) { this.fa = fa; this.ch = ch; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(getResult(sc.nextLine())); } // 操作数栈 static LinkedList\u0026lt;Fractions\u0026gt; numStack = new LinkedList\u0026lt;\u0026gt;(); // 操作符栈 static LinkedList\u0026lt;Character\u0026gt; signStack = new LinkedList\u0026lt;\u0026gt;(); public static String getResult(String s) { // +,-,*,/ 运算符优先级 HashMap\u0026lt;Character, Integer\u0026gt; priority = new HashMap\u0026lt;\u0026gt;(); priority.put(\u0026#39;+\u0026#39;, 1); priority.put(\u0026#39;-\u0026#39;, 1); priority.put(\u0026#39;*\u0026#39;, 2); priority.put(\u0026#39;/\u0026#39;, 2); // 操作数的字符缓存容器 StringBuilder numStr = new StringBuilder(); int i = 0; while (i \u0026lt; s.length()) { char c = s.charAt(i); // 遇到数字字符 if (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) { // 则将该数字所在操作数的剩余数字字符一次性探索完 while (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) { numStr.append(c); if (i + 1 \u0026gt;= s.length()) break; i++; c = s.charAt(i); } // 探索完后，将操作数缓存容器中记录的字符，变为分数后，压入操作数栈 numStack.addLast(new Fractions(1, Integer.parseInt(numStr.toString()))); // 注意清空操作数缓存容器 numStr = new StringBuilder(); } // 遇到运算符 if (c == \u0026#39;+\u0026#39; || c == \u0026#39;-\u0026#39; || c == \u0026#39;*\u0026#39; || c == \u0026#39;/\u0026#39;) { // 只要栈顶运算符的优先级 \u0026gt;= 当前运算符，就需要不停出栈运算 while (!signStack.isEmpty() \u0026amp;\u0026amp; signStack.getLast() != \u0026#39;(\u0026#39; \u0026amp;\u0026amp; priority.get(c) \u0026lt;= priority.get(signStack.getLast())) { calc(); } signStack.addLast(c); } else if (c == \u0026#39;)\u0026#39;) { // 遇到\u0026#39;)\u0026#39;, 需要将操作符栈中靠近栈顶的\u0026#39;(\u0026#39;后面的运算都出栈做了 while (signStack.getLast() != \u0026#39;(\u0026#39;) { calc(); } // 最后将\u0026#39;)\u0026#39;对应的\u0026#39;(\u0026#39;出栈 signStack.removeLast(); } else if (c == \u0026#39;(\u0026#39;) { // 遇到\u0026#39;(\u0026#39;，则直接压到操作符栈 signStack.add(c); } i++; } // numStack栈中还有2个以上的数，则还需要进行运算 while (numStack.size() \u0026gt; 1) { calc(); } // numStack栈中只剩一个数时，该数就是表达式结果 Fractions result = numStack.removeLast(); // 如果结果的分母为0（除数为0），则不合法 if (result.fa == 0) { return \u0026#34;ERROR\u0026#34;; } // 求分子、分母的最大公约数，并进行约份，求得最简格式的分子，分母 int k = getMaxCommonDivisor(result.fa, result.ch); result.fa /= k; result.ch /= k; // 求计算结果的符号，这里用乘法是为了避免 分母小，分子大，除法结果为0的情况，这样会丢失符号信息 String sign = result.fa * result.ch \u0026lt; 0 ? \u0026#34;-\u0026#34; : \u0026#34;\u0026#34;; int fa = Math.abs(result.fa); int ch = Math.abs(result.ch); if (fa == 1) { // 如果分母为1，则直接输出分子 return sign + ch; } else { // 如果分母不为1，则输出 分子 / 分母 return sign + ch + \u0026#34;/\u0026#34; + fa; } } // 取出numStack栈顶两个操作数进行运算 public static void calc() { // 操作数顺序会对运算产生影响 Fractions b = numStack.removeLast(); // 栈顶元素是运算符右边的操作数 Fractions a = numStack.removeLast(); // 栈顶倒数第二个元素是运算符左边的操作数 // 运算符 char op = signStack.removeLast(); // 记录运算结果 Fractions result = new Fractions(); switch (op) { case \u0026#39;+\u0026#39;: result.fa = a.fa * b.fa; result.ch = a.ch * b.fa + b.ch * a.fa; break; case \u0026#39;-\u0026#39;: result.fa = a.fa * b.fa; result.ch = a.ch * b.fa - b.ch * a.fa; break; case \u0026#39;*\u0026#39;: result.fa = a.fa * b.fa; result.ch = a.ch * b.ch; break; case \u0026#39;/\u0026#39;: result.fa = a.fa * b.ch; result.ch = a.ch * b.fa; break; } numStack.add(result); } // 辗转相除法，求两个数的最大公约数 public static int getMaxCommonDivisor(int x, int y) { while (y != 0) { int tmp = y; y = x % y; x = tmp; } return x; } 20. 高效的任务规划\r#\r描述\n你有 n 台机器编号为 1~n，每台都需要完成完成一项工作，机器经过配置后都能完成独立完成一项工作。 假设第 i 台机器你需要花 B 分钟进行设置，然后开始运行，J 分钟后完成任务。 现在，你需要选择布置工作的顺序，使得用最短的时间完成所有工作。 注意，不能同时对两台进行配置，但配置完成的机器们可以同时执行他们各自的工作。 输入描述： 第一行输入代表总共有 M 组任务数据（1＜M≤10）。 每组数第一行为一个整数指定机器的数量 N（0＜N≤1000）。 随后的 N 行每行两个整数，第一个表示 B（0≤B≤10000），第二个表示 J（0≤J≤10000）。 每组数据连续输入，不会用空行分隔。各组任务单独计时。 输出描述： 对于每组任务，输出最短完成时间，且每组的结果独占一行。例如，两组任务就应该有两行输出。 输入：2 2 1 1 2 2 3 1 1 2 2 3 3 输出：4 7 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); for (int i = 0; i \u0026lt; m; i++) { int n = sc.nextInt(); int[][] tasks = new int[n][2]; for (int j = 0; j \u0026lt; n; j++) { tasks[j][0] = sc.nextInt(); tasks[j][1] = sc.nextInt(); } getResult(tasks); } } public static void getResult(int[][] tasks) { // 将每个任务中的机器工作顺序，按照运行时间降序排序 Arrays.sort(tasks, (a, b) -\u0026gt; b[1] - a[1]); int configEndTime = 0; int ans = 0; for (int[] task : tasks) { int configCost = task[0]; int runCost = task[1]; configEndTime += configCost; ans = Math.max(ans, configEndTime + runCost); } System.out.println(ans); } 21. 高效货运\r#\r描述\n老李是货运公司承运人，老李的货车额定载货重量为 wt。现有两种货物： 货物 A 单件重量为 wa，单件运费利润为 pa 货物 B 单件重量为 wb，单件运费利润为 pb 老李每次发车时载货总重量刚好为货车额定的载货重量 wt，车上必须同时有货物 A 和货物 B ，货物A、B不可切割。 老李单次满载运输可获得的最高利润是多少？ 输入描述： 第一列输入为货物 A 的单件重量 wa，0 ＜ wa ＜ 10000 第二列输入为货物 B 的单件重量 wb，0 ＜ wb ＜ 10000 第三列输入为货车的额定载重 wt， 0 ＜ wt ＜ 100000 第四列输入为货物 A 的单件运费利润 pa，0 ＜ pa ＜ 1000 第五列输入为货物 B 的单件运费利润 pb，0 ＜ pb ＜ 1000 输出描述： 单次满载运输的最高利润 输入：10 8 36 15 7 输出：44 输入：1 1 2 1 1 输出：2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int wa = sc.nextInt(); int wb = sc.nextInt(); int wt = sc.nextInt(); int pa = sc.nextInt(); int pb = sc.nextInt(); // 装入货车的A货物数量至少1件，至多(wt - wb) / wa件 int minX = 1; int maxX = (wt - wb) / wa; // 记录最大利润 int ans = 0; // 枚举A货物的可能数量 for (int x = minX; x \u0026lt;= maxX; x++) { // B货物可能的总重量 int remain = wt - wa * x; if (remain % wb == 0) { // B货物的数量 int y = remain / wb; // 计算利润，保留最大利润 ans = Math.max(ans, pa * x + pb * y); } } System.out.println(ans); } 22. 根据IP查找城市\r#\r描述\n某业务需要根据终端的IP地址获取该终端归属的城市，可以根据公开的IP地址池信息查询归属城市。 地址池格式：城市名=起始IP,结束IP 起始和结束地址用英文逗号分隔，多个地址段采用英文分号分隔。如： City1=1.1.1.1,1.1.1.2;City1=1.1.1.11,1.1.1.16;City2=3.3.3.3,4.4.4.4;City3=2.2.2.2,6.6.6.6 一个城市可以有多个IP段，比如City1有2个IP段。 城市间也可能存在包含关系，如City3的IP段包含City2的IP段范围。 现在要根据输入的IP列表，返回最佳匹配的城市列表。 注：最佳匹配即包含待查询IP且长度最小的IP段， 比如例子中3.4.4.4最佳匹配是City2=3.3.3.3,4.4.4.4，5.5.5.5的最佳匹配是City3=2.2.2.2,6.6.6.6 输入描述： 第一行为城市的IP段列表，多个IP段采用英文分号 \u0026#39;;\u0026#39; 分隔，IP段列表最大不超过500000。 城市名称只包含英文字母、数字和下划线。最多不超过100000个。IP段包含关系可能有多层，但不超过100层。 第二行为查询的IP列表，多个IP采用英文逗号 \u0026#39;,\u0026#39; 分隔，最多不超过10000条。 输出描述： 最佳匹配的城市名列表，采用英文逗号分隔，城市列表长度应该跟查询的IP列表长度一致。 备注： 1. 假定用例中的所有输入均合法，IP地址均为合法的ipv4地址，满足 (1~255).(0~255).(0~255).(0~255) 的格式 2. 无论是否查到匹配正常都要输出分隔符。 举例：假如输入IP列表为IPa,IPb，两个IP均未有匹配城市，此时输出为\u0026#34;,\u0026#34;，即只有一个逗号分隔符，两个城市均为空； 输入：City1=1.1.1.1,1.1.1.2;City1=1.1.1.11,1.1.1.16;City2=3.3.3.3,4.4.4.4;City3=2.2.2.2,6.6.6.6 1.1.1.15,3.3.3.5,2.2.2.3 输出：City1,City2,City3 题解\nstatic class Range { String city; long startIpDec; long endIpDec; long ipLen; public Range(String city, String startIpStr, String endIpStr) { this.city = city; // 将IP地址转为整型 this.startIpDec = ip2dec(startIpStr); this.endIpDec = ip2dec(endIpStr); this.ipLen = this.endIpDec - this.startIpDec + 1; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); ArrayList\u0026lt;Range\u0026gt; ranges = new ArrayList\u0026lt;\u0026gt;(); // 城市IP列表 String[] cities = sc.nextLine().split(\u0026#34;;\u0026#34;); // 待查询的IP列表 String[] queryIps = sc.nextLine().split(\u0026#34;,\u0026#34;); // 提取各个城市IP列表信息 for (String city : cities) { String[] tmp = city.split(\u0026#34;[=,]\u0026#34;); ranges.add(new Range(tmp[0], tmp[1], tmp[2])); } // 遍历待查询的IP地址 StringJoiner joiner = new StringJoiner(\u0026#34;,\u0026#34;); for (String ip : queryIps) { long ipDec = ip2dec(ip); // 记录该目标IP地址的最佳匹配城市 String city = \u0026#34;\u0026#34;; // 记录最佳匹配城市IP段的长度 long minLen = Long.MAX_VALUE; // 将带查询IP与城市IP段列表逐一匹配 for (Range range : ranges) { if (ipDec \u0026gt;= range.startIpDec \u0026amp;\u0026amp; ipDec \u0026lt;= range.endIpDec \u0026amp;\u0026amp; minLen \u0026gt; range.ipLen) { city = range.city; minLen = range.ipLen; } } joiner.add(city); } System.out.println(joiner); } // IP地址转整型 public static long ip2dec(String ip) { long res = 0; String[] blocks = ip.split(\u0026#34;\\\\.\u0026#34;); for (String block : blocks) { res = (Integer.parseInt(block)) | (res \u0026lt;\u0026lt; 8); } return res; } 23. 欢乐的周末\r#\r描述\n小华和小为是很要好的朋友，他们约定周末一起吃饭。 通过手机交流，他们在地图上选择了多个聚餐地点（由于自然地形等原因，部分聚餐地点不可达）， 求小华和小为都能到达的聚餐地点有多少个？ 输入描述： 第一行输入 m 和 n（m 代表地图的长度，n 代表地图的宽度） 第二行开始具体输入地图信息，地图信息包含： 0 为通畅的道路 1 为障碍物（且仅1为障碍物） 2 为小华或者小为，地图中必定有且仅有2个 （非障碍物） 3 为被选中的聚餐地点（非障碍物） 输出描述： 可以被两方都到达的聚餐地点数量，行末无空格。 备注： 地图的长宽为 m 和 n，其中：4 ≤ m ≤ 100，4 ≤ n ≤ 100 聚餐的地点数量为 k，1＜ k ≤ 100 输入：4 4 2 1 0 3 0 1 2 1 0 3 0 0 0 0 0 0 输出：2 输入：4 4 2 1 2 3 0 1 0 0 0 1 0 0 0 1 0 0 输出：0 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); // 长度m表示行数 int m = sc.nextInt(); // 宽度n表示列数 int n = sc.nextInt(); int[][] matrix = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { matrix[i][j] = sc.nextInt(); } } System.out.println(getResult(matrix)); } public static int getResult(int[][] matrix) { int rows = matrix.length; int cols = matrix[0].length; UnionFindSet ufs = new UnionFindSet(rows * cols); // 记录小华，小为的位置 ArrayList\u0026lt;Integer\u0026gt; huawei = new ArrayList\u0026lt;\u0026gt;(); // 记录餐厅的位置 ArrayList\u0026lt;Integer\u0026gt; restaurants = new ArrayList\u0026lt;\u0026gt;(); // 上下左右四个方向偏移量 int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; for (int i = 0; i \u0026lt; rows; i++) { for (int j = 0; j \u0026lt; cols; j++) { if (matrix[i][j] != 1) { // 二维坐标(i, j) 转为 一维坐标pos int pos = i * cols + j; if (matrix[i][j] == 2) { // 收集小华，小为的位置 huawei.add(pos); } else if (matrix[i][j] == 3) { // 收集餐厅的位置 restaurants.add(pos); } for (int[] offset : offsets) { int newI = i + offset[0]; int newJ = j + offset[1]; if (newI \u0026gt;= 0 \u0026amp;\u0026amp; newI \u0026lt; rows \u0026amp;\u0026amp; newJ \u0026gt;= 0 \u0026amp;\u0026amp; newJ \u0026lt; cols \u0026amp;\u0026amp; matrix[newI][newJ] != 1) { // 如果(i,j)和（newI,newJ）位置都是非1，则合并 ufs.union(pos, newI * cols + newJ); } } } } } // 小华所在连通分量的根 int hua_fa = ufs.find(huawei.get(0)); // 小为所在连通分量的根 int wei_fa = ufs.find(huawei.get(1)); // 如果小华和小为的不属于同一个连通分量，则二人无法去往相同餐厅 if (hua_fa != wei_fa) { return 0; } // 找出和小华、小为在同一个连通分量里面的餐厅 int ans = 0; for (Integer restaurant : restaurants) { if (ufs.find(restaurant) == hua_fa) { ans++; } } return ans; } // 并查集实现 static class UnionFindSet { int[] fa; public UnionFindSet(int n) { fa = new int[n]; for (int i = 0; i \u0026lt; n; i++) fa[i] = i; } public int find(int x) { if (x != this.fa[x]) { this.fa[x] = this.find(this.fa[x]); return this.fa[x]; } return x; } public void union(int x, int y) { int x_fa = this.find(x); int y_fa = this.find(y); if (x_fa != y_fa) { this.fa[y_fa] = x_fa; } } } 24. 机器人走迷宫\r#\r描述\n1、房间有X*Y的方格组成，例如下图为6*4的大小。每一个放个以坐标(x,y)描述。 2、机器人固定从方格(0,0)出发，只能向东或者向北前进，出口固定为房间的最东北角，用例保证机器人可以从入口走到出口。 3、房间有些方格是墙壁，如(4,1),机器人不能经过那儿。 4、有些地方是一旦到达就无法走到出口的，如标记为B的方格，称之为陷阱方格。 5、有些地方是机器人无法达到的，如标记为A的方格，称之为不可达方格，不可达方格不包括墙壁所在的位置 6、如下实例图中，陷阱方格有2个，不可达方格有3个。 请为该机器人实现路径规划功能：给定房间大小，墙壁位置，请计算出陷阱方格与不可达方格分别有多少个 输入描述： 1、第一行为房间的x和y(0 ＜ x,y ≤ 1000) 2、第二行为房间中墙壁的个数N (0 ≤ N ＜ X*Y) 3、接着下面会有N行墙壁的坐标 同一行中如果有多个数据以一个空格隔开，用例保证所有的输入数据均合法，(结尾不带回车换行) 输出描述： 陷阱方格与不可达方格数量，两个信息在一行中输出，以一个空格隔开。(结尾不带回车换行) 输入：6 4 5 0 2 1 2 2 2 4 1 5 1 输出：2 3 题解\nstatic int x; static int y; static int n; static int[][] poses; static int[][] matrix; public static void main(String[] args) { Scanner sc = new Scanner(System.in); x = sc.nextInt(); // 行数 y = sc.nextInt(); // 列数 n = sc.nextInt(); // 墙数 poses = new int[n][2]; // 墙位置 for (int i = 0; i \u0026lt; n; i++) { poses[i][0] = sc.nextInt(); poses[i][1] = sc.nextInt(); } getResult(); } public static void getResult() { matrix = new int[x][y]; for (int[] pos : poses) { int i = pos[0]; int j = pos[1]; matrix[i][j] = 1; // 墙点值为1，非墙点值为0 } matrix[x - 1][y - 1] = 2; // 可达点值为2 dfs(0, 0); int trap = 0; // 陷阱数量 int unreach = 0; // 不可达点数量 for (int i = 0; i \u0026lt; x; i++) { for (int j = 0; j \u0026lt; y; j++) { if (matrix[i][j] == 0) unreach++; else if (matrix[i][j] == -1) trap++; } } System.out.println(trap + \u0026#34; \u0026#34; + unreach); } public static boolean dfs(int cx, int cy) { if (cx \u0026gt;= x || cy \u0026gt;= y) return false; if (matrix[cx][cy] == 1) return false; if (matrix[cx][cy] == -1) return false; if (matrix[cx][cy] == 2) return true; if (matrix[cx][cy] == 0) { boolean east = dfs(cx + 1, cy); boolean north = dfs(cx, cy + 1); if (east || north) { // 如果向东可达或者向北可达，则当前点可达，将值设为2 matrix[cx][cy] = 2; } else { // 如果向东，向北都不可达，则当前前也是不可达点，将值设为-1 matrix[cx][cy] = -1; } } return matrix[cx][cy] == 2; } 25. 计算疫情扩散时间\r#\r描述\n在一个地图中(地图由n*n个区域组成），有部分区域被感染病菌。 感染区域每天都会把周围（上下左右）的4个区域感染。 请根据给定的地图计算，多少天以后，全部区域都会被感染。 如果初始地图上所有区域全部都被感染，或者没有被感染区域，返回-1 输入描述： 一行N*N个数字（只包含0,1，不会有其他数字）表示一个地图，数字间用,分割，0表示未感染区域，1表示已经感染区域 每N个数字表示地图中一行，输入数据共表示N行N列的区域地图。 例如输入1,0,1,0,0,0,1,0,1，表示地图 1,0,1 0,0,0 1,0,1 输出描述： 一个整数，表示经过多少天以后，全部区域都被感染 1≤N＜200 输入：1,0,1,0,0,0,1,0,1 输出：2 说明：1天以后，地图中仅剩余中心点未被感染；2天以后，全部被感染。 输入：0,0,0,0 输出：-1 说明：无感染区域 输入：1,1,1,1,1,1,1,1,1 输出：-1 说明：全部都感染 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34;,\u0026#34;); Integer[] arr = Arrays.stream(split).map(Integer::parseInt).toArray(Integer[]::new); System.out.println(getResult(arr)); } public static int getResult(Integer[] arr) { int n = (int) Math.sqrt(arr.length); int[][] matrix = new int[n][n]; // 将矩阵中所有感染区域位置记录到queue中 LinkedList\u0026lt;Integer[]\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { matrix[i][j] = arr[i * n + j]; if (matrix[i][j] == 1) { queue.add(new Integer[]{i, j}); } } } // 全是感染区，或全是健康区 if (queue.isEmpty() || queue.size() == arr.length) { return -1; } // 健康区个数 int healthy = arr.length - queue.size(); // 上下左右偏移量 int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // day用于统计感染全部花费的时间 int day = 0; // 如果健康区个数为0，说明感染完了 while (!queue.isEmpty() \u0026amp;\u0026amp; healthy \u0026gt; 0) { // 遍历完当前queue的所有感染区，即过去一天 LinkedList\u0026lt;Integer[]\u0026gt; newQue = new LinkedList\u0026lt;\u0026gt;(); for (Integer[] tmp : queue) { int x = tmp[0], y = tmp[1]; for (int[] offset : offsets) { int newX = x + offset[0]; int newY = y + offset[1]; if (newX \u0026gt;= 0 \u0026amp;\u0026amp; newX \u0026lt; n \u0026amp;\u0026amp; newY \u0026gt;= 0 \u0026amp;\u0026amp; newY \u0026lt; n \u0026amp;\u0026amp; matrix[newX][newY] == 0) { matrix[newX][newY] = 1; healthy--; // 新增感染区加到newQue中，不影响queue的当前遍历 newQue.add(new Integer[]{newX, newY}); } } } day++; queue = newQue; } return day; } "},{"id":38,"href":"/lang2/program-design/structure-algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%9312/","title":"机试题库 - 12","section":"华为OD","content":"\r01. 简易内存池\r#\r描述\n请实现一个简易内存池Q，根据请求命令完成内存分配和释放。 内存池支持两种操作命令，REQUEST和RELEASE， REQUEST=请求的内存大小 表示请求分配指定大小内存，如果分配成功，返回分配到的内存首地址；如果内存不足，或指定的大小为0,则输出error. RELEASE=释放的内存首地址， 表示释放掉之前分配的内存，释放成功无需输出，如果释放不存在的首地址则输出error。 注意： 1.内存池总大小为100字节。 2.内存池地址分配必须是连续内存，并优先从低地址分配。 3.内存释放后可被再次分配，已释放的内存在空闲时不能被二次释放 4.不会释放已申请的内存块的中间地址， 5.释放操作只是针对首地址所对应的单个内存块进行操作，不会影响其它内存块。 输入描述： 首行为整数N，表示操作命令的个数，取值范围：N≤100. 接下来的N行，每行将给出一个操作命令，操作命令和参数之间用等号分割。 输出描述： 根据操作命令返回输出 输入：5 REQUEST=10 REQUEST=20 RELEASE=0 REQUEST=15 RELEASE=10 输出：0 10 10 题解\n// 0 表示未分配 1表示已经分配 public static final int[] RAM_ARR = new int[100]; // 存放分配过的内存的首地址及长度 static final HashMap\u0026lt;Integer, Integer\u0026gt; MAP = new HashMap\u0026lt;\u0026gt;(); public static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = sc.nextInt(); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; num; i++) { String[] strings = sc.nextLine().split(\u0026#34;=\u0026#34;); int answer = answer(strings[0], Integer.parseInt(strings[1])); if (answer != -2) { list.add(answer == -1 ? \u0026#34;error\u0026#34; : answer + \u0026#34;\u0026#34;); } } list.forEach(System.out::println); } public static int answer(String str, int num) { if (str.equals(\u0026#34;REQUEST\u0026#34;)) { if (num == 0) { return -1; } int len = 0; for (int i = 0; i \u0026lt; RAM_ARR.length; i++) { if (RAM_ARR[i] != 0) { continue; } for (int j = i; j \u0026lt; RAM_ARR.length; j++) { if (RAM_ARR[j] == 0) { len++; } else { i = len - 1; len = 0; break; } if (len == num) { for (int k = i; k \u0026lt; i + num; k++) { RAM_ARR[k] = 1; } MAP.put(i, num); return i; } } } return -1; } if (str.equals(\u0026#34;RELEASE\u0026#34;)) { if (MAP.containsKey(num)) { Integer len = MAP.get(num); MAP.remove(num); for (int i = num; i \u0026lt; len + num; i++) { RAM_ARR[i] = 0; } return -2; } else { return -1; } } return -1; } 02. 结队编程\r#\r描述\n某部门计划通过结队编程来进行项目开发， 已知该部门有 N 名员工，每个员工有独一无二的职级，每三个员工形成一个小组进行结队编程 请你按下述条件计算可能组合的小组数量。同一员工可以参加多个小组。 结队分组规则如下： 从部门中选出序号分别为 i、j、k 的3名员工，他们的职级分贝为 level[i]，level[j]，level[k]， 结队小组满足 level[i] ＜ level[j] ＜ level[k] 或者 level[i] \u0026gt; level[j] \u0026gt; level[k]， 其中 0 ≤ i ＜ j ＜ k ＜ n。 输入描述： 第一行输入：员工总数 n，1 ≤ n ≤ 6000 第二行输入：按序号依次排列的员工的职级 level，中间用空格隔开，1 ≤ level[i] ≤ 10^5 输出描述： 可能结队的小组数量 输入：4 1 2 3 4 输出：4 说明：可能结队成的组合(1,2,3)、(1,2,4)、(1,3,4)、(2,3,4) 输入：3 5 4 7 输出：0 说明：根据结队条件，我们无法为该部门组建小组 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] levels = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(n, levels)); } public static long getResult(int n, int[] levels) { long ans = 0; for (int i = 1; i \u0026lt; n - 1; i++) { int mid = levels[i]; // 左边比自己小的元素的个数 long leftSmallerCount = 0; // 左边比自己大的元素的个数 long leftBiggerCount = 0; for (int j = 0; j \u0026lt; i; j++) { if (levels[j] \u0026gt; mid) { leftBiggerCount++; } else { leftSmallerCount++; } } // 右边比自己小的元素是的个数 long rightSmallerCount = 0; // 右边比自己大的元素的个数 long rightBiggerCount = 0; for (int k = i + 1; k \u0026lt; n; k++) { if (levels[k] \u0026gt; mid) { rightBiggerCount++; } else { rightSmallerCount++; } } ans += leftSmallerCount * rightBiggerCount + leftBiggerCount * rightSmallerCount; } return ans; } 03. 九宫格按键输入\r#\r描述\n九宫格按键输入，输出显示内容，有英文和数字两个模式，默认是数字模式，数字模式直接输出数字，英文模式连续按同一个按键会依次出现这个按键上的字母，如果输入”/”或者其他字符，则循环中断。 字符对应关系如图 输入描述： 输入范围为数字 0~9 和字符’#’、’/’，输出屏幕显示，例如， 在数字模式下，输入 1234，显示 1234 在英文模式下，输入 1234，显示,adg 输出描述： #用于切换模式，默认是数字模式，执行#后切换为英文模式； /表示延迟，例如在英文模式下，输入 22/222，显示为 bc； 英文模式下，多次按同一键，例如输入 22222，显示为 b； 输入：123#222235/56 输出：123adjjm 题解\nstatic String[] dict = {\u0026#34; \u0026#34;, \u0026#34;,.\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34;}; static LinkedList\u0026lt;Character\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); static int topRepeat = 0; static boolean isEng = false; public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(getResult(sc.nextLine())); } public static String getResult(String s) { s += \u0026#34; \u0026#34;; for (int i = 0; i \u0026lt; s.length(); i++) { char c = s.charAt(i); switch (c) { case \u0026#39;#\u0026#39;: interrupt(); isEng = !isEng; break; case \u0026#39;/\u0026#39;: interrupt(); break; default: // 数字模式，直接输出数字 if (!isEng) { stack.add(c); break; } // 英文模式，需要检查栈顶 // 如果栈顶不是英文模式字符，则缓存对应字符c，并记录重复次数 if (topRepeat == 0) { stack.add(c); topRepeat++; break; } // 如果栈顶字符有重复次数 // 则此时需要比较当前按键c和之前重复的按键stack.getLast是否相同 if (c != stack.getLast()) { // 如果输入”/”或者其他字符，则循环中断 interrupt(); stack.add(c); } topRepeat++; } } StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; stack.size() - 1; i++) sb.append(stack.get(i)); return sb.toString(); } // 英文模式连续按同一个按键会依次出现这个按键上的字母，如果输入”/”或者其他字符，则循环中断 // interrupt用于处理循环中断后的逻辑 public static void interrupt() { if (!isEng || stack.isEmpty() || topRepeat == 0) return; stack.add(map(stack.removeLast(), topRepeat)); topRepeat = 0; } // 基于dict，获取一个数字c被重复repeat次后，对应的字符 public static char map(char c, int repeat) { int num = Integer.parseInt(c + \u0026#34;\u0026#34;); String s = dict[num]; int i = (repeat - 1) % s.length(); return s.charAt(i); } 04. 矩阵匹配\r#\r描述\n从一个 N * M（N ≤ M）的矩阵中选出 N 个数， 任意两个数字不能在同一行或同一列，求选出来的 N 个数中第 K 大的数字的最小值是多少。 注意：结果是第 K 大的数字的最小值 输入描述： N M K N*M矩阵范围：1 ≤ K ≤ N ≤ M ≤ 150 输出描述： N*M 的矩阵中可以选出 M! / N! 种组合数组，每个组合数组种第 K 大的数中的最小值。 无需考虑重复数字，直接取字典排序结果即可。 输入：3 4 2 1 5 6 6 8 3 4 3 6 8 6 3 输出：3 题解\nstatic int n; static int m; static int k; static int[][] matrix; public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); m = sc.nextInt(); k = sc.nextInt(); int min = 1; int max = Integer.MIN_VALUE; matrix = new int[n][m]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { matrix[i][j] = sc.nextInt(); max = Math.max(max, matrix[i][j]); } } // 二分枚举第K大值 while (min \u0026lt;= max) { // mid就是被枚举出来的N个数中的第K大值 int mid = (min + max) \u0026gt;\u0026gt; 1; // 检查mid作为N个数中第K大值时，是否存在N-K+1个不大于它的值 if (check(mid)) { max = mid - 1; } else { min = mid + 1; } } System.out.println(min); } public static boolean check(int kth) { // 利用二分图最大匹配来求解，小于等于kth（第K大值）的元素个数（即二分图最大匹配） int smallerCount = 0; // 记录每个行号的匹配成功的列号 int[] match = new int[m]; // 初始时每个行号都处于未配对状态，此时将行号配对的列号赋值为-1 Arrays.fill(match, -1); // 遍历列号，每个列号对互相心仪的行号发起配对请求 for (int i = 0; i \u0026lt; n; i++) { // 记录增广路访问过的行号 boolean[] vis = new boolean[m]; if (dfs(i, kth, match, vis)) smallerCount++; } return smallerCount \u0026gt;= n - k + 1; } public static boolean dfs(int i, int kth, int[] match, boolean[] vis) { // 列号 i 发起了配对请求 // 遍历每一个行号j for (int j = 0; j \u0026lt; m; j++) { // 如果当前行号j未被增广路探索过 // 当前行j列号i可以配对（如果行列号位置(i,j)对应矩阵元素值小于等于kth（第K大值），则可以配对） if (!vis[j] \u0026amp;\u0026amp; matrix[i][j] \u0026lt;= kth) { vis[j] = true; // 如果对应行号j未配对，或者，已配对但是配对的雷浩match[j]可以找到其他行号重新配对 if (match[j] == -1 || dfs(match[j], kth, match, vis)) { // 则当前列号i 和 行号j 可以配对 match[j] = i; return true; } } } return false; } 05. 考古学家\r#\r描述\n有一个考古学家发现一个石碑，但是很可惜发现时其已经断成多段。 有N个断口整齐的石碑碎片，为了破解石碑内容，考古学家希望有程序能帮忙计算复原后的石碑文字组合数 输入描述： 第一行输入N，N表示石碑碎片的个数 第二行依次输入石碑碎片上的文字内容S共有N组 输出描述： 输出石碑文字的组合(按照升序排列)，行尾无多余空格 备注： 如果存在石碑碎片内容完全相同，则由于碎片间的顺序变换不影响复原后的碑文内容，即相同碎片间的位置变换不影响组合。 输入：3 a b ab 输出：aabb abab abba baab baba 题解\nstatic int n; static String[] arr; public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = Integer.parseInt(sc.nextLine()); arr = sc.nextLine().split(\u0026#34; \u0026#34;); getResult(); } public static void getResult() { // 排序是为了让相同元素相邻，方便后面树层去重 Arrays.sort(arr); boolean[] used = new boolean[n]; LinkedList\u0026lt;String\u0026gt; path = new LinkedList\u0026lt;\u0026gt;(); HashSet\u0026lt;String\u0026gt; res = new HashSet\u0026lt;\u0026gt;(); dfs(used, path, res); // 输出石碑文字的组合（按照升序排列） res.stream().sorted(String::compareTo).forEach(System.out::println); } public static void dfs(boolean[] used, LinkedList\u0026lt;String\u0026gt; path, HashSet\u0026lt;String\u0026gt; res) { if (path.size() == n) { StringBuilder sb = new StringBuilder(); path.forEach(sb::append); res.add(sb.toString()); return; } for (int i = 0; i \u0026lt; n; i++) { if (used[i]) continue; // 树层去重 if (i \u0026gt; 0 \u0026amp;\u0026amp; arr[i].equals(arr[i - 1]) \u0026amp;\u0026amp; !used[i - 1]) continue; path.addLast(arr[i]); used[i] = true; dfs(used, path, res); used[i] = false; path.removeLast(); } } 06. 可以处理的最大任务数\r#\r描述\n在某个项目中有多个任务（用task数组表示）需要你进行处理，其中：task[i] = [si, ei] 你可以在 si ≤ day ≤ ei 中的任意一天处理该任务，请返回你可以处理的最大任务数。 输入描述： 第一行为任务数量 n，1 ≤ n ≤ 100000 后面 n 行表示各个任务的开始时间和终止时间，使用 si，ei 表示，1 ≤ si ≤ ei ≤ 100000 输出描述： 输出为一个整数，表示可以处理的最大任务数。 输入：3 1 1 1 2 1 3 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[][] ranges = new int[n][2]; for (int i = 0; i \u0026lt; n; i++) { ranges[i][0] = sc.nextInt(); ranges[i][1] = sc.nextInt(); } // 将所有任务按照结束时间降序 Arrays.sort(ranges, (a, b) -\u0026gt; b[1] - a[1]); // 优先队列中记录的是任务的开始时间，并且开始时间越大，优先级越高 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; b - a); // 优先队列中记录的是结束时间相同的任务的开始时间，pq_end就是优先队列中任务的相同结束时间 int pq_end = Integer.MAX_VALUE; // 最大任务数 int count = 0; for (int[] range : ranges) { // 当前任务的开始和结束时间 int start = range[0]; int end = range[1]; // 如果当前任务的结束时间 小于 优先队列中记录的任务的结束时间， // 则两个结束时间之间的间隔时间段，可以处理一些紧急任务 while (!pq.isEmpty() \u0026amp;\u0026amp; end \u0026lt; pq_end) { // 这里的紧急任务即指时间短的任务，即开始时间比较大的任务 if (pq.poll() \u0026lt;= pq_end) { // 如果紧急任务的开始时间未超过其结束时间，则可以执行 count++; pq_end--; // 一个时刻只执行一个任务 } } // 间隔时间消耗完后，优先队列中的任务的结束时间全部更新为当前任务的结束时间 pq.add(start); pq_end = end; } // 收尾处理 while (!pq.isEmpty()) { if (pq.poll() \u0026lt;= pq_end) { count++; pq_end--; } } System.out.println(count); } 07. 可以组成网络的服务器\r#\r描述\n在一个机房中，服务器的位置标识在 n*m 的整数矩阵网格中，1 表示单元格上有服务器，0 表示没有。 如果两台服务器位于同一行或者同一列中紧邻的位置，则认为它们之间可以组成一个局域网。 请你统计机房中最大的局域网包含的服务器个数。 输入描述： 第一行输入两个正整数，n和m，0＜n,m≤100 之后为n*m的二维数组，代表服务器信息 输出描述： 最大局域网包含的服务器个数。 输入：2 2 1 0 1 1 输出：3 题解\nstatic int n; static int m; static int[][] matrix; public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); m = sc.nextInt(); matrix = new int[n][m]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { matrix[i][j] = sc.nextInt(); } } System.out.println(getResult()); } public static int getResult() { int ans = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { if (matrix[i][j] == 1) ans = Math.max(ans, bfs(i, j)); } } return ans; } static int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; public static int bfs(int i, int j) { int count = 1; matrix[i][j] = 0; LinkedList\u0026lt;int[]\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.add(new int[]{i, j}); while (!queue.isEmpty()) { int[] pos = queue.removeFirst(); int x = pos[0]; int y = pos[1]; for (int[] offset : offsets) { int newX = x + offset[0]; int newY = y + offset[1]; if (newX \u0026gt;= 0 \u0026amp;\u0026amp; newX \u0026lt; n \u0026amp;\u0026amp; newY \u0026gt;= 0 \u0026amp;\u0026amp; newY \u0026lt; m \u0026amp;\u0026amp; matrix[newX][newY] == 1) { count++; matrix[newX][newY] = 0; queue.add(new int[]{newX, newY}); } } } return count; } 08. 快递员的烦恼\r#\r描述\n快递公司每日早晨，给每位快递员推送需要送到客户手中的快递以及路线信息， 快递员自己又查找了一些客户与客户之间的路线距离信息，请你依据这些信息，给快递员设计一条最短路径，告诉他最短路径的距离。 注意： 1. 不限制快递包裹送到客户手中的顺序，但必须保证都送到客户手中 2. 用例保证一定存在投递站到每位客户之间的路线，但不保证客户与客户之间有路线，客户位置及投递站均允许多次经过 3. 所有快递送完后，快递员需回到投递站 输入描述： 首行输入两个正整数n、m 接下来 n 行，输入快递公司发布的客户快递信息，格式为：客户id 投递站到客户之间的距离distance 再接下俩的 m 行，是快递员自行查找的客户与客户之间的距离信息，格式为：客户id1 客户id2 distance 在每行数据中，数据与数据之间均以单个空格分隔 规格： 0 ＜ n ≤ 10 0 ≤ m ≤ 10 0 ＜ 客户id ≤ 1000 0 ＜ distance ≤ 10000 输出描述： 最短路径距离，如无法找到，请输出-1 输入：2 1 1 1000 2 1200 1 2 300 输出：2500 输入：5 1 5 1000 9 1200 17 300 132 700 500 2300 5 9 400 输出：9200 题解\nstatic int n; static int[][] dist; static int[][] path; static int ans; public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); int m = sc.nextInt(); // floyd算法需要基于dist和path矩阵求解 // dist[i][j] 用于记录点 i-\u0026gt;j 的最短距离，初始时等价于邻接矩阵 dist = new int[n + 1][n + 1]; // path[i][j] 用于记录点 i-\u0026gt;j 最短距离情况下需要经过的中转点， // 初始时默认任意两点间无中转点，即默认path[i][j] = -1 path = new int[n + 1][n + 1]; for (int i = 0; i \u0026lt; n + 1; i++) { for (int j = 0; j \u0026lt; n + 1; j++) { // 初始时默认i,j不相连，即i,j之间距离无穷大 if (i != j) { dist[i][j] = Integer.MAX_VALUE; } path[i][j] = -1; } } // 由于本题的客户id不是顺序的，因此这里需要将客户id离散化处理 HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt;= n; i++) { int id = sc.nextInt(); int dis = sc.nextInt(); // 离散化处理 map.put(id, i); // 投递站到客户之间的距离distance dist[0][i] = dis; dist[i][0] = dis; } for (int i = 1; i \u0026lt;= m; i++) { int id1 = sc.nextInt(); int id2 = sc.nextInt(); int dis = sc.nextInt(); int i1 = map.get(id1); int i2 = map.get(id2); // 客户与客户之间的距离信息 dist[i1][i2] = dis; dist[i2][i1] = dis; } // floyd算法调用 floyd(); // ans记录经过所有点后回到出发点的最短距离 ans = Integer.MAX_VALUE; // 全排列模拟经过所有点的路径 dfs(0, 0, new boolean[n + 1], 0); System.out.println(ans); } // floyd算法求解图中任意两点之间的最短路径 public static void floyd() { for (int k = 0; k \u0026lt; n + 1; k++) { for (int i = 0; i \u0026lt; n + 1; i++) { for (int j = 0; j \u0026lt; n + 1; j++) { // newDist是经过k后，i-\u0026gt;j的距离 int newDist = dist[i][k] + dist[k][j]; // 如果newDist是i-\u0026gt;j的更短路径 if (newDist \u0026lt; dist[i][j]) { // 则更新i-\u0026gt;j的最短距离 dist[i][j] = newDist; // 且此更短距离需要经过k, path[i][j]即记录 i-\u0026gt;j 最短距离下需要经过点 k path[i][j] = k; } } } } } /** * 找一条经过所有点的最短路径，我们可以求解所有点形成的全排列， * 每一个全排列都对应一条经过所有点的路径，只是经过点的先后顺序不同 * 求某个全排列过程中，可以通过dist数组，累计上一个点i到下一个点j的最短路径dist[i][j] * * @param pre 上一个点, 初始为0，表示从快递站出发 * @param sum 当前全排列路径累计的路径权重 * @param used 全排列used数组，用于标记哪些点已使用过 * @param level 用于记录排列的长度 */ public static void dfs(int pre, int sum, boolean[] used, int level) { if (level == n) { // 此时pre是最后一个客户所在点，送完最后一个客户后， // 快递员需要回到快递站，因此最终累计路径权重为 sum + dist[pre][0] // 我们保留最小权重路径 ans = Math.min(ans, sum + dist[pre][0]); return; } for (int i = 1; i \u0026lt;= n; i++) { if (used[i]) continue; used[i] = true; dfs(i, sum + dist[pre][i], used, level + 1); used[i] = false; } } 09. 快速人名查找\r#\r描述\n给一个字符串，表示用’,’分开的人名。 然后给定一个字符串，进行快速人名查找，符合要求的输出。 快速人名查找要求︰人名的每个单词的连续前几位能组成给定字符串，一定要用到每个单词。 输入描述： 第一行是人名，用’,’分开的人名 第二行是 查找字符串 输出描述： 输出满足要求的人名 输入：zhang san,zhang san san zs 输出：zhang san 输入：zhang san san,zhang an sa,zhang hang,zhang seng,zhang sen a zhas 输出：zhang an sa,zhang seng 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] names = sc.nextLine().split(\u0026#34;,\u0026#34;); String abbr = sc.nextLine(); System.out.println(getResult(names, abbr)); } public static String getResult(String[] names, String abbr) { ArrayList\u0026lt;String\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (String name : names) { String[] parts = name.split(\u0026#34; \u0026#34;); if (parts.length \u0026gt; abbr.length()) continue; if (recursive(parts, 0, abbr, 0)) { ans.add(name); } } StringJoiner sj = new StringJoiner(\u0026#34;,\u0026#34;); for (String an : ans) { sj.add(an); } return sj.toString(); } /** * @param parts 人名组成 * @param parts_index 人名被匹配的组成部分的索引位置 * @param abbr 人名缩写 * @param abbr_index 缩写被匹配的字符的索引位置 * @return 当前人名name是否匹配对应缩写abbr */ public static boolean recursive(String[] parts, int parts_index, String abbr, int abbr_index) { if (abbr_index \u0026gt;= abbr.length()) { // 如果缩写被匹配完，且人名组成也匹配到最后一个，则说明当前人名可以匹配对应缩写 return parts_index \u0026gt;= parts.length; } // 如果缩写尚未匹配完，但是人名组成已经匹配完，则说明当前人名无法匹配对应缩写 if (parts_index \u0026gt;= parts.length) { return false; } String part_name = parts[parts_index]; for (int j = 0; j \u0026lt; part_name.length(); j++) { // 如果当前人名组成部分part_name的第 j 个字符 可以 匹配 缩写abbr的第 abbr_index个字符 if (abbr_index \u0026lt; abbr.length() \u0026amp;\u0026amp; part_name.charAt(j) == abbr.charAt(abbr_index)) { // 为了保证part_name匹配不回退， // 此时我们将缩写abbr的第abbr_index+1个字符的匹配权优先交给人名的parts_index + 1部分 if (recursive(parts, parts_index + 1, abbr, ++abbr_index)) { return true; } } else { return false; } } return false; } 10. 篮球游戏\r#\r描述\n幼儿园里有一个放倒的圆桶，它是一个线性结构，允许在桶的右边将篮球放入，可以在桶的左边和右边将篮球取出。 每个篮球有单独的编号，老师可以连续放入一个或多个篮球， 小朋友可以在桶左边或右边将篮球取出，当桶只有一个篮球的情况下，必须从左边取出。 如老师按顺序放入1、2、3、4、5 共有 5 个编号的篮球， 那么小朋友可以依次取出编号为1、2、3、4、5 或者 3、1、2、4、5 编号的篮球，无法取出 5、1、3、2、4 编号的篮球。 其中 3、1、2、4、5 的取出场景为： 连续放入1、2、3号 从右边取出3号 从左边取出1号 从左边取出2号 放入4号 从左边取出4号 放入5号 从左边取出5号 简答起见，我们以 L 表示左，R表示右，此时取出篮球的依次取出序列为“RLLLL”。 输入描述： 每次输入包含一个测试用例： 第一行的数字作为老师依次放入的篮球编号 第二行的数字作为要检查是否能够按照放入的顺序取出给定的篮球的编号，其中篮球的编号用逗号进行分隔。 其中篮球编号用逗号进行分隔。 输出描述： 对于每个篮球的取出序列，如果确实可以获取，请打印出其按照左右方向的操作取出顺序，如果无法获取则打印“NO”。 备注： 1 ≤ 篮球编号，篮球个数 ≤ 200 篮球上的数字不重复 输出的结果中 LR 必须为大写 输入：4,5,6,7,0,1,2 6,4,0,1,2,5,7 输出：RLRRRLL 输入：4,5,6,7,0,1,2 6,0,5,1,2,4,7 输出：NO 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] inputs = Arrays.stream(sc.nextLine().split(\u0026#34;,\u0026#34;)).mapToInt(Integer::parseInt).toArray(); int[] outputs = Arrays.stream(sc.nextLine().split(\u0026#34;,\u0026#34;)).mapToInt(Integer::parseInt).toArray(); // 利用队列结构模拟圆桶 LinkedList\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // outputs[index]是要被取出的篮球的编号 int index = 0; // 记录题解 StringBuilder sb = new StringBuilder(); for (int input : inputs) { // 按照放入顺序，从圆桶右边放入 queue.addLast(input); // 然后开始尝试取出 while (!queue.isEmpty()) { // 圆桶左边的篮球的编号 int left = queue.getFirst(); // 圆桶右边的篮球的编号 int right = queue.getLast(); if (left == outputs[index]) { // 优先比较圆桶左边的篮球是不是当前要取出的篮球， // 优先左边的原因是：当桶只有一个篮球的情况下，必须从左边取出 sb.append(\u0026#34;L\u0026#34;); queue.removeFirst(); index++; } else if (right == outputs[index]) { // 比较圆桶右边的篮球是不是当前要取出的篮球 sb.append(\u0026#34;R\u0026#34;); queue.removeLast(); index++; } else { // 如果圆桶左右两边都不是要取出的球，则本轮取出流程结束 break; } } } // 最终如果圆桶空了，则说明所有球都取出了，否则按照给定要求无法取出所有球 if (!queue.isEmpty()) { System.out.println(\u0026#34;NO\u0026#34;); } else { System.out.println(sb); } } 11. 连续出牌数量\r#\r描述\n有这么一款单人卡牌游戏，牌面由颜色和数字组成，颜色为红、黄、蓝、绿中的一种，数字为0-9中的一个。 游戏开始时玩家从手牌中选取一张卡牌打出，接下来如果玩家手中有和他上一次打出的手牌颜色或者数字相同的手牌， 他可以继续将该手牌打出，直至手牌打光或者没有符合条件可以继续打出的手牌。 现给定一副手牌，请找到最优的出牌策略，使打出的手牌最多。 输入描述：输入为两行 第一行是每张手牌的数字，数字由空格分隔， 第二行为对应的每张手牌的颜色，用r y b g这4个字母分别代表4种颜色，字母也由空格分隔。 手牌数量不超过10。 输出描述： 输出一个数字，即最多能打出的手牌的数量。 输入：1 4 3 4 5 r y b b r 输出：3 输入：1 2 3 4 r y b l 输出：1 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); String[] colors = sc.nextLine().split(\u0026#34; \u0026#34;); System.out.println(getResult(nums, colors)); } public static class Card { int num; char color; public Card(int num, String color) { this.num = num; this.color = color.charAt(0); } } public static int getResult(int[] nums, String[] colors) { int n = nums.length; Card[] cards = new Card[n]; for (int i = 0; i \u0026lt; n; i++) { cards[i] = new Card(nums[i], colors[i]); } int[] ans = {0}; boolean[] used = new boolean[n]; dfs(cards, used, null, 0, ans); return ans[0]; } public static void dfs(Card[] cards, boolean[] used, Card last, int count, int[] ans) { ans[0] = Math.max(ans[0], count); for (int i = 0; i \u0026lt; cards.length; i++) { if (used[i]) continue; Card cur = cards[i]; if (last != null \u0026amp;\u0026amp; last.num != cur.num \u0026amp;\u0026amp; last.color != cur.color) { continue; } used[i] = true; dfs(cards, used, cur, count + 1, ans); used[i] = false; } } 12. 两个字符串间的最短路径问题\r#\r描述\n给定两个字符串，分别为字符串 A 与字符串 B。 例如 A字符串为 \u0026#34;ABCABBA\u0026#34;，B字符串为 \u0026#34;CBABAC\u0026#34; 可以得到下图 m * n 的二维数组， 定义原点为(0,0)，终点为(m,n)，水平与垂直的每一条边距离为1，映射成坐标系如下图。 从原点 (0,0) 到 (0,A) 为水平边，距离为1，从 (0,A) 到 (A,C) 为垂直边，距离为1； 假设两个字符串同一位置的两个字符相同，则可以作一个斜边，如 (A,C) 到 (B,B) 最短距离为斜边，距离同样为1。 作出所有的斜边如下图，(0,0) 到 (B,B) 的距离为：1 个水平边 + 1 个垂直边 + 1 个斜边 = 3。 根据定义可知，原点到终点的最短距离路径如下图红线标记，最短距离为9： 输入描述： 空格分割的两个字符串 A 与字符串 B 字符串不为\u0026#34;空串\u0026#34; 字符格式满足正则规则：[A-Z] 字符串长度小于 10000 输出描述： 原点到终点的最短距离 输入：ABC ABC 输出：3 输入：ABCABBA CBABAC 输出：9 题解\nstatic String A; static String B; static int m; static int n; public static void main(String[] args) { Scanner sc = new Scanner(System.in); A = sc.next(); B = sc.next(); m = B.length(); n = A.length(); System.out.println(getResult()); } public static int getResult() { // 初始时preRow记录第一行上各点到(0,0)点的最短距离，即为(0,0) -\u0026gt; (0,j) 的直线路径 int[] preRow = new int[n + 1]; for (int j = 0; j \u0026lt;= n; j++) { preRow[j] = j; } // 初始时curRow记录第二行上各点到(0,0)点的最短距离 int[] curRow = new int[n + 1]; for (int i = 1; i \u0026lt;= m; i++) { // curRow[0]是指 (i, 0)点 到 (0,0)点 的最短距离，即为(0,0) -\u0026gt; (i, 0) 的直线路径 curRow[0] = i; for (int j = 1; j \u0026lt;= n; j++) { if (A.charAt(j - 1) == B.charAt(i - 1)) { // 如果可以走斜线，则选走斜线的点 curRow[j] = preRow[j - 1] + 1; } else { // 如果不能走斜线，则从当前点的上方点、左方点中选择一个较小值 curRow[j] = Math.min(preRow[j], curRow[j - 1]) + 1; } } // 压缩 System.arraycopy(curRow, 0, preRow, 0, n + 1); } return curRow[n]; } 13. 路口最短时间问题\r#\r描述\n假定街道是棋盘型的，每格距离相等，车辆通过每格街道需要时间均为 timePerRoad； 街道的街口（交叉点）有交通灯，灯的周期 T（=lights[row][col]）各不相同； 车辆可直行、左转和右转，其中直行和左转需要等相应 T 时间的交通灯才可通行，右转无需等待。 现给出 n * m 个街口的交通灯周期，以及起止街口的坐标，计算车辆经过两个街口的最短时间。 其中： 起点和终点的交通灯不计入时间，且可以在任意方向经过街口 不可超出 n * m 个街口，不可跳跃，但边线也是道路（即：lights[0][0] -\u0026gt; lights[0][1] 是有效路径） 输入描述： 第一行输入 n 和 m，以空格分隔 之后 n 行输入 lights矩阵，矩阵每行m个整数，以空格分隔 之后一行输入 timePerRoad 之后一行输入 rowStart colStart，以空格分隔 最后一行输入 rowEnd colEnd，以空格分隔 输出描述： lights[rowStart][colStart] 与 lights[rowEnd][colEnd] 两个街口之间的最短通行时间 输入：3 3 1 2 3 4 5 6 7 8 9 60 0 0 2 2 输出：245 题解\nstatic int n; static int m; static int[][] lights; static int timePreRoad; static int rowStart; static int colStart; static int rowEnd; static int colEnd; static boolean[][] visited; static int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); m = sc.nextInt(); lights = new int[n][m]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { lights[i][j] = sc.nextInt(); } } timePreRoad = sc.nextInt(); rowStart = sc.nextInt(); colStart = sc.nextInt(); rowEnd = sc.nextInt(); colEnd = sc.nextInt(); System.out.println(getResult()); } public static int getResult() { // 记录访问过的点，防止走回路 visited = new boolean[n][m]; // 初始时起点位置标记为访问过 visited[rowStart][colStart] = true; // 记录起点到终点的最小花费时间，这里minCost定义为数组， // 是为了其在dfs函数调用结束后，不会被释放内存，因为它是引用类型变量 int[] minCost = {Integer.MAX_VALUE}; // 开始暴搜所有起点到终点的路径 dfs(rowStart, colStart, -1, -1, 0, minCost); return minCost[0]; } /** * 暴力搜索 * * @param curX 当前位置横坐标 * @param curY 当前位置纵坐标 * @param preX 上一个位置横坐标 * @param preY 上一个位置纵坐标 * @param cost 到达当前位置花费的时间 * @param minCost 记录起点到终点的最小花费时间 */ public static void dfs(int curX, int curY, int preX, int preY, int cost, int[] minCost) { // 如果到达当前前花费的时间cost 达到了 已知minCost，那么后续路径就没必要探索了，因为必然要比minCost大 if (cost \u0026gt;= minCost[0]) { return; } // 如果当前点是终点，且花费的时间cost更少，则更新minCost if (curX == rowEnd \u0026amp;\u0026amp; curY == colEnd) { minCost[0] = cost; return; } // 否则，从当前位置的四个方向继续探索路径 for (int[] offset : offsets) { // 新位置 int nextX = curX + offset[0]; int nextY = curY + offset[1]; // 新位置越界或者已经访问过，则不能访问，继续其他方向探索 if (nextX \u0026lt; 0 || nextX \u0026gt;= n || nextY \u0026lt; 0 || nextY \u0026gt;= m || visited[nextX][nextY]) continue; // 标记新位置访问过 visited[nextX][nextY] = true; // 根据pre,cur,next三点，判断拐弯方向 int direction = getDirection(preX, preY, curX, curY, nextX, nextY); // cur到达next位置必须要增加timePreRoad个时间 int increment = timePreRoad; // preX=-1, preY=-1 表示pre位置不存在，此时探索下一个位置不需要花费等待周期 if (preX \u0026gt;= 0 \u0026amp;\u0026amp; preY \u0026gt;= 0 \u0026amp;\u0026amp; direction \u0026gt;= 0) { // pre位置存在，且cur-\u0026gt;next是左拐或者直行，则需要增加当前位置对应的等待周期时间 increment += lights[curX][curY]; } // 递归进入新位置 dfs(nextX, nextY, curX, curY, cost + increment, minCost); // 回溯 visited[nextX][nextY] = false; } } /** * 根据三点坐标，确定拐弯方向 * * @param preX 前一个点横坐标 * @param preY 前一个点纵坐标 * @param curX 当前点横坐标 * @param curY 当前点纵坐标 * @param nextX 下一个点横坐标 * @param nextY 下一个点纵坐标 * @return cur到next的拐弯方向， \u0026gt;0 表示向左拐， ==0 表示直行（含调头）， \u0026lt;0 表示向右拐 */ public static int getDirection(int preX, int preY, int curX, int curY, int nextX, int nextY) { // 向量 pre-\u0026gt;cur int dx1 = curX - preX; int dy1 = curY - preY; // 向量 cur-\u0026gt;next int dx2 = nextX - curX; int dy2 = nextY - curY; // 两个向量的叉积 \u0026gt;0 表示向左拐， ==0 表示直行（含调头）， \u0026lt;0 表示向右拐 return dx1 * dy2 - dx2 * dy1; } 14. 没有回文串\r#\r描述\n回文串的定义：正读和反读都一样的字符串。 现在已经存在一个不包含回文串的字符串，字符串的字符都是在英语字母的前N个,且字符串不包含任何长度大于等于2的回文串； 请找出下一个字典序的不包含回文串的、字符都是在英语字母的前N个、且长度相同的字符串。 如果不存在，请输出NO。 输入描述：输入包括两行。 第一行有一个整数:N（1≤N≤26），表示字符串的每个字符范围都是前N的英语字母。 第二行输入一个字符串S（输入长度≤10000），输入保证这个字符串是合法的并且没有包含回文串。 输出描述： 输出下一个字典序的不包含回文串的、字符都是在英语字母的前N个、且长度相同的字符串； 如果不存在,请输出”NO“。 输入：3 cba 输出：NO 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); String s = sc.next(); System.out.println(getResult(n, s)); } /** * @param n 字符串的每个字符范围都是前N的英语字母（1\u0026lt;=N\u0026lt;=26） * @param s 合法的并且没有包含回文串的字符串（长度\u0026lt;=10000） */ public static String getResult(int n, String s) { // 将输入的字符串转化为ASCII数组 char[] chars = s.toCharArray(); // 每一位上的最大ASCII值 char limit = (char) (\u0026#39;a\u0026#39; + n - 1); // 当前位是否处于回退检查状态 boolean back = false; // 从最低位开始检查 int i = chars.length - 1; while (i \u0026gt;= 0) { // 如果当前位还有新增空间 if (chars[i] \u0026lt; limit) { if (!back) { // 如果当前位不是回退检查状态,则当前位ASCII+1 chars[i] += 1; } else { // 如果当前位是回退检查状态, 则重置back back = false; } // 避免出现 *abb* 这种情况 if (i - 1 \u0026gt;= 0 \u0026amp;\u0026amp; chars[i] == chars[i - 1]) continue; // 避免出现 *aba* 这种情况 if (i - 2 \u0026gt;= 0 \u0026amp;\u0026amp; chars[i] == chars[i - 2]) continue; // 如果都没有出现上面两个情况： if (i == chars.length - 1) { // 当前检查位是最低位，则说明当前字符串不含回文串, 可以直接返回当前字符串 return new String(chars); } // 当前检查位不是最低位，则只完成了高位的回文检查，还要回退到低位检查 i++; // 由于回退到了低位，则标记当前i指向的位置为回退检查状态，即检查时不进行ASCII+1操作 back = true; } else { // 当前位没有新增空间了, 因此i位（低位）变为\u0026#39;a\u0026#39;, i-1位（高位）+ 1 chars[i] = \u0026#39;a\u0026#39;; i--; } } return \u0026#34;NO\u0026#34;; } 15. 迷宫问题\r#\r描述\n定义一个二维数组 N*M ，如 5 × 5 数组下所示： int maze[5][5] = { 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, }; 它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。 入口点为[0,0],既第一格是可以走的路。 数据范围： 2≤n,m≤10 ， 输入的内容只包含 0≤val≤1。 输入描述： 输入两个整数，分别表示二维数组的行数，列数。 再输入相应的数组，其中的1表示墙壁，0表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。 输出描述： 左上角到右下角的最短路径，格式如样例所示。 输入：5 5 0 1 0 0 0 0 1 1 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0 输出：(0,0) (1,0) (2,0) (2,1) (2,2) (2,3) (2,4) (3,4) (4,4) 题解\nstatic int n; // 矩阵行数 static int m; // 矩阵列数 static int[][] matrix; // 矩阵 public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); m = sc.nextInt(); matrix = new int[n][m]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { matrix[i][j] = sc.nextInt(); } } getResult(); } // 点类 static class Pos { int x; // 当前点的横坐标 int y; // 当前点的纵坐标 Pos pre; // 当前点的上一个点（此属性用于形成路径链） public Pos(int x, int y, Pos pre) { this.x = x; this.y = y; this.pre = pre; } } public static void getResult() { // 广搜队列 LinkedList\u0026lt;Pos\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // 将（0，0）位置标记为“走过状态”，即将元素值设为2 matrix[0][0] = 2; // 将走过的点加入队列 queue.add(new Pos(0, 0, null)); // 上下左右偏移量 int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 广搜 while (queue.size() \u0026gt; 0) { // 当前点 Pos cur = queue.removeFirst(); // 遍历当前点的上、下、左、右方向的新点 for (int[] offset : offsets) { // 新点的坐标 int newX = cur.x + offset[0]; int newY = cur.y + offset[1]; // 如果新点不越界，且未被访问过，且不是墙， 则新点可以访问 if (newX \u0026gt;= 0 \u0026amp;\u0026amp; newX \u0026lt; n \u0026amp;\u0026amp; newY \u0026gt;= 0 \u0026amp;\u0026amp; newY \u0026lt; m \u0026amp;\u0026amp; matrix[newX][newY] == 0) { // 将新点状态设为走过 matrix[newX][newY] = 2; // 将新点和上一个点关联，形成路径链 Pos next = new Pos(newX, newY, cur); queue.add(next); // 如果新点就是终点，那么则说明找到了起点到终点的路径 if (newX == n - 1 \u0026amp;\u0026amp; newY == m - 1) { // 打印路径 printPath(next); // 结束查找 return; } } } } } public static void printPath(Pos cur) { // 这里采用递归打印，保证打印顺序是起点到终点 if (cur.pre != null) { // 递归的作用是优先打印pre点，pre点打印完，回溯打印cur点 printPath(cur.pre); } System.out.println(\u0026#34;(\u0026#34; + cur.x + \u0026#34;,\u0026#34; + cur.y + \u0026#34;)\u0026#34;); } 16. 模拟目录管理功能\r#\r描述\n实现一个模拟目录管理功能的软件，输入一个命令序列，输出最后一条命令运行结果。 支持命令： 1. 创建目录命令：mkdir 目录名称， 如 mkdir abc 为在当前目录创建abc目录，如果已存在同名目录则不执行任何操作。此命令无输出。 2. 进入目录命令：cd 目录名称， 如 cd abc 为进入abc目录，如果目录不存在则不执行任何操作。此命令无输出。 特别地，cd .. 为返回上级目录 3. 查看当前所在路径命令：pwd，输出当前路径字符串。 约束： 1. 目录名称仅支持小写字母；mkdir 和 cd 命令的参数仅支持单个目录，如：mkdir abc 和 cd abc； 不支持嵌套路径和绝对路径，如 mkdir abc/efg，cd abc/efg，mkdir /abc/efg，cd /abc/efg 是不支持的。 2. 目录符号为/，根目录/作为初始目录。 3. 任何不符合上述定义的无效命令不做任何处理并且无输出。 输入描述： 输入 N 行字符串，每一行字符串是一条命令。 输出描述： 输出最后一条命令运行结果字符串。 备注： 命令行数限制100行以内，目录名称限制10个字符以内。 输入：mkdir abc cd abc pwd 输出：/abc/ 说明：在根目录创建一个abc的目录并进入abc目录中查看当前目录路径，输出当前路径/abc/。 题解\nstatic class TreeNode { String curDicName; TreeNode father; HashMap\u0026lt;String, TreeNode\u0026gt; children; public TreeNode(String curDicName, TreeNode father) { this.curDicName = curDicName; this.father = father; this.children = new HashMap\u0026lt;\u0026gt;(); } } static class Tree { TreeNode root; TreeNode cur; public Tree() { // root是根目录，根目录 / 作为初始目录 this.root = new TreeNode(\u0026#34;/\u0026#34;, null); // cur用于指向当前正在操作的目录 this.cur = root; } public void mkdir(String childDicName) { // mkdir 目录名称，如 mkdir abc 为在当前目录创建abc目录，如果已存在同名目录则不执行任何操作 TreeNode node = new TreeNode(childDicName + \u0026#34;/\u0026#34;, this.cur); this.cur.children.putIfAbsent( childDicName, node); } public void cd(String dicName) { if (dicName.equals(\u0026#34;..\u0026#34;)) { // cd .. 为返回上级目录，如果目录不存在则不执行任何操作 if (this.cur.father != null) { // cur 变更指向上级目录 this.cur = this.cur.father; } } else { // cd 目录名称，如 cd abc 为进入abc目录，如果目录不存在则不执行任何操作 if (this.cur.children.containsKey(dicName)) { // cur 变更指向下级目录 this.cur = this.cur.children.get(dicName); } } } public String pwd() { // 输出当前路径字符串 StringBuilder sb = new StringBuilder(); // 倒序路径，即不停向上找父目录 TreeNode cur = this.cur; while (cur != null) { // 头插目录名，保证路径中目录层级正确 sb.insert(0, cur.curDicName); cur = cur.father; } return sb.toString(); } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); // 初始化目录结构 Tree tree = new Tree(); // 记录最后一条命令的输出 String lastCommandOutPut = \u0026#34;\u0026#34;; outer: while (sc.hasNextLine()) { String line = sc.nextLine(); if (line.isEmpty()) break; String[] tmp = line.split(\u0026#34; \u0026#34;); String cmd_key = tmp[0]; if (cmd_key.equals(\u0026#34;pwd\u0026#34;)) { // pwd 命令不需要参数 if (tmp.length != 1) continue; lastCommandOutPut = tree.pwd(); } else if (cmd_key.equals(\u0026#34;mkdir\u0026#34;) || cmd_key.equals(\u0026#34;cd\u0026#34;)) { // 约束：mkdir 和 cd 命令的参数仅支持单个目录，如：mkdir abc 和 cd abc if (tmp.length != 2) continue; // 目录名 String cmd_val = tmp[1]; if (!(cmd_key.equals(\u0026#34;cd\u0026#34;) \u0026amp;\u0026amp; cmd_val.equals(\u0026#34;..\u0026#34;))) { // 目录名约束校验 // 约束：目录名称仅支持小写字母 // 约束：不支持嵌套路径和绝对路径， // 关于嵌套路径和绝对路径， // 我简单理解就是cmd_val含有\u0026#39;/\u0026#39;字符，可以被小写字母判断涵盖住 for (int i = 0; i \u0026lt; cmd_val.length(); i++) { char c = cmd_val.charAt(i); if (c \u0026lt; \u0026#39;a\u0026#39; || c \u0026gt; \u0026#39;z\u0026#39;) continue outer; } } if (cmd_key.equals(\u0026#34;mkdir\u0026#34;)) { tree.mkdir(cmd_val); // 题目进要求输出最后一个命令的运行结果， // 因此，对于无输出的命令，我认为需要覆盖掉前面的命令的输出结果 lastCommandOutPut = \u0026#34;\u0026#34;; } else { tree.cd(cmd_val); lastCommandOutPut = \u0026#34;\u0026#34;; } } } System.out.println(lastCommandOutPut); } 17. 模拟数据序列化传输\r#\r描述\n模拟一套简化的序列化传输方式，请实现下面的数据编码与解码过程 1. 编码前数据格式为 [位置,类型,值]，多个数据的时候用逗号分隔，位置仅支持数字，不考虑重复等场景； 类型仅支持：Integer / String / Compose（Compose的数据类型表示该存储的数据也需要编码） 2. 编码后数据参考图示，数据区的格式是：位置#类型#长度#数据， 类型存储需要编码，Integer-\u0026gt;0；String-\u0026gt;1；Compose-\u0026gt;2，长度是指数据的字符长度；数据仅允许数字、大小写字母、空格。 3. 输入的编码字符长度不能超过1000，一个数据的格式错误，则解析剩下数据，其他错误输出ENCODE_ERROR。 4. 输入的解码字符不能超过1000，数据区异常则跳过继续解析剩余数据区，其他异常输出DECODE_ERROR。 输入描述： 第一行是命令，1表示编码，2表示解码 第二行输入待编码、解码的字符 数据最多嵌套10层，[1,Compose,[1,String,Second]] 为2层嵌套。 输出描述： 如果输入要求是编码，则输出编码结果； 如果输入要求是解码，则输出解码结果； 当异常时输出对应的错误字符。 输入：1 [1,String,I am Mary],[2,Integer,23],[3,Long,1000000],[4,Compose,[1,String,I am Kitty],[2,Integer,44]] 输出：1#1#9#I am Mary2#0#2#234#2#25#1#1#10#I am Kitty2#0#2#44 输入：2 1#1#9#I am Mary2#0#2#233#0#3#8794#2#25#1#1#10#I am Kitty2#0#2#44 输出：[I,String,I am Mary],[2,Integer,23],[3,Integer,879],[4,Compose,[1,String,I am Kitty],[2,Integer,44]] 题解\n// 编码时，类型 -\u0026gt; 数值 static HashMap\u0026lt;String, String\u0026gt; type2num = new HashMap\u0026lt;\u0026gt;(); // 解码时，数值 -\u0026gt; 类型 static HashMap\u0026lt;String, String\u0026gt; num2type = new HashMap\u0026lt;\u0026gt;(); static Pattern num_RegExp = Pattern.compile(\u0026#34;^\\\\d+$\u0026#34;); static Pattern str_RegExp = Pattern.compile(\u0026#34;^[0-9a-zA-Z\\\\s]+$\u0026#34;); public static void main(String[] args) { Scanner sc = new Scanner(System.in); int command = Integer.parseInt(sc.nextLine()); String str = sc.nextLine(); // 编码时，类型 -\u0026gt; 数值 type2num.put(\u0026#34;Integer\u0026#34;, \u0026#34;0\u0026#34;); type2num.put(\u0026#34;String\u0026#34;, \u0026#34;1\u0026#34;); type2num.put(\u0026#34;Compose\u0026#34;, \u0026#34;2\u0026#34;); // 解码时，数值 -\u0026gt; 类型 num2type.put(\u0026#34;0\u0026#34;, \u0026#34;Integer\u0026#34;); num2type.put(\u0026#34;1\u0026#34;, \u0026#34;String\u0026#34;); num2type.put(\u0026#34;2\u0026#34;, \u0026#34;Compose\u0026#34;); switch (command) { case 1: System.out.println(encode(str)); break; case 2: try { System.out.println(decode(str)); } catch (Exception e) { // 待解码字符串如果解码过程中发生了异常，则说明格式或者嵌套关系存在问题，则此时报错 System.out.println(\u0026#34;DECODE_ERROR\u0026#34;); } break; } } // 校验待编码的字符串的格式 public static boolean check_encode_str(String str) { // 这里通过栈结构检查代编码字符串中[,]字符的闭合 LinkedList\u0026lt;Character\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; str.length(); i++) { char c = str.charAt(i); if (c == \u0026#39;]\u0026#39;) { while (!stack.isEmpty() \u0026amp;\u0026amp; stack.getLast() != \u0026#39;[\u0026#39;) { stack.removeLast(); } if (stack.isEmpty()) { return false; } else { stack.removeLast(); } } else { stack.addLast(c); } } return stack.isEmpty(); } public static boolean check_encoded(String pos, String type, String data) { if (!num_RegExp.matcher(pos).find()) { return false; } if (!type2num.containsKey(type)) { return false; } if (\u0026#34;Integer\u0026#34;.equals(type)) { return num_RegExp.matcher(data).find(); } else if (\u0026#34;String\u0026#34;.equals(type)) { return str_RegExp.matcher(data).find(); } return true; } // 编码 public static String encode(String s) { // 去除数据与数据之间的逗号后 s = s.replaceAll(\u0026#34;],\\\\[\u0026#34;, \u0026#34;][\u0026#34;); // 待编码字符串的格式校验 if (!check_encode_str(s)) { return \u0026#34;ENCODE_ERROR\u0026#34;; } // 由于后面我想用正则匹配取出字符串中 \u0026#34;[位置,类型,值]\u0026#34; 信息，而 \u0026#39;[\u0026#39;, \u0026#39;]\u0026#39; 字符又是正则表达式的元字符 // 因此为了简单实现正则，这里先将待编码字符串str中所有 \u0026#39;[\u0026#39; 替换为 \u0026#39;\u0026lt;\u0026#39;, 所有 \u0026#39;]\u0026#39; 替换为 \u0026#39;\u0026gt;\u0026#39; s = s.replaceAll(\u0026#34;\\\\[\u0026#34;, \u0026#34;\u0026lt;\u0026#34;).replaceAll(\u0026#34;]\u0026#34;, \u0026#34;\u0026gt;\u0026#34;); // 该正则用于匹配出待编码字符串中 \u0026#34;\u0026lt;位置,类型,值\u0026gt;\u0026#34; Pattern p = Pattern.compile(\u0026#34;\u0026lt;([^\u0026lt;\u0026gt;]+)\u0026gt;\u0026#34;); while (true) { Matcher m = p.matcher(s); if (!m.find()) break; // m.group(0) 是正则匹配到的完整子串 \u0026#34;\u0026lt;位置,类型,值\u0026gt;\u0026#34; // m.group(1)用于获取是第一个正则捕获组，所谓正则捕获组， // 即正则表达式中()中的正则能匹配到的内容， // 如上正则捕获组即为：[^\u0026lt;\u0026gt;]+, 匹配到的内容是：\u0026#34;位置,类型,值\u0026#34; String[] tmp = m.group(1).split(\u0026#34;,\u0026#34;); String pos = tmp[0]; String type = tmp[1]; String data = tmp[2]; // sj记录编码内容 String encodeStr = \u0026#34;\u0026#34;; if (check_encoded(pos, type, data)) { encodeStr = pos + \u0026#34;#\u0026#34; + type2num.get(type) + \u0026#34;#\u0026#34; + data.length() + \u0026#34;#\u0026#34; + data; } s = s.replace(m.group(0), encodeStr); // 将匹配到的内容 替换为 编码后的内容 } return s; } public static boolean check_decoded(String pos, String type, String data) { if (!num_RegExp.matcher(pos).find()) { return false; } if (!num2type.containsKey(type)) { return false; } if (\u0026#34;0\u0026#34;.equals(type)) { return num_RegExp.matcher(data).find(); } else if (\u0026#34;1\u0026#34;.equals(type)) { return str_RegExp.matcher(data).find(); } return true; } // 解码 public static String decode(String str) { // 解码有如下难点： // 1、各数据区之间没有分隔符，即无法直接分离出各个数据区 // 2、Compose类型数据区的\u0026#34;数据\u0026#34;部分也是一个或多个数据区组合 // 我这里直接将待解码字符串str按照\u0026#39;#\u0026#39;分割, 并加入到队列中, 方便头部出队 LinkedList\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); Collections.addAll(queue, str.split(\u0026#34;#\u0026#34;)); // res记录解码后的内容 StringJoiner res = new StringJoiner(\u0026#34;,\u0026#34;); // 如果队列不空，则继续循环 while (!queue.isEmpty()) { // 如果待解码字符串是合法的，则： // 第一个#分割出来的内容认定为当前数据区的pos String pos = queue.removeFirst(); // 第二个#分割出来的内容认定为当前数据区的type String type = queue.removeFirst(); // 第三个#分割出来的内容认定为当前数据区的len int len = Integer.parseInt(queue.removeFirst()); // 剩余部分重新以#拼接 String remain = String.join(\u0026#34;#\u0026#34;, queue); queue.clear(); // remain字符串的 [0,len) 部分作为当前数据区的data信息 String data = remain.substring(0, len); if (remain.length() \u0026gt; len) { // remain字符串的 [len,end) 部分是其他数据区，按照#分割后重新入队 Collections.addAll(queue, remain.substring(len).split(\u0026#34;#\u0026#34;)); } if (\u0026#34;2\u0026#34;.equals(type)) { data = decode(data); } // pos, type, data都合法则进行解法 if (check_decoded(pos, type, data)) { // 解码 res.add(\u0026#34;[\u0026#34; + pos + \u0026#34;,\u0026#34; + num2type.get(type) + \u0026#34;,\u0026#34; + data + \u0026#34;]\u0026#34;); } } return res.toString(); } 18. 攀登者2\r#\r描述\n攀登者喜欢寻找各种地图，并且尝试攀登到最高的山峰。 地图表示为一维数组，数组的索引代表水平位置，数组的元素代表相对海拔高度。其中数组元素0代表地面。 一个山脉可能有多座山峰(高度大于相邻位置的高度，或在地图边界且高度大于相邻的高度)。 例如：[0,1,2,4,3,1,0,0,1,2,3,1,2,1,0]，代表如下图所示的地图，地图中有两个山脉位置分别为 1,2,3,4,5 和 8,9,10,11,12,13，最高峰高度分别为 4,3。最高峰位置分别为3,10。 登山时会消耗登山者的体力(整数)， 1. 上山时，消耗相邻高度差两倍的体力 2. 下山时，消耗相邻高度差一倍的体力 3. 平地不消耗体力 4. 登山者体力消耗到零时会有生命危险。 例如，上图所示的山峰： 从索引0，走到索引1，高度差为1，需要消耗 2 * 1 = 2 的体力， 从索引2，走到索引3，高度差为2，需要消耗 2 * 2 = 4 的体力。 从索引3，走到索引4，高度差为1，需要消耗 1 * 1 = 1 的体力。 攀登者想要评估一张地图内有多少座山峰可以进行攀登，且可以安全返回到地面，且无生命危险。 例如上图中的数组，有3个不同的山峰，登上位置在3的山可以从位置0或者位置6开始，从位置0登到山顶需要消耗体力 1 * 2 + 1 * 2 + 2 * 2 = 8，从山顶返回到地面0需要消耗体力 2 * 1 + 1 * 1 + 1 * 1 = 4 的体力，按照登山路线 0 → 3 → 0 需要消耗体力12。攀登者至少需要12以上的体力（大于12）才能安全返回。 输入描述： 第一行输入为地图一维数组 第二行输入为攀登者的体力 输出描述： 确保可以安全返回地面，且无生命危险的情况下，地图中有多少山峰可以攀登。 输入：0,1,4,3,1,0,0,1,2,3,1,2,1,0 13 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] heights = Arrays.stream(sc.nextLine().split(\u0026#34;,\u0026#34;)).mapToInt(Integer::parseInt).toArray(); int strength = Integer.parseInt(sc.nextLine()); System.out.println(getResult(heights, strength)); } // 算法实现（本题实际考试为核心代码模式，因此考试时只需要写出此函数实现即可） public static int getResult(int[] heights, int strength) { // 记录可攀登的山峰索引 HashSet\u0026lt;Integer\u0026gt; idxs = new HashSet\u0026lt;\u0026gt;(); // 正向攀登 climb(heights, strength, idxs, true); // 逆序攀登 reverse(heights); climb(heights, strength, idxs, false); return idxs.size(); } public static void climb(int[] heights, int strength, HashSet\u0026lt;Integer\u0026gt; idxs, boolean direction) { // 找到第一个地面位置 int j = 0; while (j \u0026lt; heights.length \u0026amp;\u0026amp; heights[j] != 0) { j++; } int cost = 0; // 攀登体力总消耗（包括上山，下山） // int upCost = 0; // 上山体力消耗 // int downCost = 0; // 下山体力消耗 // 开始攀登 for (int i = j + 1; i \u0026lt; heights.length; i++) { // 如果遇到了新的地面，则从新的地面位置重新计算攀登消耗的体力 if (heights[i] == 0) { cost = 0; // upCost = 0; // downCost = 0; continue; } int diff = heights[i] - heights[i - 1]; // diff记录高度差 if (diff \u0026gt; 0) { // 如果过程是上坡 cost += diff * 3; // upCost += diff * 2; // 则上山时，体力消耗 = 高度差 * 2 // downCost += diff; // 相反的下山时，体力消耗 = 高度差 * 1 // 由于 height[i] \u0026gt; heights[i-1]，因此如果 height[i] \u0026gt; heights[i+1] 的话，位置 i 就是山顶 if (i + 1 \u0026gt;= heights.length || heights[i] \u0026gt; heights[i + 1]) { // 计算攀登此山顶的上山下山消耗的体力和 if (cost \u0026lt; strength) { // if (upCost + downCost \u0026lt;= strength) { // 如果小于自身体力，则可以攀登 if (direction) { idxs.add(i); } else { // 需要注意，逆序heights数组后，我们对于的山峰位置需要反转 idxs.add(heights.length - i - 1); } } } } else if (diff \u0026lt; 0) { // 如果过程是下坡 cost -= diff * 3; // upCost -= diff; // 则上山时，体力消耗 = 高度差 * 1 // downCost -= diff * 2; // 相反的下山时，体力消耗 = 高度差 * 2 // heights[i] \u0026lt; heights[i-1]，因此位置i不可能是山顶 } } } public static void reverse(int[] nums) { int i = 0; int j = nums.length - 1; while (i \u0026lt; j) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; i++; j--; } } 19. 启动多任务排序\r#\r描述\n一个应用启动时，会有多个初始化任务需要执行，并且任务之间有依赖关系， 例如A任务依赖B任务，那么必须在B任务执行完成之后，才能开始执行A任务。 现在给出多条任务依赖关系的规则，请输入任务的顺序执行序列，规则采用贪婪策略，即一个任务如果没有依赖的任务，则立刻开始执行，如果同时有多个任务要执行，则根据任务名称字母顺序排序。 例如：B任务依赖A任务，C任务依赖A任务，D任务依赖B任务和C任务，同时，D任务还依赖E任务。那么执行任务的顺序由先到后是： A任务，E任务，B任务，C任务，D任务 输入描述： 输入参数每个元素都表示任意两个任务之间的依赖关系，输入参数中符号\u0026#34;-\u0026gt;\u0026#34;表示依赖方向 例如：A-\u0026gt;B，表示A依赖B，多个依赖之间用单个空格分隔 输出描述： 输出排序后的启动任务列表，多个任务之间用单个空格分隔 输入：A-\u0026gt;B C-\u0026gt;B 输出：B A C 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); String[][] relations =Arrays.stream(split).map(s -\u0026gt; s.split(\u0026#34;-\u0026gt;\u0026#34;)).toArray(String[][]::new); HashMap\u0026lt;String, Integer\u0026gt; inDegree = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;String, ArrayList\u0026lt;String\u0026gt;\u0026gt; next = new HashMap\u0026lt;\u0026gt;(); for (String[] relation : relations) { // a依赖b, 即b执行完，才能执行a String a = relation[0]; String b = relation[1]; // b的入度不变 inDegree.put(b, inDegree.getOrDefault(b, 0)); // a的入度+1 inDegree.put(a, inDegree.getOrDefault(a, 0) + 1); // b的后继节点集合添加a next.putIfAbsent(b, new ArrayList\u0026lt;\u0026gt;()); next.get(b).add(a); // a的后继节点集合不变 next.putIfAbsent(a, new ArrayList\u0026lt;\u0026gt;()); } // queue收集第一层入度为0的点 ArrayList\u0026lt;String\u0026gt; queue = new ArrayList\u0026lt;\u0026gt;(); for (String task : inDegree.keySet()) { if (inDegree.get(task) == 0) { queue.add(task); } } // 记录任务执行的顺序 StringJoiner ans = new StringJoiner(\u0026#34; \u0026#34;); while (!queue.isEmpty()) { // 如果同时有多个任务要执行，则根据任务名称字母顺序排序 queue.sort(String::compareTo); // newQueue用于记录下一层入度为0的点 ArrayList\u0026lt;String\u0026gt; newQueue = new ArrayList\u0026lt;\u0026gt;(); for (String fa : queue) { // fa执行，则加入已完成的任务列表 ans.add(fa); for (String ch : next.get(fa)) { // fa是父任务，ch是子任务, 即fa执行完，才能执行ch // fa执行完，则对应ch的入度-1 inDegree.put(ch, inDegree.get(ch) - 1); // 如果ch的入度变为0，则加入新一层入度0的点集 if (inDegree.get(ch) == 0) { newQueue.add(ch); } } } queue = newQueue; } System.out.println(ans); } 20. 抢7游戏\r#\r描述\nA、B两个人玩抢7游戏，游戏规则为： A先报一个起始数字 X（10 ≤ 起始数字 ≤ 10000），B报下一个数字 Y （X - Y ＜ 3），A再报一个数字 Z（Y - Z ＜ 3）， 以此类推，直到其中一个抢到7，抢到7即为胜者； B赢得比赛的情况下，一共有多少种组合？ 输入描述： 起始数字 M，10 ≤ M ≤ 10000 输出描述： B能赢得比赛的组合次数 输入：10 输出：1 题解\nstatic BigInteger[] factor; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); initFactor(m - 7); int oneCount = m - 7; int twoCount = 0; // 记录B赢的情况数 BigInteger ans = new BigInteger(\u0026#34;0\u0026#34;); while (oneCount \u0026gt;= 0) { // 叫的次数为奇数时，才能B赢 if ((oneCount + twoCount) % 2 != 0) { ans = ans.add(getPermutationCount(oneCount, twoCount)); } // 合并两个1为一个2 oneCount -= 2; twoCount += 1; } System.out.println(ans); } // 求解不重复的全排列数 public static BigInteger getPermutationCount(int oneCount, int twoCount) { if (oneCount == 0 || twoCount == 0) { // 即 1 1 1 1 1 或 2 2 2 这种情况，此时只有一种排列 return new BigInteger(\u0026#34;1\u0026#34;); } else { // 排列数去重，比如 1 1 1 2 2 的不重复排列数为 5! / 3! / 2! = 10 return factor[oneCount + twoCount].divide(factor[oneCount].multiply(factor[twoCount])); } } // 阶乘 public static void initFactor(int n) { factor = new BigInteger[n + 1]; factor[0] = new BigInteger(\u0026#34;1\u0026#34;); for (int i = 1; i \u0026lt;= n; i++) { factor[i] = factor[i - 1].multiply(new BigInteger(i + \u0026#34;\u0026#34;)); } } 21. 亲子游戏\r#\r描述\n宝宝和妈妈参加亲子游戏，在一个二维矩阵（N*N）的格子地图上， 宝宝和妈妈抽签决定各自的位置，地图上每个格子有不同的糖果数量，部分格子有障碍物。 游戏规则是妈妈必须在最短的时间（每个单位时间只能走一步）到达宝宝的位置，路上的所有糖果都可以拿走，不能走障碍物的格子，只能上下左右走。 请问妈妈在最短到达宝宝位置的时间内最多拿到多少糖果（优先考虑最短时间到达的情况下尽可能多拿糖果）。 输入描述： 第一行输入为 N，N 表示二维矩阵的大小 之后 N 行，每行有 N 个值，表格矩阵每个位置的值，其中： -3：妈妈 -2：宝宝 -1：障碍 ≥0：糖果数（0表示没有糖果，但是可以走） 输出描述： 输出妈妈在最短到达宝宝位置的时间内最多拿到多少糖果，行末无多余空格 备注： 地图最大 50*50 输入：4 3 2 1 -3 1 -1 1 1 1 1 -1 2 -2 1 2 3 输出：9 题解\nstatic int n; static int[][] matrix; static int[][] candy; static int[][] offsets = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); matrix = new int[n][n]; candy = new int[n][n]; LinkedList\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { candy[i][j] = -1; matrix[i][j] = sc.nextInt(); // 妈妈的位置 if (matrix[i][j] == -3) { candy[i][j] = 0; queue.add(i * n + j); // 二维坐标一维化 } } } // 记录题解 int ans = -1; // bfs 按层扩散 while (!queue.isEmpty()) { // 记录当前扩散层的点 LinkedList\u0026lt;Integer\u0026gt; newQueue = new LinkedList\u0026lt;\u0026gt;(); // 当前层是否有宝宝所在的点 boolean flag = false; for (int pos : queue) { // 源点坐标 int x = pos / n; int y = pos % n; // 向四个方向扩散 for (int[] offset : offsets) { // 当前扩散点坐标 int newX = x + offset[0]; int newY = y + offset[1]; // 当前扩散点坐标越界，或者扩散点是墙，则无法扩散 if (newX \u0026lt; 0 || newX \u0026gt;= n || newY \u0026lt; 0 || newY \u0026gt;= n || matrix[newX][newY] == -1) { continue; } // 当前扩散点坐标对应的糖果数量为-1，说明对应扩散点坐标位置还没有加入到当前扩散层 if (candy[newX][newY] == -1) { newQueue.addLast(newX * n + newY); // 加入当前扩散层 } // 当前扩散点可能会被多个源点扩散到，因此比较保留扩散过程中带来的较大糖果数 // candy[newX][newY] 记录的是当前扩散点获得的糖果数 // candy[x][y] + Math.max(0, matrix[newX][newY]) // 记录的是从源点(x,y)带来的糖果数 + (newX,newY)位置原本的糖果数 candy[newX][newY] = Math.max(candy[newX][newY], candy[x][y] + Math.max(0, matrix[newX][newY])); // 如果当前扩散点是宝宝位置，则可以停止后续层级的bfs扩散， // 因为已经找到宝宝的最短路径长度（即扩散层数） if (matrix[newX][newY] == -2) { ans = candy[newX][newY]; flag = true; } } } // 已经找到去宝宝位置的最短路径和最大糖果数，则终止bfs if (flag) break; // 否则继续 queue = newQueue; } System.out.println(ans); } 22. 任务最优调度\r#\r描述\n给定一个正整数数组表示待系统执行的任务列表，数组的每一个元素代表一个任务，元素的值表示该任务的类型。 请计算执行完所有任务所需的最短时间。 任务执行规则如下: 1. 任务可以按任意顺序执行，且每个任务执行耗时间均为1个时间单位。 2. 两个同类型的任务之间必须有长度为N个单位的冷却时间， 比如N为2时，在时间K执行了类型3的任务，那么K+1和K+2两个时间不能执行类型3任务。 3. 系统在任何一个单位时间内都可以执行一个任务，或者等待状态。 说明：数组最大长度为1000，数组最大值1000。 输入描述： 第一行记录一个用半角逗号分隔的数组，数组长度不超过1000，数组元素的值不超过1000， 第二行记录任务冷却时间，N为正整数，N≤100。 输出描述： 输出为执行完所有任务所需的最短时间。 输出描述： 输出为执行完所有任务所需的最短时间。 输入：2,2,2,3 2 输出：7 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] tasks = Arrays.stream(sc.next().split(\u0026#34;,\u0026#34;)).mapToInt(Integer::parseInt).toArray(); int n = sc.nextInt(); System.out.println(getResult(tasks, n)); } public static int getResult(int[] tasks, int n) { HashMap\u0026lt;Integer, Integer\u0026gt; cnts = new HashMap\u0026lt;\u0026gt;(); for (int task : tasks) { cnts.put(task, cnts.getOrDefault(task, 0) + 1); } // k表示:最多任务的数量 // 比如2,2,2,3， 其中任务2数量最多，有3个，则k = 3 int k = cnts.values().stream().max((a, b) -\u0026gt; a - b).orElse(0); // p表示:数量为k的任务个数 // 比如2,2,2,3,3,3,4， 其中数量为3的任务有2个，分别是任务2，任务3，则p=2 int p = 0; for (Integer task : cnts.keySet()) { if (cnts.get(task) == k) p++; } return Math.max((k - 1) * (n + 1) + p, tasks.length); } 23. 数字排列\r#\r描述\n小明负责公司年会，想出一个趣味游戏： 屏幕给出 1 ~ 9 中任意 4 个不重复的数字，大家以最快时间给出这几个数字可拼成的数字从小到大排列位于第 N 位置的数字， 其中 N 为给出数字中最大的（如果不到这么多数字则给出最后一个即可）。 注意： 2 可以当作 5 来使用，5 也可以当作 2 来使用进行数字拼接，且屏幕不能同时给出 2 和 5； 6 可以当作 9 来使用，9 也可以当作 6 来使用进行数字拼接，且屏幕不能同时给出 6 和 9。 如给出：1，4，8，7，则可以拼接的数字为： 1，4，7，8，14，17，18，41，47，48，71，74，78，81，84，87，147，148，178 ... (省略后面的数字) 那么第 N （即8）个的数字为 41。 输入描述： 输入以逗号分隔的 4 个 int 类型整数的字符串。 输出描述： 输出为这几个数字可拼成的数字从小大大排列位于第 N （N为输入数字中最大的数字）位置的数字， 如果输入的数字不在范围内或者有重复，则输出-1。 输入：1,4,8,7 输出：41 输入：3,9,7,8 输出：39 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34;,\u0026#34;); int[] nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(solution(nums)); } public static int solution(int[] nums) { HashSet\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); int n = Integer.MIN_VALUE; for (int num : nums) { if (num \u0026lt; 1 || num \u0026gt; 9) { // 输入的数字不在范围内 return -1; } else { set.add(num); n = Math.max(n, num); } } // 输入的数字有重复 if (set.size() != 4) return -1; // 屏幕不能同时给出 2 和 5 if (set.contains(2) \u0026amp;\u0026amp; set.contains(5)) return -1; // 屏幕不能同时给出 6 和 9 if (set.contains(6) \u0026amp;\u0026amp; set.contains(9)) return -1; HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(2, 5); map.put(5, 2); map.put(6, 9); map.put(9, 6); boolean[] vis = new boolean[nums.length]; String path = \u0026#34;\u0026#34;; // 记录排列 ArrayList\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); // 排列求解 dfs(nums, vis, path, map, res); // 给出这几个数字可拼成的数字从小到大排列位于第 N 位置的数字 res.sort((a, b) -\u0026gt; a - b); // N为给出数字中最大的，如果不到这么多数字则给出最后一个即可 n = Math.min(n, res.size()); return res.get(n - 1); } // 排列求解 public static void dfs(int[] nums, boolean[] vis, String path, HashMap\u0026lt;Integer, Integer\u0026gt; map, ArrayList\u0026lt;Integer\u0026gt; res) { if (!path.isEmpty()) { res.add(Integer.parseInt(path)); } if (path.length() == nums.length) { return; } for (int i = 0; i \u0026lt; nums.length; i++) { if (vis[i]) continue; vis[i] = true; dfs(nums, vis, path + nums[i], map, res); // 2 可以当作 5 来使用，5 也可以当作 2 来使用进行数字拼接 // 6 可以当作 9 来使用，9 也可以当作 6 来使用进行数字拼接 if (map.containsKey(nums[i])) { dfs(nums, vis, path + map.get(nums[i]), map, res); } vis[i] = false; } } 24. 数组二叉树\r#\r描述\n二叉树也可以用数组来存储，给定一个数组，树的根节点的值存储在下标1， 对于存储在下标N的节点，它的左子节点和右子节点分别存储在下标2*N和2*N+1，并且我们用值-1代表一个节点为空。 给定一个数组存储的二叉树，试求从根节点到最小的叶子节点的路径，路径由节点的值组成。 输入描述： 输入一行为数组的内容，数组的每个元素都是正整数，元素间用空格分隔。 注意第一个元素即为根节点的值，即数组的第N个元素对应下标N，下标0在树的表示中没有使用，所以我们省略了。 输入的树最多为7层。 输出描述： 输出从根节点到最小叶子节点的路径上，各个节点的值，由空格分隔，用例保证最小叶子节点只有一个。 输入：3 5 7 -1 -1 2 4 输出：3 7 2 输入：5 9 8 -1 -1 7 -1 -1 -1 -1 -1 6 输出：5 8 7 6 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); Integer[] arr =Arrays.stream(split).map(Integer::parseInt).toArray(Integer[]::new); System.out.println(getResult(arr)); } public static String getResult(Integer[] arr) { int n = arr.length - 1; // 最小叶子节点的值 int min = Integer.MAX_VALUE; // 最小叶子节点的索引 int minIdx = -1; // 求解最小叶子节点的值和索引 for (int i = n; i \u0026gt;= 1; i--) { if (arr[i] != -1) { if (i * 2 + 1 \u0026lt;= n \u0026amp;\u0026amp; arr[i * 2 + 1] != -1) continue; if (i * 2 + 2 \u0026lt;= n \u0026amp;\u0026amp; arr[i * 2 + 2] != -1) continue; if (min \u0026gt; arr[i]) { min = arr[i]; minIdx = i; } } } // path用于缓存最小叶子节点到根的路径 LinkedList\u0026lt;Integer\u0026gt; path = new LinkedList\u0026lt;\u0026gt;(); path.addFirst(min); // 从最小叶子节点开始向上找父节点，直到树顶 while (minIdx != 0) { int f = (minIdx - 1) / 2; path.addFirst(arr[f]); minIdx = f; } StringJoiner sj = new StringJoiner(\u0026#34; \u0026#34;); for (Integer val : path) sj.add(val + \u0026#34;\u0026#34;); return sj.toString(); } 25. 贪吃的猴子\r#\r描述\n一只贪吃的猴子，来到一个果园，发现许多串香蕉排成一行，每串香蕉上有若干根香蕉。每串香蕉的根数由数组numbers给出。 猴子获取香蕉，每次都只能从行的开头或者末尾获取，并且只能获取N次，求猴子最多能获取多少根香蕉。 输入描述： 第一行为数组numbers的长度 第二行为数组numbers的值每个数字通过空格分开 第三行输入为N，表示获取的次数 输出描述： 按照题目要求能获取的最大数值 备注： 1 ≤ numbers.length ≤ 100000 1 ≤ numbers ≤ 100 1 ≤ N ≤ numbers.length 输入：7 1 2 2 7 3 6 1 3 输出：10 输入：3 1 2 3 3 输出：6 输入：4 4 2 2 3 2 输出：7 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int len = Integer.parseInt(sc.nextLine()); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); int n = Integer.parseInt(sc.nextLine()); System.out.println(getResult(len, nums, n)); } public static int getResult(int len, int[] nums, int n) { // 初始时，左边选择0个，因此左边选择的香蕉数为 0 int leftSum = 0; // 初始时，右边选择n个，因此右边选择的香蕉数为 nums[len-n] ~ nums[len - 1] 这个n个元素之和 int rightSum = 0; for (int i = len - n; i \u0026lt; len; i++) { rightSum += nums[i]; } // 如果选择数n == len，即全选，此时直接返回初始rightSum if (len == n) { return rightSum; } // 如果不是全选 // sum记录当前选择结果 int sum = leftSum + rightSum; // ans记录所有选择结果中最大的 int ans = sum; // l指向左边将要获得的，即左边获得一个 int l = 0; // r指向右边将要失去的，即右边失去一个 int r = len - n; while (l \u0026lt; n) { sum += nums[l++] - nums[r++]; ans = Math.max(ans, sum); } return ans; } "},{"id":39,"href":"/lang2/program-design/structure-algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%9313/","title":"机试题库 - 13","section":"华为OD","content":"\r01. 贪吃蛇\r#\r描述\n贪吃蛇是一个经典游戏，蛇的身体由若干方格连接而成，身体随蛇头移动。蛇头触碰到食物时，蛇的长度会增加一格。 蛇头和身体的任一方格或者游戏版图边界碰撞时，游戏结束。 贪吃蛇游戏的模拟： 给定一个NM的数组ar，代表NM个方格组成的版图，贪吃蛇每次移动一个方格。 若ar[i][j]==\u0026#39;H\u0026#39;，表示该方可为贪吃蛇的起始位置; 若ar[i][j]==\u0026#39;F\u0026#39;，表示该方格为食物， 若ar[i][j]==\u0026#39;E\u0026#39;，表示该方格为空格。 贪吃蛇初始长度为1，初始移动方向为向左。 输入为给定一系列贪吃蛇的移动操作，返回操作后蛇的长度，如果在操作执行完之前已经游戏结束，返回游戏结束时贪吃蛇的长度。 输入描述: 第1行：为空格分隔的字母，代表贪吃蛇的移动操作。字母取值为 U、D、L、R、G， 其中UDLR分别表示贪吃蛇往上下左右转向，转向时贪吃蛇不移动，G表示贪吃蛇按 当前的方向移动一格。用例保证输入的操作正确。 第2行：为空格分隔的两个数，指定为 N和 M，为数组的行和列数。 余下 N行每行是空格分 隔的 M个字母。字母取值为 H、F和 E，H表示贪吃蛇的起始位置，F表示食物，E表示该 方格为空。 用例保证有且只有一个 H，而 F和 E会有多个。 输出描述: 输出一个数字为蛇的长度。 输入：D G G 3 3 F F F F F H E F E 输出：1 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] roadArr = sc.nextLine().split(\u0026#34; \u0026#34;); String[] numArr = sc.nextLine().split(\u0026#34; \u0026#34;); int n = Integer.parseInt(numArr[0]); int m = Integer.parseInt(numArr[1]); String[][] arr = new String[n][m]; for (int i = 0; i \u0026lt; n; i++) { String[] tempArr = sc.nextLine().split(\u0026#34; \u0026#34;); for (int j = 0; j \u0026lt; m; j++) { arr[i][j] = tempArr[j]; } } int ans = solution(roadArr, arr, n, m); System.out.println(ans); } public static int solution(String[] roadArr, String[][] arr, int n, int m) { int[] start = {0, 0}; ArrayDeque\u0026lt;String\u0026gt; body = new ArrayDeque\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { if (\u0026#34;H\u0026#34;.equals(arr[i][j])) { body.add(i + \u0026#34;-\u0026#34; + j); start[0] = i; start[1] = j; } } } String curDir = \u0026#34;L\u0026#34;; for (int i = 0; i \u0026lt; roadArr.length; i++) { String str = roadArr[i]; if (\u0026#34;U\u0026#34;.equals(str) || \u0026#34;D\u0026#34;.equals(str) || \u0026#34;L\u0026#34;.equals(str) || \u0026#34;R\u0026#34;.equals(str)) { curDir = str; } if (\u0026#34;G\u0026#34;.equals(str)) { if (\u0026#34;U\u0026#34;.equals(curDir)) start = new int[]{start[0] - 1, start[1]}; if (\u0026#34;D\u0026#34;.equals(curDir)) start = new int[]{start[0] + 1, start[1]}; if (\u0026#34;L\u0026#34;.equals(curDir)) start = new int[]{start[0], start[1] - 1}; if (\u0026#34;R\u0026#34;.equals(curDir)) start = new int[]{start[0], start[1] + 1}; if (start[0] \u0026lt; 0 || start[1] \u0026lt; 0 || start[0] \u0026gt; n - 1 || start[1] \u0026gt; m - 1 || body.contains(start[0] + \u0026#34;-\u0026#34; + start[1])) { return body.size(); } if (\u0026#34;E\u0026#34;.equals(arr[start[0]][start[1]])) { body.addFirst(start[0] + \u0026#34;-\u0026#34; + start[1]); body.removeLast(); } if (\u0026#34;F\u0026#34;.equals(arr[start[0]][start[1]])) { body.addFirst(start[0] + \u0026#34;-\u0026#34; + start[1]); } } } return body.size(); } 02. 贪心歌手\r#\r描述\n一个歌手准备从A城去B城参加演出。问贪心的歌手最多可以赚多少钱？ 1. 按照合同，他必须在 T 天内赶到 2. 歌手途经 N 座城市 3. 歌手不能往回走 4. 每两座城市之间需要的天数都可以提前获知。 5. 歌手在每座城市都可以在路边卖唱赚钱。 经过调研，歌手提前获知了每座城市卖唱的收入预期： 如果在一座城市第一天卖唱可以赚M，后续每天的收入会减少D（第二天赚的钱是 M - D，第三天是 M - 2D ...）。 如果收入减少到 0 就不会再少了。 6. 歌手到达后的第二天才能开始卖唱。如果今天卖过唱，第二天才能出发。 输入描述： 第一行两个数字 T 和 N，中间用空格隔开。T 代表总天数，0 ＜ T ＜ 1000；N 代表路上经过 N 座城市，0 ＜ N ＜ 100 第二行 N+1 个数字，中间用空格隔开。代表每两座城市之间耗费的时间。其总和 ≤ T。 接下来 N 行，每行两个数字 M 和 D，中间用空格隔开。代表每个城市的输入预期。0 ＜ M ＜ 1000，0 ＜ D ＜ 100 输出描述： 一个数字。代表歌手最多可以赚多少钱。以回车结束。 输入：10 2 1 1 2 120 20 90 10 输出：540 题解\nstatic int t; static int n; static int roadCost; static int[][] mds; public static void main(String[] args) { Scanner sc = new Scanner(System.in); t = sc.nextInt(); n = sc.nextInt(); // roadCost是A~B城市必需的路程时间 roadCost = 0; for (int i = 0; i \u0026lt; n + 1; i++) { roadCost += sc.nextInt(); } mds = new int[n][2]; for (int i = 0; i \u0026lt; n; i++) { mds[i][0] = sc.nextInt(); mds[i][1] = sc.nextInt(); } System.out.println(getResult()); } public static int getResult() { // remain是刨去必要的路程时间后，剩余可以用于赚钱的时间 int remain = t - roadCost; // 如果没有剩余时间可以用，则赚不到钱 if (remain \u0026lt;= 0) { return 0; } // 优先队列（小顶堆）记录赚到的钱, 即堆顶是某天赚的最少的钱 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a - b); for (int[] md : mds) { // 第一天卖唱可以赚m，后续每天的收入会减少d int m = md[0]; int d = md[1]; // 只要在当前城市还有钱赚，那么就继续待 while (m \u0026gt; 0) { // 只有remain天可以赚钱，超出的时间不能赚钱， // 因此需要比较超出的时间赚的钱m，和前面时间中赚的最少的钱pq.peek if (pq.size() \u0026gt;= remain) { // pq.peek只可能是某座城市停留的最后一天的赚的钱， // 因为每座城市都是停留的最后一天赚的钱最少 if (m \u0026gt; pq.peek()) { // 如果当前城市当天赚的钱m，比前面天里面赚的最少的pq.peek多， // 那么就赚pq.peek钱的那天时间节约下来，给当天用 pq.poll(); } else { // 如果当前城市当天赚的钱m，比前面天里面赚的最少的pq.peek还少， // 则当前城市继续待下去赚的钱只会更少，因此没必要呆下去了 break; } } // 如果所有城市停留时间没有超出remain天，或者当天是超出的时间， // 但是比前面赚的最少的一天的赚的更多，则赚m更优 pq.add(m); // 每天收入减少d m -= d; } } return pq.stream().reduce(Integer::sum).orElse(0); } 03. 特殊的加密算法\r#\r描述\n有一种特殊的加密算法，明文为一段数字串，经过密码本查找转换，生成另一段密文数字串。 规则如下： 1. 明文为一段数字串由 0~9 组成 2. 密码本为数字 0~9 组成的二维数组 3. 需要按明文串的数字顺序在密码本里找到同样的数字串，密码本里的数字串是由相邻的单元格数字组成， 上下和左右是相邻的，注意：对角线不相邻，同一个单元格的数字不能重复使用。 4. 每一位明文对应密文即为密码本中找到的单元格所在的行和列序号（序号从0开始）组成的两个数宇。 如明文第 i 位 Data[i] 对应密码本单元格为 Book[x][y]，则明文第 i 位对应的密文为X Y，X和Y之间用空格隔开。 如果有多条密文，返回字符序最小的密文。 如果密码本无法匹配，返回\u0026#34;error\u0026#34;。 请你设计这个加密程序。 输入描述： 第一行输入 1 个正整数 N，代表明文的长度（1 ≤ N ≤ 200） 第二行输入 N 个明文组成的序列 Data[i]（0 ≤ Data[i] ≤ 9） 第三行输入 1 个正整数 M，代表密文的长度 接下来 M 行，每行 M 个数，代表密文矩阵 输出描述： 输出字典序最小密文，如果无法匹配，输出\u0026#34;error\u0026#34; 输入：2 0 3 3 0 0 2 1 3 4 6 6 4 输出：0 1 1 1 题解\n// 明文数字个数 static int n; // 明文 static int[] datas; // 密码本矩阵大小 static int m; // 密码本 static int[][] secrets; static int[][] offsets = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); datas = new int[n]; for (int i = 0; i \u0026lt; n; i++) { datas[i] = sc.nextInt(); } // 记录密码本中元素值等于“明文第一个数字”的所有元素的位置 ArrayList\u0026lt;Integer\u0026gt; starts = new ArrayList\u0026lt;\u0026gt;(); m = sc.nextInt(); secrets = new int[m][m]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; m; j++) { secrets[i][j] = sc.nextInt(); // 如果密码本(i,j)位置元素指等于明文第一个数字值，则记录(i,j)作为一个出发位置 if (datas[0] == secrets[i][j]) { starts.add(i * m + j); } } } System.out.println(getResult(starts)); } public static String getResult(ArrayList\u0026lt;Integer\u0026gt; starts) { for (int start : starts) { // 出发位置 int x = start / m; int y = start % m; // used[i][j]用于记录密码本(i,j)元素是否已使用 boolean[][] used = new boolean[m][m]; // 出发点位置元素已使用 used[x][y] = true; // 记录结果路径各节点位置 LinkedList\u0026lt;String\u0026gt; path = new LinkedList\u0026lt;\u0026gt;(); // 出发点位置记录 path.add(x + \u0026#34; \u0026#34; + y); // 开始深搜 if (dfs(x, y, 1, path, used)) { StringJoiner sj = new StringJoiner(\u0026#34; \u0026#34;); for (String pos : path) sj.add(pos); return sj.toString(); } } return \u0026#34;error\u0026#34;; } /** * @param x 当前位置横坐标 * @param y 当前位置纵坐标 * @param index datas[index]是将要匹配的明文数字 * @param path 路径 * @param used 密码本各元素使用情况 * @return 是否找到符合要求的路径 */ public static boolean dfs(int x, int y, int index, LinkedList\u0026lt;String\u0026gt; path, boolean[][] used) { // 已找到明文最后一个数字，则找到符合要求的路径 if (index == n) { return true; } // 否则，进行上、左、右、下四个方向偏移，注意这里的顺序是有影响的， // 即下一步偏移后产生的密文的字符序必然是：上 \u0026lt; 左 \u0026lt; 右 \u0026lt; 下 for (int[] offset : offsets) { // 新位置 int newX = x + offset[0]; int newY = y + offset[1]; // 新位置越界，或者新位置已使用，或者新位置不是目标值，则跳过 if (newX \u0026lt; 0 || newX \u0026gt;= m || newY \u0026lt; 0 || newY \u0026gt;= m || used[newX][newY] || secrets[newX][newY] != datas[index]) { continue; } // 递归进入新位置 path.add(newX + \u0026#34; \u0026#34; + newY); used[newX][newY] = true; // 如果当前分支可以找到符合要求的路径，则返回 if (dfs(newX, newY, index + 1, path, used)) { return true; } // 否则，回溯 used[newX][newY] = false; path.removeLast(); } return false; } 04. 田忌赛马\r#\r描述\n给定两个只包含数字的数组a，b，调整数组 a 里面的数字的顺序，使得尽可能多的a[i] \u0026gt; b[i]。 数组a和b中的数字各不相同。 输出所有可以达到最优结果的a数组的结果。 输入描述： 输入的第一行是数组 a 中的数字，其中只包含数字，每两个数字之间相隔一个空格，a数组大小不超过10。 输入的第二行是数组 b 中的数字，其中只包含数字，每两个数字之间相隔一个空格，b数组大小不超过10。 输出描述： 输出所有可以达到最优结果的 a 数组的数量。 输入：11 8 20 10 13 7 输出：1 说明：最优结果只有一个，a = [11, 20, 8]，故输出1 输入：11 12 20 10 13 7 输出：2 说明：有两个a数组的排列可以达到最优结果，[12, 20, 11] 和 [11, 20, 12]，故输出2 输入：1 2 3 4 5 6 输出：6 说明：a无论如何都会全输，故a任意排列都行，输出所有a数组的排列，6种排法。 题解\nstatic int[] a; static int[] b; static int maxBiggerCount = 0; static int ans = 0; public static void main(String[] args) { Scanner sc = new Scanner(System.in); a = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); b = Arrays.stream(sc.nextLine().split(\u0026#34; \u0026#34;)).mapToInt(Integer::parseInt).toArray(); // 求解a的全排列 dfs(0, new boolean[a.length], 0); System.out.println(ans); } public static void dfs(int level, boolean[] used, int biggerCount) { if (level \u0026gt;= a.length) { if (biggerCount \u0026gt; maxBiggerCount) { maxBiggerCount = biggerCount; ans = 1; } else if (biggerCount == maxBiggerCount) { ans++; } return; } for (int i = 0; i \u0026lt; a.length; i++) { if (used[i]) continue; used[i] = true; // biggerCount记录当前全排列中a[level] \u0026gt; b[level]的位置的数量, 此时a[level] == a[i] dfs(level + 1, used, biggerCount + (a[i] \u0026gt; b[level] ? 1 : 0)); used[i] = false; } } 05. 跳格子3\r#\r描述\n小明和朋友们一起玩跳格子游戏，每个格子上有特定的分数 score = [1, -1, -6, 7, -17, 7]， 从起点score[0]开始，每次最大的步长为k，请你返回小明跳到终点 score[n-1] 时，能得到的最大得分。 输入描述： 第一行输入总的格子数量 n 第二行输入每个格子的分数 score[i] 第三行输入最大跳的步长 k 输出描述： 输出最大得分 输入：6 1 -1 -6 7 -17 7 2 输出：14 说明：输出最大得分数，小明从起点score[0]开始跳，第一次跳score[1],第二次跳到score[3],第三次跳到score[5]， 因此得到的最大的得分是score[0] + score[1] + score[3] + score[5] = 14 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] scores = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); int k = Integer.parseInt(sc.nextLine()); System.out.println(getResult(n, scores, k)); } public static int getResult(int n, int[] scores, int k) { // 第i个格子，可以从第i-k个格子~第i-1个格子调过来，因此本题滑窗的长度相当于k+1 k++; // dp[i]表示跳到第i个格子能得到的最大分数 int[] dp = new int[n]; dp[0] = scores[0]; // 单调队列（单调递减，队首是滑窗最大值） LinkedList\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.addLast(dp[0]); // 初始滑窗的形成过程（即只有新增尾部元素的过程） // 注意当k \u0026gt; n时, 需要取n, 此时只有滑窗形成过程，没有滑窗移动过程 for (int i = 1; i \u0026lt; Math.min(k, n); i++) { // dp[i] = max(dp[0]~dp[i-1]) + scores[i] // 即单调队列队首保存的是max(dp[0]~dp[i-1]) dp[i] = queue.getFirst() + scores[i]; // 保持单调队列的单调递减性，即如果后入队的dp[i] 大于 队尾元素，则队尾元素出队 while (!queue.isEmpty() \u0026amp;\u0026amp; dp[i] \u0026gt; queue.getLast()) { queue.removeLast(); } // 当队尾没有比dp[i]更小的元素后，dp[i]才能入队 queue.addLast(dp[i]); } // 滑窗的右移过程（即相较于老滑窗失去一个首元素，新增一个尾元素） for (int i = k; i \u0026lt; n; i++) { // 如果滑窗失去的元素dp[i - k]，和单调队列的队首元素queue[0]相同，则单调队列需要弹出头部元素 if (dp[i - k] == queue.getFirst()) { queue.removeFirst(); } // 下面逻辑同之前 dp[i] = queue.getFirst() + scores[i]; while (!queue.isEmpty() \u0026amp;\u0026amp; dp[i] \u0026gt; queue.getLast()) { queue.removeLast(); } queue.addLast(dp[i]); } return dp[n - 1]; } 06. 跳马\r#\r描述\n马是象棋（包括中国象棋和国际象棋）中的棋子，走法是每步直一格再斜一格，即先横着或者直者走一格，然后再斜着走一个对角线，可进可退，可越过河界，俗称\u0026#34;马走日\u0026#34;字。 给定 m 行 n 列的棋盘（网格图），棋盘上只有棋子象棋中的棋子“马”，并且每个棋子有等级之分，等级为 k 的马可以跳 1~k 步（走的方式与象棋中“马”的规则一样，不可以超出棋盘位置），问是否能将所有马跳到同一位置，如果存在，输出最少需要的总步数（每匹马的步数相加），不存在则输出-1。 注：允许不同的马在跳的过程中跳到同一位置，坐标为（x,y）的马跳一次可以跳到的坐标为：(x+1, y+2)，(x+1, y-2)，(x+2, y+1)，(x+2, y-1)，(x-1, y+2)，(x-1, y-2)，(x-2, y+1)，(x-2, y-1)，的格点上，但是不可以超出棋盘范围。 输入描述： 第一行输入m，n，代表 m 行 n 列的网格图棋盘（1 ≤ m, n ≤ 25） 接下来输入 m 行 n 列的网格图棋盘，如果第 i 行，第 j 列的元素为 \u0026#34;.\u0026#34; ，代表此格点没有棋子，如果为数字 k（1 ≤ k ≤ 9），代表此格点存在等级为 k 的“马” 输出描述： 输出最少需要的总步数（每匹马的步数相加），不存在则输出-1。 输入：3 5 47.48 4744. 7.... 输出：17 题解\n// 棋盘行数 static int m; // 棋盘列数 static int n; // 棋盘矩阵 static char[][] map; // 最小步数和矩阵，stepMap[i][j]记录各个马走到棋盘(i,j)位置的最小步数之和 static int[][] stepMap; // 记录所有马都可达的公共位置坐标 static HashSet\u0026lt;Integer\u0026gt; reach; // 马走日的偏移量 static int[][] offsets = {{1, 2}, {1, -2}, {2, 1}, {2, -1}, {-1, 2}, {-1, -2}, {-2, 1}, {-2, -1}}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); m = sc.nextInt(); n = sc.nextInt(); map = new char[m][n]; stepMap = new int[m][n]; reach = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; m; i++) { map[i] = sc.next().toCharArray(); // 初始时假设所有位置都是各个马可达的 for (int j = 0; j \u0026lt; n; j++) { reach.add(i * n + j); } } System.out.println(getResult()); } public static int getResult() { // 遍历棋盘 for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { // 如果棋盘(i,j)位置是马 if (map[i][j] != \u0026#39;.\u0026#39;) { // 马的等级 int k = map[i][j] - \u0026#39;0\u0026#39;; // 对该马进行BFS走日 bfs(i, j, k); } } } // 如果所有马走完，发现没有公共可达位置 if (reach.size() == 0) { return -1; } // 记录所有马都可达位置的最小步数和 int minStep = Integer.MAX_VALUE; for (int pos : reach) { int x = pos / n; int y = pos % n; // (x,y)是所有马都可达的位置，stepMap[x][y]记录所有马到达此位置的步数和 minStep = Math.min(minStep, stepMap[x][y]); } return minStep; } // 广搜 public static void bfs(int sx, int sy, int k) { // 广搜队列 LinkedList\u0026lt;int[]\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // (sx,sy)为马所在初始位置，马到达初始位置需要0步 queue.add(new int[]{sx, sy, 0}); // 记录该马可以访问(sx,sy)位置 HashSet\u0026lt;Integer\u0026gt; vis = new HashSet\u0026lt;\u0026gt;(); vis.add(sx * n + sy); // 二维坐标一维化 // k记录该马剩余可走步数 while (queue.size() \u0026gt; 0 \u0026amp;\u0026amp; k \u0026gt; 0) { // newQueue记录该马花费相同步数的可达的位置（即BFS按层遍历的层） LinkedList\u0026lt;int[]\u0026gt; newQueue = new LinkedList\u0026lt;\u0026gt;(); // 按层BFS for (int[] tmp : queue) { // 当前马所在位置(x,y)，以及马到达该位置的步数step int x = tmp[0]; int y = tmp[1]; int step = tmp[2]; for (int[] offset : offsets) { // 马走日到达的新位置 int newX = x + offset[0]; int newY = y + offset[1]; int pos = newX * n + newY; // 如果新位置越界或者已访问过，则不能访问 if (newX \u0026lt; 0 || newX \u0026gt;= m || newY \u0026lt; 0 || newY \u0026gt;= n || vis.contains(pos)) { continue; } // 将新位置加入新层 newQueue.add(new int[]{newX, newY, step + 1}); // 该马到达(newX, newY)位置最小步数为step+1, // 由于该马首次到达(newX, newY)位置，因此step+1就是最小步数 stepMap[newX][newY] += step + 1; // 记录该马访问过该位置，后续如果该马再次访问该位置，则不是最小步数 vis.add(pos); } } queue = newQueue; k--; // 剩余步数减1 } // BFS完后，将公共可达位置reach和当前马可达位置取交集，交集部分就是新的公共可达位置 reach.retainAll(vis); } 07. 图像物体的边界\r#\r描述\n给定一个二维数组M行N列，二维数组里的数字代表图片的像素， 为了简化问题，仅包含像素1和5两种像素，每种像素代表一个物体，2个物体相邻的格子为边界，求像素1代表的物体的边界个数。 像素1代表的物体的边界指与像素5相邻的像素1的格子，边界相邻的属于同一个边界， 相邻需要考虑8个方向(上，下，左，右，左上，左下，右上，右下)。 输入描述： 第一行包含两个正整数 M 和 N，表示二维数组的行数和列数。 接下来的 M 行，每行包含 N 个数字，表示二维数组的像素。 输出描述： 输出像素1代表的物体的边界数目。如果没有边界，输出0（例如只存在像素1，或者只存在像素5）。 输入： 6 6 1 1 1 1 1 1 1 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5 1 1 1 1 1 1 1 输出：1 题解\nprivate static int m; private static int n; private static int[] dx = {0, 0, -1, 1, -1, 1, -1, 1}; private static int[] dy = {-1, 1, 0, 0, -1, 1, 1, -1}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); m = sc.nextInt(); n = sc.nextInt(); int[][] grid = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { grid[i][j] = sc.nextInt(); } } sc.close(); // 标记边界 int[][] border = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == 5) { for (int k = 0; k \u0026lt; 8; k++) { int newI = i + dx[k]; int newJ = j + dy[k]; if (0 \u0026lt;= newI \u0026amp;\u0026amp; newI \u0026lt; m \u0026amp;\u0026amp; 0 \u0026lt;= newJ \u0026amp;\u0026amp; newJ \u0026lt; n \u0026amp;\u0026amp; grid[newI][newJ] == 1) { border[newI][newJ] = 1; } } } } } // 计算边界数量 int count = 0; boolean[][] visited = new boolean[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (border[i][j] == 1 \u0026amp;\u0026amp; !visited[i][j]) { count++; dfs(i, j, border, visited); } } } System.out.println(count); } public static void dfs(int x, int y, int[][] border, boolean[][] visited) { if (x \u0026lt; 0 || x \u0026gt;= n || y \u0026lt; 0 || y \u0026gt;= m || border[x][y] == 0 || visited[x][y]) { return; } visited[x][y] = true; for (int i = 0; i \u0026lt; 8; i++) { dfs(x + dx[i], y + dy[i], border, visited); } } 08. 推荐多样性\r#\r描述\n推荐多样性需要从多个列表中选择元素，一次性要返回 N 屏数据（窗口数量），每屏展示 K 个元素（窗口大小），选择策略： 1. 各个列表元素需要做穿插处理，即先从第一个列表中为每屏选择一个元素，再从第二个列表中为每屏选择一个元素，依次类推 2. 每个列表的元素尽量均分为 N 份，如果不够 N 个，也要全部分配完，参考样例图： 输入描述： 第一行输入为 N，表示需要输出的窗口数量，取值范围 [1, 10] 第二行输入为 K，表示每个窗口需要的元素数量，取值范围 [1, 100] 之后的行数不定（行数取值范围 [1, 10]），表示每个列表输出的元素列表。元素之间以空格隔开，已经过排序处理，每个列表输出的元素数量取值范围 [1, 100] 输出描述： 输出元素列表，元素数量 = 窗口数量 * 窗口大小，元素之间以空格分隔，多个窗口合并为一个列表输出，参考样例： 先输出窗口1的元素列表，再输出窗口2的元素列表，再输出窗口3的元素列表，最后输出窗口4的元素列表 备注 1. 每个列表会保证元素数量满足窗口要求，不需要考虑元素不足情况 2. 每个列表的元素已去重，不需要考虑元素重复情况 3. 每个列表的元素列表均不为空，不需要考虑列表为空的情况 4. 每个列表的元素列表已经过排序处理，输出结果要保证不改变同一个列表的元素顺序 5. 每个列表的元素数量可能是不同的 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); int k = Integer.parseInt(sc.nextLine()); ArrayList\u0026lt;LinkedList\u0026lt;Integer\u0026gt;\u0026gt; lists = new ArrayList\u0026lt;\u0026gt;(); while (sc.hasNextLine()) { String line = sc.nextLine(); // 本地测试，以空行作为输入截止条件 if (line.length() == 0) break; String[] split = line.split(\u0026#34; \u0026#34;); Integer[] nums =Arrays.stream(split).map(Integer::parseInt).toArray(Integer[]::new); lists.add(new LinkedList\u0026lt;\u0026gt;(Arrays.asList(nums))); } // 窗口矩阵，k行n列，每一列对应一个窗口，这里将二维矩阵一维化，方便后面赋值 int[] windows = new int[k * n]; // 窗口矩阵中正在赋值的索引位置 int idx = 0; // 正在从第level个列表中取值 int level = 0; // 当窗口矩阵填满后，结束循环 while (idx \u0026lt; windows.length) { // 当前轮次是否发生了\u0026#34;借\u0026#34;动作 boolean flag = false; // 从第level个列表中取前n个元素 for (int i = 0; i \u0026lt; n; i++) { windows[idx++] = lists.get(level).removeFirst(); // 如果第level个列表没有元素了，则继续切到下一个列表中\u0026#34;借\u0026#34; if (lists.get(level).size() == 0 \u0026amp;\u0026amp; lists.size() \u0026gt; 1) { lists.remove(level); // 删除空列表 level %= lists.size(); // 防止越界 flag = true; // 发生了\u0026#34;借\u0026#34;动作 } } // 如果没有发生\u0026#34;借\u0026#34;动作，则需要切到下一行 if (!flag) { level = (level + 1) % lists.size(); // 防止越界 } } StringJoiner sj = new StringJoiner(\u0026#34; \u0026#34;); // 遍历窗口矩阵的每一列 for (int j = 0; j \u0026lt; n; j++) { // 遍历列号 for (int i = 0; i \u0026lt; k; i++) { // 遍历行号 sj.add(windows[i * n + j] + \u0026#34;\u0026#34;); // 将每一列的元素进行拼接 } } System.out.println(sj); } 09. 文本统计分析\r#\r描述\n有一个文件，包含以一定规则写作的文本，请统计文件中包含的文本数量。 规则如下： 1. 文本以”;”分隔，最后一条可以没有”;”，但空文本不能算语句， 比如”COMMAND A; ;”只能算一条语句。注意，无字符/空白字符/制表符都算作”空”文本； 2. 文本可以跨行，比如下面，是一条文本，而不是三条 COMMAND A \\nAND \\n\\nCOMMAND B; 3. 文本支持字符串，字符串为成对的单引号(\u0026#39;)或者成对的双引号(\u0026#34;)， 字符串可能出现用转义字符(\\)处理的单双引号(\u0026#34;your input is\\\u0026#34;\u0026#34;)和转义字符本身，比如 COMMAND A \u0026#34;Say \\\u0026#34;hello\\\u0026#34;\u0026#34;; 4. 支持注释，可以出现在字符串之外的任意位置注释以”-“开头，到换行结束，比如： COMMAND A; -this is comment COMMAND -comment A AND COMMAND B; 注意字符串内的”-“，不是注释。 输入描述：文本文件 输出描述：包含的文本数量 输入：COMMAND TABLE IF EXISTS \u0026#34;UNITED STATE\u0026#34;; COMMAND A GREAT ( ID ADSAB, download_length INTE-GER, -- test file_name TEXT, guid TEXT, mime_type TEXT, notifica-tionid INTEGER, original_file_name TEXT, pause_reason_type INTEGER, resumable_flag INTEGER, start_time INTEGER, state INTEGER, folder TEXT, path TEXT, total_length INTE-GER, url TEXT ); 输出：2 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); LinkedList\u0026lt;String\u0026gt; lines = new LinkedList\u0026lt;\u0026gt;(); while (sc.hasNextLine()) { String line = sc.nextLine(); if (\u0026#34;\u0026#34;.equals(line)) { System.out.println(getResult(lines)); sc.close(); break; } else { lines.add(line); } } } // 算法入口 public static int getResult(LinkedList\u0026lt;String\u0026gt; lines) { StringBuilder sb = new StringBuilder(); for (String line : lines) { line = line.replaceAll(\u0026#34;\\\\\\\\[\\\u0026#34;\u0026#39;]\u0026#34;, \u0026#34;\u0026#34;) // 替换\\\u0026#34;和\\\u0026#39;为空串 .replaceAll(\u0026#34;\\\u0026#34;.*?\\\u0026#34;\u0026#34;, \u0026#34;a\u0026#34;) // 将成对双引号及其中内容替换为空串 .replaceAll(\u0026#34;\u0026#39;.*?\u0026#39;\u0026#34;, \u0026#34;a\u0026#34;) // 将成对单引号及其中内容替换为空串 .replaceAll(\u0026#34;-.+\u0026#34;, \u0026#34;\u0026#34;) // 将-往后的注释替换为空串 .replaceAll(\u0026#34;\\\\s+\u0026#34;, \u0026#34;\u0026#34;) // 将空白字符替换为空串 .replaceAll(\u0026#34;;+\u0026#34;, \u0026#34;;\u0026#34;); // 将连续分号替换为单个分号 sb.append(line); } // 题目描述说：文本以”;”分隔，最后一条可以没有”;” // 为了避免复杂处理，这里无论最后一条文本有没有分号，都加一个 sb.append(\u0026#34;;\u0026#34;); // 下面处理主要是为了处理跨行文本 /*** * 比如 * aaaa; * ;aaaa * * 比如 * ;aaaa * ;aaaa */ String s = sb.toString().replaceAll(\u0026#34;;+\u0026#34;, \u0026#34;;\u0026#34;).replaceAll(\u0026#34;^;\u0026#34;, \u0026#34;\u0026#34;); // 记录文本条数 int count = 0; for (int i = 0; i \u0026lt; s.length(); i++) { if (s.charAt(i) == \u0026#39;;\u0026#39;) count++; } return count; } 10. 文件缓存系统\r#\r描述\n请设计一个文件缓存系统，该文件缓存系统可以指定缓存的最大值（单位为字节）。 文件缓存系统有两种操作：存储文件（put），读取文件（get） 操作命令为：put fileName fileSize，get fileName 存储文件是把文件放入文件缓存系统中； 读取文件是从文件缓存系统中访问已存在，如果文件不存在，则不作任何操作。 当缓存空间不足以存放新的文件时，根据规则删除文件，直到剩余空间满足新的文件大小位置，再存放新文件。 具体的删除规则为： 文件访问过后，会更新文件的最近访问时间和总的访问次数，当缓存不够时， 按照第一优先顺序为访问次数从少到多，第二顺序为时间从老到新的方式来删除文件。 输入描述： 第一行为缓存最大值 m（整数，取值范围为 0 ＜ m ≤ 52428800） 第二行为文件操作序列个数 n（0 ≤ n ≤ 300000） 从第三行起为文件操作序列，每个序列单独一行，文件操作定义为：op file_name file_size file_name 是文件名，file_size 是文件大小 输出描述： 输出当前文件缓存中的文件名列表，文件名用英文逗号分隔，按字典顺序排序，如：a,c 如果文件缓存中没有文件，则输出NONE 备注： 1. 如果新文件的文件名和文件缓存中已有的文件名相同，则不会放在缓存中 2. 新的文件第一次存入到文件缓存中时，文件的总访问次数不会变化，文件的最近访问时间会更新到最新时间 3. 每次文件访问后，总访问次数加1，最近访问时间更新到最新时间 4. 任何两个文件的最近访问时间不会重复 5. 文件名不会为空，均为小写字母，最大长度为10 6. 缓存空间不足时，不能存放新文件 7. 每个文件大小都是大于 0 的整数 输入：50 6 put a 10 put b 20 get a get a get b put c 30 输出：a,c 题解\n/** 双向链表节点 */ static class Node { /** 记录本题的文件名 */ String key; /** 记录本题的文件大小 */ int val; /** 记录该文件的访问次数 */ int freq; /** 当前节点的前一个节点 */ Node prev; /** 当前节点的后一个节点 */ Node next; public Node(String key, int val, int freq) { this.key = key; this.val = val; this.freq = freq; this.prev = null; this.next = null; } } /** 双向链表 */ static class Link { /** 链表节点数 */ int size; /** 链表头节点 */ Node head; /** 链表尾节点 */ Node tail; /** * 尾插 * * @param node 要插入的节点 */ public void addLast(Node node) { if (this.size == 0) { this.head = node; this.tail = node; } else { this.tail.next = node; node.prev = this.tail; this.tail = node; } this.size++; } /** * 删除指定节点 * * @param node 指定删除的节点 */ public void remove(Node node) { // 如果是空链表，则没法删除 if (this.size == 0) return; if (this.size == 1) { // 如果是单节点链表，则删除完，链表为空 this.head = null; this.tail = null; } else if (node == this.head) { // 被删除节点是链表头节点 this.head = this.head.next; this.head.prev = null; } else if (node == this.tail) { // 被删除节点是链表尾节点 this.tail = this.tail.prev; this.tail.next = null; } else { // 被删除节点是链表中间节点 node.prev.next = node.next; node.next.prev = node.prev; } this.size--; } } static class LFUCache { /** key是文件名，value是文件信息 * （key.value本质是freqMap.value对应的链表中节点Node的对象地址） */ HashMap\u0026lt;String, Node\u0026gt; keyMap; /** key是访问次数，value是访问次数位key的文件（Node）组成的链表（Link） */ HashMap\u0026lt;Integer, Link\u0026gt; freqMap; /** 文件系统总容量 */ int capacity; /** 最少访问次数（记录自各个文件访问次数中最少的那个） */ int minFreq; public LFUCache(int capacity) { this.capacity = capacity; this.minFreq = 0; this.keyMap = new HashMap\u0026lt;\u0026gt;(); this.freqMap = new HashMap\u0026lt;\u0026gt;(); } /** * @param key 对应本题的文件名 */ public void get(String key) { // 如果文件不存在，则不作任何操作。 if (!this.keyMap.containsKey(key)) return; Node node = this.keyMap.get(key); // 每次文件访问后，总访问次数加1，最近访问时间更新到最新时间 incNodeFreq(node); } /** * @param key 对应本题的文件名 * @param val 对应本题的文件大小 */ public void put(String key, int val) { // 如果新文件的文件名和文件缓存中已有的文件名相同，则不会放在缓存中 if (this.keyMap.containsKey(key)) return; // 当缓存空间不足以存放新的文件时，根据规则删除文件， // 直到剩余空间满足新的文件大小位置，再存放新文件。 while (this.capacity \u0026lt; val) { if (this.minFreq == 0) { // 文件系统空了，也放不下该文件，则不放入 return; } // 找出最少访问次数对应的链表 Link minFreqLink = this.freqMap.get(this.minFreq); // 链表头部节点是最少访问次数中，最远访问的文件，我们需要删除它 Node removeNode = minFreqLink.head; // 删除对应文件后，文件系统容量新增 this.capacity += removeNode.val; // 执行删除操作，freqMap和keyMap都要删除掉对应文件的记录 minFreqLink.remove(removeNode); this.keyMap.remove(removeNode.key); // 如果删除后，最少访问次数的链表空了，则需要找到下一个最少访问次数的链表 if (minFreqLink.size == 0) { // 最少访问次数没有对应文件（链表为空），则删除最少访问次数的记录（freqMap的key） this.freqMap.remove(this.minFreq); if (this.freqMap.size() \u0026gt; 0) { this.minFreq = this.freqMap.keySet().stream().min((a, b) -\u0026gt; a - b).get(); } else { // 文件系统没有缓存文件了，则最少次数为0，表示文件系统空了 this.minFreq = 0; } } } // 新增文件，则文件系统容量减少 this.capacity -= val; // 新增文件的访问次数为1，因此最少访问次数变为了1 this.minFreq = 1; Node node = new Node(key, val, this.minFreq); // 执行新增操作，freqMap和keyMap都要新增对应文件的记录 this.freqMap.putIfAbsent(this.minFreq, new Link()); this.freqMap.get(this.minFreq).addLast(node); this.keyMap.put(key, node); } public void incNodeFreq(Node node) { Link link = this.freqMap.get(node.freq); // 由于要更新文件的访问次数，因此需要将node从当前访问次数的链表中删除 link.remove(node); // 如果当前访问次数链表只有当前node，则继续看当前链表对应的访问次数是否位最少访问次数， // 若是，则说明删除当前节点后，最少访问次数对应的文件没了 if (link.size == 0) { // 当前访问次数没有对应文件（链表为空），则删除当前访问次数的记录（freqMap的key） this.freqMap.remove(node.freq); if (node.freq == this.minFreq) { // 此时我们应该更新最少访问次数 this.minFreq++; } } node.freq++; // 总访问次数加1 this.freqMap.putIfAbsent(node.freq, new Link()); // 将node插入到对应freq的链表中 // 尾插 是为了实现：最近访问时间更新到最新时间，即这里认为：链表尾部是最近的，链表头部是最远的 this.freqMap.get(node.freq).addLast(node); } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = Integer.parseInt(sc.nextLine()); LFUCache lfuCache = new LFUCache(m); int n = Integer.parseInt(sc.nextLine()); for (int i = 0; i \u0026lt; n; i++) { String[] operation = sc.nextLine().split(\u0026#34; \u0026#34;); String op = operation[0]; String fileName = operation[1]; if (\u0026#34;put\u0026#34;.equals(op)) { int fileSize = Integer.parseInt(operation[2]); lfuCache.put(fileName, fileSize); } else { lfuCache.get(fileName); } } if (lfuCache.capacity == m) { // 如果文件系统容量没有减少，则没有文件被缓存 System.out.println(\u0026#34;NONE\u0026#34;); } else { // 否则取出文件系统中的文件名，按照字典序输出 StringJoiner sj = new StringJoiner(\u0026#34;,\u0026#34;); lfuCache.keyMap.keySet().stream().sorted().forEach(sj::add); System.out.println(sj); } } 11. 污染水域\r#\r描述\n输入一行字符串，字符串可转换为N*N的数组，数组可认为是一个水域，判断多少天后，水域被全部污染。 数组中只有0和1，0表示纯净，1表示污染，每天只可污染上下左右的水域，如果开始全部被污染，或永远无法污染，则返回-1。 输入：1,0,1,0,0,0,1,0,1 输出：2 说明： 输入转化为数组为： 1 0 1 0 0 0 1 0 1 第一天后水域变为 1 1 1 1 0 1 1 1 1 第二天全部被污染 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34;,\u0026#34;); int[] nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(nums)); } public static int getResult(int[] nums) { int n = (int) Math.sqrt(nums.length); LinkedList\u0026lt;int[]\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); int[][] matrix = new int[n][n]; int total = nums.length; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { matrix[i][j] = nums[i * n + j]; if (matrix[i][j] == 1) { queue.add(new int[] {i, j}); total--; } } } if (queue.size() == 0 || queue.size() == nums.length) { return -1; } int day = 0; int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; while (queue.size() \u0026gt; 0 \u0026amp;\u0026amp; total \u0026gt; 0) { LinkedList\u0026lt;int[]\u0026gt; newQueue = new LinkedList\u0026lt;\u0026gt;(); for (int[] pos : queue) { int i = pos[0]; int j = pos[1]; for (int[] offset : offsets) { int newI = i + offset[0]; int newJ = j + offset[1]; if (newI \u0026gt;= 0 \u0026amp;\u0026amp; newI \u0026lt; n \u0026amp;\u0026amp; newJ \u0026gt;= 0 \u0026amp;\u0026amp; newJ \u0026lt; n \u0026amp;\u0026amp; matrix[newI][newJ] == 0) { matrix[newI][newJ] = 1; newQueue.add(new int[] {newI, newJ}); total--; } } } queue = newQueue; day++; } return day; } 12. 项目排期\r#\r描述\n项目组共有 N 个开发人员，项目经理接到了 M 个独立的需求， 每个需求的工作量不同，且每个需求只能由一个开发人员独立完成，不能多人合作。 假定各个需求直接无任何先后依赖关系，请设计算法帮助项目经理进行工作安排，使整个项目能用最少的时间交付。 输入描述： 第一行输入为 M 个需求的工作量，单位为天，用逗号隔开。 例如：X1 X2 X3 ... Xm 其中：0 ＜ M ＜ 30，0 ＜ Xm ＜ 200 第二行输入为项目组人员数量N， 其中：0 ＜ N ＜ 10 输出描述： 最快完成所有工作的天数 输入：6 2 7 7 9 3 2 1 3 11 4 2 输出：28 题解\nstatic Integer[] balls; static int n; public static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); balls = Arrays.stream(split).map(Integer::parseInt).toArray(Integer[]::new); n = Integer.parseInt(sc.nextLine()); System.out.println(getResult()); } public static int getResult() { // 这里对balls降序，有利于降低后面回溯操作的复杂度 Arrays.sort(balls, (a, b) -\u0026gt; b - a); // 二分范围：即每个桶的容量最小，最大值 int min = balls[0]; // 桶至少要有max(balls)的容量 // 当只有一个桶时，此时该桶容量要装下所有balls int max = Arrays.stream(balls).reduce(Integer::sum).get(); // 记录题解 int ans = max; // 二分找中间值作为桶容量 while (min \u0026lt;= max) { int mid = (min + max) \u0026gt;\u0026gt; 1; if (check(0, new int[n], mid)) { // 如果k个mid容量的桶，可以装完所有balls， // 那么mid容量就是一个可能解，但不一定是最优解，我们应该尝试更小的桶容量 ans = mid; max = mid - 1; } else { // 如果k个mid容量的桶，无法装完所有balls，那么说明桶容量取小了，我们应该尝试更大的桶容量 min = mid + 1; } } return ans; } /** * @param index 当前轮次要被装入的球的索引（balls数组索引） * @param buckets 桶数组，buckets[i]记录的是第 i 个桶已使用的容量 * @param limit 每个桶的最大可使用容量 * @return k个桶（每个桶容量limit）是否可以装下balls中所有球 */ public static boolean check(int index, int[] buckets, int limit) { // 如果balls已经取完，则说明k个limit容量的桶，可以装完所有balls if (index == balls.length) return true; // select是当前要装的球 int selected = balls[index]; // 遍历桶 for (int i = 0; i \u0026lt; buckets.length; i++) { // 剪枝优化 if (i \u0026gt; 0 \u0026amp;\u0026amp; buckets[i] == buckets[i - 1]) continue; // 如果当前桶装了当前选择的球后不超过容量限制，则可以装入 if (selected + buckets[i] \u0026lt;= limit) { buckets[i] += selected; // 递归装下一个球 if (check(index + 1, buckets, limit)) return true; // 如果这种策略无法装完所有球，则回溯 buckets[i] -= selected; } } return false; } 13. 小朋友分组最少调整次数\r#\r描述\nn 个学生排成一排，学生编号分别是 1 到 n，n 为 3 的整倍数。 老师随机抽签决定将所有学生分成 m 个 3 人的小组（n == 3 * m） ， 为了便于同组学生交流，老师决定将小组成员安排到一起，也就是同组成员彼此相连，同组任意两个成员之间无其它组的成员。 因此老师决定调整队伍，老师每次可以调整任何一名学生到队伍的任意位置，计为调整了一次， 请计算最少调整多少次可以达到目标。 注意：对于小组之间没有顺序要求，同组学生之间没有顺序要求。 输入描述： 第一行输入初始排队顺序序列 第二行输入分组排队顺序序列 输出描述： 最少调整多少次数 输入：4 2 8 5 3 6 1 9 7 6 3 1 2 4 8 7 9 5 输出：1 输入：7 9 8 5 6 4 2 1 3 7 8 9 4 2 1 3 5 6 输出：1 题解\n// 分块（即连续的相同组的小朋友） static class NumCount { int num; int count; public NumCount(int num, int count) { this.num = num; this.count = count; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); // 初始小朋友（序号）排队顺序 String[] split = sc.nextLine().split(\u0026#34; \u0026#34;); int[] nums = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); int n = nums.length; // 序号-\u0026gt;组号 映射关系 int[] map = new int[n + 1]; for (int i = 0; i \u0026lt; n; i++) { int num = sc.nextInt(); map[num] = i / 3; } // 初始小朋友（组号）排队顺序 nums = Arrays.stream(nums).map(num -\u0026gt; map[num]).toArray(); // key是组号，val是对应组号的小朋友分块 HashMap\u0026lt;Integer, ArrayList\u0026lt;NumCount\u0026gt;\u0026gt; blocks = new HashMap\u0026lt;\u0026gt;(); // 相邻相同组号合并为块 LinkedList\u0026lt;NumCount\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int num : nums) { if (queue.isEmpty() || queue.getLast().num != num) { queue.addLast(new NumCount(num, 1)); // 记录相同组号的各个分块 blocks.putIfAbsent(num, new ArrayList\u0026lt;\u0026gt;()); blocks.get(num).add(queue.getLast()); } else { queue.getLast().count++; } } // 记录调整位置次数 int moved_count = 0; while (queue.size() \u0026gt; 0) { NumCount first = queue.removeFirst(); // 如果开头块是空的，或者开头块已经包含3个小朋友，那么不需要调整位置 if (first.count == 0 || first.count == 3) continue; if (queue.size() == 0) break; // 第二块 NumCount second = queue.getFirst(); while (second.count == 0) { queue.removeFirst(); second = queue.getFirst(); } // 如果开头块和第二块组号相同，则合并（前面并入后面） if (first.num == second.num) { second.count += first.count; continue; } /* 如果开头块和第二块组号不同，则进入具体情况分析 */ if (first.count == 2) { // 开头块有2个小朋友，则情况如下组号1例子， // 此时需要将后面的单独1，并入开头两个1中，即调整一次 // 1 1 x 1 moved_count += 1; // 后面单独1所在块的小朋友数量清空 blocks.get(first.num).forEach(block -\u0026gt; block.count = 0); continue; } if (first.count == 1) { // 开头块只有1个小朋友，则有两种情况 if (blocks.get(first.num).size() == 3) { // 对于组号的分块有三个，即如下组号1例子 // 1 x 1 y 1 z // 此时需要将后面两个单独1，并入到开头1中，即调整两次 moved_count += 2; // 后面两个单独1所在块的小朋友数量清空 blocks.get(first.num).forEach(block -\u0026gt; block.count = 0); } else { // 对于组号的分块有两个，则如下组号1例子 // 1 x 1 1 // 此时需要将开头单独1并入到后面两个1中，即调整一次 moved_count += 1; // 后面两个1所在块的小朋友数量变为3个 blocks.get(first.num).forEach(block -\u0026gt; block.count = 3); } } } System.out.println(moved_count); } 14. 信道分配\r#\r描述\n算法工程师小明面对着这样一个问题 ，需要将通信用的信道分配给尽量多的用户: 给出一组信道资源，最多可以为多少用户传输数据? 信道的条件及分配规则如下: 1. 所有信道都有属性:”阶”。阶为 r的信道的容量为 2^r比特; 2. 所有用户需要传输的数据量都一样:D比特; 3. 一个用户可以分配多个信道，但每个信道只能分配给一个用户; 4. 只有当分配给一个用户的所有信道的容量和\u0026gt;=D，用户才能传输数据; 输入描述： 第一行，一个数字 R。R为最大阶数。0≤R＜20 第二行，R+1个数字，用空格隔开。代表每种信道的数量 Ni。按照阶的值从小到大排列。0≤i≤R，0≤Ni＜1000. 第三行，一个数字 D。D为单个用户需要传输的数据量。0＜D＜1000000 输出描述： 一个数字（代表最多可以供多少用户传输数据） 输入：5 10 5 0 1 3 2 30 输出：4 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int R = sc.nextInt(); int[] N = new int[R + 1]; for (int i = 0; i \u0026lt;= R; i++) { N[i] = sc.nextInt(); } int D = sc.nextInt(); System.out.println(getResult(R, N, D)); } public static int getResult(int R, int[] N, int D) { // 将D值转化为二进制形式，并且为了和N[]的阶位进行对应，这里将D的二进制进行了反转 String[] split = new StringBuilder(Integer.toBinaryString(D)) .reverse().toString().split(\u0026#34;\u0026#34;); int[] subtrahend = Arrays.stream(split) .mapToInt(Integer::parseInt) .toArray(); // count记录N能承载几个D int count = 0; // N中高阶信道的单个信道就能满足D，因此这些高阶信道有几个，即能承载几个D for (int i = R; i \u0026gt;= subtrahend.length; i--) { // R ~ subtrahend.length 阶的单个信道就能承载一个D，因此这些信道有几个，就能承载几个D count += N[i]; } // 0 ~ subtrahend.length - 1 阶的单个信道无法承载一个D，因此这些阶需要组合起来才能承载一个D int[] minuend = Arrays.copyOfRange(N, 0, subtrahend.length); // 进行二进制减法 while (binary_sub(minuend, subtrahend)) { count++; } return count; } /** * 二进制减法 * * @param minuend 被减数 * @param subtrahend 减数 * @return 被减数是否为正数 */ public static boolean binary_sub(int[] minuend, int[] subtrahend) { // 进行减法运算逻辑, 从高位开始 for (int i = minuend.length - 1; i \u0026gt;= 0; i--) { if (minuend[i] \u0026gt;= subtrahend[i]) { // 如果对应位的信道数足够，则直接相减 minuend[i] -= subtrahend[i]; } else { // 如果对应位的信道数不足，此时有两种策略，一是向低位借，一是向高位借 // 具体向哪里借，需要看 minuend 的 [0,i] 低位部分是否能够承载 subtrahend[0, i] 低位部分 if (calc_bin(Arrays.copyOfRange(minuend, 0, i + 1)) \u0026lt; calc_bin(Arrays.copyOfRange(subtrahend, 0, i + 1))) { // 如果minuend 的 [0,i]不能承载，则向高位借，即从j=i+1位开始借 int j = i + 1; while (j \u0026lt; minuend.length) { if (minuend[j] \u0026gt; 0) { // 如果高位 j 有信道可借，则借 minuend[j] -= 1; return true; } else { // 否则继续向更高位探索 j += 1; } } // 如果所有高位都没有富余信道数，则说明减法结果为负数 return false; } else { // 如果minuend 的 [0,i]可以承载，则向低位借(向低位借，可以避免浪费) // 此时minuend[i]为负数，表示欠债 minuend[i] -= subtrahend[i]; // 将当前阶位的欠债，转移到前面的低阶位上，注意转移时，欠债x2 minuend[i - 1] += minuend[i] \u0026lt;\u0026lt; 1; // 转移后，当前阶位的欠债变为0 minuend[i] = 0; } } } return true; } public static int calc_bin(int[] bin) { int ans = 0; for (int i = 0; i \u0026lt; bin.length; i++) { ans += bin[i] * (1 \u0026lt;\u0026lt; i); } return ans; } 15. 寻找最优的路测线路\r#\r描述\n评估一个网络的信号质量，其中一个做法是将网络划分为栅格，然后对每个栅格的信号质量计算。 路测的时候，希望选择一条信号最好的路线（彼此相连的栅格集合）进行演示。 现给出 R 行 C 列的整数数组 Cov，每个单元格的数值 S 即为该栅格的信号质量（已归一化，无单位，值越大信号越好）。 要求从 [0, 0] 到 [R-1, C-1]设计一条最优路测路线。返回该路线得分。 规则： 路测路线可以上下左右四个方向，不能对角 路线的评分是以路线上信号最差的栅格为准的，例如路径 8→4→5→9 的值为4，该线路评分为4。线路最优表示该条线路的评分最高。 输入描述： 第一行表示栅格的行数 R 第二行表示栅格的列数 C 第三行开始，每一行表示栅格地图一行的信号值，如5 4 5 输出描述： 最优路线的得分 备注： 1 ≤ R，C ≤ 20 0 ≤ S ≤ 65535 输入：3 3 5 4 5 1 2 6 7 4 6 输出：4 说明：路线为：5→4→5→6→6 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int r = sc.nextInt(); int c = sc.nextInt(); int[][] matrix = new int[r][c]; for (int i = 0; i \u0026lt; r; i++) { for (int j = 0; j \u0026lt; c; j++) { matrix[i][j] = sc.nextInt(); } } // dist[i]记录的 起点0 到 终点i 的所有路径中“最大的”最小权值节点的权值 // 其中 i 是将二维坐标一维化后的值，比如(x,y)坐标一维化后为 x * c + y; (c是列数) // dist[i] 记录的 “最大的”最小权值节点的权值，因此需要初始化为一个 \u0026#34;最小的\u0026#34; 最小权值节点的权值， // 方便后面被更大者取代，由于本题节点的最小权值\u0026gt;=0，因此这里可以初始化为0 int[] dist = new int[r * c]; // 起点0 到 终点0 路径的最小权值节点就是自身，即matrix[0][0]点的权重 dist[0] = matrix[0][0]; // 优先队列记录路径（终点），并且路径中的最小权值节点的权值越大，优先级越高 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; dist[b] - dist[a]); // 初始时将(0,0)入队 pq.add(0); // 上下左右的方向偏移量 int[][] offsets = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}; while (pq.size() \u0026gt; 0) { // 取出优先队列中优先级最大的路径（终点） int u = pq.poll(); // 将一维化坐标u，解析为二维坐标(x,y) int x = u / c; int y = u % c; // 已找到dist[r-1][c-1]最优解，则可以提前结束 if (x == r - 1 \u0026amp;\u0026amp; y == c - 1) break; // 向上下左右四个方向探索 for (int[] offset : offsets) { // 新位置坐标 int newX = x + offset[0]; int newY = y + offset[1]; // 新位置越界则无法访问 if (newX \u0026lt; 0 || newX \u0026gt;= r || newY \u0026lt; 0 || newY \u0026gt;= c) continue; // 新位置的一维化坐标 int v = newX * c + newY; // 当前路径（终点u）的最小权值节点的权值为dist[u] // 要加入当前路径的新位置的点的权值 matrix[newX][newY] // 那么形成的新路径的最小权值节点的权值即为 w = min(dist[u], matrix[newX][newY]) int w = Math.min(dist[u], matrix[newX][newY]); // 形成的新路径的终点为 v（即新位置一维化坐标） // 而dist[v]记录的是起点到点v的所有路径中“最大的”最小权值节点 if (dist[v] \u0026lt; w) { // 因此如果dist[v] \u0026lt; w的话，则更新dist[v] dist[v] = w; // 并将新路径加入优先队列，参与下一轮比较 pq.add(v); } } } // 返回起点（0，0）到终点(r-1, c-1)的所有路径中\u0026#34;最大的\u0026#34;最小权值节点的权值 System.out.println(dist[r * c - 1]); } 16. 园区参观路径\r#\r描述\n园区某部门举办了Family Day，邀请员工及其家属参加； 将公司园区视为一个矩形，起始园区设置在左上角，终点园区设置在右下角； 家属参观园区时，只能向右和向下园区前进，求从起始园区到终点园区会有多少条不同的参观路径。 输入描述： 第一行为园区的长和宽； 后面每一行表示该园区是否可以参观，0表示可以参观，1表示不能参观 输出描述： 输出为不同的路径数量 输入：3 3 0 0 0 0 1 0 0 0 0 输出：2 题解\nstatic int n; static int m; static int[][] matrix; static int[][] offsets = {{1, 0}, {0, 1}}; static int ans = 0; public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); // 长 -\u0026gt; 行数 m = sc.nextInt(); // 宽 -\u0026gt; 列数 matrix = new int[n][m]; // 地图矩阵 for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { matrix[i][j] = sc.nextInt(); } } // 从(0,0)位置开始深搜，深搜对应的每条分支都对应一条路径 if (matrix[0][0] == 0) { dfs(0, 0); } System.out.println(ans); } public static void dfs(int x, int y) { if (x == n - 1 \u0026amp;\u0026amp; y == m - 1) { // 如果当前分支可以走到终点，则对应分支路径可行 ans++; return; } // 从当前位置(x, y)向下或者向右走 for (int[] offset : offsets) { // 新位置(newX, newY) int newX = x + offset[0]; int newY = y + offset[1]; // 如果新位置越界了，或者新位置不能参观，则无法进入 if (newX \u0026lt; 0 || newX \u0026gt;= n || newY \u0026lt; 0 || newY \u0026gt;= m || matrix[newX][newY] == 1) continue; // 否则进入新位置，继续深搜 dfs(newX, newY); } } 17. 员工派遣\r#\r描述\n某公司部门需要派遣员工去国外做项目。 现在，代号为 x 的国家和代号为 y 的国家分别需要 cntx 名和 cnty 名员工。 部门每个员工有一个员工号（1,2,3,......），工号连续，从1开始。 部长派遣员工的规则： 规则1：从 [1, k] 中选择员工派遣出去 规则2：编号为 x 的倍数的员工不能去 x 国，编号为 y 的倍数的员工不能去 y 国。 问题： 找到最小的 k，使得可以将编号在 [1, k] 中的员工分配给 x 国和 y 国，且满足 x 国和 y 国的需求。 输入描述： 四个整数 x，y，cntx，cnty。 2 ≤ x ＜ y ≤ 30000 x 和 y 一定是质数 1 ≤ cntx, cnty ＜ 10^9 cntx + cnty ≤ 10^9 输出描述： 满足条件的最小的k 输入：2 3 3 1 输出：5 题解\nstatic long x; static long y; static long cntx; static long cnty; public static void main(String[] args) { Scanner sc = new Scanner(System.in); x = sc.nextInt(); y = sc.nextInt(); cntx = sc.nextInt(); cnty = sc.nextInt(); long min = cntx + cnty; // long max = Long.MAX_VALUE; // 使用此上限，实际通过率55% long max = 1000000000L; // 使用此上限，实际通过率可以100% while (min \u0026lt;= max) { long mid = min + (max - min) / 2; if (check(mid)) { max = mid - 1; } else { min = mid + 1; } } System.out.println(min); } public static boolean check(long k) { long A = k / x; // 1~k范围内x倍数的数量 long B = k / y; // 1~k范围内y倍数的数量 long C = k / (x * y); // 1~k范围内x*y倍数的数量 return Math.max(0, cntx - (B - C)) + Math.max(0, cnty - (A - C)) \u0026lt;= k - A - B + C; } 18. 运输时间\r#\r描述\nM（1 ≤ M ≤ 20）辆车需要在一条不能超车的单行道到达终点，起点到终点的距离为 N（1 ≤ N ≤ 400）。 速度快的车追上前车后，只能以前车的速度继续行驶，求最后一辆车到达目的地花费的时间。 注：每辆车固定间隔 1 小时出发，比如第一辆车 0 时出发，第二辆车 1 时出发，依次类推 输入描述： 第一行两个数字：M N，分别代表车辆数和到终点的距离，以空格分隔 接下来 M 行，每行一个数字 S，代表每辆车的速度。0 ＜ S ＜ 30 输出描述： 最后一辆车到达目的地花费的时间 输入：2 11 3 2 输出：5.5 说明：2辆车，距离11，0时出发的车速度快，1时出发的车，到达目的地花费5.5 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); int n = sc.nextInt(); // 记录前车到达终点的时刻，本题后车不可能比前车更早到达， // 因此如果后车到达时刻 \u0026lt; 前车到达时刻arrived，则后车也是按照前车arrived时刻达到 double arrived = 0; for (int i = 0; i \u0026lt; m; i++) { // 当前车的速度 double speed = sc.nextDouble(); // 当前车到达终点的时刻 // * 当前车如果比前车更早到达，则被前车阻碍，按前车到达时间算 // * 当前车如果比前车更晚到达，则不被前车阻碍，按后车到达时间算 // n*1.0/speed是行驶花费时间； i是第i辆车的出发时间 arrived = Math.max(arrived, n / speed + i); } // 到达时刻 - 出发时刻 = 路上花费的时间 double cost = arrived - (m - 1); // 格式化打印小数 NumberFormat nf = NumberFormat.getInstance(); nf.setMinimumFractionDigits(0); // 没有小数位则不保留 nf.setMaximumFractionDigits(3); // 有小数位则至多保留3位 System.out.println(nf.format(cost)); } 19. 找城市\r#\r描述\n一张地图上有n个城市，城市和城市之间有且只有一条道路相连： 要么直接相连，要么通过其它城市中转相连（可中转一次或多次）。城市与城市之间的道路都不会成环。 当切断通往某个城市 i 的所有道路后，地图上将分为多个连通的城市群， 设该城市i的聚集度为DPi，DPi = max（城市群1的城市个数，城市群2的城市个数，…城市群m 的城市个数）。 请找出地图上DP值最小的城市（即找到城市j，使得DPj = min(DP1,DP2 … DPn)) 提示：如果有多个城市都满足条件，这些城市都要找出来（可能存在多个解） 提示：DPi的计算，可以理解为已知一棵树，删除某个节点后；生成的多个子树，求解多个子数节点数的问题。 输入描述： 每个样例：第一行有一个整数N，表示有N个节点。1 ≤ N ≤ 1000。 接下来的N-1行每行有两个整数x，y，表示城市x与城市y连接。1 ≤ x, y ≤ N 输出描述： 输出城市的编号。如果有多个，按照编号升序输出。 输入：5 1 2 2 3 3 4 4 5 输出：3 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[][] relations = new int[n - 1][2]; for (int i = 0; i \u0026lt; n - 1; i++) { relations[i][0] = sc.nextInt(); relations[i][1] = sc.nextInt(); } System.out.println(getResult(n, relations)); } public static String getResult(int n, int[][] relations) { // 记录最小dpi int minDp = Integer.MAX_VALUE; // 记录最小dpi对应的切断城市 ArrayList\u0026lt;Integer\u0026gt; city = new ArrayList\u0026lt;\u0026gt;(); // i 是被切断城市 for (int i = 1; i \u0026lt;= n; i++) { // 利用并查集对城市进行关联 UnionFindSet ufs = new UnionFindSet(n + 1); for (int[] relation : relations) { int x = relation[0]; int y = relation[1]; // 如果x或y是被切断城市，则对应连接关系不成立 if (x == i || y == i) continue; // 否则连接x和y ufs.union(x, y); } int[] cnts = new int[n + 1]; for (int j = 1; j \u0026lt;= n; j++) { // 对j=1~n每个城市找根fa int fa = ufs.find(j); // 根fa下的子城市个数++ cnts[fa]++; } // cnts的最大值即最大城市群大小 int dp = Arrays.stream(cnts).max().orElse(0); // 和minDp比较，保留最小值 if (dp \u0026lt; minDp) { minDp = dp; city = new ArrayList\u0026lt;\u0026gt;(); city.add(i); } else if (dp == minDp) { city.add(i); } } // 如果有多个，按照编号升序输出。 city.sort((a, b) -\u0026gt; a - b); StringJoiner sj = new StringJoiner(\u0026#34; \u0026#34;); for (Integer c : city) { sj.add(c + \u0026#34;\u0026#34;); } return sj.toString(); } // 并查集实现 static class UnionFindSet { int[] fa; public UnionFindSet(int n) { this.fa = new int[n]; for (int i = 0; i \u0026lt; n; i++) fa[i] = i; } public int find(int x) { if (this.fa[x] != x) { return this.fa[x] = this.find(this.fa[x]); } return x; } public void union(int x, int y) { int x_fa = this.find(x); int y_fa = this.find(y); if (x_fa != y_fa) { this.fa[y_fa] = x_fa; } } } 20. 找单词\r#\r描述\n给一个字符串和一个二维字符数组，如果该字符串存在于该数组中， 则按字符串的字符顺序输出字符串每个字符所在单元格的位置下标字符串，如果找不到返回字符串“N”。 1.需要按照字符串的字符组成顺序搜索，且搜索到的位置必须是相邻单元格，其中“相邻单元格”是指那些水平相邻或垂直相邻的单元格。 2.同一个单元格内的字母不允许被重复使用。 3.假定在数组中最多只存在一个可能的匹配。 输入描述： 第1行为一个数字N指示二维数组在后续输入所占的行数。 第2行到第N+1行输入为一个二维大写字符数组，每行字符用半角,分割。 第N+2行为待查找的字符串，由大写字符组成。 二维数组的大小为N*N，0＜N≤100。 单词长度K，0＜K＜1000。 输出描述： 输出一个位置下标字符串，拼接格式为：第1个字符行下标+”,”+第1个字符列下标+”,” +第2个字符行下标+”,”+第2个字符列下标… +”,” +第N个字符行下标+”,”+第N个字符列下标。 输入：4 A,C,C,F C,D,E,D B,E,S,S F,E,C,A ACCESS 输出：0,0,0,1,0,2,1,2,2,2,2,3 题解\nstatic int n; static String[][] matrix; static String tar; public static void main(String[] args) { // 将输入分隔符改为“,”和换行 Scanner sc = new Scanner(System.in).useDelimiter(\u0026#34;[,\\n]\u0026#34;); n = sc.nextInt(); matrix = new String[n][n]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { matrix[i][j] = sc.next(); } } tar = sc.next(); System.out.println(getResult()); } public static String getResult() { for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { LinkedList\u0026lt;Integer[]\u0026gt; path = new LinkedList\u0026lt;\u0026gt;(); if (dfs(i, j, 0, path)) { StringJoiner sj = new StringJoiner(\u0026#34;,\u0026#34;); for (Integer[] pos : path) sj.add(pos[0] + \u0026#34;,\u0026#34; + pos[1]); return sj.toString(); } } } return \u0026#34;N\u0026#34;; } public static boolean dfs(int i, int j, int k, LinkedList\u0026lt;Integer[]\u0026gt; path) { if (i \u0026lt; 0 || i \u0026gt;= n || j \u0026lt; 0 || j \u0026gt;= n || !tar.substring(k, k + 1).equals(matrix[i][j])) { return false; } path.add(new Integer[] {i, j}); if (path.size() == tar.length()) return true; String tmp = matrix[i][j]; matrix[i][j] = null; boolean res = dfs(i - 1, j, k + 1, path) || dfs(i + 1, j, k + 1, path) || dfs(i, j - 1, k + 1, path) || dfs(i, j + 1, k + 1, path); if (!res) { matrix[i][j] = tmp; path.removeLast(); } return res; } 21. 找到比自己强的人数\r#\r描述\n给定数组[[2,1],[3 2]]，每组表示师徒关系，第一个元素是第二个元素的老师，数字代表排名，现在找出比自己强的徒弟。 输入：[[2,1],[3,2]] 输出：[0,1,2] 说明\t输入： 第一行数据[2,1]表示排名第 2 的员工是排名第 1 员工的导师，后面的数据以此类推。 输出： 第一个元素 0 表示成绩排名第一的导师，没有徒弟考试超过他； 第二个元素 1 表示成绩排名第二的导师，有 1 个徒弟成绩超过他 第三个元素 2 表示成绩排名第三的导师，有 2 个徒弟成绩超过他 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); // 正则：(?\u0026lt;=\\]),(?=\\[) 的含义是，找这样一个“,“,它的前面跟着\u0026#34;]\u0026#34;，后面跟着\u0026#34;[\u0026#34; String[] split = str.substring(1, str.length() - 1).split(\u0026#34;(?\u0026lt;=\\\\]),(?=\\\\[)\u0026#34;); Integer[][] relations = Arrays.stream(split) .map(s -\u0026gt; Arrays.stream(s.substring(1, s.length() - 1).split(\u0026#34;,\u0026#34;)) .map(Integer::parseInt).toArray(Integer[]::new)).toArray(Integer[][]::new); System.out.println(getResult(relations)); } public static String getResult(Integer[][] relations) { // fa用于统计每个师傅名下的直接徒弟的排名，fa对象的属性是师傅排名， // 属性值是一个数组，里面元素是直接徒弟的排名 HashMap\u0026lt;Integer, ArrayList\u0026lt;Integer\u0026gt;\u0026gt; fa = new HashMap\u0026lt;\u0026gt;(); for (Integer[] relation : relations) { int f = relation[0]; int c = relation[1]; fa.putIfAbsent(f, new ArrayList\u0026lt;\u0026gt;()); fa.putIfAbsent(c, new ArrayList\u0026lt;\u0026gt;()); fa.get(f).add(c); } ArrayList\u0026lt;Integer[]\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); // 输出结果要求依次统计：排名第一的师傅的高于自己的徒弟的个数， // 排名第二的师傅的高于自己的徒弟的个数，...... for (Integer f : fa.keySet()) { ans.add(new Integer[] {f, getHighC(f, f, new HashSet\u0026lt;\u0026gt;(), fa)}); } // 按照师傅排名升序后，输出高于师傅排名的徒弟的个数 ans.sort((a, b) -\u0026gt; a[0] - b[0]); return Arrays.toString(ans.stream().map(arr -\u0026gt; arr[1]).toArray(Integer[]::new)); } /** * @param f 当前的师傅，初始时为源头祖师 * @param src 源头祖师 * @param highC 比源头祖师排名的高的徒弟的排名集合 * @param fa fa对象的属性是师傅排名，属性值是一个数组，里面元素是直接徒弟的排名 * @return 比源头祖师排名的高的徒弟的个数，即highC.size */ public static int getHighC( int f, int src, HashSet\u0026lt;Integer\u0026gt; highC, HashMap\u0026lt;Integer, ArrayList\u0026lt;Integer\u0026gt;\u0026gt; fa) { if (f == 1) return 0; // 如果当前师傅是第一名，那么肯定没有徒弟超过它，因此直接返回0 // 遍历当前师傅的所有徒弟 for (int c : fa.get(f)) { // flag标记是否需要统计间接徒弟，默认需要 boolean flag = true; // 如果徒弟的排名高于源头祖师（排名越高，值越小），则应该统计到highC集合中 if (c \u0026lt; src) { if (!highC.contains(c)) { // 如果highC集合没有这个徒弟，则统计，并需要统计这个徒弟的徒弟（即间接徒弟）的排名情况 highC.add(c); } else { // 如果highC中已经有了当前的徒弟，则说明当前徒弟已经统计过了， // 不需要再统计，且当前徒弟的徒弟也不需要再统计了 flag = false; } } else if (c == src) { // 形成环，需要打断 return 0; } // 统计间接徒弟 if (flag) getHighC(c, src, highC, fa); } return highC.size(); } 22. 找数字\r#\r描述\n小扇和小船今天又玩起来了数字游戏，小船给小扇一个正整数 n（1 ≤ n ≤ 1e9），小扇需要找到一个比 n 大的数字 m， 使得 m 和 n 对应的二进制中 1 的个数要相同，现在求 m 的最小值。 输入描述：输入一个正整数 n（1 ≤ n ≤ 1e9） 输出描述：输出一个正整数 m 输入：2 输出：4 输入：7 输出：11 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); // 将整数n转为二进制字符串 String nBinStr = \u0026#34;0\u0026#34; + Integer.toBinaryString(n); char[] mBinCharArr = nBinStr.toCharArray(); int countOne = 0; for (int i = mBinCharArr.length - 2; i \u0026gt;= 0; i--) { if (mBinCharArr[i] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; mBinCharArr[i + 1] == \u0026#39;1\u0026#39;) { // 从右向左找到了第一组\u0026#34;01\u0026#34;子串，则替换为\u0026#34;10\u0026#34; mBinCharArr[i] = \u0026#39;1\u0026#39;; mBinCharArr[i + 1] = \u0026#39;0\u0026#39;; // 如果第一组\u0026#34;01\u0026#34;子串右边存在1 if (countOne \u0026gt; 0) { // 则将第一组\u0026#34;01\u0026#34;子串的右边部分的\u0026#39;1\u0026#39;要全部集中到尾部 for (int j = i + 2; j \u0026lt; mBinCharArr.length; j++) { if (j \u0026lt; mBinCharArr.length - countOne) { mBinCharArr[j] = \u0026#39;0\u0026#39;; } else { mBinCharArr[j] = \u0026#39;1\u0026#39;; } } } break; } if (mBinCharArr[i + 1] == \u0026#39;1\u0026#39;) countOne++; // 记录第一组\u0026#34;01\u0026#34;子串右边1的个数 } int m = Integer.parseInt(new String(mBinCharArr), 2); System.out.println(m); } 23. 智能驾驶\r#\r描述\n有一辆汽车需要从 m * n 的地图左上角（起点）开往地图的右下角（终点）， 去往每一个地区都需要消耗一定的油量，加油站可进行加油。请你计算汽车确保从从起点到达终点时所需的最少初始油量。 说明： 1. 智能汽车可以上下左右四个方向移动 2. 地图上的数字取值是 0 或 -1 或 正整数： -1 ：表示加油站，可以加满油，汽车的油箱容量最大为100； 0 ：表示这个地区是障碍物，汽车不能通过 正整数：表示汽车走过这个地区的耗油量 3. 如果汽车无论如何都无法到达终点，则返回 -1 输入描述： 第一行为两个数字，M，N，表示地图的大小为 M * N，0 ＜ M,N ≤ 200， 后面一个 M * N 的矩阵，其中的值是 0 或 -1 或正整数，加油站的总数不超过 200 个 输出描述： 如果汽车无论如何都无法到达终点，则返回 -1 如果汽车可以到达终点，则返回最少的初始油量 输入：2,2 10,20 30,40 输出：70 题解\nstatic int m; static int n; static int[][] matrix; public static void main(String[] args) { Scanner sc = new Scanner(System.in).useDelimiter(\u0026#34;[,\\n]\u0026#34;); // 将逗号和换行符作为一次读取的截止符 m = sc.nextInt(); n = sc.nextInt(); matrix = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { matrix[i][j] = sc.nextInt(); } } System.out.println(bfs()); } // 上下左右四个方向对应的偏移量 static int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 记录路径中位置的几个状态 static class Node { int x; // 位置横坐标 int y; // 位置纵坐标 int init; // 到达此位置所需的最少初始油量 int remain; // 到达此位置时剩余可用油量 boolean flag; // 到达此位置前有没有加过油 public Node(int x, int y) { this.x = x; this.y = y; } } public static int bfs() { // 如果左上角和右下角不可达，则直接返回-1 if (matrix[0][0] == 0 || matrix[m - 1][n - 1] == 0) { return -1; } // 广搜队列 LinkedList\u0026lt;Node\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // 起始位置 Node src = new Node(0, 0); if (matrix[0][0] == -1) { // 如果起始位置就是加油站，则到达(0,0)位置所需初始油量为0， // 且剩余可用油量为100，且需要标记已加油 src.init = 0; src.remain = 100; src.flag = true; } else { // 如果起始位置不是加油站，则到达(0,0)位置所需的初始油量至少为matrix[0][0], // 剩余可用油量为0，未加油状态 src.init = matrix[0][0]; src.remain = 0; src.flag = false; } queue.add(src); // dist_init[x][y] 用于记录起点 (0, 0) 到达 (x, y) 的所有可达路径中最优路径 // （即初始油量需求最少的路径）的初始油量 int[][] dist_init = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { // 由于需要记录每个位置的最少需要的初始油量， // 因此每个位置所需的初始油量初始化为一个较大值 dist_init[i][j] = Integer.MAX_VALUE; } } // dist_remain 用于记录起点 (0,0) 到达 (x,y) 的所有可达路径中最优路径 // （即初始油量需求最少的路径）的最大剩余可用油量 // 即如果存在多条最优路径，我们应该选这些路径中到达此位置剩余油量最多的 int[][] dist_remain = new int[m][n]; // 起点（0,0）到达自身位置（0,0）所需的最少初始油量和最多剩余油量 dist_init[0][0] = src.init; dist_remain[0][0] = src.remain; // 广搜 while (queue.size() \u0026gt; 0) { Node cur = queue.removeFirst(); // 从当前位置cur开始向上下左右四个方向探路 for (int[] offset : offsets) { // 新位置 int newX = cur.x + offset[0]; int newY = cur.y + offset[1]; // 新位置越界 或者 新位置是障碍，则新位置不可达，继续探索其他方向 if (newX \u0026lt; 0 || newX \u0026gt;= m || newY \u0026lt; 0 || newY \u0026gt;= n || matrix[newX][newY] == 0) continue; // 如果新位置可达，则计算到达新位置的三个状态数据 int init = cur.init; // 到达新位置所需的最少初始油量 int remain = cur.remain; // 到达新位置时还剩余的最多可用油量 boolean flag = cur.flag; // 是否加油了 if (matrix[newX][newY] == -1) { // 如果新位置是加油站，则加满油 remain = 100; // 标记加过油了 flag = true; } else { // 如果新位置不是加油站，则需要消耗matrix[newX][newY]个油 remain -= matrix[newX][newY]; } // 如果到达新位置后，剩余油量为负数 if (remain \u0026lt; 0) { if (flag) { // 如果之前已经加过油了，则说明到达此路径前是满油状态， // 因此我们无法从初始油量里面\u0026#34;借\u0026#34;油 continue; } else { // 如果之前没有加过油，则超出的油量（-remain），可以从初始油量里面\u0026#34;借\u0026#34;， // 即需要初始油量 init + (-remain) 才能到达新位置 init -= remain; // 由于初始油量 init + (-remain) 刚好只能支持汽车到达新位置， // 因此汽车到达新位置后剩余可用油量为0 remain = 0; } } // 如果到达新位置所需的初始油量超过了满油100，则无法到达新位置 if (init \u0026gt; 100) { continue; } // 如果可达新位置，则继续检查当前路径策略到达新位置(newX, newY) // 所需的初始油量init是否比其他路径策略更少 if (init \u0026gt; dist_init[newX][newY]) { // 如果不是，则无需探索新位置(newX, newY) continue; } // 当前路径策略到达新位置(newX,newY)所需初始油量init更少， // 或者，init和前面路径策略相同，但是当前路径策略剩余可用油量remain更多 if (init \u0026lt; dist_init[newX][newY] || remain \u0026gt; dist_remain[newX][newY]) { // 则当前路径策略更优，记录更优路径的状态 dist_init[newX][newY] = init; dist_remain[newX][newY] = remain; // 将当前新位置加入BFS队列 Node next = new Node(newX, newY); next.init = init; next.remain = remain; next.flag = flag; queue.add(next); } } } // dist_init[m - 1][n - 1] 记录的是到达右下角终点位置所需的最少初始油量 return dist_init[m - 1][n - 1] == Integer.MAX_VALUE ? -1 : dist_init[m - 1][n - 1]; } 24. 中文分词模拟器\r#\r描述\n给定一个连续不包含空格的字符串，该字符串仅包含英文小写字母及英文标点符号（逗号、分号、句号）， 同时给定词库，对该字符串进行精确分词。 说明： 1. 精确分词：字符串分词后，不会出现重叠。即\u0026#34;ilovechina\u0026#34;， 不同词库可分割为\u0026#34;i,love,china\u0026#34;，\u0026#34;ilove,china\u0026#34;，不能分割出现重叠的\u0026#34;i,ilove,china\u0026#34;，i 出现重叠 2. 标点符号不成词，仅用于断句 3. 词库：根据外部知识库统计出来的常用词汇例：dictionary = [\u0026#34;i\u0026#34;, \u0026#34;love\u0026#34;, \u0026#34;china\u0026#34;, \u0026#34;lovechina\u0026#34;, \u0026#34;ilove\u0026#34;] 4. 分词原则：采用分词顺序优先且最长匹配原则 \u0026#34;ilovechina\u0026#34;，假设分词结果 [i,ilove,lo,love,ch,china,lovechina]，则输出 [ilove,china] 错误输出：[i,lovechina]，原因：\u0026#34;ilove\u0026#34; \u0026gt; 优先于 \u0026#34;lovechina\u0026#34; 成词 错误输出：[i,love,china]，原因：\u0026#34;ilove\u0026#34; \u0026gt; \u0026#34;i\u0026#34;遵循最长匹配原则 输入描述： 第一行输入待分词语句 \u0026#34;ilovechina\u0026#34; 字符串长度限制：0 ＜ length ＜ 256 第二行输入中文词库 \u0026#34;i,love,china,ch,na,ve,lo,this,is,this,word\u0026#34; 词库长度限制：1 ＜ length ＜ 100000 输出描述： 按顺序输出分词结果 \u0026#34;i,love,china\u0026#34; 输入：iat i,love,china,ch,na,ve,lo,this,is,the,word,beauti,tiful,ful 输出：i,a,t 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] sentences = sc.nextLine().split(\u0026#34;[,.;]\u0026#34;); String[] words = sc.nextLine().split(\u0026#34;[,.;]\u0026#34;); System.out.println(getResult(sentences, words)); } public static String getResult(String[] sentences, String[] words) { // wordSet 记录词库词汇 HashSet\u0026lt;String\u0026gt; wordSet = new HashSet\u0026lt;\u0026gt;(Arrays.asList(words)); // queue记录待分词语句 LinkedList\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(Arrays.asList(sentences)); // ans记录最终分词结果 LinkedList\u0026lt;String\u0026gt; ans = new LinkedList\u0026lt;\u0026gt;(); while (queue.size() \u0026gt; 0) { // 待分词的句子 String sentence = queue.removeFirst(); int r = sentence.length(); for (; r \u0026gt; 0; r--) { // 截取句子 [0,r) 范围子串词汇, 这样的就能实现优先最长匹配， // 并且由于是必须从0索引开始截取，因此满足了分词顺序优先 String fragment = sentence.substring(0, r); // 若词库中是否存在该子串词汇 if (wordSet.contains(fragment)) { // 则将对应子串词汇纳入结果 ans.addLast(fragment); // 我理解词库中每个词汇只能使用一次，因此这里将词库中使用过的词汇移除 wordSet.remove(fragment); // 若子串词汇只是句子部分，则句子剩余部分还要继续去词库中查找 if (r \u0026lt; sentence.length()) { queue.addFirst(sentence.substring(r)); } break; } } // 没有在词库中找到对应子串词汇，则输出单个字母 if (r == 0) { // 注意，这里只放一个字母到结果中，句子剩余部分继续去词库中查找 ans.add(sentence.charAt(0) + \u0026#34;\u0026#34;); if (sentence.length() \u0026gt; 1) { queue.addFirst(sentence.substring(1)); } } } StringJoiner sj = new StringJoiner(\u0026#34;,\u0026#34;); ans.forEach(sj::add); return sj.toString(); } 25. 转骰子\r#\r描述\n骰子是一个立方体，每个面一个数字，初始为左1，右2，前3(观察者方向)，后4，上5，下6，用123456表示这个状态，放置在平面上， 1. 可以向左翻转(用L表示向左翻转1次)， 2. 可以向右翻转(用R表示向右翻转1次)， 3. 可以向前翻转(用F表示向前翻转1次)， 4. 可以向后翻转(用B表示向后翻转1次)， 5. 可以逆时针旋转(用A表示逆时针旋转90度)， 6. 可以顺时针旋转(用C表示顺时针旋转90度)， 现从123456这个初始状态开始，根据输入的动作序列，计算得到最终的状态。 骰子的初始状态和初始状态转动后的状态如图所示。 输入描述： 输入一行，为只包含LRFBAC的字母序列，最大长度为50，字母可重复。 输出描述： 输出最终状态 输入：L R 输出：123456 输入：F C R 输出：342156 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] directives = sc.nextLine().split(\u0026#34; \u0026#34;); turnDice(directives); } public static void turnDice(String[] directives) { Dice dice = new Dice(); for (String directive : directives) { switch (directive) { case \u0026#34;L\u0026#34;: dice.turnL(); break; case \u0026#34;R\u0026#34;: dice.turnR(); break; case \u0026#34;F\u0026#34;: dice.turnF(); break; case \u0026#34;B\u0026#34;: dice.turnB(); break; case \u0026#34;A\u0026#34;: dice.turnA(); break; case \u0026#34;C\u0026#34;: dice.turnC(); break; } } dice.print(); } static class Dice { int left = 1; int right = 2; int front = 3; int back = 4; int top = 5; int bottom = 6; public void turnL() { // 前后不变，上变左，左变下，下变右，右变上 int tmp = this.right; this.right = this.bottom; this.bottom = this.left; this.left = this.top; this.top = tmp; } public void turnR() { // 前后不变，上变右，右变下，下变左，左变上 int tmp = this.left; this.left = this.bottom; this.bottom = this.right; this.right = this.top; this.top = tmp; } public void turnF() { // 左右不变，上变前，前变下，下变后，后变上 int tmp = this.front; this.front = this.top; this.top = this.back; this.back = this.bottom; this.bottom = tmp; } public void turnB() { // 左右不变，前变上，上变后，后变下，下边前 int tmp = this.top; this.top = this.front; this.front = this.bottom; this.bottom = this.back; this.back = tmp; } public void turnA() { // 上下不变， 前变右，右变后，后变左，左变前 int tmp = this.right; this.right = this.front; this.front = this.left; this.left = this.back; this.back = tmp; } public void turnC() { // 上下不变， 右变前，前变左，左变后，后变右 int tmp = this.front; this.front = this.right; this.right = this.back; this.back = this.left; this.left = tmp; } public void print() { String sb = String.valueOf(this.left) + this.right + this.front + this.back + this.top + this.bottom; System.out.println(sb); } } "},{"id":40,"href":"/lang2/program-design/structure-algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%9314/","title":"机试题库 - 14","section":"华为OD","content":"\r01. 字符串比较\r#\r描述\n给定字符串A、B和正整数V，A的长度与B的长度相等， 请计算A中满足如下条件的最大连续子串的长度： 1. 该连续子串在A和B中的位置和长度均相同。 2. 该连续子串|A[i] – B[i]|之和小于等于V。其中|A[i] – B[i]|表示两个字母ASCII码之差的绝对值。 输入描述： 第一行为字符串A，仅包含小写字符，1 ≤ A.length ≤1000。 第二行为字符串B，仅包含小写字符，1 ≤ B.length ≤1000。 第三行为正整数V，0≤ V ≤ 10000。 输出描述： 字符串最大连续子串的长度，要求该子串|A[i] – B[i]|之和小于等于V。 输入：xxcdefg cdefghi 5 输出：2 说明：它的最大连续子串可以是cd-\u0026gt;ef,de-\u0026gt;fg,ef-\u0026gt;gh,fg-\u0026gt;hi，所以最大连续子串是2。 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String a = sc.nextLine(); String b = sc.nextLine(); int v = Integer.parseInt(sc.nextLine()); System.out.println(getResult(a, b, v)); } public static int getResult(String a, String b, int v) { int n = a.length(); // a,b字符串的各位字符的ascii绝对值差距数组 int[] preSum = new int[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { preSum[i] = preSum[i - 1] + Math.abs(a.charAt(i - 1) - b.charAt(i - 1)); } int ans = 0; for (int l = 0; l \u0026lt;= n - 1; l++) { for (int r = l + 1; r \u0026lt;= n; r++) { // 区间 [l+1, r]的和 = preSum[r] - preSum[l] if (preSum[r] - preSum[l] \u0026lt;= v) { ans = Math.max(ans, r - l); } } } return ans; } 02. 字符串拼接\r#\r描述\n给定 M（0 ＜ M ≤ 30）个字符（a-z），从中取出任意字符（每个字符只能用一次）拼接成长度为 N（0 ＜ N ≤ 5）的字符串， 要求相同的字符不能相邻，计算出给定的字符列表能拼接出多少种满足条件的字符串， 输入非法或者无法拼接出满足条件的字符串则返回0。 输入描述：给定的字符列表和结果字符串长度，中间使用空格(\u0026#34; \u0026#34;)拼接 输出描述：满足条件的字符串个数 输入：abc 1 输出：3 输入：dde 2 输出：2 题解\nstatic String s; static int n; public static void main(String[] args) { Scanner sc = new Scanner(System.in); s = sc.next(); n = sc.nextInt(); System.out.println(getResult()); } public static int getResult() { if (s.length() \u0026lt; n) { // 无法拼接出满足条件的字符串 return 0; } char[] cArr = s.toCharArray(); for (char c : cArr) { // 输入非法 if (c \u0026lt; \u0026#39;a\u0026#39; || c \u0026gt; \u0026#39;z\u0026#39;) return 0; } // 排序cArr，可以方便后面求解全排列时，进行树层去重 Arrays.sort(cArr); return dfs(cArr, -1, 0, new boolean[cArr.length], 0); } /** * 全排列求解 * * @param cArr 基于cArr数组求解全排列 * @param pre 排列最后一个字符在cArr中的位置 * @param level 排列的长度 * @param used used[i] 用于标记 cArr[i] 元素是否已使用 * @param count 符号要求的排列有几个 * @return count */ public static int dfs(char[] cArr, int pre, int level, boolean[] used, int count) { // 当排列长度到达n，则是一个符合要求的排列 if (level == n) { // 符合要求的排列个数+1 return ++count; } for (int i = 0; i \u0026lt; cArr.length; i++) { // 每个字符只能用一次 if (used[i]) continue; // 相同的字符不能相邻， pre指向前面一个被选择的字符的在cArr中的位置， // i指向当前被选择的字符在cArr中的位置 if (pre \u0026gt;= 0 \u0026amp;\u0026amp; cArr[i] == cArr[pre]) continue; // 树层去重(去除重复排列) if (i \u0026gt; 0 \u0026amp;\u0026amp; cArr[i] == cArr[i - 1] \u0026amp;\u0026amp; !used[i - 1]) continue; used[i] = true; count = dfs(cArr, i, level + 1, used, count); used[i] = false; } return count; } 03. 最大社交距离\r#\r描述\n疫情期间需要大家保证一定的社交距离，公司组织开交流会议。 座位一排共 N 个座位，编号分别为 [0, N - 1] 。要求员工一个接着一个进入会议室，并且可以在任何时候离开会议室。 满足： 每当一个员工进入时，需要坐到最大社交距离（最大化自己和其他人的距离的座位）； 如果有多个这样的座位，则坐到索引最小的那个座位。 输入描述： 会议室座位总数 seatNum，1 ≤ seatNum ≤ 500 员工的进出顺序 seatOrLeave 数组 元素值为 1，表示进场 元素值为负数，表示出场（特殊：位置 0 的员工不会离开） 例如 -4 表示坐在位置 4 的员工离开（保证有员工坐在该座位上） 输出描述： 最后进来员工，他会坐在第几个位置，如果位置已满，则输出-1。 输入：10 [1, 1, 1, 1, -4, 1] 输出：5 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int seatNum = Integer.parseInt(sc.nextLine()); String tmp = sc.nextLine(); String[] split = tmp.substring(1, tmp.length() - 1).split(\u0026#34;, \u0026#34;); int[] searOrLeave = Arrays.stream(split).mapToInt(Integer::parseInt).toArray(); System.out.println(getResult(seatNum, searOrLeave)); } public static int getResult(int seatNum, int[] seatOrLeave) { // 记录已经坐人位置的序号 ArrayList\u0026lt;Integer\u0026gt; seatIdx = new ArrayList\u0026lt;\u0026gt;(); // 记录题解 int lastSeatIdx = -1; // 遍历员工的进出顺序 for (int info : seatOrLeave) { // 如果当前元素值为负数，表示出场（特殊：位置 0 的员工不会离开） // 例如 -4 表示坐在位置 4 的员工离开（保证有员工坐在该座位上） if (info \u0026lt; 0) { int leaveIdx = -info; seatIdx.remove(leaveIdx); continue; } // 如果当前元素值为 1，表示进场 // 如果没有空闲位置，则坐不下 if (seatIdx.size() == seatNum) { // 假设当前人就是最后一个人 lastSeatIdx = -1; continue; } if (seatIdx.size() == 0) { // 当前人员进场前，座位上没有人，则当前人员是第一个进场的，直接坐第0个位置 seatIdx.add(0); lastSeatIdx = 0; } else if (seatIdx.size() == 1) { // 当前人员进场前，座位上只有一个人，那么这个人肯定坐在第0个位置， // 则当前进场的人坐在 seatNum - 1 位置才能离 0 位置最远 seatIdx.add(seatNum - 1); lastSeatIdx = seatNum - 1; } else { // 记录具有最大社交距离的座位号 int bestSeatIdx = -1; // 记录最大社交距离 int bestSeatDis = -1; // 找到连续空闲座位区域（该区域左、右边界是坐了人的座位） int left = seatIdx.get(0); // 左边界 for (int i = 1; i \u0026lt; seatIdx.size(); i++) { int right = seatIdx.get(i); // 右边界 // 连续空闲座位区域的长度 int dis = right - left - 1; // 如果连续空闲座位区域长度为0，则无法坐人，此时遍历下一个连续空闲座位区域 // 如果连续空闲座位区域长度大于0，则可以坐人 if (dis \u0026gt; 0) { // 当前空闲区域能产生的最大社交距离 int curSeatDis = dis / 2 - (dis % 2 == 0 ? 1 : 0); // 当前空闲区域中具备最大社交距离的位置 int curSeatIdx = left + curSeatDis + 1; // 保留最优解 if (curSeatDis \u0026gt; bestSeatDis) { bestSeatDis = curSeatDis; bestSeatIdx = curSeatIdx; } } left = right; } // 如果最后一个座位，即第 seatNum - 1 号座位没有坐人的话， // 比如 1 0 0 0 1 0 0 0 0，此时最后一段空闲区域是没有右边界的，需要特殊处理 if (seatIdx.get(seatIdx.size() - 1) \u0026lt; seatNum - 1) { // 此时可以直接坐到第 seatNum - 1 号座位，最大社交距离为 curSeatDis int curSeatDis = seatNum - 1 - seatIdx.get(seatIdx.size() - 1) - 1; int curSeatIdx = seatNum - 1; // 保留最优解 if (curSeatDis \u0026gt; bestSeatDis) { bestSeatIdx = curSeatIdx; } } // 如果能坐人，则将坐的位置加入seatIdx中 if (bestSeatIdx \u0026gt; 0) { seatIdx.add(bestSeatIdx); seatIdx.sort((a, b) -\u0026gt; a - b); } // 假设当前人就是最后一个人，那么无论当前人是否能坐进去， // 都更新lastSeatIdx = bestSeatIdx lastSeatIdx = bestSeatIdx; } } return lastSeatIdx; } 04. 最小传输时延Ⅱ\r#\r描述\n有M*N的节点矩阵，每个节点可以向8个方向（上、下、左、右及四个斜线方向）转发数据包，每个节点转发时会消耗固定时延， 连续两个相同时延可以减少一个时延值（即当有K个相同时延的节点连续转发时可以减少K- 1个时延值）， 求左上角（0，0）开始转发数据包到右下角（M-1，N- 1）并转发出的最短时延。 输入描述：第一行两个数字，M、N，接下来有M行，每行有N个数据，表示M* N的矩阵。 输出描述：最短时延值。 输入：3 3 0 2 2 1 2 1 2 2 1 输出：3 题解\n// 地图矩阵 static int[][] matrix; // 最短路径矩阵，即dist[i][j]记录的是坐标(i,j)到(0,0)的最短距离 static int[][] dist; // 地图矩阵行数 static int m; // 地图矩阵列数 static int n; // 八个方向偏移量 static int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {-1, -1}, {-1, 1}, {1, -1}, {1, 1}}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); m = sc.nextInt(); n = sc.nextInt(); matrix = new int[m][n]; dist = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { matrix[i][j] = sc.nextInt(); // 最短路径矩阵初始化，假设每个点到(0,0)距离无穷大 dist[i][j] = Integer.MAX_VALUE; } } System.out.println(spfa()); } public static int spfa() { LinkedList\u0026lt;int[]\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.add(new int[] {0, 0}); dist[0][0] = matrix[0][0]; while (queue.size() \u0026gt; 0) { int[] tmp = queue.removeFirst(); int x = tmp[0], y = tmp[1]; for (int[] offset : offsets) { int newX = x + offset[0]; int newY = y + offset[1]; if (newX \u0026gt;= 0 \u0026amp;\u0026amp; newX \u0026lt; m \u0026amp;\u0026amp; newY \u0026gt;= 0 \u0026amp;\u0026amp; newY \u0026lt; n) { int newDist = dist[x][y] + matrix[newX][newY]; // 题目说：连续两个相同时延可以减少一个时延值 // 但是需要注意的是，应该不能产生负的时延值，比如前一个时延是0， // 当前时延也是0，则减少1个时延值，不应该变为-1 if (matrix[newX][newY] == matrix[x][y] \u0026amp;\u0026amp; matrix[newX][newY] \u0026gt;= 1) { newDist -= 1; } if (newDist \u0026lt; dist[newX][newY]) { dist[newX][newY] = newDist; queue.add(new int[] {newX, newY}); } } } } return dist[m - 1][n - 1]; } 05. 最小矩阵宽度\r#\r描述\n给定一个矩阵，包含 N * M 个整数，和一个包含 K 个整数的数组。 现在要求在这个矩阵中找一个宽度最小的子矩阵，要求子矩阵包含数组中所有的整数。 输入描述： 第一行输入两个正整数 N，M，表示矩阵大小。 接下来 N 行 M 列表示矩阵内容。 下一行包含一个正整数 K。 下一行包含 K 个整数，表示所需包含的数组，K 个整数可能存在重复数字。 所有输入数据小于1000。 输出描述： 输出包含一个整数，表示满足要求子矩阵的最小宽度，若找不到，输出-1。 输入：2 5 1 2 2 3 1 2 3 2 3 2 3 1 2 3 输出：2 说明：矩阵第0、3列包含了1，2，3，矩阵第3，4列包含了1，2，3 题解\nstatic int n; // 矩阵行数 static int m; // 矩阵列数 static int[][] matrix; // 矩阵 static int k; // 目标数组长度 static int[] cnts; // cnts[num] 记录的是 目标数组中num元素的个数 public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); m = sc.nextInt(); matrix = new int[n][m]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { matrix[i][j] = sc.nextInt(); } } k = sc.nextInt(); cnts = new int[1000]; for (int i = 0; i \u0026lt; k; i++) { int num = sc.nextInt(); cnts[num]++; } System.out.println(getResult()); } public static int getResult() { // 未完成匹配的元素的个数 int total = k; // 记录最小子矩阵的宽度 int minLen = Integer.MAX_VALUE; // 当前子矩阵的左边界（列号） int l = 0; // 当前子矩阵的右边界（列号） int r = 0; // 如果右边界未越界，则可以继续尝试找最小子矩阵 while (r \u0026lt; m) { // 将第r列所有元素纳入子矩阵 for (int i = 0; i \u0026lt; n; i++) { // 第r列的元素num int num = matrix[i][r]; // cnts[num] 记录的是 目标数组中num元素的个数，也可以理解为： // 目标数组中num元素剩余未匹配的个数 // 如果num不是目标数组元素，则cnts[num]初始时必然为0， // 对于非目标数组元素num, 即使进行了 cnts[num]--， 也不影响总的未匹配数量 total // 如果num是目标数组元素，则cnts[num]初始时必然大于0， // 且随着子矩阵扩大范围，如果子矩阵中包含num元素个数超过了初始cnts[num]数量， // 则超出部分起不到匹配效果，即不能影响总的未匹配数量 if (cnts[num]-- \u0026gt; 0) { total--; } } // 纳入r列后，看看总的未匹配元素数量total还有几个，如果total为0， // 则说明当前子矩阵匹配到了所有目标数组元素 while (total == 0) { // 若此时子矩阵宽度 r - l + 1 更小，则更新最小子矩阵宽度 minLen = Math.min(minLen, r - l + 1); // 由于当前子矩阵已经匹配到所有目标数组元素， // 因此下一步应该将 l 右移，尝试更小宽度的子矩阵 for (int i = 0; i \u0026lt; n; i++) { // l 右移，相当于当前子矩阵移除了第 l 列所有元素， // 被移除的元素num如果是目标数组元素，则对应的未匹配数量应该被恢复 int num = matrix[i][l]; // 如果当前num不是目标数组元素，或者当前num是目标数组元素， // 但是属于超出部分（这两种情况必然cnts[num] \u0026lt; 0）， // 则对应num元素的恢复，不能影响到整体未匹配数量total， // 如果当前num是目标数组元素，且不是超出部分（此时必然cnts[num] \u0026gt;= 0）， // 则对应num元素的恢复，会影响到整体未匹配数量total if (cnts[num]++ \u0026gt;= 0) { total++; } } // l右移，且下一轮要继续检查l右移后的子矩阵是否依旧能覆盖目标数组所有元素 l++; } // r右移 r++; } if (minLen == Integer.MAX_VALUE) { return -1; } else { return minLen; } } 06. 最长子字符串的长度(二)\r#\r描述\n给你一个字符串 s，字符串 s 首尾相连成一个环形，请你在环中找出 \u0026#39;l\u0026#39;、\u0026#39;o\u0026#39;、\u0026#39;x\u0026#39; 字符都恰好出现了偶数次最长子字符串的长度。 输入描述：输入是一串小写的字母组成的字符串 输出描述：输出是一个整数 备注： 1 ≤ s.length ≤ 5 * 10^5 s 只包含小写英文字母 输入：alolobo 输出：6 输入：looxdolx 输出：7 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.nextLine(); System.out.println(getResult(s)); } public static int getResult(String s) { int status = 0b000; // map.get(i) 用于记录 状态i 出现的过的所有位置 ArrayList\u0026lt;LinkedList\u0026lt;Integer\u0026gt;\u0026gt; map = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 8; i++) { map.add(new LinkedList\u0026lt;\u0026gt;()); } map.get(0).add(-1); int maxLen = 0; for (int i = 0; i \u0026lt; s.length() * 2; i++) { // 第二轮时，i\u0026gt;=s.length()，此时i需要对s.length()求余，避免后面越界 char c = s.charAt(i % s.length()); switch (c) { case \u0026#39;l\u0026#39;: status ^= 0b100; break; case \u0026#39;o\u0026#39;: status ^= 0b010; break; case \u0026#39;x\u0026#39;: status ^= 0b001; break; } if (i \u0026lt; s.length()) { // 第一轮时，i ∈ [0, s.length()), 左闭右开 // 记录该状态出现过的所有位置 map.get(status).add(i); } while (map.get(status).size() \u0026gt; 0) { // status状态最早出现的位置 int earliest = map.get(status).getFirst(); // i 是当前位置，和 earliest 位置的状态相同 if (i - earliest \u0026gt; s.length()) { // 如果 [earliest, i] 范围子串长度超过s串长度， // 则说明earliest左越界，应该尝试更大一点的earliest map.get(status).removeFirst(); } else { // 如果 [earliest, i] 范围子串长度未超过s串长度， // 则该范围子串就是一个符合要求的子串，记录此时子串长度 maxLen = Math.max(maxLen, i - earliest); break; } } } return maxLen; } "},{"id":41,"href":"/lang2/program-design/structure-algorithm/huawei-od/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/","title":"华为机试","section":"华为OD","content":"\rHJ1：字符串最后一个单词的长度\r#\r描述\n计算字符串最后一个单词的长度，单词以空格隔开，字符串长度小于5000。（注：字符串末尾不以空格为结尾） 输入描述：输入一行，代表要计算的字符串，非空，长度小于5000。 输出描述：输出一个整数，表示输入字符串最后一个单词的长度。 输入：hello nowcoder 输出：8 题解\n// 遍历字符串，每遍历一个字符，length++ // 如果遇到空格，则length归零 public static void main(String[] args) throws Exception{ InputStream InputStream = System.in; int length = 0; char c; while (\u0026#39;\\n\u0026#39; != (c=(char)InputStream.read())) { length++; if (c == \u0026#39; \u0026#39;) { length = 0; } } System.out.println(length); } HJ2：计算某字符出现次数\r#\r描述\n写出一个程序，接受一个由字母、数字和空格组成的字符串，和一个字符，然后输出输入字符串中该字符的出现次数。（不区分大小写字母） 数据范围：1 ≤ n ≤ 1000 输入描述：第一行输入一个由字母、数字和空格组成的字符串，第二行输入一个字符（保证该字符不为空格）。 输出描述：输出输入字符串中含有该字符的个数。（不区分大小写字母） 输入：ABCabc A 输出：2 题解\n// 字符串转为小写 // 遍历字符串数组，判断字符相等，累加count++ public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); char[] chars1 = br.readLine().toLowerCase().toCharArray(); char[] chars2 = br.readLine().toLowerCase().toCharArray(); int count = 0; for (int i = 0; i \u0026lt; chars1.length; i++) { if (chars1[i] == chars2[0]) { count++; } } System.out.println(count); } HJ3：明明的随机数\r#\r描述\n明明生成了个1到500之间的随机整数。请你删去其中重复的数字， 即相同的数字只保留一个，把其余相同的数去掉，然后再把这些数从小到大排序，按照排好的顺序输出。 数据范围：1≤n≤1000 ，输入的数字大小满足 1≤val≤500 输入描述：第一行先输入随机整数的个数 N 。 接下来的 N 行每行输入一个整数，代表明明生成的随机数。 输出描述：输出多行，表示输入数据处理后的结果 输入：3 2 2 1 输出：1 2 题解\n// 数组下标不重复，且有序 public static void main(String[] args)throws IOException { BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); String str; while((str=bf.readLine())!=null) { boolean[] stu = new boolean[1001]; StringBuilder sb=new StringBuilder(); int n = Integer.parseInt(str); for(int i=0;i\u0026lt;n;i++) { stu[Integer.parseInt(bf.readLine())] = true; } for(int i=1;i\u0026lt;1001;i++) { if(stu[i]) { sb.append(i).append(\u0026#34;\\n\u0026#34;); } } sb.deleteCharAt(sb.length()-1); System.out.println(sb.toString()); } } HJ4：字符串分隔\r#\r描述\n输入一个字符串，请按长度为8拆分每个输入字符串并进行输出； 长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。 输入描述：连续输入字符串(每个字符串长度小于等于100) 输出描述：依次输出所有分割后的长度为8的新字符串 输入：abc 输出：abc00000 题解\n// 足够8的部分：直接打印输出，记录字符位置 // 不足8的部分：构造零值数组，再放入字符，最后打印输出 public static void main(String[] args) throws IOException{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str; while((str = br.readLine())!=null){ int len = str.length(); int start = 0; while (len \u0026gt;= 8){ System.out.println(str.substring(start, start + 8)); start += 8; len -= 8; } if (len \u0026gt; 0) { char[] tmp = new char[8]; for(int i = 0;i\u0026lt;8;i++){ tmp[i]=\u0026#39;0\u0026#39;; } for(int i = 0; start \u0026lt; str.length(); i++) { tmp[i] = str.charAt(start++); } System.out.println(String.valueOf(tmp)); } } } HJ5：进制转换\r#\r描述\n写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。 数据范围：保证结果在1≤n≤2^31−1 输入描述：输入一个十六进制的数值字符串。 输出描述：输出该数值的十进制字符串。不同组的测试用例用\\n隔开。 示例： 输入：0xAA 输出：170 题解\n// 判断字符：ASCII码值大于等于65 // 字符代表的值：charNum-65+10 // 数字代表的值：charNum-48 public static void main(String[] args) throws IOException{ BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); String input; while((input = bf.readLine())!=null){ String temp = input.substring(2,input.length()); int sum = 0; int length = temp.length(); for(int i= length-1;i\u0026gt;=0;i--){ char c = temp.charAt(i); int tempNum = (int)c; if(tempNum\u0026gt;=65){ tempNum = tempNum - 65 + 10; }else{ tempNum = tempNum - 48; } sum = sum + (int) Math.pow(16, length-i-1)*tempNum; } System.out.println(sum); } } HJ6：质数因子\r#\r描述\n功能:输入一个正整数，按照从小到大的顺序输出它的所有质因子（重复的也要列举）（如180的质因子为2 2 3 3 5 ） 数据范围：1≤n≤2×10^9+14 输入描述：输入一个整数 输出描述：按照从小到大的顺序输出它的所有质数的因子，以空格隔开。 输入：180 输出：2 2 3 3 5 题解\n// 质数：又叫素数，指的是在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数 // 质数因子：能整除给定正整数的质数 public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str; while ((str = br.readLine()) != null) { int num = Integer.parseInt(str); StringBuilder sb = new StringBuilder(); for (int i = 2; i \u0026lt;= Math.sqrt(num); i++) { if (num % i == 0) { sb.append(i).append(\u0026#34; \u0026#34;); num = num / i; i--; } } sb.append(num).append(\u0026#34; \u0026#34;); System.out.println(sb.toString()); } } HJ7：取近似值\r#\r描述\n写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于 0.5 ,向上取整；小于 0.5 ，则向下取整。 数据范围：保证输入的数字在 32 位浮点数范围内 输入描述：输入一个正浮点数值 输出描述：输出该数值的近似整数值 输入：5.5 输出：6 题解\n// 判断小数点位置，及小数点后一位是否大于等于5 public static void main(String args[])throws Exception{ BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); String str = bf.readLine(); int index = str.indexOf(\u0026#34;.\u0026#34;); int a = Integer.parseInt(str.substring(0, index)); int b = Integer.parseInt(str.substring(index + 1, index + 2)); if(b \u0026gt;= 5){ a++; System.out.println(a); }else{ System.out.println(a); } } HJ8：合并表记录\r#\r描述\n数据表记录包含表索引index和数值value（int范围的正整数），请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照index值升序进行输出。 提示：0≤index≤11111111、1≤value≤100000 输入描述：先输入键值对的个数n（1≤n≤500），接下来n行每行输入成对的index和value值，以空格隔开 输出描述：输出合并后的键值对（多行） 输入：4 0 1 0 2 1 2 3 4 输出：0 3 1 2 3 4 题解\n// 使用HashMap // 使用jdk8流排序 public static void main(String[] args){ Scanner input = new Scanner(System.in); int size = input.nextInt(); Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; size; i++) { int key = input.nextInt(); int value = input.nextInt(); if (map.containsKey(key)) { map.put(key, map.get(key) + value); } else { map.put(key, value); } } List\u0026lt;Integer\u0026gt; list = map.keySet().stream().sorted().collect( Collectors.toList()); for (Integer key : list) { System.out.println( key + \u0026#34; \u0026#34; + map.get(key)); } } HJ9：提取不重复的整数\r#\r描述\n输入一个 int 型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。 保证输入的整数最后一位不是 0 。 数据范围：1≤n≤10^8 输入描述：输入一个int型整数 输出描述：按照从右向左的阅读顺序，返回一个不含重复数字的新的整数 输入：9876673 输出：37689 题解\n// String.charAt() // 去重判断：String.contains() public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String str1=sc.nextLine(); String str2=\u0026#34;\u0026#34;; for(int i=str1.length()-1;i\u0026gt;=0;i--){ String c=String.valueOf(str1.charAt(i)); if(!str2.contains(c)){ str2=str2+c; } } System.out.println(str2); } } HJ10：字符个数统计\r#\r描述\n编写一个函数，计算字符串中含有的不同字符的个数。字符在 ASCII 码范围内( 0~127 ，包括 0 和 127 )，换行表示结束符，不算在字符里。不在范围内的不作统计。多个相同的字符只计算一次 例如，对于字符串 abaca 而言，有 a、b、c 三种不同的字符，因此输出 3 。 数据范围：1≤n≤500 输入描述：输入一行没有空格的字符串。 输出描述：输出 输入字符串 中范围在(0~127，包括0和127)字符的种数。 输入：abc 输出：3 题解\n// String.charAt() // 数组下标不重复，且有序 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String s = sc.nextLine(); int[] a = new int[128]; int count = 0; for (int i = 0; i \u0026lt; s.length(); i++) { char b = s.charAt(i); if (a[b] == 0) { count++; a[b] = 1; } } System.out.println(count); } } HJ11：数字颠倒\r#\r描述\n输入一个整数，将这个整数以字符串的形式逆序输出 程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001 数据范围：0≤n≤2^30−1 输入描述：输入一个int整数 输出描述：将这个整数以字符串的形式逆序输出 输入：1516000 输出：0006151 题解\n// 反转StringBuilder.reverse() public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String input=sc.nextLine(); StringBuilder sb=new StringBuilder(input); sb.reverse(); System.out.println(sb.toString()); } } HJ12：字符串反转\r#\r描述\n接受一个只包含小写字母的字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000） 输入描述：输入一行，为一个只包含小写字母的字符串。 输出描述：输出该字符串反转后的字符串。 输入：abcd 输出：dcba 题解\n同HJ11 HJ13：句子逆序\r#\r描述\n将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I” 所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符 数据范围：输入的字符串长度满足1≤n≤1000，注意本题有多组输入 输入描述：输入一个英文语句，每个单词用空格隔开。保证输入只包含空格和字母。 输出描述：得到逆序的句子 输入：I am a boy 输出：boy a am I 题解\n// 字符串分割String.split() public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String line=sc.nextLine(); String[] arr=line.split(\u0026#34; \u0026#34;); List\u0026lt;String\u0026gt; list=new ArrayList\u0026lt;\u0026gt;(); for(int i=arr.length-1;i\u0026gt;=0;i--){ list.add(arr[i]); } System.out.println(String.join(\u0026#34; \u0026#34;,list)); } } HJ14：字符串排序\r#\r描述\n给定 n 个字符串，请对 n 个字符串按照字典序排列。 数据范围：1≤n≤1000，字符串长度满足 1≤len≤100 输入描述：输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。 输出描述：数据输出n行，输出结果为按照字典序排列的字符串。 输入：5 cap to cat boat boot 输出：boat boot cap cat to 题解\n// 排序Arrays.sort() public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { int sum = Integer.valueOf(sc.nextLine()); String[] arr = new String[sum]; for (int i = 0; i \u0026lt; sum; i++) { arr[i] = sc.nextLine(); } Arrays.sort(arr); for (int j = 0; j \u0026lt; sum; j++) { System.out.println(arr[j]); } } } HJ15：求int型正整数在内存中存储时1的个数\r#\r描述\n输入一个 int 型的正整数，计算出该 int 型数据在内存中存储时 1 的个数。 数据范围：保证在 32 位整型数字范围内 输入描述：输入一个整数（int类型） 输出描述：这个数转换成2进制后，输出1的个数 输入：5 输出：2 题解\n// 十进制转二进制Integer.toBinaryString() public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { int num=Integer.valueOf(sc.nextLine()); char[] arr=Integer.toBinaryString(num).toCharArray(); int count=0; for (int i = 0; i \u0026lt; arr.length; i++) { if(arr[i]==\u0026#39;1\u0026#39;){ count++; } } System.out.println(count); } } HJ16：购物单\r#\r王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的 如果要买归类为附件的物品，必须先买该附件所属的主件，且每件物品只能购买一次。 每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。 王强查到了每件物品的价格（都是 10 元的整数倍），而他只有 N 元的预算。除此之外，他给每件物品规定了一个重要度，用整数 1 ~ 5 表示。他希望在花费不超过 N 元的前提下，使自己的满意度达到最大。 满意度是指所购买的每件物品的价格与重要度的乘积的总和，假设设第i件物品的价格为v[i]，重要度为w[i]，共选中了k件物品， 编号依次为j1、j2、...、jk，则满意度为：v[j1]*w[j1]+v[j2]*w[j2]+...+v[jk]*w[jk]。（其中 * 为乘号） 请你帮助王强计算可获得的最大的满意度。 输入描述： 输入的第 1 行，为两个正整数N，m，用一个空格隔开：（其中 N （ N＜32000 ）表示总钱数， m （m ＜60 ）为可购买的物品的个数。） 从第 2 行到第 m+1 行，第 j 行给出了编号为 j-1 的物品的基本数据，每行有 3 个非负整数 v p q （其中 v 表示该物品的价格（ v＜10000 ）， p 表示该物品的重要度（ 1 ~ 5 ）， q 表示该物品是主件还是附件。如果 q=0 ，表示该物品为主件，如果 q\u0026gt;0 ，表示该物品为附件， q 是所属主件的编号） 输出描述： 输出一个正整数，为张强可以获得的最大的满意度。 输入：1000 5 800 2 0 400 5 1 300 5 1 400 3 0 500 2 0 输出：2200 题解\npublic static void main(String[]args) throws IOException{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str= br.readLine(); String [] money_number = str.split(\u0026#34; \u0026#34;); int money = Integer.parseInt(money_number[0]);//钱数 int count = Integer.parseInt(money_number[1]);//物品数 int v[] = new int[count + 1];//物品的v p q和附件序号 int p[] = new int[count + 1]; int q[] = new int[count + 1]; int sub1[] = new int[count + 1]; int sub2[] = new int[count + 1]; int dw = 100; boolean flag = true; for(int i = 1;i \u0026lt; count + 1;i++){//第i件物品的属性 String obj[] = br.readLine().split(\u0026#34; \u0026#34;); v[i] = Integer.parseInt(obj[0]); if (flag \u0026amp;\u0026amp; v[i] % dw != 0) { dw = 10; flag = false; for (int m = 1; m \u0026lt; i; m ++) {//出现不是整百的，按整十除 v[m] *=10; p[m] *=10; } } v[i] = v[i] / dw; p[i] = Integer.parseInt(obj[1]) * v[i];//价值=价格*权重，需要的是p最大 q[i] = Integer.parseInt(obj[2]); if (q[i] \u0026gt; 0) {//是附件 if(sub1[q[i]] == 0) sub1[q[i]] = i;//是附件1 else sub2[q[i]] = i;//是附件2 } } money /= dw; int dp[][] = new int[count +1][money + 1];//money为啥+1？ for(int i = 1; i \u0026lt; count + 1; i++) {//两层for循环，动态规划二维表逐列逐行 int p1 = 0, p2 = 0, p3 = 0;//根据附件数量，分4种情况v[i]、v1、v2、v3 int v1 = -1, v2 = -1, v3 = -1;// if(sub1[i] != 0) { v1 = v[i] + v[sub1[i]]; p1 = p[i] + p[sub1[i]]; } if(sub2[i] != 0) { v2 = v[i] + v[sub2[i]]; p2 = p[i] + p[sub2[i]]; } if(sub1[i] != 0 \u0026amp;\u0026amp; sub2[i] != 0) { v3 = v1 + v2 - v[i]; p3 = p1 + p2 - p[i]; } for (int j = 1; j \u0026lt; money + 1; j++) { dp[i][j] = dp[i-1][j];//最大价值最少是这一件不放进去的大小 if(q[i] == 0) { if(j \u0026gt;= v[i]) dp[i][j] = Math.max(dp[i][j], dp[i-1][j-v[i]] + p[i]); if(v1 != -1 \u0026amp;\u0026amp; j \u0026gt;= v1) dp[i][j] = Math.max(dp[i][j], dp[i-1][j-v1] + p1); if(v2 != -1 \u0026amp;\u0026amp; j \u0026gt;= v2) dp[i][j] = Math.max(dp[i][j], dp[i-1][j-v2] + p2); if(v3 != -1 \u0026amp;\u0026amp; j \u0026gt;= v3) dp[i][j] = Math.max(dp[i][j], dp[i-1][j-v3] + p3); } } } System.out.println(dp[count][money] * dw); } HJ17：坐标移动\r#\r描述\n开发一个坐标计算工具， A表示向左移动，D表示向右移动，W表示向上移动，S表示向下移动。从（0,0）点开始移动，从输入字符串里面读取一些坐标，并将最终输入结果输出到输出文件里面。 输入：合法坐标为A(或者D或者W或者S) + 数字（两位以内），坐标之间以;分隔。非法坐标点需要进行丢弃。 数据范围：每组输入的字符串长度满足1≤n≤10000，坐标保证满足-2^31 ≤ x,y ≤ 2^31-1，且数字部分仅含正数 输入描述：一行字符串 输出描述：最终坐标，以逗号分隔 输入：A10;S20;W10;D30;X;A1A;B10A11;;A10; 输出：10,-10 题解\npublic static void main(String[] args) throws IOException { BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); String[] in = bf.readLine().split(\u0026#34;;\u0026#34;); int x = 0; int y = 0; for(String s : in){ if(!s.matches(\u0026#34;[WASD][0-9]{1,2}\u0026#34;)){ continue; } int val = Integer.valueOf(s.substring(1)); switch(s.charAt(0)){ case \u0026#39;W\u0026#39;: y += val; break; case \u0026#39;S\u0026#39;: y -= val; break; case \u0026#39;A\u0026#39;: x -= val; break; case \u0026#39;D\u0026#39;: x += val; break; } } System.out.println(x+\u0026#34;,\u0026#34;+y); } HJ18：识别有效的IP地址和掩码并进行分类统计\r#\r描述\n请解析IP地址和对应的掩码，进行分类识别。要求按照A/B/C/D/E类地址归类，不合法的地址和掩码单独归类。 所有的IP地址划分为 A,B,C,D,E五类 A类地址从1.0.0.0到126.255.255.255 B类地址从128.0.0.0到191.255.255.255 C类地址从192.0.0.0到223.255.255.255 D类地址从224.0.0.0到239.255.255.255 E类地址从240.0.0.0到255.255.255.255 私网IP范围是： 从10.0.0.0到10.255.255.255 从172.16.0.0到172.31.255.255 从192.168.0.0到192.168.255.255 子网掩码为二进制下前面是连续的1，然后全是0。 例如：255.255.255.32就是一个非法的掩码，注意二进制下全是1或者全是0均为非法子网掩码 注意： 1. 类似于【0.*.*.*】和【127.*.*.*】的IP地址不属于上述输入的任意一类，也不属于不合法ip地址，计数时请忽略 2. 私有IP地址和A,B,C,D,E类地址是不冲突的 输入描述：多行字符串。每行一个IP地址和掩码，用~隔开。 输出描述：统计A、B、C、D、E、错误IP地址或错误掩码、私有IP的个数，之间以空格隔开。 输入：10.70.44.68~255.254.255.0 1.0.0.1~255.0.0.0 192.168.0.2~255.255.255.0 19..0.~255.255.255.0 输出：1 0 1 0 0 2 1 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int aNum = 0; int bNum = 0; int cNum = 0; int dNum = 0; int eNum = 0; int errNum = 0; int pNum = 0; while (sc.hasNextLine()) { String str = sc.nextLine(); String[] strArr = str.split(\u0026#34;~\u0026#34;); int ipFirst = getIpSeg(strArr[0], 0); if (ipFirst == 0 || ipFirst == 127) { continue; } if (maskIsInvaild(strArr[1])) { errNum++; continue; } if (ipIsInvaild(strArr[0])) { errNum++; continue; } if (ipFirst \u0026gt;= 1 \u0026amp;\u0026amp; ipFirst \u0026lt;= 126) { aNum++; } if (ipFirst \u0026gt;= 128 \u0026amp;\u0026amp; ipFirst \u0026lt;= 191) { bNum++; } if (ipFirst \u0026gt;= 192 \u0026amp;\u0026amp; ipFirst \u0026lt;= 223) { cNum++; } if (ipFirst \u0026gt;= 224 \u0026amp;\u0026amp; ipFirst \u0026lt;= 239) { dNum++; } if (ipFirst \u0026gt;= 240 \u0026amp;\u0026amp; ipFirst \u0026lt;= 255) { eNum++; } int ipSecond = getIpSeg(strArr[0], 1); if (ipFirst == 10 || (ipFirst == 172 \u0026amp;\u0026amp; ipSecond \u0026gt;= 16 \u0026amp;\u0026amp; ipSecond \u0026lt;= 31) || (ipFirst == 192 \u0026amp;\u0026amp; ipSecond == 168)) { pNum++; } } System.out.println(aNum + \u0026#34; \u0026#34; + bNum + \u0026#34; \u0026#34; + cNum + \u0026#34; \u0026#34; + dNum + \u0026#34; \u0026#34; + eNum + \u0026#34; \u0026#34; + errNum + \u0026#34; \u0026#34; + pNum); } public static boolean maskIsInvaild(String mask) { String[] maskArr = mask.split(\u0026#34;\\\\.\u0026#34;); if (maskArr.length != 4) { return true; } String maskBinary = toBinary(maskArr[0]) + toBinary(maskArr[1]) + toBinary(maskArr[2]) + toBinary(maskArr[3]); if (!maskBinary.matches(\u0026#34;[1]{1,}[0]{1,}\u0026#34;)) { return true; } return false; } public static String toBinary(String num) { String numBinary = Integer.toBinaryString(Integer.valueOf(num)); while (numBinary.length() \u0026lt; 8) { numBinary = \u0026#34;0\u0026#34; + numBinary; } return numBinary; } public static boolean ipIsInvaild(String ip) { String[] ipArr = ip.split(\u0026#34;\\\\.\u0026#34;); if (ipArr.length != 4) { return true; } if (Integer.valueOf(ipArr[0]) \u0026gt; 255 || Integer.valueOf(ipArr[1]) \u0026gt; 255 || Integer.valueOf(ipArr[2]) \u0026gt; 255 || Integer.valueOf(ipArr[3]) \u0026gt; 255) { return true; } return false; } public static int getIpSeg(String ip, int index) { String[] ipArr = ip.split(\u0026#34;\\\\.\u0026#34;); return Integer.valueOf(ipArr[index]); } HJ19：简单错误记录\r#\r描述\n开发一个简单错误记录功能小模块，能够记录出错的代码所在的文件名称和行号。 处理： 1、 记录最多8条错误记录，循环记录，最后只用输出最后出现的八条错误记录。对相同的错误记录只记录一条，但是错误计数增加。最后一个斜杠后面的带后缀名的部分（保留最后16位）和行号完全匹配的记录才做算是“相同”的错误记录。 2、 超过16个字符的文件名称，只记录文件的最后有效16个字符； 3、 输入的文件可能带路径，记录文件名称不能带路径。也就是说，哪怕不同路径下的文件，如果它们的名字的后16个字符相同，也被视为相同的错误记录 4、循环记录时，只以第一次出现的顺序为准，后面重复的不会更新它的出现时间，仍以第一次为准 数据范围：错误记录数量满足1≤n≤100，每条记录长度满足1≤len≤100 输入描述：每组只包含一个测试用例。一个测试用例包含一行或多行字符串。每行包括带路径文件名称，行号，以空格隔开。 输出描述：将所有的记录统计并将结果输出，格式：文件名 代码行数 数目，一个空格隔开 输入：D:\\zwtymj\\xccb\\ljj\\cqzlyaszjvlsjmkwoqijggmybr 645 E:\\je\\rzuwnjvnuz 633 C:\\km\\tgjwpb\\gy\\atl 637 F:\\weioj\\hadd\\connsh\\rwyfvzsopsuiqjnr 647 E:\\ns\\mfwj\\wqkoki\\eez 648 D:\\cfmwafhhgeyawnool 649 E:\\czt\\opwip\\osnll\\c 637 G:\\nt\\f 633 F:\\fop\\ywzqaop 631 F:\\yay\\jc\\ywzqaop 631 D:\\zwtymj\\xccb\\ljj\\cqzlyaszjvlsjmkwoqijggmybr 645 输出：rzuwnjvnuz 633 1 atl 637 1 rwyfvzsopsuiqjnr 647 1 eez 648 1 fmwafhhgeyawnool 649 1 c 637 1 f 633 1 ywzqaop 631 2 题解\npublic static void main(String[] args) throws Exception { BufferedReader buffer = new BufferedReader(new InputStreamReader(System.in)); String str; LinkedHashMap\u0026lt;String, Integer\u0026gt; data = new LinkedHashMap\u0026lt;String, Integer\u0026gt;(); while ((str = buffer.readLine()) != null) { int idx1 = str.lastIndexOf(\u0026#34; \u0026#34;); int idx2 = str.lastIndexOf(\u0026#34;\\\\\u0026#34;); String key = (idx1 - idx2) \u0026gt; 16 ? str.substring(idx1 - 16) : str.substring(idx2 + 1); data.put(key, data.getOrDefault(key, 0) + 1); } int count = 0; for (String key : data.keySet()) { count++; if (count \u0026gt; (data.size() - 8)) { System.out.println(key + \u0026#34; \u0026#34; + data.get(key)); } } } HJ20：密码验证合格程序\r#\r描述\n密码要求: 1.长度超过8位 2.包括大小写字母、数字、其它符号，以上四种至少三种 3.不能有长度大于2的包含公共元素的子串重复 （注：其他符号不含空格或换行） 数据范围：输入的字符串长度满足1≤n≤100 输入描述：一组字符串。 输出描述：如果符合要求输出：OK，否则输出NG 输入：021Abc9000 021Abc9Abc1 021ABC9000 021$bc9000 输出：OK NG NG OK 题解\npublic static void main(String[] args) throws IOException { BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); String input = null; while (null != (input = reader.readLine())) { char[] chars = input.toCharArray(); // 条件1：长度超过8位 if (chars.length \u0026lt; 9) { System.out.println(\u0026#34;NG\u0026#34;); continue; } // 条件2：包括大小写字母、数字、其它符号，以上四种至少三种 int flag1 = 0; int flag2 = 0; int flag3 = 0; int flag4 = 0; for (char ch : chars) { if (\u0026#39;A\u0026#39; \u0026lt;= ch \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;Z\u0026#39;) { flag1 = 1; } else if (\u0026#39;a\u0026#39; \u0026lt;= ch \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;z\u0026#39;) { flag2 = 1; } else if (\u0026#39;0\u0026#39; \u0026lt;= ch \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { flag3 = 1; } else { flag4 = 1; } } if ((flag1 + flag2 + flag3 + flag4) \u0026lt; 3) { System.out.println(\u0026#34;NG\u0026#34;); continue; } // 条件3：不存在两个大于2的子串相同 String msg = \u0026#34;OK\u0026#34;; Map\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; chars.length - 2; i++) { String key = input.substring(i, i + 3); if (map.containsKey(key)) { msg = \u0026#34;NG\u0026#34;; break; } map.put(key, \u0026#34;1\u0026#34;); } System.out.println(msg); } } HJ21：简单密码\r#\r描述\n现在有一种密码变换算法。 九键手机键盘上的数字与字母的对应： 1--1， abc--2, def--3, ghi--4, jkl--5, mno--6, pqrs--7, tuv--8 wxyz--9, 0--0，把密码中出现的小写字母都变成九键键盘对应的数字，如：a 变成 2，x 变成 9. 而密码中出现的大写字母则变成小写之后往后移一位，如：X ，先变成小写，再往后移一位，变成了 y ，例外：Z 往后移是 a 。 数字和其它的符号都不做变换。 数据范围：输入的字符串长度满足1≤n≤100 输入描述：输入一组密码，长度不超过100个字符。 输出描述：输出密码变换后的字符串 输入：YUANzhi1987 输出：zvbo9441987 题解\npublic static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str = br.readLine(); StringBuffer sb = new StringBuffer(); for (int i = 0; i \u0026lt; str.length(); i++) { //获取第i个字符 char c = str.charAt(i); //判断，处理 if (c \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c \u0026lt; \u0026#39;Z\u0026#39;) { c = (char) (c + \u0026#39;b\u0026#39; - \u0026#39;A\u0026#39;); } else if (c == \u0026#39;Z\u0026#39;) { c = \u0026#39;a\u0026#39;; } else if (c\u0026gt;=\u0026#39;a\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;c\u0026#39;) { c = \u0026#39;2\u0026#39;; } else if (c\u0026gt;=\u0026#39;d\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;f\u0026#39;) { c = \u0026#39;3\u0026#39;; } else if (c\u0026gt;=\u0026#39;g\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;i\u0026#39;) { c = \u0026#39;4\u0026#39;; } else if (c\u0026gt;=\u0026#39;j\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;l\u0026#39;) { c = \u0026#39;5\u0026#39;; } else if (c\u0026gt;=\u0026#39;m\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;o\u0026#39;) { c = \u0026#39;6\u0026#39;; } else if (c\u0026gt;=\u0026#39;p\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;s\u0026#39;) { c = \u0026#39;7\u0026#39;; } else if (c\u0026gt;=\u0026#39;t\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;v\u0026#39;) { c = \u0026#39;8\u0026#39;; } else if (c\u0026gt;=\u0026#39;w\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;z\u0026#39;) { c = \u0026#39;9\u0026#39;; } sb.append(c); } System.out.println(sb.toString().trim()); } HJ22：汽水瓶\r#\r描述\n某商店规定：三个空汽水瓶可以换一瓶汽水，允许向老板借空汽水瓶（但是必须要归还）。 小张手上有n个空汽水瓶，她想知道自己最多可以喝到多少瓶汽水。 数据范围：输入的正整数满足1≤n≤100 注意：本题存在多组输入。输入的 0 表示输入结束，并不用输出结果。 输入描述：输入文件最多包含 10 组测试数据，每一行仅包含一个正整数 n（1≤n≤100），表示小张手上的空汽水瓶数。n=0表示输入结束 输出描述：对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出0。 输入：3 10 81 0 输出：1 5 40 题解\n// 每两个空瓶可以喝一瓶：2空瓶加上借的1空瓶，兑换1瓶汽水，喝掉后将空瓶还回给老板 public static void main(String[] args){ Scanner sc = new Scanner(System.in); while(sc.hasNextInt()){ int bottle = sc.nextInt(); if(bottle==0){ break; } System.out.println(bottle/2); } } HJ23：删除字符串中出现次数最少的字符\r#\r描述\n实现删除字符串中出现次数最少的字符，若出现次数最少的字符有多个，则把出现次数最少的字符都删除。 输出删除这些单词后的字符串，字符串中其它字符保持原来的顺序。 数据范围：输入的字符串长度满足1≤n≤20，保证输入的字符串中仅出现小写字母 输入描述：字符串只包含小写英文字母, 不考虑非法输入，输入的字符串长度小于等于20个字节。 输出描述：删除字符串中出现次数最少的字符后的字符串。 输入：aabcddd 输出：aaddd 题解\npublic static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { String s = scanner.nextLine(); char[] chars = s.toCharArray(); //统计每个字母的数量 HashMap\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (char aChar : chars) { map.put(aChar, (map.getOrDefault(aChar, 0) + 1)); } //找到数量最少的字符数量 Collection\u0026lt;Integer\u0026gt; values = map.values(); Integer min = Collections.min(values); //用空字符串替换该字母 for (Character character : map.keySet()) { if (map.get(character) == min){ s = s.replaceAll(String.valueOf(character), \u0026#34;\u0026#34;); } } System.out.println(s); } } HJ26：字符串排序\r#\r描述\n编写一个程序，将输入字符串中的字符按如下规则排序。 规则1：英文字母从 A 到 Z 排列，不区分大小写。如，输入： Type 输出： epTy 规则2：同一个英文字母的大小写同时存在时，按照输入顺序排列。如，输入： BabA 输出： aABb 规则3：非英文字母的其它字符保持原来的位置。如，输入： By?e 输出： Be?y 数据范围：输入的字符串长度满足1≤n≤1000 输入描述：输入字符串 输出描述：输出字符串 输入：A Famous Saying: Much Ado About Nothing (2012/8). 输出：A aaAAbc dFgghh: iimM nNn oooos Sttuuuy (2012/8). 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String str = sc.nextLine(); String res = sort(str); System.out.println(res); } } public static String sort(String str) { // 先将英文字母收集起来 List\u0026lt;Character\u0026gt; letters = new ArrayList\u0026lt;\u0026gt;(); char[] chars = str.toCharArray(); for (char ch : chars) { if (Character.isLetter(ch)) { letters.add(ch); } } // 将英文字母先排序好 letters.sort(Comparator.comparingInt(Character::toLowerCase)); // 若是非英文字母则直接添加 StringBuilder result = new StringBuilder(); for (int i = 0, j = 0; i \u0026lt; str.length(); i++) { if (Character.isLetter(str.charAt(i))) { result.append(letters.get(j++)); } else { result.append(str.charAt(i)); } } return result.toString(); } HJ27：查找兄弟单词\r#\r定义一个单词的“兄弟单词”为：交换该单词字母顺序（注：可以交换任意次），而不添加、删除、修改原有的字母就能生成的单词。 兄弟单词要求和原来的单词不同。例如： ab 和 ba 是兄弟单词。 ab 和 ab 则不是兄弟单词。 现在给定你 n 个单词，另外再给你一个单词 x ，让你寻找 x 的兄弟单词里，按字典序排列后的第 k 个单词是什么？ 注意：字典中可能有重复单词。 数据范围：1≤n≤1000 ，输入的字符串长度满足1≤len(str)≤10，1≤k\u0026lt;n 输入描述：输入只有一行。 先输入字典中单词的个数n，再输入n个单词作为字典单词。 然后输入一个单词x最后后输入一个整数k 输出描述：第一行输出查找到x的兄弟单词的个数m，第二行输出查找到的按照字典顺序排序后的第k个兄弟单词，没有符合则不用输出。 输入：3 abc bca cab abc 1 输出：2 bca 题解\npublic static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { String[] arr = scanner.nextLine().split(\u0026#34; \u0026#34;); int num = Integer.parseInt(arr[0]); String x = arr[arr.length - 2]; int k = Integer.parseInt(arr[arr.length - 1]); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt;= num; i++) { if (isBrother(x, arr[i])) { list.add(arr[i]); } } int size = list.size(); System.out.println(size); if (size \u0026gt;= k) { Collections.sort(list); System.out.println(list.get(k - 1)); } } } public static boolean isBrother(String str1, String str2) { if (str1.length() != str2.length() || str2.equals(str1)) { return false; } char[] chars1 = str1.toCharArray(); char[] chars2 = str2.toCharArray(); Arrays.sort(chars1); Arrays.sort(chars2); return new String(chars1).equals(new String(chars2)); } HJ28：素数伴侣\r#\r描述\n若两个正整数的和为素数，则这两个正整数称之为“素数伴侣”，如2和5、6和13 从已有的N（N为偶数）个正整数中挑选出若干对组成“素数伴侣”，能组成“素数伴侣”最多的方案称为“最佳方案” 例如有4个正整数：2，5，6，13，如果将5和6分为一组中只能得到一组“素数伴侣”，而将2和5、6和13编组将得到两组“素数伴侣”，能组成“素数伴侣”最多的方案称为“最佳方案” 输入：有一个正偶数 n ，表示待挑选的自然数的个数。后面给出 n 个具体的数字。 输出：输出一个整数 K ，表示你求得的“最佳方案”组成“素数伴侣”的对数。 数据范围：1≤n≤100，输入的数据大小满足2≤val≤30000 输入描述：输入一个正偶数 n，输入 n 个整数 输出描述：求得的“最佳方案”组成“素数伴侣”的对数。 输入：4 2 5 6 13 输出：2 题解\n// 素数一定是奇数，因此素数伴侣一定是奇数+偶数 public static void main(String[] args) { //标准输入 Scanner sc = new Scanner(System.in); while (sc.hasNext()) { //输入正偶数 int n = sc.nextInt(); //用于记录输入的n个整数 int[] arr = new int[n]; //用于存储所有的奇数 ArrayList\u0026lt;Integer\u0026gt; odds = new ArrayList\u0026lt;\u0026gt;(); //用于存储所有的偶数 ArrayList\u0026lt;Integer\u0026gt; evens = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { arr[i] = sc.nextInt(); //将奇数添加到odds if (arr[i] % 2 == 1) { odds.add(arr[i]); } //将偶数添加到evens if (arr[i] % 2 == 0) { evens.add(arr[i]); } } //下标对应已经匹配的偶数的下标，值对应这个偶数的伴侣 int[] matcheven = new int[evens.size()]; //记录伴侣的对数 int count = 0; for (int j = 0; j \u0026lt; odds.size(); j++) { //用于标记对应的偶数是否查找过 boolean[] v = new boolean[evens.size()]; //如果匹配上，则计数加1 if (find(odds.get(j), matcheven, evens, v)) { count++; } } System.out.println(count); } } //判断奇数x能否找到伴侣 private static boolean find(int x, int[] matcheven, ArrayList\u0026lt;Integer\u0026gt; evens, boolean[] v) { for (int i = 0; i \u0026lt; evens.size(); i++) { //该位置偶数没被访问过，并且能与x组成素数伴侣 if (isPrime(x + evens.get(i)) \u0026amp;\u0026amp; v[i] == false) { v[i] = true; // 如果i位置偶数还没有伴侣，则与x组成伴侣 // 如果已经有伴侣，并且这个伴侣能重新找到新伴侣，则把原来伴侣让给别人，自己与x组成伴侣 if (matcheven[i] == 0 || find(matcheven[i], matcheven, evens, v)) { matcheven[i] = x; return true; } } } return false; } //判断x是否是素数 private static boolean isPrime(int x) { if (x == 1) return false; //如果能被2到根号x整除，则一定不是素数 for (int i = 2; i \u0026lt;= (int) Math.sqrt(x); i++) { if (x % i == 0) { return false; } } return true; } HJ29：字符串加解密\r#\r描述\n对输入的字符串进行加解密，并输出。 加密方法为： 当内容是英文字母时则用该英文字母的后一个字母替换，同时字母变换大小写,如字母a时则替换为B；字母Z时则替换为a； 当内容是数字时则把该数字加1，如0替换1，1替换2，9替换0； 其他字符不做变化。 解密方法为加密的逆过程。 数据范围：输入的两个字符串长度满足 1≤n≤1000，保证输入的字符串都是只由大小写字母或者数字组成 输入描述： 第一行输入一串要加密的密码 第二行输入一串加过密的密码 输出描述： 第一行输出加密后的字符 第二行输出解密后的字符 输入：abcdefg BCDEFGH 输出：BCDEFGH abcdefg 题解\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { System.out.println(encode(sc.nextLine())); System.out.println(decode(sc.nextLine())); } } //加密函数 private static String encode(String code) { char[] t = code.toCharArray(); for (int i = 0; i \u0026lt; t.length; i++) { if (t[i] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; t[i] \u0026lt; \u0026#39;z\u0026#39;) { t[i] = (char) (t[i] - \u0026#39;a\u0026#39; + \u0026#39;A\u0026#39; + 1); } else if (t[i] == \u0026#39;z\u0026#39;) { t[i] = \u0026#39;A\u0026#39;; } else if (t[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; t[i] \u0026lt; \u0026#39;Z\u0026#39;) { t[i] = (char) (t[i] - \u0026#39;A\u0026#39; + \u0026#39;a\u0026#39; + 1); } else if (t[i] == \u0026#39;Z\u0026#39;) { t[i] = \u0026#39;a\u0026#39;; } else if (t[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; t[i] \u0026lt; \u0026#39;9\u0026#39;) { t[i] = (char) (t[i] + 1); } else if (t[i] == \u0026#39;9\u0026#39;) { t[i] = \u0026#39;0\u0026#39;; } } return String.valueOf(t); } //解密函数 private static String decode(String password) { char[] t = password.toCharArray(); for (int i = 0; i \u0026lt; t.length; i++) { if (t[i] \u0026gt; \u0026#39;a\u0026#39; \u0026amp;\u0026amp; t[i] \u0026lt;= \u0026#39;z\u0026#39;) { t[i] = (char) (t[i] - \u0026#39;a\u0026#39; + \u0026#39;A\u0026#39; - 1); } else if (t[i] == \u0026#39;a\u0026#39;) { t[i] = \u0026#39;Z\u0026#39;; } else if (t[i] \u0026gt; \u0026#39;A\u0026#39; \u0026amp;\u0026amp; t[i] \u0026lt;= \u0026#39;Z\u0026#39;) { t[i] = (char) (t[i] - \u0026#39;A\u0026#39; + \u0026#39;a\u0026#39; - 1); } else if (t[i] == \u0026#39;A\u0026#39;) { t[i] = \u0026#39;z\u0026#39;; } else if (t[i] \u0026gt; \u0026#39;0\u0026#39; \u0026amp;\u0026amp; t[i] \u0026lt;= \u0026#39;9\u0026#39;) { t[i] = (char) (t[i] - 1); } else if (t[i] == \u0026#39;0\u0026#39;) { t[i] = \u0026#39;9\u0026#39;; } } return String.valueOf(t); } "},{"id":42,"href":"/lang2/program-design/structure-algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%9321/","title":"机试题库 - 21","section":"华为OD","content":"\r01. 盛最多水的容器\r#\r描述\n给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 说明：你不能倾斜容器。 输入：[1,8,6,2,5,4,8,3,7] 输出：49 题解\npublic int maxArea(int[] height) { int res = 0; int i = 0; int j = height.length - 1; while (i \u0026lt; j) { int area = (j - i) * Math.min(height[i], height[j]); res = Math.max(res, area); if (height[i] \u0026lt; height[j]) { i++; } else { j--; } } return res; } 02. 接雨水\r#\r描述\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 题解\npublic int trap(int[] height) { int sum = 0; //最两端的列不用考虑，因为一定不会有水。所以下标从 1 到 length - 2 for (int i = 1; i \u0026lt; height.length - 1; i++) { int max_left = 0; //找出左边最高 for (int j = i - 1; j \u0026gt;= 0; j--) { if (height[j] \u0026gt; max_left) { max_left = height[j]; } } int max_right = 0; //找出右边最高 for (int j = i + 1; j \u0026lt; height.length; j++) { if (height[j] \u0026gt; max_right) { max_right = height[j]; } } //找出两端较小的 int min = Math.min(max_left, max_right); //只有较小的一段大于当前列的高度才会有水，其他情况不会有水 if (min \u0026gt; height[i]) { sum = sum + (min - height[i]); } } return sum; } 03. 无重复字符的最长子串\r#\r描述\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。 输入: s = \u0026#34;abcabcbb\u0026#34; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026#34;abc\u0026#34;，所以其长度为 3。 题解\npublic int lengthOfLongestSubstring(String s) { int n = s.length(), ans = 0; Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int end = 0, start = 0; end \u0026lt; n; end++) { char alpha = s.charAt(end); if (map.containsKey(alpha)) { start = Math.max(map.get(alpha), start); } ans = Math.max(ans, end - start + 1); map.put(s.charAt(end), end + 1); } return ans; } 04. 岛屿数量\r#\r描述\n给你一个由 \u0026#39;1\u0026#39;（陆地）和 \u0026#39;0\u0026#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 输入：grid = [ [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;] ] 输出：3 题解\npublic int maxAreaOfIsland(int[][] grid) { int res = 0; for (int r = 0; r \u0026lt; grid.length; r++) { for (int c = 0; c \u0026lt; grid[0].length; c++) { if (grid[r][c] == 1) { int a = area(grid, r, c); res = Math.max(res, a); } } } return res; } int area(int[][] grid, int r, int c) { // 判断 base case if (!inArea(grid, r, c)) { return 0; } // 如果这个格子不是岛屿，直接返回 if (grid[r][c] != 1) { return 0; } // 将格子标记为「已遍历过」 grid[r][c] = 2; // 访问上、下、左、右四个相邻结点 return 1 + area(grid, r - 1, c) + area(grid, r + 1, c) + area(grid, r, c - 1) + area(grid, r, c + 1); } // 判断坐标 (r, c) 是否在网格中 boolean inArea(int[][] grid, int r, int c) { return 0 \u0026lt;= r \u0026amp;\u0026amp; r \u0026lt; grid.length \u0026amp;\u0026amp; 0 \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt; grid[0].length; } 05. 不同的二叉搜索树\r#\r描述\n给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 输入：n = 3 输出：5 题解\npublic int numTrees(int n) { // 提示：我们在这里需要用 long 类型防止计算过程中的溢出 long C = 1; for (int i = 0; i \u0026lt; n; ++i) { C = C * 2 * (2 * i + 1) / (i + 2); } return (int) C; } /* dp[i] = i个不同的数组成的二叉搜索数的个数 假设 i = 5 当根节点等于 1 时 ，其余数字都比1大，只能在右边 dp[i] += dp[4] 当根节点等于 2 时，左边有一个1比2小，右边有三个比2大的数字 dp[i] += dp[1] * dp[3] 当根节点等于 3 时，左边有两个数比3小，右边有两个数比3大的数字 dp[i] += dp[2] * dp[2] ... 知道根节点等于5，左边有4个数字比5小，只能放在5的左边,dp[i] += dp[4] */ public int numTrees(int n) { int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= i; j++) { int leftNum = dp[j - 1]; int rightNum = dp[i - j]; dp[i] += leftNum * rightNum; } } return dp[n]; } 06. 买卖股票的最佳时机 II\r#\r描述\n给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。 返回 你能获得的 最大 利润 。 输入：prices = [7,1,5,3,6,4] 输出：7 题解\npublic int maxProfit(int[] prices) { int profit = 0; for (int i = 1; i \u0026lt; prices.length; i++) { int tmp = prices[i] - prices[i - 1]; if (tmp \u0026gt; 0) profit += tmp; } return profit; } 07. 买卖股票的最佳时机 III\r#\r描述\n给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 题解\npublic int maxProfit(int[] prices) { // 第一次买入，第一次卖出，第二次买入，第二次卖出 int f1 = -prices[0], f2 = 0, f3 = -prices[0], f4 = 0; for (int i = 1; i \u0026lt; prices.length; ++i) { f1 = Math.max(f1, -prices[i]); f2 = Math.max(f2, f1 + prices[i]); f3 = Math.max(f3, f2 - prices[i]); f4 = Math.max(f4, f3 + prices[i]); } return f4; } 08. 打家劫舍II\r#\r描述\n你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。 输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 题解\npublic int rob(int[] nums) { int length = nums.length; if (length == 1) { return nums[0]; } else if (length == 2) { return Math.max(nums[0], nums[1]); } return Math.max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1)); } public int robRange(int[] nums, int start, int end) { int first = nums[start]; int second = Math.max(nums[start], nums[start + 1]); for (int i = start + 2; i \u0026lt;= end; i++) { int temp = second; second = Math.max(first + nums[i], second); first = temp; } return second; } 09. 爬楼梯\r#\r描述\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 输入：n = 3 输出：3 解释：有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 题解\n// 状态定义： 设 dp 为一维数组，其中 dp[i] 的值代表斐波那契数列的第 i 个数字。 // 转移方程： dp[i+1]=dp[i]+dp[i−1] ，即对应数列定义 f(n+1)=f(n)+f(n−1) 。 // 初始状态： dp[0]=1, dp[1]=1 ，即初始化前两个数字。 // 返回值： dp[n] ，即斐波那契数列的第 n 个数字。 public int climbStairs(int n) { int a = 1, b = 1, sum; for(int i = 0; i \u0026lt; n - 1; i++){ sum = a + b; a = b; b = sum; } return b; } 10. 路径总和\r#\r描述\n给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 叶子节点 是指没有子节点的节点。 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 输出：true 题解\npublic boolean hasPathSum(TreeNode root, int sum) { if (root == null) { return false; } if (root.left == null \u0026amp;\u0026amp; root.right == null) { return sum == root.val; } return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); } public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } 11. 斐波那契数\r#\r描述\n斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。 该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n \u0026gt; 1 给定 n ，请计算 F(n) 。 输入：n = 4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3 题解\npublic int fib(int n) { int a = 0, b = 1, sum; for(int i = 0; i \u0026lt; n; i++){ sum = a + b; a = b; b = sum; } return a; } 12. 合并 K 个升序链表\r#\r描述\n给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 输入：lists = [[1,4,5],[1,3,4],[2,6]] 输出：[1,1,2,3,4,4,5,6] 题解\npublic class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) { return null; } // 将所有链表的所有节点加入列表 List\u0026lt;Integer\u0026gt; list = new ArrayList(); for(ListNode node : lists){ while(node != null){ list.add(node.val); node = node.next; } } // 列表排序 list = list.stream().sorted().collect(Collectors.toList()); // 列表转链表 ListNode head = new ListNode(0); ListNode cur = head; for(int val : list){ cur.next = new ListNode(val); cur = cur.next; } return head.next; } 13. 多数元素\r#\r描述\n给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 输入：nums = [3,2,3] 输出：3 题解\npublic int majorityElement(int[] nums) { Arrays.sort(nums); return nums[nums.length / 2]; } 14. 搜索二维矩阵 II\r#\r描述\n编写一个高效的算法来搜索 m * n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5 输出：true 题解\npublic boolean searchMatrix(int[][] matrix, int target) { int i = matrix.length - 1, j = 0; while (i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; matrix[0].length) { if (matrix[i][j] \u0026gt; target) i--; else if (matrix[i][j] \u0026lt; target) j++; else return true; } return false; } 15. 柱状图中最大的矩形\r#\r描述\n给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中红色区域，面积为 10 题解\npublic int largestRectangleArea(int[] heights) { int len = heights.length; // 特判 if (len == 0) { return 0; } int res = 0; for (int i = 0; i \u0026lt; len; i++) { // 找左边最后 1 个大于等于 heights[i] 的下标 int left = i; int curHeight = heights[i]; while (left \u0026gt; 0 \u0026amp;\u0026amp; heights[left - 1] \u0026gt;= curHeight) { left--; } // 找右边最后 1 个大于等于 heights[i] 的索引 int right = i; while (right \u0026lt; len - 1 \u0026amp;\u0026amp; heights[right + 1] \u0026gt;= curHeight) { right++; } int width = right - left + 1; res = Math.max(res, width * curHeight); } return res; } 16. 最大矩形\r#\r描述\n给定一个仅包含 0 和 1 、大小为 rows * cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 输入：matrix = [ [\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;]] 输出：6 题解\npublic int maximalRectangle(char[][] matrix) { int m = matrix.length; if (m == 0) { return 0; } int n = matrix[0].length; int[][] left = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (matrix[i][j] == \u0026#39;1\u0026#39;) { left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1; } } } int ret = 0; for (int j = 0; j \u0026lt; n; j++) { // 对于每一列，使用基于柱状图的方法 int[] up = new int[m]; int[] down = new int[m]; Deque\u0026lt;Integer\u0026gt; stack = new LinkedList\u0026lt;Integer\u0026gt;(); for (int i = 0; i \u0026lt; m; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; left[stack.peek()][j] \u0026gt;= left[i][j]) { stack.pop(); } up[i] = stack.isEmpty() ? -1 : stack.peek(); stack.push(i); } stack.clear(); for (int i = m - 1; i \u0026gt;= 0; i--) { while (!stack.isEmpty() \u0026amp;\u0026amp; left[stack.peek()][j] \u0026gt;= left[i][j]) { stack.pop(); } down[i] = stack.isEmpty() ? m : stack.peek(); stack.push(i); } for (int i = 0; i \u0026lt; m; i++) { int height = down[i] - up[i] - 1; int area = height * left[i][j]; ret = Math.max(ret, area); } } return ret; } 17. 每日温度\r#\r描述\n给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。 输入: temperatures = [73,74,75,71,69,72,76,73] 输出: [1,1,4,2,1,1,0,0] 题解\npublic int[] dailyTemperatures(int[] T) { int length = T.length; int[] result = new int[length]; for (int i = 0; i \u0026lt; length; i++) { int current = T[i]; if (current \u0026lt; 100) { for (int j = i + 1; j \u0026lt; length; j++) { if (T[j] \u0026gt; current) { result[i] = j - i; break; } } } } return result; } 18. 下一个更大元素 II\r#\r描述\n给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。 数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。 输入: nums = [1,2,3,4,3] 输出: [2,3,4,-1,4] 题解\npublic int[] nextGreaterElements(int[] nums) { int n = nums.length; int[] ret = new int[n]; Arrays.fill(ret, -1); Deque\u0026lt;Integer\u0026gt; stack = new LinkedList\u0026lt;Integer\u0026gt;(); for (int i = 0; i \u0026lt; n * 2 - 1; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; nums[stack.peek()] \u0026lt; nums[i % n]) { ret[stack.pop()] = nums[i % n]; } stack.push(i % n); } return ret; } 19. 和为 K 的子数组\r#\r描述\n给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。 子数组是数组中元素的连续非空序列。 输入：nums = [1,1,1], k = 2 输出：2 题解\npublic int subarraySum(int[] nums, int k) { int len = nums.length; // 计算前缀和数组 int[] preSum = new int[len + 1]; preSum[0] = 0; for (int i = 0; i \u0026lt; len; i++) { preSum[i + 1] = preSum[i] + nums[i]; } int count = 0; for (int left = 0; left \u0026lt; len; left++) { for (int right = left; right \u0026lt; len; right++) { // 区间和 [left..right]，注意下标偏移 if (preSum[right + 1] - preSum[left] == k) { count++; } } } return count; } 20. 买卖股票的最佳时机\r#\r描述\n定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 输入：[7,1,5,3,6,4] 输出：5 题解\npublic int maxProfit(int[] prices) { int cost = Integer.MAX_VALUE, profit = 0; for (int price : prices) { cost = Math.min(cost, price); profit = Math.max(profit, price - cost); } return profit; } 21. 课程表 II\r#\r描述\n现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。 返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。 输入：numCourses = 2, prerequisites = [[1,0]] 输出：[0,1] 题解\n// 简单的 BFS public int[] findOrder(int numCourses, int[][] prerequisites) { if (numCourses == 0) return new int[0]; int[] inDegrees = new int[numCourses]; // 建立入度表 for (int[] p : prerequisites) { // 对于有先修课的课程，计算有几门先修课 inDegrees[p[0]]++; } // 入度为0的节点队列 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; inDegrees.length; i++) { if (inDegrees[i] == 0) queue.offer(i); } int count = 0; // 记录可以学完的课程数量 int[] res = new int[numCourses]; // 可以学完的课程 // 根据提供的先修课列表，删除入度为 0 的节点 while (!queue.isEmpty()){ int curr = queue.poll(); res[count++] = curr; // 将可以学完的课程加入结果当中 for (int[] p : prerequisites) { if (p[1] == curr){ inDegrees[p[0]]--; if (inDegrees[p[0]] == 0) queue.offer(p[0]); } } } if (count == numCourses) return res; return new int[0]; } 22. 单词替换\r#\r描述\n在英语中，我们有一个叫做 词根(root) 的概念，可以词根 后面 添加其他一些词组成另一个较长的单词——我们称这个词为 衍生词 (derivative)。例如，词根 help，跟随着 继承词 \u0026#34;ful\u0026#34;，可以形成新的单词 \u0026#34;helpful\u0026#34;。 现在，给定一个由许多 词根 组成的词典 dictionary 和一个用空格分隔单词形成的句子 sentence。你需要将句子中的所有 衍生词 用 词根 替换掉。如果 衍生词 有许多可以形成它的 词根，则用 最短 的 词根 替换它。 你需要输出替换之后的句子。 输入：dictionary = [\u0026#34;cat\u0026#34;,\u0026#34;bat\u0026#34;,\u0026#34;rat\u0026#34;], sentence = \u0026#34;the cattle was rattled by the battery\u0026#34; 输出：\u0026#34;the cat was rat by the bat\u0026#34; 题解\npublic String replaceWords(List\u0026lt;String\u0026gt; dictionary, String sentence) { Set\u0026lt;String\u0026gt; dictionarySet = new HashSet\u0026lt;String\u0026gt;(); for (String root : dictionary) { dictionarySet.add(root); } String[] words = sentence.split(\u0026#34; \u0026#34;); for (int i = 0; i \u0026lt; words.length; i++) { String word = words[i]; for (int j = 0; j \u0026lt; word.length(); j++) { if (dictionarySet.contains(word.substring(0, 1 + j))) { words[i] = word.substring(0, 1 + j); break; } } } return String.join(\u0026#34; \u0026#34;, words); } 23.\r#\r描述\n题解\n24.\r#\r描述\n题解\n25.\r#\r描述\n题解\n"},{"id":43,"href":"/lang2/program-design/structure-algorithm/huawei-od/%E6%9C%BA%E8%AF%95%E9%A2%98%E5%BA%9322/","title":"机试题库 - 22","section":"华为OD","content":"\r01.\r#\r描述\n题解\n02.\r#\r描述\n题解\n03.\r#\r描述\n题解\n04.\r#\r描述\n题解\n05.\r#\r描述\n题解\n06.\r#\r描述\n题解\n07.\r#\r描述\n题解\n08.\r#\r描述\n题解\n09.\r#\r描述\n题解\n10.\r#\r描述\n题解\n11.\r#\r描述\n题解\n12.\r#\r描述\n题解\n13.\r#\r描述\n题解\n14.\r#\r描述\n题解\n15.\r#\r描述\n题解\n16.\r#\r描述\n题解\n17.\r#\r描述\n题解\n18.\r#\r描述\n题解\n19.\r#\r描述\n题解\n20.\r#\r描述\n题解\n21.\r#\r描述\n题解\n22.\r#\r描述\n题解\n23.\r#\r描述\n题解\n24.\r#\r描述\n题解\n25.\r#\r描述\n题解\n"},{"id":44,"href":"/lang2/program-design/structure-algorithm/huawei-od/%E5%85%A8/","title":"索引","section":"华为OD","content":"\r必会题 - 1\r#\r#01-字符串分割 01. 字符串分割 02. 组成最大数 03. 统计射击比赛成绩 04. 字符串序列判定 05. 数据分类 06. 五键键盘的输出 07. 检查是否存在满足条件的数字组合 08. 数组拼接 09. 数列描述 10. 考勤信息 11. 按单词下标区间翻转文章内容 12. 最大括号深度 13. 字符串加密 14. 整数对最小和 15. 求字符串中所有整数的最小和 16. 乱序整数序列两数之和绝对值最小 17. 非严格递增连续数字序列 18. 分积木 19. 连续字母长度 20. 滑动窗口最大和 21. 素数之积 22. 仿LISP运算 23. 贪吃蛇 24. 解密犯罪时间 25. 求满足条件的最长子串的长度\n必会题 - 2\r#\r01. 机器人走迷宫 02. 高效的任务规划 03. 二叉树遍历 04. 书籍叠放 05. 区间交集 06. 分月饼 07. 找最小数 08. 简易内存池 09. 服务失效判断 10. 图像物体的边界 11. 跳格子游戏 12. 最小叶子节点 13. 考古学家 14. 解压报文 15. 最长的指定瑕疵度的元音子串 16. 目录删除 17. 吃火锅 18. 服务器广播 19. 二叉树的广度优先遍历 20. 单词搜索 21. 最少面试官数 22. 斗地主之顺子\n参考题 - 1\r#\r01. 字符串反转 02. 数字颠倒 03. 表达式求值 04. 字符逆序 05. 尼科彻斯定力 06. 公共子串计算 07. 求最大连续bit数 08. 最长回文子串 09. 等差数列 10. 密码强度等级 11. 字符个数统计 12. 截取字符串 13. 查找组成一个偶数最接近的两个素数 14. 统计字符 15. 字符串排序 16. 进制转换 17. 找出字符串中第一个只出现一次的字符 18. 输入n个整数，输出其中最小的K个 19. 字符串字符匹配\n机库题 - 1\r#\r01. 车路协同场景 02. API集群负载统计 03. CPU算力分配 04. We Are A Team 05. 爱吃蟠桃的孙悟空 06. 按身高和体重排队 07. 报数游戏 08. 表达式括号匹配 09. 部门人力分配 10. 求幸存数之和 11. 测试用例执行计划 12. 查找接口成功率最优时间段 13. 查找众数及中位数 14. 单词加密 15. 单词接龙 16. 单词重量 17. 德州扑克 18. 第k个排列 19. 堆内存申请 20. 堆栈中的剩余数字 21. 多段线数据压缩 22. 翻牌求最大分 23. 分割均衡字符串 24. 分配土地 25. 分披萨\n机库题 - 2\r#\r01. 工号不够用了怎么办 02. 勾股数元组 03. 冠亚军排名，奖牌榜排名 04. 猴子爬山 05. 滑动窗口最大和 06. 灰度图存储 07. 会议室占用时间 08. 绘图机器 09. 火星文计算 10. 机场航班调度程序 11. 机器人搬砖 12. 计算礼品发放的最小分组数目 13. 计算三叉搜索树的高度 14. 检查是否存在满足条件的数字组合 15. 解密犯罪时间 16. 精准核酸检测 17. 开源项目热度榜单 18. 考勤信息 19. 靠谱的车 20. 快递运输 21. 括号匹配 22. 来自异国的客人 23. 连续字母长度 24. 两数之和绝对值最小 25. 螺旋数字矩阵\n机库题 - 3\r#\r01. 密码解密 02. 密码输入检测 03. 密钥格式化 04. 免单统计 05. 内存冷热标记 06. 攀登者 07. 判断字符串子序列 08. 拼接URL 09. 悄悄话 10. 求符合要求的结对方式 11. 求解连续数列 12. 求满足条件的最长子串的长度 13. 求字符串中所有整数的最小和 14. 求最多可以派出多少支团队 15. 全排列 16. 生成哈夫曼树 17. 剩余银饰的重量 18. 石头剪刀布游戏 19. 手机App防沉迷系统 20. 输出指定字母在字符串的中的索引 21. 数的分解 22. 数据单元的变化替换 23. 数字涂色 24. 数字字符串组合倒序 25. 数组连续和\n机库题 - 4\r#\r01. 数组组成的最小数字 02. 水仙花数 03. 素数之积 04. 提取字符串中的最长合法简单数学表达式 05. 停车场车辆统计 06. 围棋的气 07. 消消乐游戏 08. 小华地图寻宝 09. 小明的幸运数 10. 小明找位置 11. 小朋友来自多少小区 12. 虚拟理财游戏 13. 寻找身高相近的小朋友 14. 寻找相同子串 15. 一种字符串压缩表示的解压 16. 英文输入法 17. 用户调度问题 18. 用连续自然数之和来表达整数 19. 游戏分组 20. 约瑟夫问题 21. 在字符串中找出连续最长的数字串 22. 掌握的单词个数 23. 找出符合要求的字符串子串 24. 找出经过特定点的路径长度 25. 找朋友\n机库题 - 5\r#\r01. 找座位 02. 整数对最小和 03. 整型数组按个位值排序 04. 执行任务赚积分 05. 执行时长 06. 智能成绩表 07. 转盘寿司 08. 字符串变换最小字符串 09. 字符串分割 10. 字符串排序 11. 字符串筛选排序 12. 字符串序列判定 13. 字符统计及重排 14. 最大N个数与最小N个数的和 15. 最大股票收益 16. 最大矩阵和 17. 最大括号深度 18. 最大时间 19. 最多购买宝石数目 20. 最富裕的小家庭 21. 最长的指定瑕疵度的元音子串 22. 最长子字符串的长度 23. 堆内存申请\n机库题 - 11\r#\r01. 5G网络建设 02. N进制减法 03. TLV解析 04. Wonderland 05. 比较两个版本号的大小 06. 猜密码 07. 查找一个有向网络的头节点和尾节点 08. 出错的或电路 09. 打印任务排序 10. 导师请吃火锅 11. 电脑病毒感染 12. 叠积木 13. 二叉树的广度优先遍历 14. 二叉树计算 15. 发广播 16. 伐木工 17. 反射计数 18. 分月饼 19. 符号运算 20. 高效的任务规划 21. 高效货运 22. 根据IP查找城市 23. 欢乐的周末 24. 机器人走迷宫 25. 计算疫情扩散时间\n机库题 - 12\r#\r01. 简易内存池 02. 结队编程 03. 九宫格按键输入 04. 矩阵匹配 05. 考古学家 06. 可以处理的最大任务数 07. 可以组成网络的服务器 08. 快递员的烦恼 09. 快速人名查找 10. 篮球游戏 11. 连续出牌数量 12. 两个字符串间的最短路径问题 13. 路口最短时间问题 14. 没有回文串 15. 迷宫问题 16. 模拟目录管理功能 17. 模拟数据序列化传输 18. 攀登者2 19. 启动多任务排序 20. 抢7游戏 21. 亲子游戏 22. 任务最优调度 23. 数字排列 24. 数组二叉树 25. 贪吃的猴子\n机库题 - 13\r#\r01. 贪吃蛇 02. 贪心歌手 03. 特殊的加密算法 04. 田忌赛马 05. 跳格子3 06. 跳马 07. 图像物体的边界 08. 推荐多样性 09. 文本统计分析 10. 文件缓存系统 11. 污染水域 12. 项目排期 13. 小朋友分组最少调整次数 14. 信道分配 15. 寻找最优的路测线路 16. 园区参观路径 17. 员工派遣 18. 运输时间 19. 找城市 20. 找单词 21. 找到比自己强的人数 22. 找数字 23. 智能驾驶 24. 中文分词模拟器 25. 转骰子\n机库题 - 14\r#\r01. 字符串比较 02. 字符串拼接 03. 最大社交距离 04. 最小传输时延Ⅱ 05. 最小矩阵宽度 06. 最长子字符串的长度(二)\n华为机试\r#\rHJ1：字符串最后一个单词的长度 HJ2：计算某字符出现次数 HJ3：明明的随机数 HJ4：字符串分隔 HJ5：进制转换 HJ6：质数因子 HJ7：取近似值 HJ8：合并表记录 HJ9：提取不重复的整数 HJ10：字符个数统计 HJ11：数字颠倒 HJ12：字符串反转 HJ13：句子逆序 HJ14：字符串排序 HJ15：求int型正整数在内存中存储时1的个数 HJ16：购物单 HJ17：坐标移动 HJ18：识别有效的IP地址和掩码并进行分类统计 HJ19：简单错误记录 HJ20：密码验证合格程序 HJ21：简单密码 HJ22：汽水瓶 HJ23：删除字符串中出现次数最少的字符 HJ26：字符串排序 HJ27：查找兄弟单词 HJ28：素数伴侣 HJ29：字符串加解密\n机库题 - 21\r#\r01. 盛最多水的容器 02. 接雨水 03. 无重复字符的最长子串 04. 岛屿数量 05. 不同的二叉搜索树 06. 买卖股票的最佳时机 II 07. 买卖股票的最佳时机 III 08. 打家劫舍II 09. 爬楼梯 10. 路径总和 11. 斐波那契数 12. 合并 K 个升序链表 13. 多数元素 14. 搜索二维矩阵 II 15. 柱状图中最大的矩形 16. 最大矩形 17. 每日温度 18. 下一个更大元素 II 19. 和为 K 的子数组 20. 买卖股票的最佳时机 21. 课程表 II 22. 单词替换\n"}]