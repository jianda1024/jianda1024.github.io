<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Spring on Interview</title>
    <link>https://localhost:1313/interview/framework/spring/</link>
    <description>Recent content in Spring on Interview</description>
    <generator>Hugo</generator>
    <language>interview</language>
    <atom:link href="https://localhost:1313/interview/framework/spring/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Part.1</title>
      <link>https://localhost:1313/interview/framework/spring/p1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://localhost:1313/interview/framework/spring/p1/</guid>
      <description>&lt;h2 id=&#34;---spring&#34;&gt;&#xD;&#xA;  &amp;ndash; Spring&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#---spring&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Spring 是一个开源的轻量级 Java 开发框架&lt;/li&gt;&#xA;&lt;li&gt;Spring 的核心是控制反转（IoC）和面向切面（AOP）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;---spring-优点&#34;&gt;&#xD;&#xA;  &amp;ndash; Spring 优点&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#---spring-%e4%bc%98%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;div style=&#34;font-weight:400&#34;&gt;方便解耦，简化开发&lt;/div&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;div style=&#34;font-weight:400&#34;&gt;用户可以将所有对象的创建和依赖关系的维护，交给Spring管理&lt;/div&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;支持AOP编程&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;支持声明式事务&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;只需要通过配置就可以完成对事务的管理，而无需手动编程&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;方便程序测试&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Spring对Junit4支持，可以通过注解方便的测试Spring程序&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;集成各种优秀框架&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Spring内部提供了对各种优秀框架的直接支持&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;简化JavaEE的使用&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Spring对JavaEE开发中非常难用的一些API，都提供了封装，降低了使用难度&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;---ioc&#34;&gt;&#xD;&#xA;  &amp;ndash; IOC&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#---ioc&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Inversion of Control，即“控制反转”，是一种设计思想，用于解决对象之间的耦合问题。&lt;/li&gt;&#xA;&lt;li&gt;以前对象的创建及依赖关系是由开发人员自己维护，现在反转交给 spring 来完成创建及注入&lt;/li&gt;&#xA;&lt;li&gt;控制：指的是对象创建（实例化、管理）的权利&lt;/li&gt;&#xA;&lt;li&gt;反转：控制权交给外部环境了（spring框架、IoC容器）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;---ioc-容器&#34;&gt;&#xD;&#xA;  &amp;ndash; IoC 容器&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#---ioc-%e5%ae%b9%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;具有依赖注入功能的容器，它可以创建对象，负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖&lt;/li&gt;&#xA;&lt;li&gt;IoC容器底层其实就是一个Bean工厂，Spring提供了两种IoC容器，即BeanFactory、ApplicationContext&lt;/li&gt;&#xA;&lt;li&gt;BeanFactory：最简单的IoC容器，它提供了IoC容器最基本的功能&lt;/li&gt;&#xA;&lt;li&gt;ApplicationContext：BeanFactory的子接口，并添加了更多的企业特定的功能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;---iocdi&#34;&gt;&#xD;&#xA;  &amp;ndash; IOC、DI&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#---iocdi&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DI，Dependency Injection，即“依赖注入”，由容器动态的将某个依赖关系注入到组件之中。&lt;/li&gt;&#xA;&lt;li&gt;IOC 是一种软件设计思想，DI 是这种软件设计思想的一个实现。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;---aop&#34;&gt;&#xD;&#xA;  &amp;ndash; AOP&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#---aop&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Aspect Oriented Programming，面向切面编程，是一种编程思想&lt;/li&gt;&#xA;&lt;li&gt;是通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术&lt;/li&gt;&#xA;&lt;li&gt;在面向对象编程(OOP)中，基本单元是类(class)，而 AOP 中的基本单元是切面(aspect)&lt;/li&gt;&#xA;&lt;li&gt;OOP是解决了纵向的代码复用问题，AOP是解决了横向的代码复用问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;---aop-术语&#34;&gt;&#xD;&#xA;  &amp;ndash; AOP 术语&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#---aop-%e6%9c%af%e8%af%ad&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;术语&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;名称&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Jointpoint&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;连接点&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;程序类中，允许插入通知（Advice）的位置点&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Pointcut&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;切入点&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;程序类中，已经插入通知（Advice）的位置点&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Advice&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;通知、增强&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;在切入点（Pointcut）上要执行的代码&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Aspect&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;切面&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;是切入点（Pointcut）和通知（Advice）的结合&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Target&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;目标&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;被织入通知（Advice）的目标对象，这个对象永远是一个被代理对象&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Weaving&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;织入&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;将通知（Advice）添加到目标类具体连接点上的过程&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;---aop-通知类型&#34;&gt;&#xD;&#xA;  &amp;ndash; AOP 通知类型&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#---aop-%e9%80%9a%e7%9f%a5%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;通知&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;备注&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;around&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;环绕通知&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;在建议方法调用之前和之后，执行通知。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;before&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;前置通知&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;在一个方法执行之前，执行通知。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;after&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;后置通知&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;在一个方法执行之后，不考虑其结果，执行通知。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;after-returning&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;正常返回通知&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;在一个方法执行之后，只有在方法成功完成时，才能执行通知。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;after-throwing&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;异常返回通知&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;在一个方法执行之后，只有在方法退出抛出异常时，才能执行通知。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;---bean&#34;&gt;&#xD;&#xA;  &amp;ndash; Bean&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#---bean&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Bean是指由Spring IoC容器实例化、组装和管理的对象&lt;/li&gt;&#xA;&lt;li&gt;可以把Spring IoC容器看作是一个大工厂，Bean就相当于工厂的产品&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;---bean-作用域&#34;&gt;&#xD;&#xA;  &amp;ndash; Bean 作用域&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#---bean-%e4%bd%9c%e7%94%a8%e5%9f%9f&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于prototype作用域的Bean来说，Spring IoC 容器只负责创建&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;作用域&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;singleton&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;默认值，在 spring IoC 容器仅存在一个 Bean 实例&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;prototype&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;每次通过 Spring 容器获取 Bean 时，容器都会创建一个新的 Bean 实例&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;request&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;每次 HTTP 请求，容器都会创建一个 Bean 实例， 仅在当前 HTTP Request 内有效&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;session&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;同一个 HTTP Session 共享一个 Bean 实例，仅在当前 HTTP Session 内有效&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;application&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;同一个 Web 应用共享一个 Bean 实例，在当前 ServletContext 内有效&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;---bean-生命周期&#34;&gt;&#xD;&#xA;  &amp;ndash; Bean 生命周期&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#---bean-%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;实例化&lt;/p&gt;</description>
    </item>
    <item>
      <title>Part.2</title>
      <link>https://localhost:1313/interview/framework/spring/p2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://localhost:1313/interview/framework/spring/p2/</guid>
      <description>&lt;h2 id=&#34;---spring-mvc&#34;&gt;&#xD;&#xA;  &amp;ndash; Spring MVC&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#---spring-mvc&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一种基于 Java 的、实现了 MVC 设计模式的、请求驱动类型的轻量级 Web 框架。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;---mvc-设计模式&#34;&gt;&#xD;&#xA;  &amp;ndash; MVC 设计模式&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#---mvc-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Model、View、Controller&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;是一种软件设计典范，通过分离业务逻辑、数据、界面显示的方式来组织代码。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;使程序分层、分工合作，既相互独立，又协同合作。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;div style=&#34;font-weight:400&#34;&gt;Model&lt;/div&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;div style=&#34;font-weight:400&#34;&gt;模型&lt;/div&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;div style=&#34;font-weight:400&#34;&gt;负责数据封装及业务逻辑处理 &lt;/div&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;View&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;视图&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;负责渲染模型数据，进行可视化展示&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Controller&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;控制器&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;负责居中调度。将接收的用户请求，指派给模型进行处理，并将结果传递给视图进行展示&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;---spring-mvc-工作流程&#34;&gt;&#xD;&#xA;  &amp;ndash; Spring MVC 工作流程&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#---spring-mvc-%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1.  发起请求到前端控制器。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2.  前端控制器请求 HandlerMapping 查找 Handler。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;3.  HandlerMapping 向前端控制器返回 Handler 执行链。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;4.  前端控制器调用 HandlerAdapter 去执行 Handler。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;5.  HandlerAdapter 执行 Handler。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;6.  Handler 执行完成后，向 HandlerAdapter 返回 ModelAndView。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;7.  HandlerAdapter 将 ModelAndView返回给前端控制器。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;8.  前端控制器将 ModelAndView 传给 ViewReslover。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;9.  ViewReslover 解析后，向前端控制器返回具体 View。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;10. 前端控制器根据 View 进行渲染视图。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;11. 前端控制器响应用户。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
  </channel>
</rss>
