[{"id":0,"href":"/interview/13_dev-tool/git/","title":"Git","section":"开发工具","content":"\r\u0026ndash; 版本控制\r#\rSVN：是基于差异的版本控制，存储的是一组基本文件和每个文件随时间逐步累积的差异\n优缺点：节省磁盘空间，耗时、效率低。 不适合的领域：跨地域的协同开发、追求高质量代码和代码门禁 Git：是基于快照的版本控制，存储的是文件的一系列快照\n优缺点：版本切换时非常快，占用磁盘空间较大 不适合的领域：目录级别的读授权、word等二进制文档的版本控制 \u0026ndash; Git 工作流程\r#\r工作区：日常工作的工程目录\n暂存区：又称索引，工程根目录.git/index 文件夹\n版本区：又称本地仓库，工程根目录.git文件夹\n\u0026ndash; Git 基本命令\r#\r"},{"id":1,"href":"/interview/04_jvm/java-jvm/p1/","title":"Part.1","section":"Java虚拟机","content":"\r\u0026ndash; JVM 结构\r#\r类加载器，Class Loader 执行引擎，Execution Engine 运行时数据区，Runtime Data Area 本地方法接口，Native Interface \u0026ndash; 类加载过程\r#\r\u0026ndash; 类加载机制\r#\r双亲委派模式\n1. 当类加载器需要加载某一个 .class 字节码文件时，它会首先将这个任务委托给其父类加载器。 2. 递归这个操作，直至传递到顶层的启动类加载器。 3. 只有当父类加载器无法完成此加载任务时，子类加载器才会自己去加载。 优点\n1. 避免类的重复加载 2. 避免Java的核心API被篡改 3. Java类随着类加载器一起具备了带有优先级的层级关系 \u0026ndash; JVM 内存模型\r#\r方法区\n即永久代 用于存储类信息、常量、静态常量、即时编译后的代码 运行时常量池，也是方法区的一部分，用于存放编译期生成的各种字面量和符号引用 堆内存\n用于存储对象实例、数组 是垃圾收集器管理的主要区域 堆内存采用分代收集算法，又细分为：新生代（Eden区、SurvivorFrom区、SurvivorTo区）、老年代 虚拟机栈\n栈内存，是Java方法执行的内存模型 每个方法被执行时，都会创建一个栈帧来存储局部变量表、操作数栈、动态链接、方法出口等信息 方法从被调用到执行完成的过程，就对应着栈帧在虚拟机栈中从入栈到出栈的过程 本地方法栈\n与虚拟机栈相同，区别是虚拟机栈为执行 Java 方法服务，而本地方法栈则为 Native 方法服务 程序计算器\n在 Java 虚拟机中，唯一没有 OOM 的区域 是一小块内存空间，用于存储当前线程正在执行字节码指令的地址值 正在执行 Java 方法时，记录的是当前指令的地址 正在执行 Native 方法时，则为 Undefined \u0026ndash; 内存区域分代\r#\r新生代\n由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收 分为：Eden区、ServivorFrom区、ServivorTo区 老年代\n主要存放应用程序中生命周期长的内存对象，老年代的对象比较稳定，所以 MajorGC 不会频繁执行 永久代\n指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息 GC 不会在主程序运行期对永久区域进行清理 在JDK1.8中，永久代被元空间取代，元空间并不在虚拟机中，而是使用本地内存 \u0026ndash; 堆和栈的区别\r#\r堆内存\r栈内存\r功能不同\r存储Java中的对象\r存储局部变量和方法调用\r共享性不同\r是线程共有的\r是线程私有的\r异常错误不同\r堆空间不足：java.lang.OutOfMemoryError\r栈空间不足：java.lang.StackOverFlowError\r空间大小\r堆内存远远大于栈内存\r\u0026ndash; 垃圾收集算法\r#\r标记-清除\n标记：扫描内存空间，对存活的对象进行标记 清除：扫描内存空间，回收未标记的对象。 标记-压缩\n标记：扫描内存空间，对存活的对象进行标记 压缩：再次扫描，并整理存活的对象 复制算法\n从 From 区找到存活的对象，复制到 To 区。 From、To区交互身份，进行下一轮垃圾收集。 \u0026ndash; 垃圾判定算法\r#\r引用计数法\n1、给对象添加一个引用计数器，记录引用该对象的次数 2、新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收 3、缺陷：无法解决对象间循环引用的问题 可达性分析法\n1、从GC Roots开始向下搜索，搜索所走过的路径称为引用链。 2、当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，即垃圾对象 \u0026ndash; 垃圾回收方式\r#\r串行（Serial）、并行（Parallel）、并发（Concurrent）、STW \u0026ndash; JVM 垃圾收集器\r#\r垃圾收集器 作用区域 收集算法 收集方式 说明 Serial 新生代 复制算法 串行 优点：简单高效 ParNew 新生代 复制算法 并行 Serial的多线程版本 Serial Old 老年代 标记-整理算法 串行 Serial的老年代版本 . Parallel Scavenge 新生代 复制算法 并行 追求高吞吐量，高效利用 CPU Parallel Old 老年代 标记-整理算法 并行 Parallel Scavenge的老年代版本 . CMS 老年代 标记-清除算法 并行 优点：高并发、低停顿 G1 新生代、老年代 标记-整理算法 并行 \u0026ndash; 触发FullGC执行的场景\r#\r1、直接触发 直接调用System.gc jvm参数显式地触发 2、内存区域已满 永久代或元空间内存不足 老年代内存不足 3、CMS垃圾回收失败 4、内存分配失败 当JVM尝试分配对象时，如果堆内存中没有足够的空间来容纳新的对象 \u0026ndash; 永久代中会发生垃圾回收吗\r#\r垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(FullGC) "},{"id":2,"href":"/interview/05_programming/java-base/p1/","title":"Part.1","section":"Java基础","content":"\r\u0026ndash; 面向过程、面向对象\r#\r面向过程\n是一种以过程为中心的编程思想 分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现 面向对象\n是一种以对象为中心的编程思想 把构成问题的事务分解成各个对象，建立对象，来描述某个事物在解决整个问题的过程中所发生的行为 \u0026ndash; 四种引用类型\r#\r引用类型 说明 强引用 最常见的引用类型，引用存在时，对象不会被回收 软引用 适用于内存敏感的缓存，当内存不足时，对象才会被回收 弱引用 适用于非重要对象，当垃圾收集器运行时，对象就可能被回收 虚引用 适用于对象回收跟踪，就和没有引用一样，在任何时候都可能被回收 // 强引用 String strongRef = new String(\u0026#34;abc\u0026#34;); // 软引用 SoftReference\u0026lt;String\u0026gt; softRef = new SoftReference\u0026lt;\u0026gt;(\u0026#34;abc\u0026#34;); // 弱引用 WeakReference\u0026lt;String\u0026gt; weakRef = new WeakReference\u0026lt;\u0026gt;(\u0026#34;abc\u0026#34;); // 虚引用 ReferenceQueue queue = new ReferenceQueue(); PhantomReference phantomRef = new PhantomReference(\u0026#34;abc\u0026#34;, queue); \u0026ndash; 访问修饰符\r#\r修饰符 当前类 同包 子类 其他包 public OK OK OK OK protected OK OK OK default OK OK private OK \u0026ndash; 数据类型\r#\r基本数据类型\n字符型：char 布尔型：boolean 数值型： 整数类型：byte, short, int, long 浮点类型：float, double 引用数据类型\n类： class 接口： interface 数组： [] \u0026ndash; 创建对象的方式\r#\r1. new创建新对象 2. 通过反射机制 3. 采用clone机制 4. 通过序列化机制 \u0026ndash; 获取Class对象的方式\r#\rString str = new String(\u0026#34;abc\u0026#34;); // 方式一：通过类对象的 getClass() Class\u0026lt;?\u0026gt; clazz = str.getClass(); // 方式二：通过类的静态成员 Class\u0026lt;?\u0026gt; clazz = String.class; // 方式三：通过Class 类的静态方法 forName() Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;java.lang.String\u0026#34;); \u0026ndash; 浅拷贝、深拷贝\r#\r浅拷贝： 在拷贝一个对象时，对基本数据类型的成员变量进行拷贝，对引用类型的成员变量只进行引用的传递 深拷贝： 在拷贝一个对象时，对基本数据类型的成员变量进行拷贝，对引用类型的成员变量，创建一个新的对象，并复制其内容。 实现深拷贝的方式： 1. 将对象序列化为字节流，然后再反序列化为新的对象 2. 逐个复制引用类型属性 \u0026ndash; 自动装箱、自动拆箱\r#\r自动装箱： 自动将基本数据类型转换为包装器类型（int--\u0026gt;Integer），调用Integer的valueOf(int)方法 自动拆箱： 自动将包装器类型转换为基本数据类型（Integer--\u0026gt;int），调用Integer的intValue()方法 // 试题 Integer i1 = 100; Integer i2 = 100; Integer i3 = 200; Integer i4 = 200; System.out.println(i1==i2); System.out.println(i3==i4); 运行结果： true false ---------------------------------------------------------------------- 在通过valueOf方法创建Integer对象的时候， 如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用； 否则创建一个新的Integer对象 ps：在某个范围内的整型数值的个数是有限的，而浮点数不是 \u0026ndash; 方法重载、方法重写\r#\r重载 overload\n在一个类里面，方法名字相同，而参数不同 每个重载的方法都必须有独一无二的参数类型列表（参数个数、参数类型、参数顺序） 重写 override\n是子类对父类方法的实现进行重新编写 方法名、参数列表均相同 重写方法抛出的异常，需宽于被重写方法 构造方法不能被重写 区别\n区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常捕获 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问限制 可以修改 一定不能做更严格的限制（可以降低限制） \u0026ndash; 红黑树的特征\r#\r1. 节点颜色：每个节点被标记为红色或黑色 2. 根节和叶子节点都是黑色的 3. 红色节点的子节点不能是红色，即红色节点不能连续存在 4. 从任意节点到其每个叶子节点的路径包含相同数量的黑色节点 \u0026ndash; switch 能作用的类型\r#\rswitch可以作用于 byte、short、char、int 类型 从Java5开始，可以作用于 enum 类型 从Java7开始，可以作用于 String 类型 "},{"id":3,"href":"/interview/07_concurrent/java-thread/p1/","title":"Part.1","section":"Java多线程","content":"\r\u0026ndash; 程序、进程、线程\r#\r程序\n是含有指令和数据的文件，存储在硬件设备中，因此程序是静态的 进程\n是程序的一次执行过程，是程序的一个运行实例，因此进程是动态的 进程之间是相互独立的，各自有自己独立的内存空间和系统资源 线程\n是指在一个进程内的独立执行路径。一个进程可以包含多个线程。 每个线程都是独立运行的，有自己的执行顺序和状态。 多个线程可以共享内存空间和系统资源。 \u0026ndash; 创建线程的方式\r#\r继承Thread类 实现Runnable接口 实现Callable接口 使用线程池创建 \u0026ndash; 停止线程的方式\r#\r使用退出标志，使线程正常退出 使用interrupt()方法中断线程 使用stop()方法强行终止，但不推荐，可能会产生不可预料的结果 \u0026ndash; 线程安全\r#\r如果在多线程下执行和在单线程下执行永远都能获得一样的结果，那么代码就是线程安全的 \u0026ndash; 并发三特性\r#\r原子性\n不可分割，是一个整体 即一个操作或者多个操作，要么全部执行并且不被打断，要么就都不执行 可见性\n当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值 有序性\n程序执行的顺序按照代码的先后顺序执行 \u0026ndash; 线程池\r#\r核心参数\n工作过程\n1. 创建线程池后，等待提交过来的任务请求 2. 当调用execute()添加一个新任务时，线程池会做如下判断： a. 如果当前运行的线程数量还小于corePoolSize，则会创建新线程来执行新任务 b. 如果当前运行的线程数量不小于corePoolSize，则会将提交的任务放入阻塞队列中 c. 如果当前阻塞队列满了，且当前运行的线程数量还小于maximumPoolSize，则创建线程运行这个任务 d. 如果当前阻塞队列满了，且当前运行的线程数量不小于maximumPoolSize，则启动拒绝策略 3. 当一个线程完成任务时，它会从队列中取下一个任务来执行 4. 当一个线程空闲超过一定时间，并且此时当前运行的线程大于corePoolSize时，这个线程会被销毁 \u0026ndash; 常见线程池\r#\rnewSingleThreadExecutor：\n创建一个单线程的线程池 此线程池保证所有任务的执行顺序按照任务的提交顺序执行 newFixedThreadPool：\n创建固定大小的线程池 每次提交一个任务就创建一个线程，直到线程数达到线程池的最大数量 newCachedThreadPool：\n创建一个可缓存的线程池 此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程数量 newScheduledThreadPool：\n创建一个大小无限的线程池 此线程池支持定时以及周期性执行任务的需求 \u0026ndash; 线程池拒绝策略\r#\r拒绝策略 说明 AbortPolicy 默认策略，直接丢弃任务，抛出异常 CallerRunsPolicy 由调用者所在的线程处理该任务 DiscardPolicy 直接丢弃任务，也不抛出异常 DiscardOldestPolicy 丢弃等待队列中最旧的任务，并执行当前任务 \u0026ndash; 死锁的必要条件\r#\r互斥使用 一个资源每次只能被一个线程使用 不可抢占 资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放 请求和保持 当资源请求者在请求其他的资源的同时保持对原有资源的占有 循环等待 若干线程之间形成一种头尾相接的循环等待资源关系 \u0026ndash; CAS\r#\rCAS\n1. 比较并交换，Compare-And-Swap 2. 通过处理器的指令来保证操作的原子性，是一种无锁算法 3. Java CAS硬件底层接口：sun.misc.Unsafe 原理\n涉及三个操作数： 1. V：变量内存地址 2. A：旧的预期值 3. B：准备设置的新值 当执行CAS指令时，只有当V等于A时，才会用B去更新V的值，否则就不会执行更新操作 一般情况下是一个自旋操作，即不断的重试 缺点\n1. 自旋时间长开销很大 2. 只能保证一个共享变量的原子性 3. 存在ABA问题 ABA问题： 存在场景：在一段时间内，其他线程将A值改成B值，又改回A值 而CAS却误认为数据未被修改 \u0026ndash; AQS\r#\rAQS\n抽象的队列同步器，AbstarctQueuedSynchronizer，简称AQS AQS定义了一套多线程访问共享资源的同步器基础框架，许多同步类实现都依赖于它 AQS原理\n1. AQS维护了一个共享变量state和一个CLH队列（FIFO先入先出双向队列）。 2. 线程通过CAS去改变state状态，成功则获取锁成功，失败则进入等待队列，等待被唤醒。 AQS实现\n1、AQS的设计是基于模板模式。 2、AQS已实现了对等待队列的维护，自定义同步器只需要实现共享资源state的获取与释放方式即可。 3、AQS定义了两种资源共享方式： a. 独占方式：Exclusive，只有一个线程能执行，如ReentrantLock b. 共享方式：Share，多个线程可以同时执行，如Semaphore、CountDownLatch "},{"id":4,"href":"/interview/08_framework/spring/p1/","title":"Part.1","section":"Spring","content":"\r\u0026ndash; Spring\r#\rSpring 是一个开源的轻量级 Java 开发框架 Spring 的核心是控制反转（IoC）和面向切面（AOP） \u0026ndash; Spring 优点\r#\r方便解耦，简化开发 用户可以将所有对象的创建和依赖关系的维护，交给Spring管理 支持AOP编程 Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能 支持声明式事务 只需要通过配置就可以完成对事务的管理，而无需手动编程 方便程序测试 Spring对Junit4支持，可以通过注解方便的测试Spring程序 集成各种优秀框架 Spring内部提供了对各种优秀框架的直接支持 简化JavaEE的使用 Spring对JavaEE开发中非常难用的一些API，都提供了封装，降低了使用难度 \u0026ndash; IoC\r#\rInversion of Control，即“控制反转”，是一种设计思想，用于解决对象之间的耦合问题。 以前对象的创建及依赖关系是由开发人员自己维护，现在反转交给 spring 来完成创建及注入 控制：指的是对象创建（实例化、管理）的权利 反转：控制权交给外部环境了（spring框架、IoC容器） \u0026ndash; IoC 容器\r#\r具有依赖注入功能的容器，它可以创建对象，负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖 IoC容器底层其实就是一个Bean工厂，Spring提供了两种IoC容器，即BeanFactory、ApplicationContext BeanFactory：最简单的IoC容器，它提供了IoC容器最基本的功能 ApplicationContext：BeanFactory的子接口，并添加了更多的企业特定的功能 \u0026ndash; IoC、DI\r#\rDI，Dependency Injection，即“依赖注入”，由容器动态的将某个依赖关系注入到组件之中。 IoC 是一种软件设计思想，DI 是这种软件设计思想的一个实现。 \u0026ndash; AOP\r#\rAspect Oriented Programming，面向切面编程，是一种编程思想 是通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术 在面向对象编程(OOP)中，基本单元是类(class)，而 AOP 中的基本单元是切面(aspect) OOP是解决了纵向的代码复用问题，AOP是解决了横向的代码复用问题 \u0026ndash; AOP 术语\r#\r术语 名称 描述 Jointpoint 连接点 程序类中，允许插入通知（Advice）的位置点 Pointcut 切入点 程序类中，已经插入通知（Advice）的位置点 Advice 通知 在切入点（Pointcut）上要执行的代码 Aspect 切面 是切入点（Pointcut）和通知（Advice）的结合 Target 目标 被织入通知（Advice）的目标对象，这个对象永远是一个被代理对象 Weaving 织入 将通知（Advice）添加到目标类具体连接点上的过程 \u0026ndash; AOP 通知类型\r#\r通知 说明 备注 around 环绕通知 在建议方法调用之前和之后，执行通知。 before 前置通知 在一个方法执行之前，执行通知。 after 后置通知 在一个方法执行之后，不考虑其结果，执行通知。 after-returning 正常返回通知 在一个方法执行之后，只有在方法成功完成时，才能执行通知。 after-throwing 异常返回通知 在一个方法执行之后，只有在方法退出抛出异常时，才能执行通知。 \u0026ndash; Bean\r#\rBean是指由Spring IoC容器实例化、组装和管理的对象 可以把Spring IoC容器看作是一个大工厂，Bean就相当于工厂的产品 \u0026ndash; Bean 作用域\r#\r对于prototype作用域的Bean来说，Spring IoC 容器只负责创建 作用域 描述 singleton 默认值，在 spring IoC 容器仅存在一个 Bean 实例 prototype 每次通过 Spring 容器获取 Bean 时，容器都会创建一个新的 Bean 实例 request 每次 HTTP 请求，容器都会创建一个 Bean 实例， 仅在当前 HTTP Request 内有效 session 同一个 HTTP Session 共享一个 Bean 实例，仅在当前 HTTP Session 内有效 application 同一个 Web 应用共享一个 Bean 实例，在当前 ServletContext 内有效 \u0026ndash; Bean 生命周期\r#\r实例化\n对于BeanFactory容器，当被请求未初始化的bean时，容器就会调用createBean进行实例化。 对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean 属性注入\n实例化后的对象被封装在BeanWrapper对象中，Spring根据BeanDefinition、BeanWrapper完成属性注入 初始化\n1、处理Aware接口 若Bean实现了接口BeanNameAware，则执行setBeanName()，设置bean的名字 若Bean实现了接口BeanFactoryAware，则执行setBeanFactory()，设置BeanFactory 若Bean实现了接口ApplicationContextAware，则执行setApplicationContext()，设置应用上下文 2、BeanPostProcessor前置处理 若Bean实现了接口BeanPostProcessor，则先执行postProcessBeforeInitialization() 3、InitializingBean与init-method 若Bean实现了接口InitializingBean，则执行afterPropertiesSet() 若Bean配置了属性init-method，则执行自定义方法； 4、BeanPostProcessor后置处理 若Bean实现了接口BeanPostProcessor，则先执行postProcessAfterInitialization() 使用\n此时 Bean 已经准备就绪，可以被使用了 销毁\n当Bean不再需要时，会进入清理阶段 若Bean实现了DisposableBean接口，则会调用其destory()； 若Bean配置了destory-method属性，则会调用其配置的销毁方法。 \u0026ndash; Spring 用到的设计模式\r#\r单例模式\n当使用Bean默认作用域时，用到了单例模式 在整个应用程序中只有一个Bean实例，由Spring容器负责管理 类似的如Service层的业务逻辑组件、DAO层的数据访问组件也是单例 原型模式\n当设置Bean为prototype作用域时，用到了原型模式 每次获取的是通过克隆生成的新实例，对其进行修改时，对原有实例对象不造成任何影响。 工厂模式\nSpring中的BeanFactory、ApplicationContext类，用到了工厂模式 由工厂类根据传入的参数，动态的决定实例化哪个Bean 代理模式\nSpring的AOP功能，是通过代理模式中的动态代理实现的 模板模式\nSpring中的JdbcTemplate类，用到了模板模式 JdbcTemplate是Spring提供的用于简化JDBC操作的模板类，它封装了一些常见的JDBC操作 策略模式\nSpring中访问资源的Resource接口，用到了策略模式 ClassPathResourece、FileSystemResource、ServletContextResource、UrlResource定义了不同的资源访问策略 装饰器模式\nSpring中配置的DataSource可能是不同的数据源 SessionFactory根据用户的每次请求，将DataSource设置成不同的数据源，以达到切换数据源的目的 \u0026ndash; Spring 中的单例 Bean 是否线程安全\r#\r1. Spring并没有对单例Bean进行任何多线程的封装处理，需要开发者手动处理 2. Spring关注的是：根据配置，创建单例Bean或多例Bean \u0026ndash; @Autowired、@Resource\r#\r共同点\n1. 都是用于Bean的注入 2. 都可以标注在字段和setter方法上 @Autowired\n1. 是Spring提供的注解 2. 只能按照类型（byType）注入Bean 3. 可与@Qualifier一起使用，改为按照名称（ByName）注入Bean @Resource\n1. 是J2EE提供的注解，Spring 做了支持 2. 默认按照名称（ByName）注入bean 3. 可以通过属性（name、type）指定注入策略 \u0026ndash; @Transactional\r#\r1. 表明该方法要参与事务 2. 配置相关属性来定制事务的参与方式和运行行为 声明式事务主要是得益于Spring AOP。使用一个事务拦截器，在方法调用的前后/周围进行事务性 增强（advice），来驱动事务完成。 "},{"id":5,"href":"/interview/05_programming/network/","title":"网络","section":"编程基础","content":"\r\u0026ndash; 网络模型\r#\r\u0026ndash; TCP 协议\r#\r1. Transmission Control Protocol，传输控制协议 2. 是面向连接的协议，在收发数据前，必须和对方建立可靠的连接。 3. 一个TCP连接必须有三次握手、四次挥手 \u0026ndash; TCP 三次握手\r#\r三次握手：Three-way Handshake，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包\n第一次握手：客户端发出报文（SYN），请求建立连接 第二次握手：服务器收到报文（SYN），如果同意连接，则发出确认报文（SYN+ASK） 第三次握手：客户端收到确认报文（SYN+ASK）后，再发出确认报文（ASK） 过程简述： 第一次握手：A请求建立连接 第二次握手：A发送正常，B接收正常 第三次握手：B发送正常，A接收正常 类比打电话： A：你听清楚么？ B：能听清楚，你呢？ A：也能听清楚。 \u0026ndash; TCP 四次挥手\r#\r四次挥手：Four-way handshake，即TCP 的连接的拆除需要发送四个包\n第一次挥手：客户端发出报文（FIN），请求释放连接，停止发送数据 第二次挥手：服务器收到报文（FIN），发出确认报文（ASK），停止接收数据 第三次挥手：服务器发出报文（FIN），停止发送数据 第四次挥手：客户端收到报文（FIN），发出确认报文（ASK），停止接收数据 过程简述： 第一次挥手：A请求断开连接 第二次挥手：B收到请求，同意断开连接 第三次挥手：B确认断开连接 第四次挥手：A收到确认，断开连接 类比打电话： A：我要挂电话了？ B：收到，挂吧。 B：我也没有话要说了。 A：挂断电话。 \u0026ndash; TCP、UDP\r#\rTCP UDP 连接性 面向字节流，需要建立连接 面向报文，不需建立连接 可靠性 可靠，不丢包 不可靠，会丢包 传输效率 传输效率低，速度慢 传输效率高，速度快 流量控制 滑动窗口 无 拥塞控制 慢开始、拥塞避免、快重传、快恢复 无 应用场合 对效率要求低，对准确性要求高或要求有连接的场景 对效率要求高，对准确性要求低 连接方式 只支持点到点 支持一对一、一对多、多对多 首部开销 开销20字节 开销8字节 \u0026ndash; HTTP 协议\r#\r1. Hyper Text Transfer Protocol，超文本传输协议，是一种网络通信协议 2. 用于将超文本标记语言（HTML）文档从Web服务器传送到本地浏览器 3. 基于客户端/服务端（C/S）模型，将浏览器为客户端，通过URL向服务端发送所有请求 \u0026ndash; HTTP 状态码\r#\r状态码 含义 描述 1xx 消息响应 服务器收到请求，需要请求者继续执行操作 2xx 成功响应 操作被成功接收并处理 3xx 重定向 需要进一步的操作以完成请求 4xx 客户端错误 请求包含语法错误或无法完成请求 5xx 服务器错误 服务器在处理请求的过程中发生了错误 \u0026ndash; HTTP 请求步骤\r#\r1、DNS 解析 2、HTTP 请求，当输入一个请求时，建立一个 Socket 连接发起 TCP的 3 次握手 3.1、客户端向服务器发送请求命令 3.2、客户端发送请求头信息和数据。 4.1、服务器发送应答头信息。 4.2、服务器向客户端发送数据。 5、服务器关闭 TCP 连接（4次挥手）。 6、客户端根据返回的 HTML 、 CSS 、 JS 进行渲染。 \u0026ndash; HTTP、HTTPS\r#\r1. https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 4. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 \u0026ndash; URI、URL\r#\rURI： Uniform Resource Identifier，统一资源标识符 是一种语义上的抽象概念 唯一标识了资源 URL： Uniform Resource Location，统一资源定位符 是URI的一个子集，一种具体的URI 唯一标识并定位了资源 \u0026ndash; GET、POST\r#\r数据传输方式\nGET: 数据通过URL传递，数据以 key=value 的形式拼接在URL后面。 POST: 数据通过请求体传递，可以包含大量数据，格式灵活。 数据长度限制\nGET: 受到URL长度的限制，一般为2048字符。 POST: 请求体数据长度不受限制，可以传输大量数据。 安全性\nGET: 数据明文传输，容易被截取和篡改，适合传输少量不敏感数据。 POST: 数据在请求体中传输，经多重编码安全性较高，适合传输敏感数据。 缓存\nGET: 请求可以被浏览器缓存，可以被收藏为标签 POST: 请求不能被浏览器缓存，不能被收藏为标签 \u0026ndash; Cookie、Session\r#\rCookie、Session 都是一种用于维持客户端与服务端之间会话的机制 Cookie Session 数据存放位置 客户的浏览器 服务器 安全程度 可能会被篡改 安全 性能方面 只影响客户的浏览器 占用服务器性能 存储数据量 客户的浏览器对其有限制 不影响 存储结构 键值对形式的文本 哈希表结构 \u0026ndash; Forward、Redirect\r#\r转发是服务器行为，重定向是客户端行为 请求转发 请求重定向 服务器内部跳转，所有地址栏上的路径不会改变 是浏览器再次发送请求，地址栏上的路径会发生改变 只发送一次请求 会发送两次请求 只能在当前应用内部跳转 可以在内部跳转，也可以跳出当前应用 可以共享reqeust 不能可以共享reqeust request.getRequestDispatcher().forward(); response.sendRedirect(); "},{"id":6,"href":"/interview/05_programming/linux/","title":"Linux","section":"编程基础","content":"\r\u0026ndash; 目录路径\r#\r绝对路径： /etc/init.d 当前目录： ./ 上层目录： ../ 主目录： ~/ 切换目录： cd \u0026ndash; 命令：查看文件\r#\r$ vi 文件名 #编辑方式查看，可修改 $ cat 文件名 #显示全部文件内容 $ more 文件名 #分页显示文件内容 $ less 文件名 #与 more 相似，更好的是可以往前翻页 $ tail 文件名 #仅查看尾部，还可以指定行数 $ head 文件名 #仅查看头部,还可以指定行数 "},{"id":7,"href":"/interview/13_dev-tool/maven/","title":"Maven","section":"开发工具","content":"\r\u0026ndash; Maven\r#\r是一款纯 java 开发的、用于项目构建和管理的工具\n作用： 1. 添加第三方jar包 2. 处理jar包之间的依赖关系 3. 获取第三方jar包 4. 将项目拆分为多个工程模块 \u0026ndash; Maven 生命周期\r#\r阶段 处理 描述 validate 验证 验证项目是否正确，且所有必须信息是可用的 compile 编译 编译源代码 test 测试 使用单元测试框架运行测试 package 打包 创建jar/war包 verify 检查 对集成测试结果进行检查，以保证质量达标 install 安装 安装打包的项目到本地仓库，以供其他项目使用 deploy 部署 拷贝最终的工程包到远程仓库，以共享给其他工程 \u0026ndash; Maven 常用命令\r#\rmvn clean # 清除项目目录中的生成结果 mvn compile # 编译源代码 mvn test-compile # 编译测试源代码 mvn test # 运行应用程序中的单元测试 mvn package # 根据项目生成的jar mvn install # 在本地Repository中安装jar mvn deploy # 发布项目 # 启动tomcat服务 mvntomcat:run # 清除以前的包后重新打包，跳过测试类 mvn clean package -Dmaven.test.skip=true \u0026ndash; Maven 依赖原则\r#\r1. 最短路径原则 依赖传递的路径越短越优先 2. 声明顺序优先 路径长度一样，则先声明的优先 3. 覆写原则 当前pom文件里声明的直接覆盖父工程传过来的 \u0026ndash; Maven 依赖冲突\r#\r使用exclusion进行排除\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.3.14.RELEASE\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;commons-logging\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;commons-logging\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; "},{"id":8,"href":"/interview/04_jvm/java-jvm/p2/","title":"Part.2","section":"Java虚拟机","content":"\r\u0026ndash; JVM 调优工具\r#\rjconsole\nJDK中自带的java监控和管理控制台 用于对JVM中内存，线程和类等的监控 jvisualvm\njdk自带全能工具 可以分析内存快照、线程快照；监控内存变化、GC变化等 MAT\nMemory Analyzer Tool 一个基于Eclipse的内存分析工具 可以帮助查找内存泄漏和减少内存消耗 GChisto\n一款专业分析gc日志的工具 \u0026ndash; JVM 调优参数\r#\r示例 说明 -XX:-PrintGCDetails 关闭：打印GC收集细节 -XX:+PrintGCDetails 开启：打印GC收集细节 -XX:MetaspaceSize=128m 设置元空间的内存大小，默认21m 备注： 布尔类型：-XX:+或-某个属性（+ 表示开启，- 表示关闭） 键值类型：-XX:属性键=属性值 \u0026ndash; JVM 调优参数：堆栈内存\r#\r参数 说明 等价于 -Xms 设置堆的初始内存大小，默认是物理内存的1/64 -XX:InitialHeapSize -Xmx 设置堆的最大内存大小，默认是物理内存的1/4 -XX:MaxHeapSize -Xmn 设置新生代的内存大小，一般使用默认值 -XX:NewSize、-XX:MaxnewSize -Xss 设置单个线程栈的内存大小，一般默认512K ~ 1024K -XX:ThreadStackSize 参数 说明 -XX:MetaspaceSize 设置元空间的内存大小，默认21m -XX:NewRatio 设置新生代与老年代的比值 -XX:SurvivorRatio 设置新生代中Eden区与两个Survivor区的比值 -XX:MaxTenuringThreshold 设置新生代中对象最大存活次数 -XX:PretenureSizeThreshold 当创建的对象超过指定大小时，直接把对象分配在老年代 \u0026ndash; JVM 调优参数：垃圾收集器\r#\r参数 说明 XX:+UseSerialGC 使用 Serial 收集器 -XX:+UseParNewGC 使用 ParNew 收集器 -XX:+UseParallelGC 使用 Parallel Scavenge 收集器 -XX:+UseParallelOldGC 使用 Parallel Old 收集器 -XX:+UseConcMarkSweepGC 使用 CMS 收集器 . -XX:ParallelGCThreads 配置并行收集器的线程数 \u0026ndash; JVM 调优参数：辅助信息\r#\r参数 说明 -XX:+PrintFlagsInitial 打印全部初始默认参数 -XX:+PrintFlagsFinal 打印全部最终参数 -XX:+PrintCommandLineFlags 打印特定参数 -XX:+PrintGCDetails 打印GC详细信息 -XX:+PrintTLAB 打印TLAB空间的使用情况 -XX:+DisableExplicitGC 禁止系统System.gc() -XX:+HeapDumpOnOutOfMemoryError 在内存溢出的时候，自动生成内存快照 "},{"id":9,"href":"/interview/05_programming/java-base/p2/","title":"Part.2","section":"Java基础","content":"\r\u0026ndash; equals、==\r#\r==\n是一个运算符，用于比较两个对象的引用是否指向同一个内存地址 对于基本数据类型，比较的是值 对于引用数据类型，比较的是内存地址 equals\n是一个定义在 Object 类中的方法，用于比较两个对象的内容是否相等 默认情况下，equals 与 == 等同，但许多类会重写 equals 方法 \u0026ndash; final\r#\r修饰符，可以修饰类、变量、方法\n1. 被final修饰的类不可以被继承 2. 被final修饰的方法不可以被重写 3. 被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的 4. 被final修饰的常量，在编译阶段会存入常量池中 \u0026ndash; final、finally、finalize\r#\rfinal\n修饰符，可以修饰类、变量、方法 finally\n用于跟在try-catch代码块后， 表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。 finalize\n是java.lang.Object类中的一个方法 该方法一般由垃圾回收器来调用，当调用System.gc()方法时，由垃圾回收器调用finalize() \u0026ndash; String\r#\r字符串常量\n由final修饰，一经创建，便不能再改变 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象 字符串 + 拼接，JVM会进行优化\nString str = \u0026#34;abc\u0026#34; + \u0026#34;def\u0026#34;; // 优化成 String str = \u0026#34;abcdef\u0026#34;; String str1 = \u0026#34;abc\u0026#34;; String str2 = str1 + \u0026#34;abc\u0026#34;; // 优化成 String str2 = (new StringBuilder()).append(str1).append(\u0026#34;def\u0026#34;).toString(); \u0026ndash; String、StringBuffer、StringBuilder\r#\rString可以赋null值，后者两者不行 String StringBuffer StringBuilder 不可变字符串 可变字符串 可变字符串 线程安全 线程不安全 效率低 效率高 \u0026ndash; Vector、ArrayList、LinkedList\r#\r相同点\n1. 实现List接口 2. 有序性 3. 可包含重复元素 4. 可动态调整大小 ArrayList\n底层基于动态数组实现，非线程安全 随机访问和遍历方面，效率相对较高 插入和删除元素时，涉及到数组元素的移动，效率相对较低 LinkedList\n底层基于双向链表实现，非线程安全 随机访问元素时，需要遍历链表，效率相对较低 插入和删除元素时，只需要改变相邻节点的引用，效率相对较高 Vector\n底层基于动态数组实现，线程安全 底层与ArrayList类似，但由于线程同步的开销，性能通常不如ArrayList "},{"id":10,"href":"/interview/07_concurrent/java-thread/p2/","title":"Part.2","section":"Java多线程","content":"\r\u0026ndash; volatile\r#\rvolatile\n1. 是java提供的一种轻量级同步机制 2. 用于修饰变量，保证所修饰变量的可见性，不保证原子性 3. 会禁止指令重排优化 底层原理\n1. 当对volatile变量进行写操作的时候，JVM会增加Lock前缀指令 2. 基于缓存一致性协议，cpu会检查缓存是否过期，如果过期，则重新读取系统内存数据 2. 缓存一致性：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期 \u0026ndash; synchronized\r#\rsynchronized\n1. 是Java提供的一种基于内置锁的同步机制 2. 保证原子性、可见性、有序性 底层原理\n完全依赖于JVM虚拟机进行实现，基于Java对象头、Monitor监视器 当线程进入同步代码块时，如果此同步对象没有被锁定， JVM会在当前线程的栈中创建Lock Record空间，用于存储锁对象的Mark Word的拷贝。 每一个被锁住的对象Mark Word都会和一个Lock Record关联， Lock Record 锁记录\n1. Lock Record，是线程私有的数据结构 2. Lock Record中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用 Monitor监视器\n1. Monitor，可以理解为一种同步机制、一个对象。任何一个对象都有一个Monitor与之关联。 2. Monitor只能被一个线程持有，此时当前对象就处于锁定状态，其它线程只能阻塞等待。 3. 在JVM中，Synchronized是基于进入和退出Monitor对象，来实现方法同步和代码块同步。 java对象头\n\u0026ndash; synchronized 同步优化\r#\r为优化synchronized性能，在JDK1.6后增加了自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁等策略\n锁膨胀：方向不可逆\n1. 无锁 ——\u0026gt; 偏向锁： 当持有锁的线程再次请求该锁时，无需再做任何同步操作，即获取锁 2. 偏向锁 ——\u0026gt; 轻量级锁： 当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁 3. 轻量级锁——\u0026gt; 重量级锁： 当同一时间有多个线程竞争锁时，锁就会被升级成重量级锁，此时其申请锁带来的开销也就变大 其他策略\n锁消除 当检测到不可能存在共享数据的竞争时，JVM会对这些同步锁进行消除 锁粗化 将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁 自旋锁 是一种锁机制，尝试获取锁的线程不会立即阻塞，而是采用循环的方式去多次尝试 自适应自旋锁 自旋的次数不是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定 \u0026ndash; synchronized、ReentrantLock\r#\r相同点\n1. 都是用来协调多线程共享对象、变量的访问。 2. 都是可重入锁，同一线程可以多次获得同一个锁。 3. 都保证了可见性和互斥性。 不同点\n不同点 synchronized ReentrantLock 实现级别 是一个关键字，属于 JVM 级别 是一个接口，属于 API 级别 底层实现 是同步阻塞，使用悲观并发策略 同步非阻塞，使用乐观并发策略 锁 隐式的获得/释放锁，会自动释放锁 显式的获得/释放锁，须手动释放锁 ReentrantLock 高级功能\n1. 可实现公平锁 2. 可锁绑定多个条件 3. 等待可中断：当锁长时间不释放的时候，可以选择放弃等待 \u0026ndash; wait()、sleep()\r#\rwait() sleep() 所属类 java.lang.Object java.lang.Thread 对象锁 释放 不释放 使用位置 只能在同步块中使用 任意地方 捕获异常 不需要 需要 \u0026ndash; wait()、notify()、notifyAll()\r#\rwait()\n1. 使当前线程等待，把当前线程放入等待池中 2. 释放当前的锁 3. 满足一定条件时被唤醒, 重新尝试获取这个锁 4. 须在 synchronized 同步块中调用 notify()\n1. 唤醒在此对象监视器上等待的其中一个线程（由虚拟机控制） 2. 调用对象的 notify() 方法后，要等到执行 notify() 方法的线程将程序执行完，当前线程才会释放锁 3. 须在同步方法、同步块中调用 notifyAll()\n1. 唤醒在此对象监视器上等待的所有线程 2. 由这些线程重新竞争锁，竞争成功者则继续执行 \u0026ndash; interrupt()、interrupted()、isInterrupted()\r#\r1. 都是 java.lang.Thread 类中的方法 2. interrupt(): 是实例方法，中断线程，设置中断标识为true 3. interrupted(): 是静态方法，判断线程是否被中断，并清除中断状态 4. isInterrupted(): 是实例方法，获取线程的中断状态 \u0026ndash; ThreadLocal\r#\r线程本地变量\n1. ThreadLocal会为每个访问线程都创建一个本地副本 2. 各个线程实际上是操作独属于本线程的变量，从而起到线程隔离的作用，避免了线程安全问题 实现原理\n1. Thread类中，有个ThreadLocal.ThreadLocalMap 的成员变量 2. ThreadLocalMap的key是ThreadLocal实例本身，value则存储泛型对象值 3. 每个线程都是操作自己的成员变量，从而互相不影响 \u0026ndash; CountDownLatch\r#\rCountDownLatch\n倒计时器： 一个或多个线程一直等待，直到其他线程完成某件事情之后再执行 实现原理\n1. 通过一个计数器进行实现。计数器初始值为线程的数量。 2. 每当一个线程执行完毕后，计数器的值就减1。 3. 当计数器的值为0时，表示所有线程都执行完毕，然后在CountDownLatch上等待的线程就可以恢复执行了 \u0026ndash; CyclicBarrier\r#\rCyclicBarrier\n循环栅栏： 多个线程互相等待，直到全部都到达同一个同步点，再继续一起执行 实现原理\n1. 在CyclicBarrier类的内部有一个计数器 2. 每个线程在到达屏障点的时候都会调用await()将自己阻塞，此时计数器会减1 3. 当计数器减为0的时候，所有因调用await()而被阻塞的线程将被唤醒 \u0026ndash; Semaphore\r#\rSemaphore\n信号灯： 作为一种流量控制手段，用于控制同时访问特定资源的线程数量，保证合理的使用共享资源 实现原理\n1. Semaphore管理一系列许可（仅维护许可的计数）。 2. 线程通过acquire()获取许可。当没有可用的许可的时候，线程阻塞，直到有可用的许可为止。 3. 线程通过release()释放许可。 \u0026ndash; Exchanger\r#\rExchanger\n交换器： 是一个用于线程间协作的工具类，用于两个线程间交换数据。 实现原理\n1. Exchanger提供了一个交换的同步点，在这个同步点两个线程能够交换数据。 2. 如果一个线程先执行exchange()，那它会阻塞等待另一个线程也执行exchange()。 3. 当两个线程就都达到了同步点，它们就可以交换数据。 "},{"id":11,"href":"/interview/09_service/spring-cloud/","title":"SpringCloud","section":"服务治理","content":"\r\u0026ndash; SpringCloud\r#\r分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的有序集合 \u0026ndash; SpringBoot、SpringCloud\r#\rSpringBoot： 专注于快速方便的开发单个个体微服务 SpringCloud： 关注全局的微服务协调治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来 SpringBoot可以离开SpringCloud独立使用开发项目，但是SpringCloud离不开SpringBoot，属于依赖的关系 \u0026ndash; 雪崩效应\r#\r1. 分布式系统环境下，各服务之前有依赖关系 2. 由于各种原因，服务不能保证100%可用 3. 如果单个服务不可用，会导致依赖于它的服务不可用，如此循环导致更多的服务不可用 4. 这种将不可用逐渐放大导致系统崩溃的现象，即雪崩效应 \u0026ndash; 服务降级、服务熔断\r#\r服务降级： 是一种在服务不可用或响应过慢的情况下，通过执行预设的降级逻辑来保障核心功能和服务可用性的措施 服务熔断： 是一种保护系统的措施，当系统某个服务的异常调用达到预设的阈值时， 熔断器会主动阻止对该服务的调用，立即返回错误信息或执行降级处理，从而避免系统整体崩溃 "},{"id":12,"href":"/interview/05_programming/java-base/p3/","title":"Part.3","section":"Java基础","content":"\r\u0026ndash; HashMap 的工作原理\r#\r底层数据结构\nHashMap 底层是由数组和单向链表实现，数组中的每个元素都是链表，由 Node 内部类实现 HashMap 通过 put \u0026amp; get 方法存储和获取元素对象 存储对象时，将 K/V 键值传给 put() 方法\n1、调用 hash(K)方法计算 K的 hash值，然后结合数组长度，计算得数组下标； 2、判断数组该下标节点是否存在： A. 如果不存在，则新增节点，直接执行插入 B. 如果已存在，即为发生哈希碰撞，则遍历该位置的链表，对比判断 K值、hash值，是否在链表节点中已经存在： a. 如果已存在，则更新链表节点的键值对； b. 如果不存在，则新增节点，插入链表的尾部（尾插法）或者红黑树中（树的添加方式） 3、判断是否需要扩容，调整数组大小； 获取对象时，将 K 传给 get() 方法\n1、调用 hash(K)方法计算 K的 hash值，然后结合数组长度，计算得数组下标，即找到了该 K所在的链表 2、顺序遍历链表，对比查找 K值、hash值两者相同的链表节点 3、如果找到，则返回链表节点的 V值，否则返回空 \u0026ndash; HashMap 的数据结构\r#\rJDK1.7及其之前，是数组+链表\nJDK1.8及其之后，是数组+链表/红黑树\n\u0026ndash; HashMap 的数组的初始化长度\r#\r默认的初始容量值是16，也可以手动指定 \u0026ndash; HashMap 的容量\r#\r1、容量capacity，决定着table 数组的大小，默认是16，也可以构造时传入 2、装载因子loadFactor，主要目的是用来确认table 数组是否需要动态扩展，默认值是0.75(概率泊松分布) 3、阈值threshold，等于capacity * loadFactor，当超过阈值时 table 就需要动态扩容 \u0026ndash; HashMap 的数组什么时候扩容\r#\rJDK1.7及其之前，以下两个条件同时满足时会扩容： 1、size 达到 threshold 2、table[index]!=null JDK1.8及其之后，以下两个条件满足其一时会扩容： 1、size达到threshold 2、当table[index]下的结点个数达到8个但是table.length又没有达到64 \u0026ndash; HashMap 什么时候会转红黑树\r#\r当table[index]下的结点个数达到8个，但是table.length已经达到64 \u0026ndash; HashMap 的数组长度为什么是2的幂次方数\r#\r为了效率更快： 1、在HashMap中，先得到key的hashcode，然后通过hashcode \u0026amp; (table.length - 1) 运算得到一个数组下标index 2、用与运算计算数组下标，相比于取余运算速度更快，但这有个前提条件，就是数组的长度得是一个2的幂次方数。 \u0026ndash; HashMap、HashTable\r#\rHashMap HashTable 非线程安全，效率相对较高 线程安全，效率相对较低 key/value 都允许为 null key/value 都不允许为 null 默认初始容量16，按 2n 进行扩容 默认初始容量11，按 2n+1 进行扩容 重新计算hash值 直接使用对象的 hashCode \u0026ndash; HashMap、ConcurrentHashMap\r#\r区别\nHashMap： 1. key/value 都允许为 null值 2. 非线程安全 ConcurrentHashMap： 1. key/value 都不允许为 null值 2. 线程安全 ConcurrentHashMap 线程锁：\nJDK 1.7中 1、使用分段锁，相当于把一个 HashMap 分成多个段，每段分配一把锁。 2、锁粒度：基于 Segment，包含多个 HashEntry。 JDK 1.8中 1、使用 CAS + synchronized + Node + 红黑树 2、锁粒度：Node（首结点） \u0026ndash; HashMap、LinkedHashMap、TreeMap\r#\rHashMap\n1、底层是基于哈希表（散列表/数组）的数据结构 2、key是无序的 TreeMap\n1、底层是基于红黑树的数据结构 2、key是有序的 3、使用场景：在需要按自然顺序或自定义顺序遍历键的情况下 LinkedHashMap\n1、继承自HashMap，其内部多维护了一个双向链表 2、key是有序的 3、使用场景：在需要输出的顺序和输入的顺序相同的情况下 "},{"id":13,"href":"/interview/13_dev-tool/tomcat/","title":"Tomcat","section":"开发工具","content":"\r\u0026ndash; Tomcat\r#\r是一个免费开源的轻量级Web应用服务器 默认端口：8080 \u0026ndash; Tomcat 部署方式\r#\r使用 Tomcat 的自动部署\n将web应用拷贝到webapps目录。 当Tomcat启动时，会自动部署应用。 使用 Manager 应用部署\n进入Tomcat主页的Manager App控制台，可以指定一个web应用的路径或war文件 修改 conf/server.xml 文件部署\n在server.xml文件的\u0026lt;Host\u0026gt;标签内添加\u0026lt;Context\u0026gt;标签，可以指定应用路径和文件位置 \u0026ndash; Tomcat 目录结构\r#\rbin -- 脚本文件 conf -- 配置文件 lib -- 公共类库 logs -- 日志文件 temp -- 临时文件 webapps -- web应用目录 work -- 编译后的文件 "},{"id":14,"href":"/interview/09_service/nginx/","title":"Nginx","section":"服务治理","content":"\r\u0026ndash; Nginx\r#\r是一个开源的高性能 HTTP 服务器和反向代理服务器\n优点： 1. 高并发、高可靠性、低内存消耗 2. 配置简单、支持热部署 3. 良好的负载均衡和缓存功能 \u0026ndash; Nginx 处理HTTP请求\r#\rNginx 是一个高性能的 Web 服务器，能够同时处理大量的并发请求\n1. 多进程机制 Nginx包含一个主进程和多个工作进程。 主进程主要负责调度管理工作进程，工作进程则负责处理用户的请求 2. 异步非阻塞机制 工作进程接收到客户端的请求以后，会调用IO进行处理， 当发生等待时，工作线程会注册一个事件，转而去处理其他的请求 当IO返回时，就会触发该事件，工作线程会继续执行该未完成的请求 \u0026ndash; 正向代理、反向代理\r#\r正向代理\n1. 是一个代理服务器，它代表客户端向目标服务器发起请求。 2. 代理的对象是客户端，对外隐藏了真实的客户端 反向代理\n1. 是一个代理服务器，它代表服务端向客户端提供服务 2. 代理的对象是服务端，对外隐藏了真实的服务端 "},{"id":15,"href":"/interview/09_service/dubbo/","title":"Dubbo","section":"服务治理","content":"\r\u0026ndash; Dubbo\r#\r是一款高性能、轻量级的开源Java RPC框架 \u0026ndash; Dubbo 工作原理\r#\r0. 服务容器负责启动、加载、运行服务提供者。 1. 服务提供者向注册中心注册自己提供的服务 2. 服务消费者向注册中心订阅自己消费的服务 3. 注册中心通知服务消费者，服务节点的变更 4. 服务消费者基于负载均衡算法，从服务列表中选一台进行调用 5. 服务消费者/提供者，将调用信息发送到监控中心 \u0026ndash; Dubbo 负载均衡策略\r#\r策略 策略 说明 随机策略 random 随机选择一个可用的服务节点 轮询策略 roundrobin 按公平轮询的方式选择服务节点 最少活跃数策略 leastactive 优先选择活跃调用数最少的服务节点 一致性哈希策略 consistenthash 通过哈希算法将相同参数的请求发送到同一个服务节点 \u0026ndash; Dubbo、Spring Cloud\r#\rDubbo Spring Cloud 所属厂商 阿里系的分布式服务治理框架 Apache 旗下的 Spring 体系下的微服务解决方案 通信机制 RPC 通信 基于 HTTP 的 REST 方式 技术维度 只是实现了服务治理 覆盖了微服务架构下的方方面面 \u0026ndash; Dubbo、Zookeeper\r#\rDubbo推荐使用Zookeeper作为服务的注册中心\n1. Dubbo是管理中间层的工具，在业务层到数据仓库间，有很多服务需要接入和调度，dubbo提供一个框架解决这个问题 2. Dubbo有多种注册中心供选择，使用Zookeeper，是为了引入Zookeeper特性 \u0026ndash; RPC、REST\r#\rRPC\n1. RPC，远程过程调用，是一种进程间通信方式 2. 优点：调用简单、性能高、低延迟、自带负载均衡 3. 缺点：耦合性强、无法跨语言，平台敏感 REST\n1. REST，即RESTful ，是一种架构风格，指的是一组架构约束条件和原则。 2. 优点：耦合性低，兼容性好，通用性好，跨语言支持 3. 缺点：性能不如 RPC 高 RPC、REST\nRPC适用于内网服务调用，对外提供服务请走REST。 IO密集的服务调用用RPC，低频服务用REST 服务调用过于密集与复杂，RPC就比较适用 "},{"id":16,"href":"/interview/09_service/zookeeper/","title":"Zookeeper","section":"服务治理","content":"\r\u0026ndash; Zookeeper\r#\r是一个开源的分布式的服务协调框架 特点 说明 数据一致性 每个server都保存了一份相同的数据副本，client无论连接到哪个server，数据都是一致的 请求顺序性 来自同一个client的更新请求，其发送顺序和最后的执行顺序是一致的 可靠性 当一个消息被成功更新后，不会因为网络波动或其他原因而回滚 原子性 更新要不成功要不失败，没有第三个状态 独立性 不同的client之间互不影响 实时性 在一定时间范围内，client能读到最新数据 \u0026ndash; Zookeeper 角色\r#\r角色 角色 说明 Leader 领导者 为客户端提供读服务和写服务。管理集群内的所有事务的顺序，以及维护集群状态的同步 Follower 跟随者 为客户端提供读服务，参与Leader选举过程 Observer 观察者 为客户端提供读服务，不参与Leader选举过程 \u0026ndash; Zookeeper 应用场景\r#\r1. 数据发布与订阅 2. 命名服务 3. 配置管理 4. 集群管理 5. 分布式通知与协调 6. 分布式锁 7. 分布式队列 \u0026ndash; Zookeeper 工作原理\r#\r1. Zookeeper是基于观察者模式设计，接受观察者的注册 2. Zookeeper上存储和管理着大家都关心的数据 3. 当这些数据发生变化时，Zookeeper将会通知已注册的观察者做出相应的回应 \u0026ndash; Zookeeper 通知机制\r#\r1. Zookeeper允许客户端向服务端的某个znode注册一个Watcher监听 2. 当服务端的一些指定事件触发了这个Watcher，服务端会向指定客户端发送一个事件通知 3. 客户端根据Watcher通知状态和事件类型做出业务上的改变 \u0026ndash; Zookeeper 选举原则\r#\r1. Zookeeper 集群中只有超过半数以上的服务器启动，集群才能正常工作； 2. 在集群正常工作之前，myid 小的服务器给 myid 大的服务器投票，直到集群正常工作，选出 Leader； 3. 选出Leader之后，之前的服务器状态由 Looking 改变为 Following，以后的服务器都是 Follower。 \u0026ndash; Zookeeper 选举过程\r#\r假设：有五台服务器，从S1-S5 依序启动\nS1启动，发起选举\nS1投自己一票 此时S1为1票，不够半数以上，选举无法完成； S2启动，发起选举\nS2投自己一票，然后与S1交换选票，因为S2的ServerID大于S1，S1更改投S2 此时S1为0票，S2为2票，不够半数以上，选举无法完成； S3启动，发起选举\nS3投自己一票，然后与S1、S2交换选票，因为S3的ServerID最大，S1、S2更改投S3 此时S1、S2为0票，S3为3票，S3票数已经超过半数当选Leader； S4启动，发起选举\nS4投自己一票，然后相互交换选票，因为S1、S2、S3已经不是LOOKING状态，不会更改选票信息。 此时S3为3票，S4为1票，S4服从多数改投S3 S5启动，发起选举\n同4一样，S5改投S3， 最终S3是Leader，状态为LEADING； 其余服务器是Follower，状态为FOLLOWING。 \u0026ndash; Zookeeper 监听原理\r#\r1. 在Main()主线程中创建zkClient客户端。 2. zkClient会创建两个线程，一个负责网络连接通信（connet），一个负责监听（listener）。 3. zkClient通过connet线程，将监听事件注册到Zookeeper的监听列表。 4. 当数据或路径发生改变时，Zookeeper会将消息发送给listener线程。 5. listener线程调用process()方法，执行相应的操作。 "}]