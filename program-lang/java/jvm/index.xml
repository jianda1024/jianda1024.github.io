<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>虚拟机 on IWiki</title>
    <link>https://jianda1024.github.io/program-lang/java/jvm/</link>
    <description>Recent content in 虚拟机 on IWiki</description>
    <generator>Hugo</generator>
    <language>iwiki</language>
    <atom:link href="https://jianda1024.github.io/program-lang/java/jvm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>内存结构</title>
      <link>https://jianda1024.github.io/program-lang/java/jvm/memory-structure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://jianda1024.github.io/program-lang/java/jvm/memory-structure/</guid>
      <description>&lt;h1 id=&#34;内存结构&#34;&gt;&#xD;&#xA;  内存结构&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;运行时数据区&#34;&gt;&#xD;&#xA;  运行时数据区&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%90%e8%a1%8c%e6%97%b6%e6%95%b0%e6%8d%ae%e5%8c%ba&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;JVM 在执行 Java 程序的过程中，会把它所管理的内存区域划分为若干个不同的数据区域&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;img src=&#34;https://jianda1024.github.io/img/2022Q1/img_2022-03-28_104000.png&#34; width=&#34;800&#34;/&gt;&#xD;&#xA;&lt;h3 id=&#34;方法区&#34;&gt;&#xD;&#xA;  方法区&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%b9%e6%b3%95%e5%8c%ba&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;即永久代&lt;/li&gt;&#xA;&lt;li&gt;用于存储&lt;strong&gt;类信息&lt;/strong&gt;、&lt;strong&gt;常量&lt;/strong&gt;、&lt;strong&gt;静态常量&lt;/strong&gt;、&lt;strong&gt;即时编译后的代码&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;运行时常量池&lt;/strong&gt;，也是方法区的一部分，用于存放编译期生成的各种字面量和符号引用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;堆内存&#34;&gt;&#xD;&#xA;  堆内存&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a0%86%e5%86%85%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用于存储&lt;strong&gt;对象实例&lt;/strong&gt;、&lt;strong&gt;数组&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;是垃圾收集器管理的主要区域&lt;/li&gt;&#xA;&lt;li&gt;堆内存采用分代收集算法，又细分为：新生代（Eden区、SurvivorFrom区、SurvivorTo区）、老年代&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;虚拟机栈&#34;&gt;&#xD;&#xA;  虚拟机栈&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%a0%88&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;栈内存，是Java方法执行的内存模型&lt;/li&gt;&#xA;&lt;li&gt;每个方法被执行时，都会创建一个栈帧来存储&lt;strong&gt;局部变量表&lt;/strong&gt;、&lt;strong&gt;操作数栈&lt;/strong&gt;、&lt;strong&gt;动态链接&lt;/strong&gt;、&lt;strong&gt;方法出口&lt;/strong&gt;等信息&lt;/li&gt;&#xA;&lt;li&gt;方法从被调用到执行完成的过程，就对应着栈帧在虚拟机栈中从入栈到出栈的过程&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;本地方法栈&#34;&gt;&#xD;&#xA;  本地方法栈&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%ac%e5%9c%b0%e6%96%b9%e6%b3%95%e6%a0%88&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;与虚拟机栈相同，区别是虚拟机栈为执行 Java 方法服务，而本地方法栈则为 Native 方法服务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;程序计算器&#34;&gt;&#xD;&#xA;  程序计算器&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%a8%8b%e5%ba%8f%e8%ae%a1%e7%ae%97%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在 Java 虚拟机中，唯一没有 OOM 的区域&lt;/li&gt;&#xA;&lt;li&gt;是一小块内存空间，用于存储当前线程正在执行字节码指令的地址值&#xA;&lt;ul&gt;&#xA;&lt;li&gt;正在执行 Java 方法时，记录的是当前指令的地址&lt;/li&gt;&#xA;&lt;li&gt;正在执行 Native 方法时，则为 Undefined&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;内存区域分代&#34;&gt;&#xD;&#xA;  内存区域分代&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98%e5%8c%ba%e5%9f%9f%e5%88%86%e4%bb%a3&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;img src=&#34;https://jianda1024.github.io/img/2022Q1/img_2022-03-28_104001.png&#34; width=&#34;650&#34;/&gt;&#xD;&#xA;&lt;h3 id=&#34;新生代&#34;&gt;&#xD;&#xA;  新生代&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%b0%e7%94%9f%e4%bb%a3&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;分区&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Eden 区&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Java 新对象的出生地（大对象直接分配到老年代）&lt;br/&gt;当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;ServivorFrom 区&lt;br/&gt;ServivorTo 区&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;存放 MinorGC 过程中的幸存者&lt;br/&gt;使用复制算法，From、To区交互配合使用&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;老年代&#34;&gt;&#xD;&#xA;  老年代&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%80%81%e5%b9%b4%e4%bb%a3&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主要存放应用程序中生命周期长的内存对象，老年代的对象比较稳定，所以 MajorGC 不会频繁执行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;永久代&#34;&gt;&#xD;&#xA;  永久代&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b0%b8%e4%b9%85%e4%bb%a3&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息&lt;/li&gt;&#xA;&lt;li&gt;GC 不会在主程序运行期对永久区域进行清理&lt;/li&gt;&#xA;&lt;li&gt;在JDK1.8中，永久代被元空间取代，元空间并不在虚拟机中，而是使用本地内存&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
