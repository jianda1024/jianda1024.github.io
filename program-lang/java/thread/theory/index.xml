<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>并发理论 on IWiki</title>
    <link>https://localhost:1313/program-lang/java/thread/theory/</link>
    <description>Recent content in 并发理论 on IWiki</description>
    <generator>Hugo</generator>
    <language>iwiki</language>
    <atom:link href="https://localhost:1313/program-lang/java/thread/theory/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java 内存模型</title>
      <link>https://localhost:1313/program-lang/java/thread/theory/JMM/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://localhost:1313/program-lang/java/thread/theory/JMM/</guid>
      <description>&lt;h1 id=&#34;java-内存模型&#34;&gt;&#xD;&#xA;  Java 内存模型&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java-%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;jmm&#34;&gt;&#xD;&#xA;  JMM&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jmm&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Java Memory Model，是一种抽象的概念。&lt;/li&gt;&#xA;&lt;li&gt;描述的是一组规则或规范，规定了程序中各个变量的访问方式。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;内存&#34;&gt;&#xD;&#xA;  内存&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主内存：共享的内存区域，所有线程都可访问。代表：内存条&lt;/li&gt;&#xA;&lt;li&gt;工作内存：每个线程的私有数据区域。代表：CPU缓存&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;规则&#34;&gt;&#xD;&#xA;  规则&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%84%e5%88%99&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;线程解锁前，必须把共享变量的值刷新回主内存&lt;/li&gt;&#xA;&lt;li&gt;线程加锁前，必须读取主内存的最新值到自己的工作内存&lt;/li&gt;&#xA;&lt;li&gt;加锁解锁是同一把锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;访问过程&#34;&gt;&#xD;&#xA;  访问过程&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%bf%e9%97%ae%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;线程对变量的操作(读取赋值等)，必须在工作内存中进行&lt;/li&gt;&#xA;&lt;li&gt;首先要将变量从主内存拷贝到自己的工作空间，然后对变量进行操作，操作完成再将变量写回主内存&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;img src=&#34;https://localhost:1313/img/2022Q1/img_2022-02-19_010757.png&#34; width=&#34;650&#34;/&gt;&#xD;&#xA;&lt;h2 id=&#34;并发三特性&#34;&gt;&#xD;&#xA;  并发三特性&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b6%e5%8f%91%e4%b8%89%e7%89%b9%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;&lt;div style=&#34;font-weight:400&#34;&gt;原子性&lt;/div&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;div style=&#34;font-weight:400&#34;&gt;不可分割，是一个整体。即一个操作或者多个操作，要么全部执行并且不被打断，要么就都不执行&lt;/div&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;可见性&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;有序性&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;程序执行的顺序按照代码的先后顺序执行&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;指令重排&#34;&gt;&#xD;&#xA;  指令重排&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8c%87%e4%bb%a4%e9%87%8d%e6%8e%92&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为了优化程序性能，编译器和处理器重新对指令序列进行排序的一种手段&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;img src=&#34;https://localhost:1313/img/2022Q1/img_2022-02-19_022750.png&#34; width=&#34;650&#34;/&gt;&#xD;&#xA;&lt;h2 id=&#34;内存屏障&#34;&gt;&#xD;&#xA;  内存屏障&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Memory Barrier&lt;/li&gt;&#xA;&lt;li&gt;作用：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;阻止屏障两侧的指令重排序&lt;/li&gt;&#xA;&lt;li&gt;强制将缓存数据刷新到主内存&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;类型：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Load指令：读屏障，将内存存储的数据拷贝到处理器的缓存中。&lt;/li&gt;&#xA;&lt;li&gt;Store指令：写屏障，让当前线程写入高速缓存中的最新数据更新写入到内存，让其他线程也可见。&lt;/li&gt;&#xA;&lt;li&gt;分为四类：LoadLoad、StoreStore、LoadStore、 StoreLoad&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;数据依赖性&#34;&gt;&#xD;&#xA;  数据依赖性&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e4%be%9d%e8%b5%96%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;语义as-if-serial&#34;&gt;&#xD;&#xA;  语义：as-if-serial&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e4%b9%89as-if-serial&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不管怎么指令重排，单线程程序的执行结果不会改变&lt;/li&gt;&#xA;&lt;li&gt;为了遵循此语义，编译器不会对存在数据依赖关系的操作做重排序，因为会改变执行结果。&lt;/li&gt;&#xA;&lt;li&gt;编译器、runtime和处理器都遵守as-if-serial语义&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;规则happens-before&#34;&gt;&#xD;&#xA;  规则：happens-before&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%84%e5%88%99happens-before&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果A Happens-Before B，则A操作的结果对B操作可见，且A操作在B操作之前执行&lt;/li&gt;&#xA;&lt;li&gt;JMM承诺保证happens-before规则&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;as-if-serial--happens-before&#34;&gt;&#xD;&#xA;  as-if-serial &amp;amp; happens-before&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#as-if-serial--happens-before&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;两者目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;div style=&#34;font-weight:400&#34;&gt;as-if-serial&lt;/div&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;div style=&#34;font-weight:400&#34;&gt;保证结果：单线程程序的执行结果不被改变&lt;/div&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;as-if-serial&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;创造环境：单线程程序是按程序的顺序来执行的&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;happens-before&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;保证结果：正确同步的多线程程序的执行结果不被改变&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;happens-before&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;创造环境：正确同步的多线程程序是按happens-before指定的顺序来执行的&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>synchronized</title>
      <link>https://localhost:1313/program-lang/java/thread/theory/synchronized/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://localhost:1313/program-lang/java/thread/theory/synchronized/</guid>
      <description>&lt;h1 id=&#34;synchronized&#34;&gt;&#xD;&#xA;  synchronized&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#synchronized&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;特性&#34;&gt;&#xD;&#xA;  特性&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%b9%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;并发三特性：&lt;a href=&#34;https://localhost:1313/docs/develop-language/java/concurrency/concurrency-theory/JMM/#并发三特性&#34; target=&#34;_blank&#34;&gt;原子性、可见性、有序性&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;可重入性：是可重入锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;基本用法&#34;&gt;&#xD;&#xA;  基本用法&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;synchronized 内置锁，是一种“对象锁”，锁的是对象而非引用变量，作用粒度是对象&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;img src=&#34;https://localhost:1313/img/2022Q1/img_2022-02-20_051245.png&#34; width=&#34;650&#34;/&gt;&#xD;&#xA;&lt;h2 id=&#34;同步原理&#34;&gt;&#xD;&#xA;  同步原理&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%90%8c%e6%ad%a5%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;对象头&#34;&gt;&#xD;&#xA;  对象头&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1%e5%a4%b4&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实例数据：存放类的属性数据信息，包括父类的属性信息&lt;/li&gt;&#xA;&lt;li&gt;对齐填充：非必须，仅仅是为了字节对齐&lt;/li&gt;&#xA;&lt;li&gt;对象头：Mark Word、Class Metadata Address、Array Length&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;div style=&#34;font-weight:400&#34;&gt;Mark Word&lt;/div&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;div style=&#34;font-weight:400&#34;&gt;  存储对象自身的运行时数据，如  hashCode、锁信息或分代年龄或GC标志等&lt;/div&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Class Metadata Address&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;存储指向对象类型数据的指针&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Array Length&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;存储数组长度（如果当前对象是数组）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;img src=&#34;https://localhost:1313/img/2022Q1/img_2022-02-20_055206.png&#34; width=&#34;650&#34;/&gt;&#xD;&#xA;&lt;h3 id=&#34;锁记录&#34;&gt;&#xD;&#xA;  锁记录&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%94%81%e8%ae%b0%e5%bd%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Lock Record，是线程私有的数据结构。&lt;/li&gt;&#xA;&lt;li&gt;当线程进入同步代码块时，如果此同步对象没有被锁定，&lt;br/&gt;JVM会在当前线程的栈中创建Lock Record空间，用于存储锁对象的Mark Word的拷贝。&lt;/li&gt;&#xA;&lt;li&gt;每一个被锁住的对象Mark Word都会和一个Lock Record关联，&lt;br/&gt;同时Lock Record中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;监视器&#34;&gt;&#xD;&#xA;  监视器&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%91%e8%a7%86%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Monitor，可以理解为一种同步机制、一个对象。任何一个对象都有一个Monitor与之关联。&lt;/li&gt;&#xA;&lt;li&gt;Monitor只能被一个线程持有，此时当前对象就处于锁定状态，其它线程只能阻塞等待。&lt;/li&gt;&#xA;&lt;li&gt;在JVM中，Synchronized是基于进入和退出Monitor对象，来实现方法同步和代码块同步。&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;div style=&#34;font-weight:400&#34;&gt;MonitorEnter指令&lt;/div&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;div style=&#34;font-weight:400&#34;&gt;插入在同步代码块的开始位置。&lt;br/&gt;当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁；&lt;/div&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;MonitorExit指令&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;插入在方法结束处和异常处。&lt;br/&gt;JVM保证每个MonitorEnter必须有对应的MonitorExit；&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;同步优化&#34;&gt;&#xD;&#xA;  同步优化&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%90%8c%e6%ad%a5%e4%bc%98%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为优化synchronized性能，在JDK1.6后增加了自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁等策略&lt;/li&gt;&#xA;&lt;li&gt;锁的信息存储在对象头的MarkWord里，不同的锁状态对应的存储内容如下图&lt;/li&gt;&#xA;&lt;li&gt;锁膨胀：无锁——&amp;gt;偏向锁——&amp;gt;轻量级锁——&amp;gt;重量级锁，并且膨胀方向不可逆&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;img src=&#34;https://localhost:1313/img/2022Q1/img_2022-02-20_083614.png&#34; width=&#34;650&#34;/&gt;&#xD;&#xA;&lt;h3 id=&#34;偏向锁&#34;&gt;&#xD;&#xA;  偏向锁&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%81%8f%e5%90%91%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;减少同一线程获取锁的代价&lt;/li&gt;&#xA;&lt;li&gt;当持有锁的线程再次请求该锁时，无需再做任何同步操作，即获取锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;轻量级锁&#34;&gt;&#xD;&#xA;  轻量级锁&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bd%bb%e9%87%8f%e7%ba%a7%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;轻量级锁是由偏向锁升级而来&lt;/li&gt;&#xA;&lt;li&gt;当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;重量级锁&#34;&gt;&#xD;&#xA;  重量级锁&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%87%8d%e9%87%8f%e7%ba%a7%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;重量级锁是由轻量级锁升级而来&lt;/li&gt;&#xA;&lt;li&gt;当&lt;strong&gt;同一时间&lt;/strong&gt;有多个线程竞争锁时，锁就会被升级成重量级锁，此时其申请锁带来的开销也就变大&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;其他策略&#34;&gt;&#xD;&#xA;  其他策略&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b6%e4%bb%96%e7%ad%96%e7%95%a5&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;div style=&#34;font-weight:400&#34;&gt;锁消除&lt;/div&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;div style=&#34;font-weight:400&#34;&gt;当检测到不可能存在共享数据的竞争时，JVM会对这些同步锁进行消除&lt;/div&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;锁粗化&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;自旋锁&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;是一种锁机制，尝试获取锁的线程不会立即阻塞，而是采用循环的方式去多次尝试&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;自适应自旋锁&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;自旋的次数不是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>volatile</title>
      <link>https://localhost:1313/program-lang/java/thread/theory/volatile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://localhost:1313/program-lang/java/thread/theory/volatile/</guid>
      <description>&lt;h1 id=&#34;volatile&#34;&gt;&#xD;&#xA;  volatile&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#volatile&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;概述&#34;&gt;&#xD;&#xA;  概述&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;volatile：是一种比sychronized关键字更轻量级的同步机制，用来确保将变量的更新操作通知到其他线程。&lt;/li&gt;&#xA;&lt;li&gt;保证所修饰变量对所有的线程的可见性&lt;/li&gt;&#xA;&lt;li&gt;禁止指令重排优化&lt;/li&gt;&#xA;&lt;li&gt;不保证原子性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;实现原理&#34;&gt;&#xD;&#xA;  实现原理&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于volatile所修饰变量的写操作，在生成汇编代码时，会增加Lock前缀指令&lt;/li&gt;&#xA;&lt;li&gt;缓存一致性：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;内存语义&#34;&gt;&#xD;&#xA;  内存语义&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98%e8%af%ad%e4%b9%89&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;写volatile变量会重新刷新到主内存中，其他线程读volatile变量，会重新从主内存中读取新值&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;内存语义的实现&#34;&gt;&#xD;&#xA;  内存语义的实现&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98%e8%af%ad%e4%b9%89%e7%9a%84%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在生成字节码时，编译器会在指令序列中插入内存屏障，来禁止特定类型的处理器重排序&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;img src=&#34;https://localhost:1313/img/2022Q1/img_2022-02-20_103454.png&#34; width=&#34;650&#34;/&gt;&#xD;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;div style=&#34;font-weight:400&#34;&gt;StoreStore屏障&lt;/div&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;div style=&#34;font-weight:400&#34;&gt;禁止上面的普通写和下面的volatile写重排序&lt;/div&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;StoreLoad屏障&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;防止上面的volatile写与下面可能有的volatile读/写重排序&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;LoadLoad屏障&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;禁止下面所有的普通读操作和上面的volatile读重排序&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;LoadStore屏障&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;禁止下面所有的普通写操作和上面的volatile读重排序&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;解决不保证原子性&#34;&gt;&#xD;&#xA;  解决：不保证原子性&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e5%86%b3%e4%b8%8d%e4%bf%9d%e8%af%81%e5%8e%9f%e5%ad%90%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;解决办法：使用 synchronized 修饰、使用 AtomicInteger 类型&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Singleton&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;{&lt;span style=&#34;color:#bbb&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//volatile：禁止指令重排&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;volatile&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;Singleton&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;instance&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;=&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;&lt;span style=&#34;color:#bbb&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#008b45&#34;&gt;Singleton&lt;/span&gt;()&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;{&lt;span style=&#34;color:#bbb&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;}&lt;span style=&#34;color:#bbb&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 双重检测机制&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;Singleton&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#008b45&#34;&gt;getInstance&lt;/span&gt;()&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;{&lt;span style=&#34;color:#bbb&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;        &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;(instance&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;==&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;)&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;{&lt;span style=&#34;color:#bbb&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;            &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;synchronized&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;(Singleton.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;)&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;{&lt;span style=&#34;color:#bbb&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;                &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;(instance&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;==&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;)&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;{&lt;span style=&#34;color:#bbb&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;                    &lt;/span&gt;instance&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;=&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;Singleton();&lt;span style=&#34;color:#bbb&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;                &lt;/span&gt;}&lt;span style=&#34;color:#bbb&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;            &lt;/span&gt;}&lt;span style=&#34;color:#bbb&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;        &lt;/span&gt;}&lt;span style=&#34;color:#bbb&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;        &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;instance;&lt;span style=&#34;color:#bbb&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;}&lt;span style=&#34;color:#bbb&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#bbb&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>final</title>
      <link>https://localhost:1313/program-lang/java/thread/theory/final/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://localhost:1313/program-lang/java/thread/theory/final/</guid>
      <description>&lt;h1 id=&#34;final&#34;&gt;&#xD;&#xA;  final&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#final&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;概述&#34;&gt;&#xD;&#xA;  概述&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;final，即最终、不可变&lt;/li&gt;&#xA;&lt;li&gt;可以用来修饰类、方法和变量&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;用法&#34;&gt;&#xD;&#xA;  用法&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%94%a8%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;修饰类&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;final 修饰的类，不能被继承&lt;/li&gt;&#xA;&lt;li&gt;final 类中的方法，都会被隐式地指定为 final 方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;​&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;修饰方法&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;final 修饰的方法，不能被重写，但可以被重载&lt;/li&gt;&#xA;&lt;li&gt;private 修饰的方法，都会隐式地指定为 final 方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;​&lt;/p&gt;</description>
    </item>
    <item>
      <title>CAS</title>
      <link>https://localhost:1313/program-lang/java/thread/theory/CAS/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://localhost:1313/program-lang/java/thread/theory/CAS/</guid>
      <description>&lt;h1 id=&#34;cas-算法&#34;&gt;&#xD;&#xA;  CAS 算法&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cas-%e7%ae%97%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;cas&#34;&gt;&#xD;&#xA;  CAS&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cas&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;比较并交换，Compare-And-Swap，是一种无锁算法&lt;/li&gt;&#xA;&lt;li&gt;基于硬件原语实现，能够在不使用锁的情况下实现多线程之间的变量同步&lt;/li&gt;&#xA;&lt;li&gt;Java CAS硬件底层接口 ：sun.misc.Unsafe&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;cas-机制&#34;&gt;&#xD;&#xA;  CAS 机制&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cas-%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;涉及到三个参数，数据所在的内存地址 V，旧的预期值 A，要修改的更新值 B&lt;/li&gt;&#xA;&lt;li&gt;从 V 取值，和 A 做比较，如果相等，则更新为 B。如果不相等则重试&lt;/li&gt;&#xA;&lt;li&gt;一般情况下是一个自旋操作，即不断的重试。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;cas-缺点&#34;&gt;&#xD;&#xA;  CAS 缺点&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cas-%e7%bc%ba%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;自旋时间长开销很大&lt;/li&gt;&#xA;&lt;li&gt;只能保证一个共享变量的原子性&lt;/li&gt;&#xA;&lt;li&gt;存在 ABA 问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;aba-问题&#34;&gt;&#xD;&#xA;  ABA 问题&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aba-%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在 CAS 操作中，内存中某时刻的值与下一时刻再次读取的值相等，并不意味着数据没有被修改&lt;/li&gt;&#xA;&lt;li&gt;存在这种情况：在这段时间内，其他线程将 A 值改成 B 值，又改回 A 值。而CAS却误认为数据未被修改&lt;/li&gt;&#xA;&lt;li&gt;解决方案：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1、加版本号（时间戳）；&lt;/li&gt;&#xA;&lt;li&gt;2、时间戳原子引用：AtomicStampedReference&amp;lt;V&amp;gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
